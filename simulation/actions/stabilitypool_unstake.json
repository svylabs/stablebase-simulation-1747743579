{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The amount to unstake must be greater than 0.",
      "The amount to unstake must be less than or equal to the user's current stake.",
      "Specify the amount of tokens to unstake. This amount must be a valid uint256.",
      "Optionally specify a frontend address and fee. The fee represents a percentage.",
      "The frontend address should be a valid Ethereum address.",
      "The fee must be a valid uint256 representing the fee percentage, typically within a reasonable range (e.g., 0-10000 for 0%-100%)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Updates",
        "state_update_descriptions": [
          "User's staked amount decreases.",
          "Total staked amount decreases."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "User receives unstaked tokens (stakingToken)."
        ]
      },
      {
        "category": "Reward and Collateral Updates",
        "state_update_descriptions": [
          "User may claim pending rewards (SBR, reward, collateral) before unstaking.",
          "The user's reward, collateral and SBR reward snapshots are updated."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "If totalStakedRaw becomes 0, the reward distribution from stableBaseCDP might be disabled."
        ]
      },
      {
        "category": "User Data Update",
        "state_update_descriptions": [
          "User's effective stake is updated based on stake scaling factor.",
          "User's cumulative product scaling factor and stake reset count are updated."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Updates",
        "rule_descriptions": [
          "users[msg.sender].stake should decrease by _amount.",
          "users[msg.sender].stake should be non-negative.",
          "totalStakedRaw should decrease by _amount.",
          "totalStakedRaw should be non-negative."
        ]
      },
      {
        "category": "Token Transfer",
        "rule_descriptions": [
          "msg.sender should receive _amount of the stakingToken."
        ]
      },
      {
        "category": "Reward Snapshots",
        "rule_descriptions": [
          "users[msg.sender].rewardSnapshot should be updated to totalRewardPerToken.",
          "users[msg.sender].collateralSnapshot should be updated to totalCollateralPerToken.",
          "sbrRewardSnapshots[msg.sender].rewardSnapshot should be updated to totalSbrRewardPerToken if SBR reward distribution is not ended."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Reflects the user's current stake, affecting reward calculations and liquidation possibilities. ",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the user's stake is decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the specified amount (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the StabilityPool.",
            "why_is_is_important": "Used in reward calculations and to determine if the StabilityPool can receive rewards. ",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Verify that the totalStakedRaw is decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked amount by the unstaked amount (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP.setCanStabilityPoolReceiveRewards(false)",
            "type": "external_call",
            "what_does_it_track": "Controls whether the StabilityPool can receive rewards from the RewardSender contract.",
            "why_is_is_important": "Stops the StabilityPool from receiving rewards when no tokens are staked. ",
            "when_is_it_updated": "When the total staked amount becomes zero.",
            "how_to_validate_state_update": "Check if `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)` is called successfully when `totalStakedRaw` is 0 and `rewardSenderActive` is true. Note that it calls an external contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially calls `setCanStabilityPoolReceiveRewards(false)` on `stableBaseCDP` contract if totalStakedRaw becomes zero.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "Various state variables in `_addSBRRewards()`",
            "type": "internal_call",
            "what_does_it_track": "Tracks the status and parameters related to the distribution of SBR rewards.",
            "why_is_is_important": "Ensures SBR rewards are properly distributed during the distribution period. ",
            "when_is_it_updated": "Before rewards are claimed, determining if SBR rewards should be added.",
            "how_to_validate_state_update": "Check if `_addSBRRewards()` is called when `sbrRewardDistributionStatus` is not `SBRRewardDistribution.ENDED`. Inspect values modified by `_addSBRRewards()` using event logs.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls `_addSBRRewards()` which updates SBR reward distribution status and relevant state variables.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "Various state variables in `_updateRewards()`",
            "type": "internal_call",
            "what_does_it_track": "Tracks rewards and collateral owed to the user.",
            "why_is_is_important": "Allows users to claim rewards and collateral before unstaking. ",
            "when_is_it_updated": "Before unstaking, to calculate and transfer any pending rewards and collateral.",
            "how_to_validate_state_update": "Check the event logs for `RewardClaimed` and `DFireRewardClaimed` to see the reward, rewardFee, collateral, and collateralFee values.",
            "has_conditional_updates": false,
            "summary_of_update": "Calls `_updateRewards()` to update reward snapshots, and potentially transfer rewards and collateral.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor, users[msg.sender].stakeResetCount",
            "type": "internal_call",
            "what_does_it_track": "Tracks user stake and scaling factor for reward calculations.",
            "why_is_is_important": "Ensures user's stake and scaling factor are up to date for reward calculations.",
            "when_is_it_updated": "Before unstaking, to update user's stake and scaling factor.",
            "how_to_validate_state_update": "Check `users[msg.sender].cumulativeProductScalingFactor` and `users[msg.sender].stakeResetCount`",
            "has_conditional_updates": false,
            "summary_of_update": "Calls `_updateUserStake()` to adjust user's stake, update user's scaling factor and reset count.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "dfidToken",
        "state_updated": [
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, _amount)",
            "type": "external_call",
            "what_does_it_track": "Tracks the transfer of staked tokens back to the user.",
            "why_is_is_important": "Returns the unstaked tokens to the user. ",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Verify that `stakingToken.transfer(msg.sender, _amount)` is called successfully by checking the emitted `Transfer` event on the `stakingToken` contract.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers the unstaked tokens to the user.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "dfireToken",
        "state_updated": [
          {
            "state_variable_name": "sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee)",
            "type": "external_call",
            "what_does_it_track": "Tracks the minting of SBR tokens for the user's rewards.",
            "why_is_is_important": "Provides the user with their earned SBR rewards. ",
            "when_is_it_updated": "When a user has pending SBR rewards to claim.",
            "how_to_validate_state_update": "Verify that `sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee)` is called successfully by checking the emitted `Mint` event on the `sbrToken` contract. Check event logs for `DFireRewardClaimed`.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the user as rewards.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "sbrToken.mint(frontend, sbrFee)",
            "type": "external_call",
            "what_does_it_track": "Tracks the minting of SBR tokens for the frontend fees.",
            "why_is_is_important": "Compensates the frontend for their services. ",
            "when_is_it_updated": "When a user has pending SBR rewards and a frontend fee is applicable.",
            "how_to_validate_state_update": "Verify that `sbrToken.mint(frontend, sbrFee)` is called successfully by checking the emitted `Mint` event on the `sbrToken` contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the frontend as fees.",
            "conditions": [
              "pendingSbrRewards != 0",
              "fee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "address",
        "state_updated": [
          {
            "state_variable_name": "msg.sender.call{value: pendingCollateral - collateralFee}(\"\")",
            "type": "external_call",
            "what_does_it_track": "Tracks collateral sent to user.",
            "why_is_is_important": "Sends collateral to user. ",
            "when_is_it_updated": "When user has pending collateral.",
            "how_to_validate_state_update": "Check emitted events. Cannot check internal balance.",
            "has_conditional_updates": true,
            "summary_of_update": "Sends collateral to user.",
            "conditions": [
              "pendingCollateral != 0"
            ]
          },
          {
            "state_variable_name": "frontend.call{value: collateralFee}(\"\")",
            "type": "external_call",
            "what_does_it_track": "Tracks collateral sent to frontend.",
            "why_is_is_important": "Sends collateral to the frontend. ",
            "when_is_it_updated": "When user has pending collateral, and fee > 0.",
            "how_to_validate_state_update": "Check emitted events. Cannot check internal balance.",
            "has_conditional_updates": true,
            "summary_of_update": "Sends collateral to the frontend.",
            "conditions": [
              "pendingCollateral != 0",
              "fee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "address",
        "state_updated": [
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, pendingReward - rewardFee)",
            "type": "external_call",
            "what_does_it_track": "Tracks reward sent to user.",
            "why_is_is_important": "Sends reward to user. ",
            "when_is_it_updated": "When user has pending rewards.",
            "how_to_validate_state_update": "Verify that `stakingToken.transfer(msg.sender, pendingReward - rewardFee)` is called successfully by checking the emitted `Transfer` event on the `stakingToken` contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward to user.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "stakingToken.transfer(frontend, rewardFee)",
            "type": "external_call",
            "what_does_it_track": "Tracks reward sent to frontend.",
            "why_is_is_important": "Sends reward to frontend. ",
            "when_is_it_updated": "When user has pending rewards, and fee > 0.",
            "how_to_validate_state_update": "Verify that `stakingToken.transfer(frontend, rewardFee)` is called successfully by checking the emitted `Transfer` event on the `stakingToken` contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers fee to frontend.",
            "conditions": [
              "pendingReward != 0",
              "fee > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}