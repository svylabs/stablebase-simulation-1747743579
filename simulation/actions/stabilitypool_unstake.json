{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The 'amount' parameter is the quantity of tokens the user wishes to unstake. It must be a positive integer.",
      "The 'amount' must be less than or equal to the current staked amount of the user, as recorded in 'StabilityPool.users[caller].stake'."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "StabilityPool User Stake & Totals",
        "state_update_descriptions": [
          "The 'stake' balance of the transaction sender (msg.sender) in 'StabilityPool.users' is first adjusted based on internal scaling factors and then decreased by the specified unstaked 'amount'.",
          "The 'cumulativeProductScalingFactor' for the transaction sender in 'StabilityPool.users' is updated to the current 'stakeScalingFactor'.",
          "The 'stakeResetCount' for the transaction sender in 'StabilityPool.users' is updated to the current 'stakeResetCount'.",
          "The 'totalStakedRaw' variable in 'StabilityPool' decreases by the unstaked 'amount'."
        ]
      },
      {
        "category": "StabilityPool User Reward Snapshots",
        "state_update_descriptions": [
          "The 'rewardSnapshot' for the transaction sender in 'StabilityPool.users' is updated to the 'totalRewardPerToken' at the time of the claim.",
          "The 'collateralSnapshot' for the transaction sender in 'StabilityPool.users' is updated to the 'totalCollateralPerToken' at the time of the claim.",
          "The 'sbrRewardSnapshots[msg.sender].rewardSnapshot' is updated to the 'totalSbrRewardPerToken' at the time of the claim (if SBR reward distribution is not ended).",
          "The 'sbrRewardSnapshots[msg.sender].status' is set to 'CLAIMED' if SBR reward distribution has ended and it wasn't already claimed."
        ]
      },
      {
        "category": "StabilityPool SBR Reward Distribution State (Conditional)",
        "state_update_descriptions": [
          "If SBR reward distribution is active ('STARTED'): 'lastSBRRewardDistributedTime' is updated to the current 'block.timestamp'. 'sbrRewardDistributionStatus' may change to 'ENDED' if 'block.timestamp' passes 'sbrRewardDistributionEndTime'. 'sbrRewardLoss' and 'totalSbrRewardPerToken' are updated based on SBR calculation.",
          "If SBR reward distribution was 'NOT_STARTED': 'lastSBRRewardDistributedTime' is initialized to 'block.timestamp'. 'sbrRewardDistributionEndTime' is set to 'block.timestamp + 365 days'. 'sbrRewardDistributionStatus' transitions to 'STARTED'."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "The 'stakingToken' (DFIDToken) balance of the transaction sender increases by the unstaked 'amount' plus any calculated pending reward (minus reward fee).",
          "The 'stakingToken' (DFIDToken) balance of the 'frontend' address (if provided and fee > 0) increases by the reward fee.",
          "The 'sbrToken' (DFIREToken) balance of the transaction sender increases by the calculated pending SBR rewards (minus SBR fee) via minting.",
          "The 'sbrToken' (DFIREToken) balance of the 'frontend' address (if provided and fee > 0) increases by the SBR fee via minting."
        ]
      },
      {
        "category": "Native Token Transfers",
        "state_update_descriptions": [
          "The native currency balance of the transaction sender increases by the calculated pending collateral (minus collateral fee).",
          "The native currency balance of the 'frontend' address (if provided and fee > 0) increases by the collateral fee."
        ]
      },
      {
        "category": "External Contract State Updates (Conditional)",
        "state_update_descriptions": [
          "If 'StabilityPool.totalStakedRaw' becomes '0' after the unstake and 'StabilityPool.rewardSenderActive' is 'true', 'StableBaseCDP.setCanStabilityPoolReceiveRewards(false)' is called, setting 'StableBaseCDP.canStabilityPoolReceiveRewards' to 'false'."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "StabilityPool Contract State",
        "rule_descriptions": [
          "The 'stake' balance of the caller (msg.sender) in the 'StabilityPool' contract's 'users' mapping must be reduced by the 'amount' specified, after accounting for any internal effective stake adjustments that occurred during the transaction.",
          "The 'totalStakedRaw' variable in the 'StabilityPool' contract must be reduced by the 'amount' unstaked.",
          "The 'rewardSnapshot', 'collateralSnapshot', 'cumulativeProductScalingFactor', and 'stakeResetCount' for the caller in 'StabilityPool.users' must be updated to their respective current global values at the time of the claim.",
          "The 'sbrRewardSnapshots[msg.sender].rewardSnapshot' must reflect the 'totalSbrRewardPerToken' at the time of the transaction (if SBR rewards were not ended).",
          "If SBR reward distribution was 'ENDED' and 'sbrRewardSnapshots[msg.sender].status' was not 'CLAIMED' before, it must now be 'CLAIMED'.",
          "If 'StabilityPool.totalStakedRaw' became 0 and 'StabilityPool.rewardSenderActive' was true, the 'StableBaseCDP.canStabilityPoolReceiveRewards()' state must be 'false'."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The 'DFIDToken' (staking token) balance of 'msg.sender' must have increased by the 'amount' unstaked, plus any calculated pending reward minus reward fee.",
          "The 'DFIDToken' (staking token) balance of the 'StabilityPool' contract must have decreased by the 'amount' unstaked, plus any calculated pending reward.",
          "If a 'frontend' address and a non-zero 'fee' were provided, the 'DFIDToken' (staking token) balance of the 'frontend' address must have increased by the reward fee.",
          "The 'DFIREToken' (SBR token) balance of 'msg.sender' must have increased by any calculated pending SBR rewards minus SBR fee.",
          "The total supply of 'DFIREToken' (SBR token) must have increased by any calculated pending SBR rewards.",
          "If a 'frontend' address and a non-zero 'fee' were provided, the 'DFIREToken' (SBR token) balance of the 'frontend' address must have increased by the SBR fee."
        ]
      },
      {
        "category": "Native Currency Balance",
        "rule_descriptions": [
          "The native currency balance of 'msg.sender' must have increased by any calculated pending collateral minus collateral fee.",
          "If a 'frontend' address and a non-zero 'fee' were provided, the native currency balance of the 'frontend' address must have increased by the collateral fee."
        ]
      },
      {
        "category": "Events Emitted",
        "rule_descriptions": [
          "An 'Unstaked' event must be emitted from 'StabilityPool' with 'user' matching 'msg.sender' and 'amount' matching the unstaked amount.",
          "A 'RewardClaimed' event must be emitted from 'StabilityPool' with 'user' matching 'msg.sender' and the correct calculated 'totalReward', 'rewardFrontendFee', 'totalCollateral', and 'collateralFrontendFee'.",
          "If any SBR rewards were claimed ('pendingSbrRewards > 0'), a 'DFireRewardClaimed' event must be emitted from 'StabilityPool' with 'user' matching 'msg.sender' and the correct calculated 'amount' and 'frontendFee'.",
          "If '_addSBRRewards' was triggered and resulted in an SBR calculation update (i.e., 'totalStakedRaw' was initially positive), an 'SBRRewardsAdded' event should be emitted from 'StabilityPool'.",
          "'Transfer' events should be emitted by the 'stakingToken' (DFIDToken) for the unstaked amount and the reward transfers to 'msg.sender' and 'frontend'.",
          "'Transfer' events should be emitted by the 'sbrToken' (DFIREToken) for the minting of SBR rewards to 'msg.sender' and 'frontend'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens currently staked by a specific user.",
            "why_is_is_important": "It reflects the user's current investment and their share in the stability pool.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Verify the user's stake in the `users` mapping has decreased by the unstaked amount, after accounting for any prior effective stake calculation by `_getUserEffectiveStake`.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's staked amount is reduced by the unstake amount. Before this reduction, the `user.stake` value itself is updated to its 'effective stake' based on `stakeScalingFactor` and `cumulativeProductScalingFactor` to reflect any scaling factor changes since the last update.",
            "conditions": [
              "User must have a positive stake",
              "Unstake amount must be less than or equal to the user's current stake"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The raw sum of all tokens currently staked in the stability pool.",
            "why_is_is_important": "It indicates the overall liquidity and health of the stability pool.",
            "when_is_it_updated": "When tokens are unstaked from the pool.",
            "how_to_validate_state_update": "Verify that `totalStakedRaw` has decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total raw amount of tokens staked in the pool is reduced by the unstaked amount.",
            "conditions": [
              "Unstake amount must be greater than zero"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive (and IRewardSender.setCanStabilityPoolReceiveRewards)",
            "type": "bool",
            "what_does_it_track": "Whether the Stability Pool is currently eligible to receive rewards from the reward sender.",
            "why_is_is_important": "It controls the flow of rewards to the stability pool.",
            "when_is_it_updated": "When the total staked amount in the pool drops to zero and the reward sender is active.",
            "how_to_validate_state_update": "Check the `rewardSenderActive` boolean variable in the `StabilityPool` contract to confirm it is set to `false` if conditions are met. Also, check the `canStabilityPoolReceiveRewards` state in `StableBaseCDP` through `IRewardSender` interface.",
            "has_conditional_updates": true,
            "summary_of_update": "If the total staked amount becomes zero and the reward sender is active, the `rewardSenderActive` flag is implicitly set to `false` through an external call to `stableBaseCDP.setCanStabilityPoolReceiveRewards(false)` which is expected to update `rewardSenderActive` within StabilityPool (as it likely acts as a proxy or has a corresponding internal state). This action disables future reward distribution to the stability pool.",
            "conditions": [
              "`totalStakedRaw` becomes zero after the unstake operation AND `rewardSenderActive` is true."
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum (SBRRewardDistribution)",
            "what_does_it_track": "The current state of SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "It controls when and how SBR rewards are calculated and distributed.",
            "when_is_it_updated": "During the `_addSBRRewards` internal call, which occurs when a user unstakes (as part of claiming).",
            "how_to_validate_state_update": "Check the `sbrRewardDistributionStatus` enum variable. It should be updated to `ENDED` if the end time is passed and it was started, or to `STARTED` if it was previously `NOT_STARTED`.",
            "has_conditional_updates": true,
            "summary_of_update": "The status of SBR reward distribution can change to `ENDED` if the current time exceeds the distribution end time, or to `STARTED` if it was previously `NOT_STARTED`.",
            "conditions": [
              "`sbrRewardDistributionStatus` was `STARTED` AND `block.timestamp` is greater than `sbrRewardDistributionEndTime`.",
              "`sbrRewardDistributionStatus` was `NOT_STARTED`."
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp of the last time SBR rewards were calculated and potentially distributed.",
            "why_is_is_important": "It's crucial for calculating the elapsed time to determine new SBR rewards.",
            "when_is_it_updated": "During the `_addSBRRewards` internal call, which occurs when a user unstakes (as part of claiming).",
            "how_to_validate_state_update": "Verify `lastSBRRewardDistributedTime` is updated to `block.timestamp`.",
            "has_conditional_updates": true,
            "summary_of_update": "Records the timestamp of the last SBR reward distribution calculation.",
            "conditions": [
              "`sbrRewardDistributionStatus` is not `ENDED` (i.e., `STARTED` or `NOT_STARTED`)."
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBR reward distributed per unit of staked token over time.",
            "why_is_is_important": "It's used to calculate the SBR rewards owed to each staker based on their stake and staking duration.",
            "when_is_it_updated": "When SBR rewards are added (during `_addSBRRewards` within a claim operation).",
            "how_to_validate_state_update": "Verify that `totalSbrRewardPerToken` has increased based on the `sbrReward` calculated for the elapsed time.",
            "has_conditional_updates": true,
            "summary_of_update": "The total SBR reward per token is updated by adding newly accrued SBR rewards, scaled by `stakeScalingFactor` and `totalStakedRaw`.",
            "conditions": [
              "`sbrRewardDistributionStatus` is `STARTED` AND `totalStakedRaw` is greater than zero."
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "The remainder of SBR rewards that couldn't be fully distributed in the current period, carried over to the next.",
            "why_is_is_important": "Ensures that all calculated SBR rewards are eventually accounted for and distributed accurately.",
            "when_is_it_updated": "When SBR rewards are added (during `_addSBRRewards` within a claim operation).",
            "how_to_validate_state_update": "Verify `sbrRewardLoss` is updated based on any remainder from the SBR reward distribution calculation.",
            "has_conditional_updates": true,
            "summary_of_update": "Accounts for any fractional SBR reward that could not be precisely distributed among `totalStakedRaw` tokens.",
            "conditions": [
              "`sbrRewardDistributionStatus` is `STARTED` AND `totalStakedRaw` is greater than zero."
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp at which SBR reward distribution is scheduled to end.",
            "why_is_is_important": "It defines the duration for which SBR rewards will be distributed.",
            "when_is_it_updated": "When SBR reward distribution status transitions from `NOT_STARTED` to `STARTED`.",
            "how_to_validate_state_update": "Verify `sbrRewardDistributionEndTime` is set to `block.timestamp + 365 days`.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the end time for SBR reward distribution to 365 days from the current block timestamp.",
            "conditions": [
              "`sbrRewardDistributionStatus` is `NOT_STARTED`."
            ]
          },
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of `totalRewardPerToken` for a user at their last interaction, used to calculate their pending rewards.",
            "why_is_is_important": "It's crucial for accurate reward calculation, ensuring users only claim rewards accrued since their last interaction.",
            "when_is_it_updated": "Every time a user claims rewards (as part of `unstake`).",
            "how_to_validate_state_update": "Verify `user.rewardSnapshot` is updated to the current `totalRewardPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "Records the `totalRewardPerToken` at the time of claim for the user, used for calculating future rewards.",
            "conditions": [
              "Always updated when `_updateRewards` is called (which happens in `_claim`)."
            ]
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of `totalCollateralPerToken` for a user at their last interaction, used to calculate their pending collateral gains.",
            "why_is_is_important": "It's crucial for accurate collateral gain calculation, ensuring users only claim gains accrued since their last interaction.",
            "when_is_it_updated": "Every time a user claims rewards (as part of `unstake`).",
            "how_to_validate_state_update": "Verify `user.collateralSnapshot` is updated to the current `totalCollateralPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "Records the `totalCollateralPerToken` at the time of claim for the user, used for calculating future collateral rewards.",
            "conditions": [
              "Always updated when `_updateRewards` is called (which happens in `_claim`)."
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of `totalSbrRewardPerToken` for a user at their last interaction, used to calculate their pending SBR rewards.",
            "why_is_is_important": "It's crucial for accurate SBR reward calculation, ensuring users only claim SBR rewards accrued since their last interaction.",
            "when_is_it_updated": "Every time a user claims rewards (as part of `unstake`), provided SBR distribution is not `ENDED`.",
            "how_to_validate_state_update": "Verify `sbrRewardSnapshots[msg.sender].rewardSnapshot` is updated to the current `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Records the `totalSbrRewardPerToken` at the time of claim for the user, used for calculating future SBR rewards.",
            "conditions": [
              "`sbrRewardDistributionStatus` is not `ENDED`."
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum (SBRRewardDistribution)",
            "what_does_it_track": "The SBR reward claim status for a specific user.",
            "why_is_is_important": "Prevents users from claiming SBR rewards after the distribution period has concluded.",
            "when_is_it_updated": "When a user claims rewards (as part of `unstake`) and the overall SBR distribution has ended.",
            "how_to_validate_state_update": "Verify `sbrRewardSnapshots[msg.sender].status` is set to `CLAIMED`.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the SBR reward status for a user to `CLAIMED` if the overall SBR distribution has ended and they haven't claimed yet, preventing future SBR reward calculations for this user.",
            "conditions": [
              "`sbrRewardDistributionStatus` is `ENDED` AND `sbrRewardSnapshots[msg.sender].status` is not `CLAIMED`."
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "The cumulative scaling factor applied to a user's stake, accounting for changes in the pool's reward distribution.",
            "why_is_is_important": "Essential for correctly calculating a user's effective stake and their share of future rewards after pool events (like liquidations) that change `stakeScalingFactor`.",
            "when_is_it_updated": "Every time a user claims rewards (as part of `unstake`).",
            "how_to_validate_state_update": "Verify `user.cumulativeProductScalingFactor` is updated to the current `stakeScalingFactor`.",
            "has_conditional_updates": false,
            "summary_of_update": "Records the current `stakeScalingFactor` for the user's stake, reflecting the cumulative product of scaling factors up to this point.",
            "conditions": [
              "Always updated when `_updateUserStake` is called (which happens in `_claim`)."
            ]
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "The count of how many times the stake has been 'reset' or a new snapshot created for reward calculation purposes.",
            "why_is_is_important": "Used in conjunction with `cumulativeProductScalingFactor` to accurately calculate rewards and effective stake across multiple scaling factor resets.",
            "when_is_it_updated": "Every time a user claims rewards (as part of `unstake`).",
            "how_to_validate_state_update": "Verify `user.stakeResetCount` is updated to the current `stakeResetCount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Records the current `stakeResetCount` for the user, aligning their stake calculation with the latest reset snapshot.",
            "conditions": [
              "Always updated when `_updateUserStake` is called (which happens in `_claim`)."
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The DFIDToken balance of individual addresses.",
            "why_is_is_important": "It reflects the user's ownership of DFIDTokens.",
            "when_is_it_updated": "When the `stakingToken.transfer` function is called successfully from the StabilityPool, transferring unstaked tokens to the user.",
            "how_to_validate_state_update": "Check the `balanceOf(msg.sender)` for DFIDToken. It should have increased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of the unstaking user (`msg.sender`) for the staking token (DFIDToken) increases by the unstaked amount.",
            "conditions": [
              "The `stakingToken.transfer` call is successful."
            ]
          },
          {
            "state_variable_name": "_balances[StabilityPool address]",
            "type": "uint256",
            "what_does_it_track": "The DFIDToken balance held by the StabilityPool contract.",
            "why_is_is_important": "It tracks the amount of DFIDTokens available in the StabilityPool for redemptions and other operations.",
            "when_is_it_updated": "When the `stakingToken.transfer` function is called successfully from the StabilityPool, transferring unstaked tokens to the user.",
            "how_to_validate_state_update": "Check the `balanceOf(address(this))` (StabilityPool's address) for DFIDToken. It should have decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The DFIDToken balance held by the StabilityPool contract decreases by the amount transferred to the user.",
            "conditions": [
              "The `stakingToken.transfer` call is successful and StabilityPool has sufficient balance."
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The DFIREToken balance of individual addresses.",
            "why_is_is_important": "It reflects the user's earned DFIRETokens.",
            "when_is_it_updated": "When `sbrToken.mint` is called successfully to distribute SBR rewards to the user as part of claiming.",
            "how_to_validate_state_update": "Check the `balanceOf(msg.sender)` for DFIREToken. It should have increased by `pendingSbrRewards - sbrFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The DFIREToken balance of the unstaking user (`msg.sender`) increases by the amount of SBR rewards they are eligible to receive, minus any frontend fee.",
            "conditions": [
              "`pendingSbrRewards` is not zero AND the `sbrToken.mint` call for the user is successful."
            ]
          },
          {
            "state_variable_name": "_balances[frontend]",
            "type": "uint256",
            "what_does_it_track": "The DFIREToken balance of individual addresses, specifically the frontend.",
            "why_is_is_important": "It tracks the DFIREToken rewards collected by the frontend service.",
            "when_is_it_updated": "When `sbrToken.mint` is called successfully to distribute SBR reward fees to the frontend as part of claiming.",
            "how_to_validate_state_update": "Check the `balanceOf(frontend)` for DFIREToken. It should have increased by `sbrFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The DFIREToken balance of the specified `frontend` address increases by the SBR reward fee.",
            "conditions": [
              "`pendingSbrRewards` is not zero AND `sbrFee` is greater than zero AND the `sbrToken.mint` call for the frontend is successful."
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of DFIRETokens in circulation.",
            "why_is_is_important": "It represents the total availability of DFIRETokens in the system.",
            "when_is_it_updated": "When DFIRETokens are minted to distribute SBR rewards.",
            "how_to_validate_state_update": "Check the `totalSupply()` of DFIREToken. It should have increased by the sum of SBR rewards minted to the user and the frontend.",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of DFIRETokens increases by the total amount of SBR rewards minted (user's reward + frontend fee).",
            "conditions": [
              "`pendingSbrRewards` is not zero."
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}