{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The 'amount' parameter must be greater than 0.",
      "The 'amount' parameter must be less than or equal to the user's stake, which can be obtained by calling the `users` mapping with the user's address.",
      "If unstaking through a frontend to distribute rewards/fees, provide the frontend address and fee. Otherwise, the 'frontend' parameter can be the zero address and 'fee' can be 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "State Updates",
        "state_update_descriptions": [
          "The user's stake (`users[msg.sender].stake`) is decreased by the unstaked amount.",
          "The user's reward snapshot, collateral snapshot and stake reset count are updated.",
          "The total staked amount (`totalStakedRaw`) is decreased by the unstaked amount.",
          "If `totalStakedRaw` becomes 0 and `rewardSenderActive` is true, the `stableBaseCDP` contract's `setCanStabilityPoolReceiveRewards` function is called to disable reward distribution.",
          "Claim accrued rewards and collateral before unstaking, potentially distributing fees to a frontend.",
          "The `stakingToken` is transferred from the contract to the user (`msg.sender`) for the unstaked amount.",
          "SBR rewards are potentially added if the distribution is active. These rewards are distributed proportionally to stakers.",
          "The user's reward and collateral snapshots are updated to reflect the current total reward and collateral per token.",
          "Pending rewards and collateral are calculated and transferred to the user and potentially a frontend, deducting fees where applicable.",
          "The user's stake might be adjusted based on scaling factor resets.  Scaling factor resets adjust the effective stake of all users based on changes in the total stake."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stake (`users[msg.sender].stake`) should be decreased by the unstaked amount.",
          "The user's stake (`users[msg.sender].stake`) must be greater or equal to zero.",
          "The unstaked amount should be transferred to the user's address.",
          "Verify the updated value of `users[msg.sender].rewardSnapshot` against the current `totalRewardPerToken`.",
          "Verify the updated value of `users[msg.sender].collateralSnapshot` against the current `totalCollateralPerToken`."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "The total staked amount (`totalStakedRaw`) should be decreased by the unstaked amount.",
          "The total staked amount (`totalStakedRaw`) must be greater or equal to zero."
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The user's balance of `stakingToken` should increase by the unstaked amount.",
          "If a frontend is used, the frontend's balance of `stakingToken` and ETH should increase by the reward and collateral fees, respectively."
        ]
      },
      {
        "category": "Reward Claimed",
        "rule_descriptions": [
          "Check event `RewardClaimed` to ensure that claim action emits an event.",
          "Check event `DFireRewardClaimed` to ensure that claim action emits an event for DFire reward."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Important for calculating rewards and collateral, and ensuring users can only unstake what they have staked.",
            "when_is_it_updated": "Updated when a user successfully unstakes tokens.",
            "how_to_validate_state_update": "Check the user's stake before and after the unstake, ensuring the difference matches the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the contract.",
            "why_is_is_important": "Important for calculating rewards and collateral distribution.",
            "when_is_it_updated": "Updated when a user successfully unstakes tokens.",
            "how_to_validate_state_update": "Check the total staked amount before and after the unstake, ensuring the difference matches the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked amount by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Tracks whether the reward sender is active.",
            "why_is_is_important": "Controls reward distribution to the Stability Pool.",
            "when_is_it_updated": "Updated when `totalStakedRaw` becomes zero and reward distribution is active and `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)` returns true.",
            "how_to_validate_state_update": "Check the value of rewardSenderActive before and after the unstake if totalStakedRaw becomes 0 and `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)` returns true.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially deactivates reward distribution if `totalStakedRaw` becomes zero.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive",
              "IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate the amount of SBR rewards to distribute.",
            "when_is_it_updated": "Updated when the `_addSBRRewards` function is called inside the _claim function.",
            "how_to_validate_state_update": "Check the last SBR reward distribution time before and after the `_addSBRRewards` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last SBR reward distribution time to the current block timestamp if SBR reward distribution is started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate the amount of SBR rewards to distribute.",
            "when_is_it_updated": "Updated when the `_addSBRRewards` function is called inside the _claim function.",
            "how_to_validate_state_update": "Check the last SBR reward distribution time before and after the `_addSBRRewards` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last SBR reward distribution time to the current block timestamp if SBR reward distribution is not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the end time for SBR reward distribution.",
            "why_is_is_important": "Used to determine when SBR rewards should stop being distributed.",
            "when_is_it_updated": "Updated when the `_addSBRRewards` function is called inside the _claim function and SBR reward distribution is not started.",
            "how_to_validate_state_update": "Check the SBR reward distribution end time before and after the `_addSBRRewards` function is called when SBR reward distribution is not started.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution end time to the current block timestamp plus 365 days if SBR reward distribution is not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "Tracks the status of SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "Controls the logic for distributing SBR rewards.",
            "when_is_it_updated": "Updated within the `_addSBRRewards` function which is called inside the _claim function, based on elapsed time and current status.",
            "how_to_validate_state_update": "Check the SBR reward distribution status before and after the `_addSBRRewards` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status to ENDED based on time elapsed.",
            "conditions": [
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "Tracks the status of SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "Controls the logic for distributing SBR rewards.",
            "when_is_it_updated": "Updated within the `_addSBRRewards` function which is called inside the _claim function, based on elapsed time and current status.",
            "how_to_validate_state_update": "Check the SBR reward distribution status before and after the `_addSBRRewards` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status to STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR rewards distributed per token.",
            "why_is_is_important": "Used to calculate the SBR rewards owed to each user.",
            "when_is_it_updated": "Updated within the `_addSBRRewards` function which is called inside the _claim function, if totalStakedRaw > 0.",
            "how_to_validate_state_update": "Check the total SBR reward per token before and after the `_addSBRRewards` function is called if totalStakedRaw > 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total SBR reward per token if `totalStakedRaw > 0`.",
            "conditions": [
              "totalStakedRaw > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks any loss in SBR rewards due to precision errors.",
            "why_is_is_important": "Ensures accurate SBR reward distribution.",
            "when_is_it_updated": "Updated within the `_addSBRRewards` function which is called inside the _claim function, if totalStakedRaw > 0.",
            "how_to_validate_state_update": "Check the SBR reward loss before and after the `_addSBRRewards` function is called if totalStakedRaw > 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward loss if `totalStakedRaw > 0`.",
            "conditions": [
              "totalStakedRaw > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's reward snapshot.",
            "why_is_is_important": "Used to calculate pending rewards.",
            "when_is_it_updated": "Updated in `_updateRewards` function.",
            "how_to_validate_state_update": "Check the user's reward snapshot before and after the `_updateRewards` function call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's reward snapshot to the current `totalRewardPerToken`.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's collateral snapshot.",
            "why_is_is_important": "Used to calculate pending collateral.",
            "when_is_it_updated": "Updated in `_updateRewards` function.",
            "how_to_validate_state_update": "Check the user's collateral snapshot before and after the `_updateRewards` function call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's collateral snapshot to the current `totalCollateralPerToken`.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's SBR reward snapshot.",
            "why_is_is_important": "Used to calculate pending SBR rewards.",
            "when_is_it_updated": "Updated in `_updateRewards` function.",
            "how_to_validate_state_update": "Check the user's SBR reward snapshot before and after the `_updateRewards` function call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current `totalSbrRewardPerToken`.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "uint8",
            "what_does_it_track": "Tracks the user's SBR reward snapshot status.",
            "why_is_is_important": "Used to calculate pending SBR rewards.",
            "when_is_it_updated": "Updated in `_updateRewards` function.",
            "how_to_validate_state_update": "Check the user's SBR reward snapshot status before and after the `_updateRewards` function call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot status to CLAIMED if SBR reward distribution is ended.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's effective stake.",
            "why_is_is_important": "Ensures accurate calculation of rewards and collateral.",
            "when_is_it_updated": "Updated in `_updateUserStake` function.",
            "how_to_validate_state_update": "Verify the user's stake is updated correctly based on stake scaling factor and cumulative product scaling factor.",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts user's stake based on stake scaling factor and cumulative product scaling factor.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative product of scaling factors for a user.",
            "why_is_is_important": "Used to calculate the user's effective stake.",
            "when_is_it_updated": "Updated in `_updateUserStake` function.",
            "how_to_validate_state_update": "Check that the cumulativeProductScalingFactor is updated to the current stakeScalingFactor.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's cumulative product scaling factor to the current stakeScalingFactor.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of stake resets for a user.",
            "why_is_is_important": "Used to calculate rewards and collateral accurately across stake resets.",
            "when_is_it_updated": "Updated in `_updateUserStake` function.",
            "how_to_validate_state_update": "Check that the stakeResetCount is updated to the current stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's stake reset count to the current stakeResetCount.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}