{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The amount parameter should be a positive integer greater than 0.",
      "The amount parameter should be less than or equal to the user's current stake *before* any rewards are claimed.",
      "The frontend address can be set to the zero address if no frontend fee is involved.",
      "The fee parameter should be set to 0 if no frontend fee is involved. Otherwise, it should be a value between 0 and BASIS_POINTS_DIVISOR, representing the fee percentage in basis points."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "The user's stake (users[msg.sender].stake) is decreased by the unstaked amount (_amount). The effective stake calculation is part of this update."
        ]
      },
      {
        "category": "Total Staked",
        "state_update_descriptions": [
          "The totalStakedRaw variable is decreased by the unstaked amount (_amount)."
        ]
      },
      {
        "category": "Staking Token Transfer",
        "state_update_descriptions": [
          "The stakingToken is transferred from the StabilityPool to the user (msg.sender) for the unstaked amount (_amount)."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "Pending rewards and collateral are calculated and transferred *from the contract* to the user, and to the frontend if a fee is specified.",
          "User's rewardSnapshot and collateralSnapshot are updated to the current totalRewardPerToken and totalCollateralPerToken."
        ]
      },
      {
        "category": "SBR Reward Claim",
        "state_update_descriptions": [
          "Pending SBR rewards are calculated and minted *from the contract* to the user and frontend (if a fee is specified).",
          "User's sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to the current totalSbrRewardPerToken."
        ]
      },
      {
        "category": "SBR Rewards",
        "state_update_descriptions": [
          "SBR rewards are added to the pool if the SBR reward distribution is active.",
          "totalSbrRewardPerToken and sbrRewardLoss are updated based on the time elapsed and distribution rate."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stake should be decreased by the unstaked amount.",
          "user.stake == oldUserStake - amount"
        ]
      },
      {
        "category": "Total Staked",
        "rule_descriptions": [
          "The totalStakedRaw variable should be decreased by the unstaked amount.",
          "totalStakedRaw == oldTotalStakedRaw - amount"
        ]
      },
      {
        "category": "Staking Token Transfer",
        "rule_descriptions": [
          "The user's staking token balance should increase by the unstaked amount.",
          "stakingToken.balanceOf(user) == oldStakingTokenBalance + amount"
        ]
      },
      {
        "category": "Reward Claim",
        "rule_descriptions": [
          "If rewards are claimed during unstake, the user's rewardSnapshot and collateralSnapshot should be updated to totalRewardPerToken and totalCollateralPerToken, respectively.",
          "user.rewardSnapshot == totalRewardPerToken",
          "user.collateralSnapshot == totalCollateralPerToken"
        ]
      },
      {
        "category": "SBR Reward Claim",
        "rule_descriptions": [
          "If SBR rewards are claimed during unstake, the user's sbrRewardSnapshots[msg.sender].rewardSnapshot should be updated to totalSbrRewardPerToken.",
          "sbrRewardSnapshots[msg.sender].rewardSnapshot == totalSbrRewardPerToken"
        ]
      },
      {
        "category": "Unstaked Event",
        "rule_descriptions": [
          "Verify that the Unstaked event is emitted with the correct parameters.",
          "The user address in the event should match the sender's address (msg.sender).",
          "The amount in the event should match the unstaked amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens a user has staked in the StabilityPool.",
            "why_is_is_important": "Accurately reflects the user's investment and determines their share of rewards.",
            "when_is_it_updated": "The user's stake is reduced when they unstake tokens.",
            "how_to_validate_state_update": "Check the user's stake before and after the unstake to ensure it decreases by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by the amount unstaked.",
            "conditions": [
              "The unstake amount must be greater than zero.",
              "The unstake amount must be less than or equal to the user's current stake."
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Keeps track of total staked amount in stability pool",
            "why_is_is_important": "Used to calculate reward distribution.",
            "when_is_it_updated": "Total staked amount is decreased when user unstakes.",
            "how_to_validate_state_update": "Verify the totalStakedRaw amount before and after unstake operation",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by the amount unstaked.",
            "conditions": [
              "Amount unstaked should be greater than 0.",
              "Amount unstaked should be less than the user's stake."
            ]
          },
          {
            "state_variable_name": "IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)",
            "type": "bool",
            "what_does_it_track": "Whether the StabilityPool can receive rewards from the reward sender.",
            "why_is_is_important": "Stops reward distribution when no tokens are staked.",
            "when_is_it_updated": "When totalStakedRaw becomes 0 and rewardSenderActive is true.",
            "how_to_validate_state_update": "Check the value of rewardSenderActive and the return value of setCanStabilityPoolReceiveRewards.",
            "has_conditional_updates": true,
            "summary_of_update": "setCanStabilityPoolReceiveRewards set to false",
            "conditions": [
              "totalStakedRaw is equal to 0",
              "rewardSenderActive is true"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime, sbrRewardDistributionEndTime, sbrRewardDistributionStatus, totalSbrRewardPerToken, sbrRewardLoss",
            "type": "uint256, uint256, enum, uint256, uint256",
            "what_does_it_track": "SBR rewards distribution status",
            "why_is_is_important": "Calculates and distributes SBR rewards if distribution is ongoing",
            "when_is_it_updated": "Before calculating reward or collateral updates, only if rewards haven't ended.",
            "how_to_validate_state_update": "Examine sbrRewardDistributionStatus",
            "has_conditional_updates": true,
            "summary_of_update": "Updates SBR rewards based on time elapsed and distribution rate.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot, user.collateralSnapshot, sbrRewardSnapshots[msg.sender].rewardSnapshot, sbrRewardSnapshots[msg.sender].status",
            "type": "uint256, uint256, uint256, enum",
            "what_does_it_track": "Snapshots of totalRewardPerToken, totalCollateralPerToken, and totalSbrRewardPerToken.",
            "why_is_is_important": "Used to calculate pending rewards and collateral for the user.",
            "when_is_it_updated": "Always, before user stake is effectively updated.",
            "how_to_validate_state_update": "Verify rewardSnapshot, collateralSnapshot, and sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "has_conditional_updates": false,
            "summary_of_update": "Updates snapshots to the current global reward and collateral per token values.",
            "conditions": []
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor, user.stakeResetCount",
            "type": "uint256, uint256",
            "what_does_it_track": "Scaling factor and reset count to adjust user stake",
            "why_is_is_important": "Used to update user stake based on scaling factor and reset count",
            "when_is_it_updated": "Always, after claim but before token transfer.",
            "how_to_validate_state_update": "Verify user.cumulativeProductScalingFactor and user.stakeResetCount",
            "has_conditional_updates": false,
            "summary_of_update": "Update user's stake based on current state variables",
            "conditions": []
          },
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, _amount)",
            "type": "function call",
            "what_does_it_track": "Transfer of unstaked tokens to the user.",
            "why_is_is_important": "Transfers the unstaked tokens back to the user.",
            "when_is_it_updated": "After updating user stake and total staked amount.",
            "how_to_validate_state_update": "Check the user's balance before and after the transfer.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers unstaked tokens from the contract to the user.",
            "conditions": []
          },
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, pendingReward - rewardFee), stakingToken.transfer(frontend, rewardFee)",
            "type": "function call",
            "what_does_it_track": "Transfer of reward tokens from the contract to the user and frontend.",
            "why_is_is_important": "Distributes accumulated reward tokens to the user.",
            "when_is_it_updated": "When pending reward tokens are transferred to user and frontend.",
            "how_to_validate_state_update": "Check balances of msg.sender and frontend before and after the transfer.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to user and frontend if pending rewards exist.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee), sbrToken.mint(frontend, sbrFee)",
            "type": "function call",
            "what_does_it_track": "Minting of SBR reward tokens to the user and frontend.",
            "why_is_is_important": "Distributes accumulated SBR reward tokens to the user.",
            "when_is_it_updated": "When pending SBR reward tokens are minted to user and frontend.",
            "how_to_validate_state_update": "Check balances of msg.sender and frontend before and after the mint.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to user and frontend if pending SBR rewards exist.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      }
    ]
  }
}