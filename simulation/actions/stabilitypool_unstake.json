{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "Amount must be greater than zero.",
      "Amount must be less than or equal to the user's current stake.",
      "Frontend address can be zero if no frontend is involved.",
      "Fee can be zero if no fee is involved."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Update",
        "state_update_descriptions": [
          "users[msg.sender].stake is decreased by _amount.",
          "totalStakedRaw is decreased by _amount."
        ]
      },
      {
        "category": "Reward Claim and Distribution",
        "state_update_descriptions": [
          "Pending rewards and collateral are calculated and distributed to msg.sender, potentially incurring frontend fees.",
          "The user's rewardSnapshot and collateralSnapshot are updated.",
          "SBR reward snapshots are updated based on the distribution status.",
          "SBR rewards are minted to msg.sender.",
          "Fees are transferred to the frontend if applicable."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "stakingToken is transferred from the contract to msg.sender."
        ]
      },
      {
        "category": "SBR Reward Distribution Management",
        "state_update_descriptions": [
          "SBR reward distribution status and timestamps are updated based on elapsed time and distribution rate.",
          "totalSbrRewardPerToken is updated if SBR rewards are active.",
          "sbrRewardLoss is updated."
        ]
      },
      {
        "category": "Reward Sender Management",
        "state_update_descriptions": [
          "rewardSenderActive might be set to false if totalStakedRaw reaches zero."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Validation",
        "rule_descriptions": [
          "users[msg.sender].stake should reflect the unstaked amount.",
          "totalStakedRaw should be reduced by the unstaked amount."
        ]
      },
      {
        "category": "Token Balance Validation",
        "rule_descriptions": [
          "The balance of stakingToken for msg.sender should increase by the unstaked amount.",
          "The contract's stakingToken balance should decrease by the unstaked amount."
        ]
      },
      {
        "category": "Reward and Collateral Validation",
        "rule_descriptions": [
          "User's pending rewards and collateral should be appropriately adjusted after claiming.",
          "totalRewardPerToken, totalCollateralPerToken, and totalSbrRewardPerToken should be consistent with any new rewards added."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "An Unstaked event should be emitted with the correct user and amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Reflects the actual stake of a user and affects reward calculations and liquidation possibilities. It's crucial for tracking individual user contributions to the pool.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the user's stake is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the specified amount (_amount).",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the pool.",
            "why_is_is_important": "It's crucial for calculating reward distribution and determining pool stability. It's a global variable that reflects the overall health of the pool.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the totalStakedRaw is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked amount in the pool by the specified amount (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Indicates if reward distribution is active.",
            "why_is_is_important": "Controls whether the StabilityPool can receive rewards. If no tokens are staked, rewards should not be distributed to the pool.",
            "when_is_it_updated": "When totalStakedRaw becomes zero after unstaking.",
            "how_to_validate_state_update": "Check if IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false) is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially deactivates reward distribution from the reward sender if totalStakedRaw becomes zero and rewardSenderActive is true.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "It is used to calculate the SBR rewards to be distributed.",
            "when_is_it_updated": "During the _addSBRRewards function, called by _claim when unstaking if the SBR reward distribution has not ended.",
            "how_to_validate_state_update": "Verify that _addSBRRewards is called when the condition is true.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the lastSBRRewardDistributedTime when the SBR reward distribution is started.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward distribution.",
            "why_is_is_important": "Indicates whether SBR rewards can be distributed.",
            "when_is_it_updated": "During the _addSBRRewards function, called by _claim when unstaking.",
            "how_to_validate_state_update": "Verify that sbrRewardDistributionStatus is set to SBRRewardDistribution.ENDED.",
            "has_conditional_updates": true,
            "summary_of_update": "If the current block timestamp is greater than the sbrRewardDistributionEndTime, update the sbrRewardDistributionStatus to ENDED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward distribution.",
            "why_is_is_important": "Initializes the SBR reward distribution process.",
            "when_is_it_updated": "During the _addSBRRewards function, called by _claim when unstaking.",
            "how_to_validate_state_update": "Verify that sbrRewardDistributionStatus is set to SBRRewardDistribution.STARTED and lastSBRRewardDistributedTime and sbrRewardDistributionEndTime are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "If SBR reward distribution has not started, it initializes the distribution, setting status to STARTED and updating related timestamps.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of a user's reward and collateral.",
            "why_is_is_important": "Used to calculate the amount of reward and collateral user should receive",
            "when_is_it_updated": "Called by _claim when unstaking.",
            "how_to_validate_state_update": "Verify userPendingRewardAndCollateral function",
            "has_conditional_updates": true,
            "summary_of_update": "Update the user's rewardSnapshot and collateralSnapshot to the current totalRewardPerToken and totalCollateralPerToken",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of a user's reward and collateral.",
            "why_is_is_important": "Used to calculate the amount of reward and collateral user should receive",
            "when_is_it_updated": "Called by _claim when unstaking.",
            "how_to_validate_state_update": "Verify userPendingRewardAndCollateral function",
            "has_conditional_updates": true,
            "summary_of_update": "Update the user's rewardSnapshot and collateralSnapshot to the current totalRewardPerToken and totalCollateralPerToken",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's SBR reward snapshot.",
            "why_is_is_important": "Used to calculate the user's SBR reward.",
            "when_is_it_updated": "In the _updateRewards function, which is called by the unstake function, if SBR reward distribution is not ended.",
            "how_to_validate_state_update": "Verify that sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to totalSbrRewardPerToken.",
            "has_conditional_updates": true,
            "summary_of_update": "Takes a snapshot of the totalSbrRewardPerToken for the user, which is later used to calculate the user's SBR reward.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward distribution for the user.",
            "why_is_is_important": "Indicates if SBR rewards for the user have been claimed.",
            "when_is_it_updated": "In the _updateRewards function, which is called by the unstake function, if SBR reward distribution is ended.",
            "how_to_validate_state_update": "Verify that sbrRewardSnapshots[msg.sender].status is updated to SBRRewardDistribution.CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "If SBR reward distribution is ended, the status of the user's snapshot is set to CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "The user's stake.",
            "why_is_is_important": "Used for reward calculations.",
            "when_is_it_updated": "Called by _updateUserStake function",
            "how_to_validate_state_update": "Verify with _getUserEffectiveStake function",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts user's stake, calculates the user's effective stake based on stake scaling factor",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative product scaling factor for a user.",
            "why_is_is_important": "Used for calculating reward distribution based on stake changes.",
            "when_is_it_updated": "During unstaking, in the _updateUserStake function.",
            "how_to_validate_state_update": "Check that user's cumulativeProductScalingFactor is updated to stakeScalingFactor.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulative product scaling factor.",
            "conditions": []
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of stake resets for a user.",
            "why_is_is_important": "Used for calculating reward distribution based on stake resets.",
            "when_is_it_updated": "During unstaking, in the _updateUserStake function.",
            "how_to_validate_state_update": "Check that user's stakeResetCount is updated to stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stake reset count.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Tracks the token balance of each user.",
            "why_is_is_important": "Reflects the user's token balance after unstaking.",
            "when_is_it_updated": "When the StabilityPool unstakes the tokens to the user.",
            "how_to_validate_state_update": "Check the balance of msg.sender increases by _amount after unstake.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers the unstaked tokens (_amount) to the user (msg.sender).",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBR token balance of each user.",
            "why_is_is_important": "Distributes SBR rewards to the user.",
            "when_is_it_updated": "During the _updateRewards function, which is called by the unstake function, if there are pending SBR rewards.",
            "how_to_validate_state_update": "Verify that sbrToken.mint is called with msg.sender and pendingSbrRewards - sbrFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the user based on pending SBR rewards.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}