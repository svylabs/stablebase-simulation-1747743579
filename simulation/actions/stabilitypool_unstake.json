{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "amount: The amount of tokens to unstake. Must be greater than 0 and less than or equal to the user's current stake.",
      "frontend: (Optional) The address of the frontend receiving a fee. Can be zero address.",
      "fee: (Optional) The fee to be paid to the frontend, in basis points (out of 10000). Defaults to 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "users[msg.sender].stake is decreased by _amount."
        ]
      },
      {
        "category": "Total Staked",
        "state_update_descriptions": [
          "totalStakedRaw is decreased by _amount."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "stakingToken.transfer(msg.sender, _amount) transfers _amount of staking tokens to the user."
        ]
      },
      {
        "category": "Reward Calculation",
        "state_update_descriptions": [
          "User's pending reward and collateral are calculated based on their stake and global reward/collateral per token values.",
          "Reward and collateral snapshots are updated for the user."
        ]
      },
      {
        "category": "Reward Distribution",
        "state_update_descriptions": [
          "Rewards are distributed to the user and a frontend, if applicable.",
          "Collateral is transferred to the user and a frontend, if applicable.",
          "SBR rewards are minted for the user and a frontend, if applicable."
        ]
      },
      {
        "category": "SBR Rewards",
        "state_update_descriptions": [
          "SBR rewards are added if the distribution is active, potentially updating totalSbrRewardPerToken and sbrRewardLoss."
        ]
      },
      {
        "category": "Reward Sender Status",
        "state_update_descriptions": [
          "If totalStakedRaw becomes zero and rewardSenderActive is true, the stableBaseCDP's ability to receive rewards may be disabled."
        ]
      },
      {
        "category": "Stake Resets",
        "state_update_descriptions": [
          "User stake is adjusted based on scaling factors and reset snapshots, potentially updating user.cumulativeProductScalingFactor and user.stakeResetCount."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "users[msg.sender].stake should decrease by the unstaked amount.",
          "users[msg.sender].stake should be non-negative. If the unstaked amount equals the initial stake, users[msg.sender].stake should be 0."
        ]
      },
      {
        "category": "Total Staked",
        "rule_descriptions": [
          "totalStakedRaw should decrease by the unstaked amount.",
          "totalStakedRaw should be non-negative. If the unstaked amount equals the initial totalStakedRaw, totalStakedRaw should be 0."
        ]
      },
      {
        "category": "Token Transfer",
        "rule_descriptions": [
          "The user's stakingToken balance should increase by the unstaked amount, verifiable through a separate balance check on the stakingToken contract.",
          "Verify the stakingToken's transfer function was successfully called with the correct parameters (recipient and amount)."
        ]
      },
      {
        "category": "Reward Snapshots",
        "rule_descriptions": [
          "user.rewardSnapshot should be updated to totalRewardPerToken after the claim.",
          "user.collateralSnapshot should be updated to totalCollateralPerToken after the claim.",
          "sbrRewardSnapshots[msg.sender].rewardSnapshot should be updated to totalSbrRewardPerToken if SBR rewards are active.",
          "If SBR rewards are ended, sbrRewardSnapshots[msg.sender].status should be set to CLAIMED."
        ]
      },
      {
        "category": "Reward and Collateral Claim",
        "rule_descriptions": [
          "If rewards or collateral are claimed during the unstake, ensure the user's balances have increased accordingly based on rewards and collateral calculations.",
          "If a frontend address is specified and a fee is applicable, verify that the specified frontend has received the correct fee amount of rewards and collateral.",
          "Verify that the appropriate events (RewardClaimed, DFireRewardClaimed) are emitted with the correct parameters (user, reward, rewardFee, collateral, collateralFee, sbrReward, sbrRewardFee)."
        ]
      },
      {
        "category": "Stake Reset",
        "rule_descriptions": [
          "The user's cumulativeProductScalingFactor should be updated to stakeScalingFactor.",
          "The user's stakeResetCount should be updated to stakeResetCount.",
          "Verify that the user's effective stake is correctly recalculated based on stake resets and scaling factors."
        ]
      },
      {
        "category": "SBR Rewards",
        "rule_descriptions": [
          "If SBR rewards are active, verify that totalSbrRewardPerToken has been updated correctly based on the elapsed time and distribution rate.",
          "If SBR rewards are active, ensure sbrRewardLoss is correctly adjusted.",
          "Verify the SBRRewardsAdded event is emitted with the correct parameters (lastTime, currentTime, rewardAmount, totalRewardPerToken)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens a user has staked in the StabilityPool.",
            "why_is_is_important": "Tracks the amount staked by the user, ensuring non-zero and valid amounts.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the user's stake is decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Total amount of tokens staked in the StabilityPool.",
            "why_is_is_important": "Reflects the total amount staked in the pool.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the total staked amount is decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked amount by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP.setCanStabilityPoolReceiveRewards(false)",
            "type": "bool",
            "what_does_it_track": "Whether the StabilityPool can receive rewards from the RewardSender contract.",
            "why_is_is_important": "Controls reward distribution, preventing it when no tokens are staked.",
            "when_is_it_updated": "When totalStakedRaw becomes zero after an unstake.",
            "how_to_validate_state_update": "Verify that reward distribution is disabled when conditions are met.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially disables reward distribution if totalStakedRaw becomes zero and rewardSenderActive is true.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBR rewards distributed per token.",
            "why_is_is_important": "Tracks the total SBR reward per token, accrues SBR rewards",
            "when_is_it_updated": "When claim is triggered and SBR reward distribution status is not ENDED",
            "how_to_validate_state_update": "Check if totalSbrRewardPerToken increased, and verify if event SBRRewardsAdded is emitted",
            "has_conditional_updates": true,
            "summary_of_update": "Increment totalSbrRewardPerToken",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "The amount of SBR rewards that were lost due to precision errors or other issues.",
            "why_is_is_important": "Tracks loss of SBR rewards",
            "when_is_it_updated": "When claim is triggered and SBR reward distribution status is not ENDED",
            "how_to_validate_state_update": "Check if sbrRewardLoss is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Update SBR reward loss",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The last time SBR rewards were distributed.",
            "why_is_is_important": "Initialize reward distribution",
            "when_is_it_updated": "When sbr reward distribution status is not started",
            "how_to_validate_state_update": "Check the timestamp",
            "has_conditional_updates": true,
            "summary_of_update": "Initialize time",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The end time of the SBR reward distribution period.",
            "why_is_is_important": "Initialize reward distribution",
            "when_is_it_updated": "When sbr reward distribution status is not started",
            "how_to_validate_state_update": "Check if the end time is equal to block.timestamp + 365 days",
            "has_conditional_updates": true,
            "summary_of_update": "Initialize end time",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "The status of SBR reward distribution.",
            "why_is_is_important": "Initialize reward distribution",
            "when_is_it_updated": "When sbr reward distribution status is not started",
            "how_to_validate_state_update": "Check if the status is STARTED",
            "has_conditional_updates": true,
            "summary_of_update": "Set the status to STARTED",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "uint8",
            "what_does_it_track": "The reward claim status for a user",
            "why_is_is_important": "Set the status to CLAIMED",
            "when_is_it_updated": "When sbr reward distribution status is ENDED",
            "how_to_validate_state_update": "Check if the status is CLAIMED",
            "has_conditional_updates": true,
            "summary_of_update": "Set the status to CLAIMED",
            "conditions": [
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED && sbrRewardDistributionStatus == SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The snapshot of totalSbrRewardPerToken for a user.",
            "why_is_is_important": "Track rewards",
            "when_is_it_updated": "When _claim is called",
            "how_to_validate_state_update": "Compare with global variable",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the snapshot of SBR rewards",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Users effective stake after scaling factors",
            "why_is_is_important": "Updates user stake",
            "when_is_it_updated": "When claim is triggered and user has cumulativeProductScalingFactor != 0",
            "how_to_validate_state_update": "Compare the stake value",
            "has_conditional_updates": true,
            "summary_of_update": "Update user stake",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "tracks a scaling factor",
            "why_is_is_important": "Resets the user's cumulative product scaling factor to the current global scaling factor",
            "when_is_it_updated": "Always",
            "how_to_validate_state_update": "Verify cumulativeProductScalingFactor",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulativeProductScalingFactor",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "The number of stake resets that have occurred.",
            "why_is_is_important": "Keeps track of scaling factor",
            "when_is_it_updated": "Always",
            "how_to_validate_state_update": "Compare with global variable",
            "has_conditional_updates": false,
            "summary_of_update": "Update stake reset count",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, _amount)",
            "type": "bool",
            "what_does_it_track": "Transfers the staking token",
            "why_is_is_important": "Transfers the unstaked tokens back to the user.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the user's balance of stakingToken increased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers staking tokens to the user.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee)",
            "type": "bool",
            "what_does_it_track": "DFIRE token transfer",
            "why_is_is_important": "Mints SBR tokens to the user",
            "when_is_it_updated": "When claim is triggered",
            "how_to_validate_state_update": "Verify that the user's balance of sbrToken increased",
            "has_conditional_updates": true,
            "summary_of_update": "Mint DFIRE token to user",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "sbrToken.mint(frontend, sbrFee)",
            "type": "bool",
            "what_does_it_track": "DFIRE token transfer",
            "why_is_is_important": "Mints SBR tokens to frontend",
            "when_is_it_updated": "When claim is triggered",
            "how_to_validate_state_update": "Verify that the frontend's balance of sbrToken increased",
            "has_conditional_updates": true,
            "summary_of_update": "Mint DFIRE token to frontend",
            "conditions": [
              "sbrFee > 0",
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "stabilityPool"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "mockPriceOracle"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "stabilityPool"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "dfireStaking"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "safesOrderedForRedemption"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}