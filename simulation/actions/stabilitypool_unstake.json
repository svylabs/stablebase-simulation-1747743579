{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The amount to unstake must be greater than 0.  A require statement enforces this.",
      "The amount to unstake must be less than or equal to the user's current stake.  A require statement enforces this.",
      "The user must have a sufficient balance of staking tokens in the StabilityPool to unstake. This is implicitly checked by the user.stake value.",
      "Consider that require statements in the code can cause the transaction to revert if conditions are not met."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake",
        "state_update_descriptions": [
          "The user's stake is decreased by the unstaked amount."
        ]
      },
      {
        "category": "Total Stake",
        "state_update_descriptions": [
          "The total staked amount in the StabilityPool is decreased by the unstaked amount."
        ]
      },
      {
        "category": "Rewards and Collateral",
        "state_update_descriptions": [
          "Pending rewards, collateral, and SBR rewards are calculated and transferred to the user if any exist.",
          "User's rewardSnapshot, collateralSnapshot, and sbrRewardSnapshots are updated.",
          "Fees for rewards, collateral and SBR rewards are transferred to the frontend, if applicable.",
          "sbrToken is minted to the user and frontend with reward calculation."
        ]
      },
      {
        "category": "User Scaling Factors",
        "state_update_descriptions": [
          "The user's stake is adjusted based on scaling factors.",
          "The user's cumulativeProductScalingFactor and stakeResetCount are updated to reflect the current scaling factor and reset count."
        ]
      },
      {
        "category": "Reward Distribution Control",
        "state_update_descriptions": [
          "If totalStakedRaw becomes 0, the rewardSenderActive flag is potentially set to false, preventing the StabilityPool from receiving further rewards.  This will trigger a call to stableBaseCDP.setCanStabilityPoolReceiveRewards(false) if rewardSenderActive was initially true.",
          "The status of SBR reward distribution can be updated to ENDED if the current block timestamp exceeds sbrRewardDistributionEndTime."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Reduction",
        "rule_descriptions": [
          "The user's stake in the StabilityPool should be decreased by the unstaked amount.",
          "user.stake == initial_user.stake - unstake_amount."
        ]
      },
      {
        "category": "Total Stake Reduction",
        "rule_descriptions": [
          "The totalStakedRaw in the StabilityPool should be decreased by the unstaked amount.",
          "totalStakedRaw == initial_totalStakedRaw - unstake_amount."
        ]
      },
      {
        "category": "Token Transfer",
        "rule_descriptions": [
          "The user's staking token balance should increase by the unstaked amount.",
          "stakingToken.balanceOf(user) == initial_stakingToken.balanceOf(user) + unstake_amount.",
          "The stakingToken.transfer call must succeed. If it fails, the transaction will revert.",
          "Check the stakingToken.transfer event is emitted with correct arguments."
        ]
      },
      {
        "category": "Reward Claiming",
        "rule_descriptions": [
          "Pending rewards, collateral, and SBR rewards should have been claimed and transferred to the user if they existed.",
          "userPendingRewardAndCollateral(user) should return 0 for pending rewards, collateral and sbr rewards after the unstake operation, assuming no other activity has occurred in the meantime.  If frontend and fee parameters are used, the fees are transferred to the frontend address.",
          "frontend should receive fees for rewards, collateral and sbr rewards if frontend and fee are given.",
          "Check the RewardClaimed and DFireRewardClaimed events are emitted with correct arguments."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens a user has staked in the pool.",
            "why_is_is_important": "Reflects the correct amount of tokens a user has staked in the pool, ensuring correct reward calculation and preventing over-unstaking.",
            "when_is_it_updated": "When a user successfully unstakes tokens.",
            "how_to_validate_state_update": "Check the user's `stake` value using the `users` mapping after the `unstake` function is called. It should be reduced by the `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduces the staker's stake by the unstaked amount.",
            "conditions": [
              "The unstake amount must be greater than zero.",
              "The unstake amount must be less than or equal to the user's current stake."
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total amount of staked tokens in the StabilityPool.",
            "why_is_is_important": "Reflects the total staked amount in the contract, important for calculating rewards, liquidation, and checking pool emptiness.",
            "when_is_it_updated": "When a user successfully unstakes tokens.",
            "how_to_validate_state_update": "Check the `totalStakedRaw` variable after the `unstake` function is called. It should be reduced by the `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total amount of staked tokens in the StabilityPool.",
            "conditions": [
              "The unstake amount must be greater than zero.",
              "The unstake amount must be less than or equal to the user's current stake."
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Indicates whether the reward sender is active.",
            "why_is_is_important": "Stops reward distribution when there are no more tokens staked, saving gas and preventing potential errors.",
            "when_is_it_updated": "When totalStakedRaw becomes zero after unstaking.",
            "how_to_validate_state_update": "Check the value of `rewardSenderActive` after unstaking when `totalStakedRaw` is zero. It should be false.",
            "has_conditional_updates": true,
            "summary_of_update": "Deactivates the reward sender if totalStakedRaw becomes zero.",
            "conditions": [
              "totalStakedRaw is 0",
              "rewardSenderActive is true"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Reward snapshot for the user.",
            "why_is_is_important": "Ensures correct reward calculation for the user when they claim rewards or perform other actions.",
            "when_is_it_updated": "Every time a user unstakes.",
            "how_to_validate_state_update": "Check that `user.rewardSnapshot` and other user info variables are updated with current global values using `getUser` after unstaking.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Collateral snapshot for the user.",
            "why_is_is_important": "Ensures correct collateral calculation for the user.",
            "when_is_it_updated": "Every time a user unstakes.",
            "how_to_validate_state_update": "Check that `user.collateralSnapshot` is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Scaling factor for the user's stake.",
            "why_is_is_important": "Tracks the cumulative product of scaling factors, used to calculate a user's effective stake across stake resets.",
            "when_is_it_updated": "Every time a user unstakes.",
            "how_to_validate_state_update": "Check that user info has been updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulativeProductScalingFactor",
            "conditions": []
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Stake reset count for the user.",
            "why_is_is_important": "Tracks the number of stake resets the user's stake has been through, used to determine which snapshots to use for reward calculation.",
            "when_is_it_updated": "Every time a user unstakes.",
            "how_to_validate_state_update": "Check that user info has been updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stakeResetCount",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "User's SBR reward snapshot.",
            "why_is_is_important": "Keeps track of SBR rewards for users, ensuring correct SBR reward calculation.",
            "when_is_it_updated": "During unstaking, if SBR reward distribution is active.",
            "how_to_validate_state_update": "Inspect `sbrRewardSnapshots` mapping for the user's address and verify the `rewardSnapshot`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "uint8",
            "what_does_it_track": "User's SBR reward claim status.",
            "why_is_is_important": "Tracks SBR reward status for users, preventing multiple claims after the reward period has ended.",
            "when_is_it_updated": "During unstaking, when SBR reward distribution has ended and the status hasn't been claimed yet.",
            "how_to_validate_state_update": "Inspect `sbrRewardSnapshots` mapping for the user's address and verify the `status`.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets SBR reward snapshot status to CLAIMED if reward distribution is ended.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "msg.sender's balance in stakingToken",
            "type": "uint256",
            "what_does_it_track": "User's balance of staking tokens.",
            "why_is_is_important": "Returns the unstaked tokens to the user's wallet, allowing them to use or transfer the tokens elsewhere.",
            "when_is_it_updated": "When a user successfully unstakes tokens.",
            "how_to_validate_state_update": "Check the user's balance of the staking token after unstaking. It should increase by the unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers staking tokens to the user.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "msg.sender's balance",
            "type": "uint256",
            "what_does_it_track": "User's balance of SBR tokens.",
            "why_is_is_important": "Distributes SBR rewards to stakers, incentivizing participation in the StabilityPool.",
            "when_is_it_updated": "When pending SBR rewards are claimed during unstaking.",
            "how_to_validate_state_update": "Check the user's SBR token balance after unstaking. It should increase by the pendingSbrRewards (minus fee, if any).",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to the user as a reward.",
            "conditions": [
              "pendingSbrRewards > 0"
            ]
          },
          {
            "state_variable_name": "frontend's balance",
            "type": "uint256",
            "what_does_it_track": "Frontend's balance of SBR tokens.",
            "why_is_is_important": "Incentivizes frontends to direct users to the StabilityPool, contributing to its growth and stability.",
            "when_is_it_updated": "When a frontend receives a fee from claimed SBR rewards during unstaking.",
            "how_to_validate_state_update": "Check the frontend's SBR token balance after unstaking. It should increase by the sbrFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to the frontend as a fee.",
            "conditions": [
              "sbrFee > 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of DFIRE token.",
            "why_is_is_important": "Reflects the total supply of DFIRE token.",
            "when_is_it_updated": "When the _mint function is called.",
            "how_to_validate_state_update": "Check the `totalSupply` variable after the `mint` function is called. It should be increased by the `amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total supply of DFIRE token.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[to]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The balance of a specified account.",
            "why_is_is_important": "Reflects the balance of the account.",
            "when_is_it_updated": "When the account receives tokens.",
            "how_to_validate_state_update": "Check the `balanceOf` variable after the `mint` function is called. It should be increased by the `amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the balance of a specified account.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      }
    ]
  }
}