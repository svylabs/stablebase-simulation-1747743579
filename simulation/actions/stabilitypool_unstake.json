{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The 'amount' parameter must be a positive integer.",
      "The 'amount' parameter must not exceed the current staked amount of 'msg.sender' in the 'StabilityPool' contract (i.e., 'amount' <= 'users[msg.sender].stake')."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "StabilityPool Contract State",
        "state_update_descriptions": [
          "The 'stake' of 'msg.sender' within the 'users' mapping is decreased by the 'amount' specified.",
          "The 'totalStakedRaw' global variable is decreased by the 'amount' specified.",
          "The 'rewardSnapshot' for 'msg.sender' in the 'users' mapping is updated to the current 'totalRewardPerToken'.",
          "The 'collateralSnapshot' for 'msg.sender' in the 'users' mapping is updated to the current 'totalCollateralPerToken'.",
          "The 'cumulativeProductScalingFactor' for 'msg.sender' in the 'users' mapping is updated to the current 'stakeScalingFactor'.",
          "The 'stakeResetCount' for 'msg.sender' in the 'users' mapping is updated to the current 'stakeResetCount'.",
          "The 'rewardSnapshot' for 'msg.sender' in the 'sbrRewardSnapshots' mapping is updated to 'totalSbrRewardPerToken' if SBR reward distribution is not ended.",
          "The 'status' for 'msg.sender' in the 'sbrRewardSnapshots' mapping is set to 'CLAIMED' if SBR reward distribution has ended.",
          "If 'sbrRewardDistributionStatus' was 'NOT_STARTED', it changes to 'STARTED'.",
          "The 'lastSBRRewardDistributedTime' is updated to 'block.timestamp'.",
          "If 'sbrRewardDistributionStatus' changes from 'NOT_STARTED' to 'STARTED', 'sbrRewardDistributionEndTime' is set to 'block.timestamp + 365 days'.",
          "If SBR rewards are added (i.e., time elapsed since 'lastSBRRewardDistributedTime' and 'sbrRewardDistributionStatus' is 'STARTED'), 'totalSbrRewardPerToken' increases and 'sbrRewardLoss' is adjusted."
        ]
      },
      {
        "category": "Token Balances",
        "state_update_descriptions": [
          "The 'stakingToken' (DFIDToken) balance of 'msg.sender' increases by the unstaked 'amount' plus any calculated pending reward.",
          "The 'stakingToken' (DFIDToken) balance of the 'StabilityPool' contract decreases by the unstaked 'amount' plus any calculated pending reward.",
          "The native token (ETH) balance of 'msg.sender' increases by any calculated pending collateral.",
          "The native token (ETH) balance of the 'StabilityPool' contract decreases by any calculated pending collateral.",
          "The 'sbrToken' (DFIREToken) balance of 'msg.sender' increases by any calculated pending SBR rewards.",
          "The 'DFIREToken' (sbrToken) 'totalSupply' increases by any calculated pending SBR rewards."
        ]
      },
      {
        "category": "External Contract State",
        "state_update_descriptions": [
          "If 'totalStakedRaw' becomes 0 and 'rewardSenderActive' is true, the 'canStabilityPoolReceiveRewards' state in the 'StableBaseCDP' contract is set to 'false'."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "StabilityPool Contract State",
        "rule_descriptions": [
          "The 'stake' of 'msg.sender' in the 'users' mapping must be reduced by the 'amount' that was unstaked, accounting for any internal adjustments from reward claiming and stake updates.",
          "The 'totalStakedRaw' in the 'StabilityPool' contract must be decreased by the 'amount' that was unstaked.",
          "The 'rewardSnapshot', 'collateralSnapshot', 'cumulativeProductScalingFactor', and 'stakeResetCount' for 'msg.sender' in the 'users' mapping must be updated to reflect the state after reward claiming and stake adjustment.",
          "If SBR rewards were claimable, the 'sbrRewardSnapshots[msg.sender].rewardSnapshot' must be updated to the new 'totalSbrRewardPerToken' and 'sbrRewardSnapshots[msg.sender].status' may change to 'CLAIMED' if the distribution period has ended.",
          "If 'sbrRewardDistributionStatus' was 'NOT_STARTED' before execution, it must be 'STARTED' after execution, and 'lastSBRRewardDistributedTime' and 'sbrRewardDistributionEndTime' must be set correctly.",
          "If 'sbrRewardDistributionStatus' was 'STARTED' and 'block.timestamp' is beyond 'sbrRewardDistributionEndTime', the 'sbrRewardDistributionStatus' must transition to 'ENDED'."
        ]
      },
      {
        "category": "Token Balance Changes",
        "rule_descriptions": [
          "The 'stakingToken' (DFIDToken) balance of 'msg.sender' must have increased by the unstaked 'amount' plus any calculated pending reward (since frontend fee is 0).",
          "The 'stakingToken' (DFIDToken) balance of the 'StabilityPool' contract must have decreased by the unstaked 'amount' plus any calculated pending reward.",
          "The native token (ETH) balance of 'msg.sender' must have increased by any calculated pending collateral (since frontend fee is 0).",
          "The native token (ETH) balance of the 'StabilityPool' contract must have decreased by any calculated pending collateral.",
          "The 'sbrToken' (DFIREToken) balance of 'msg.sender' must have increased by any calculated pending SBR rewards (since frontend fee is 0).",
          "The 'DFIREToken' (sbrToken) 'totalSupply' must have increased by any calculated pending SBR rewards."
        ]
      },
      {
        "category": "External Contract Interactions",
        "rule_descriptions": [
          "If 'totalStakedRaw' becomes 0 in 'StabilityPool' and 'rewardSenderActive' is true, then 'StableBaseCDP.canStabilityPoolReceiveRewards()' must be 'false'."
        ]
      },
      {
        "category": "Events Emitted",
        "rule_descriptions": [
          "An 'Unstaked' event must be emitted by 'StabilityPool' with 'user' as 'msg.sender' and 'amount' matching the unstaked 'amount'.",
          "A 'RewardClaimed' event must be emitted by 'StabilityPool' with 'user' as 'msg.sender', 'totalReward' matching the calculated pending reward, 'rewardFrontendFee' as 0, 'totalCollateral' matching the calculated pending collateral, and 'collateralFrontendFee' as 0.",
          "If any SBR rewards were processed ('pendingSbrRewards' > 0), a 'DFireRewardClaimed' event must be emitted by 'StabilityPool' with 'user' as 'msg.sender', 'amount' matching the calculated pending SBR rewards, and 'frontendFee' as 0.",
          "If SBR rewards were added during the transaction (i.e., '_addSBRRewards' was executed), an 'SBRRewardsAdded' event should be emitted by 'StabilityPool'.",
          "A 'Transfer' event must be emitted by the 'stakingToken' (DFIDToken) contract, showing the transfer of unstaked amount and claimed reward from 'StabilityPool' to 'msg.sender'.",
          "If SBR rewards were minted, a 'Transfer' event must be emitted by the 'sbrToken' (DFIREToken) contract, showing the mint from 'address(0)' to 'msg.sender'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of `stakingToken` tokens that a specific user has staked in the Stability Pool.",
            "why_is_is_important": "It tracks the individual contributions of users to the Stability Pool and determines their share of rewards and collateral.",
            "when_is_it_updated": "It is updated when a user successfully unstakes tokens. It is first adjusted to reflect effective stake and then explicitly reduced by the `_amount` provided.",
            "how_to_validate_state_update": "Compare the user's stake before and after the transaction. The new stake should be the old stake minus the unstaked amount, after potential adjustments from reward claiming and stake scaling.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's staked amount is reduced by the specified `_amount`. Additionally, the user's effective stake might be updated prior to the reduction based on `_getUserEffectiveStake` and `stakeScalingFactor` during the `_updateUserStake` call within `_claim`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The cumulative raw (unscaled) amount of all `stakingToken` tokens currently staked in the Stability Pool.",
            "why_is_is_important": "It provides a global count of the total liquidity in the Stability Pool, crucial for reward distribution calculations and determining if the reward sender should be deactivated.",
            "when_is_it_updated": "It is updated whenever tokens are staked or unstaked from the Stability Pool.",
            "how_to_validate_state_update": "Compare the total staked raw amount before and after the transaction. The new total should be the old total minus the unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The total raw amount of tokens staked in the Stability Pool is reduced by the `_amount` unstaked by the user.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp when SBR rewards were last calculated and added to the pool's reward per token.",
            "why_is_is_important": "It serves as the starting point for calculating elapsed time to determine new SBR rewards in subsequent distributions.",
            "when_is_it_updated": "It is updated each time `_addSBRRewards` is called, which happens before calculating rewards for the user's claim.",
            "how_to_validate_state_update": "Observe `lastSBRRewardDistributedTime` for updates. It will be set to `block.timestamp` if SBR rewards are being added or initialized.",
            "has_conditional_updates": true,
            "summary_of_update": "The timestamp of the last SBR reward distribution is updated to the current block's timestamp. This occurs regardless of whether SBR rewards are actually distributed or if the distribution simply starts.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED (before calling _addSBRRewards)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The current phase of SBR reward distribution: `NOT_STARTED`, `STARTED`, or `ENDED`.",
            "why_is_is_important": "It controls the lifecycle of SBR reward distribution, affecting when rewards are added and when users can claim them.",
            "when_is_it_updated": "It is updated within `_addSBRRewards` if the distribution end time has passed, or if the distribution is starting for the first time.",
            "how_to_validate_state_update": "Monitor `sbrRewardDistributionStatus`. It changes to ENDED if the distribution period has passed.",
            "has_conditional_updates": true,
            "summary_of_update": "The status of SBR reward distribution is updated to `ENDED` if the current block timestamp exceeds the `sbrRewardDistributionEndTime`. It can also be set to `STARTED` if it was `NOT_STARTED`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED (before calling _addSBRRewards)",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp when the SBR reward distribution period is scheduled to end.",
            "why_is_is_important": "It defines the duration over which SBR rewards are accumulated and distributed to stakers.",
            "when_is_it_updated": "It is set only once, when the SBR reward distribution status transitions from `NOT_STARTED` to `STARTED`.",
            "how_to_validate_state_update": "Check `sbrRewardDistributionEndTime`. It will be set to `block.timestamp + 365 days` if SBR reward distribution starts.",
            "has_conditional_updates": true,
            "summary_of_update": "The end time for SBR reward distribution is set to `block.timestamp + 365 days` if the distribution status is `NOT_STARTED`, effectively initiating the distribution period.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED (before calling _addSBRRewards)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBR rewards earned per unit of staked `stakingToken` tokens.",
            "why_is_is_important": "It is a crucial metric for calculating each user's share of SBR rewards based on their staked amount and duration.",
            "when_is_it_updated": "It is updated within `_addSBRRewards` when SBR rewards are added to the pool, provided the distribution is active and there are staked tokens.",
            "how_to_validate_state_update": "Monitor `totalSbrRewardPerToken`. It increases proportionally to the time elapsed and the `sbrDistributionRate` if there are staked tokens.",
            "has_conditional_updates": true,
            "summary_of_update": "The total SBR reward accumulated per unit of staked token is increased. This calculation is based on the elapsed time since the last distribution, `sbrDistributionRate`, and `totalStakedRaw`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED (before calling _addSBRRewards)",
              "totalStakedRaw > 0 (after current unstake operation, relevant for calculation)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "A residual amount of SBR rewards that could not be fully distributed `perToken` in the previous calculation, which is carried over to the next distribution.",
            "why_is_is_important": "It ensures that no SBR reward is lost due to integer arithmetic, carrying over small amounts to be included in future distributions.",
            "when_is_it_updated": "It is updated within `_addSBRRewards` when new SBR rewards are added to the pool, if `totalStakedRaw` is greater than 0.",
            "how_to_validate_state_update": "Check `sbrRewardLoss`. It is updated to reflect any remainder from the SBR reward distribution calculation.",
            "has_conditional_updates": true,
            "summary_of_update": "Any fractional SBR reward that cannot be perfectly distributed `perToken` due to integer division is accumulated in `sbrRewardLoss`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED (before calling _addSBRRewards)",
              "totalStakedRaw > 0 (after current unstake operation, relevant for calculation)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of `totalRewardPerToken` at the time a user's rewards were last claimed or their stake was updated.",
            "why_is_is_important": "It is used to calculate the pending rewards for a user by comparing it with the current `totalRewardPerToken`.",
            "when_is_it_updated": "It is updated every time `_updateRewards` is called, which happens when a user claims rewards or unstakes.",
            "how_to_validate_state_update": "Compare `users[msg.sender].rewardSnapshot` before and after. It should be updated to `totalRewardPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "The `rewardSnapshot` for the user is updated to the current `totalRewardPerToken`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of `totalCollateralPerToken` at the time a user's collateral was last claimed or their stake was updated.",
            "why_is_is_important": "It is used to calculate the pending collateral for a user by comparing it with the current `totalCollateralPerToken`.",
            "when_is_it_updated": "It is updated every time `_updateRewards` is called, which happens when a user claims rewards or unstakes.",
            "how_to_validate_state_update": "Compare `users[msg.sender].collateralSnapshot` before and after. It should be updated to `totalCollateralPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "The `collateralSnapshot` for the user is updated to the current `totalCollateralPerToken`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of `totalSbrRewardPerToken` at the time a user's SBR rewards were last claimed or their stake was updated.",
            "why_is_is_important": "It is used to calculate the pending SBR rewards for a user by comparing it with the current `totalSbrRewardPerToken`.",
            "when_is_it_updated": "It is updated within `_updateRewards` if the SBR reward distribution is still active.",
            "how_to_validate_state_update": "Observe `sbrRewardSnapshots[msg.sender].rewardSnapshot`. It updates to `totalSbrRewardPerToken` if SBR distribution is not ended.",
            "has_conditional_updates": true,
            "summary_of_update": "The `rewardSnapshot` for SBR rewards for the user is updated to the current `totalSbrRewardPerToken`. This occurs if the SBR reward distribution has not `ENDED`.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED (before calling _updateRewards)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "The claiming status of SBR rewards for a specific user.",
            "why_is_is_important": "It prevents a user from claiming SBR rewards multiple times after the distribution has officially ended.",
            "when_is_it_updated": "It is updated within `_updateRewards` when the SBR reward distribution is over and the user's rewards are processed.",
            "how_to_validate_state_update": "Check `sbrRewardSnapshots[msg.sender].status`. It will be set to `CLAIMED` if the distribution has ended and the user's snapshot status is not already claimed.",
            "has_conditional_updates": true,
            "summary_of_update": "The SBR reward snapshot status for the user is set to `CLAIMED` if the overall SBR reward distribution has `ENDED` and the user's status is not already `CLAIMED`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED (before calling _updateRewards)",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "A cumulative product of scaling factors used to accurately calculate a user's effective stake over time, especially after stake resets.",
            "why_is_is_important": "It ensures that the user's stake is correctly scaled for reward calculations, taking into account any changes in the global `stakeScalingFactor`.",
            "when_is_it_updated": "It is updated within `_updateUserStake` during a claim or unstake operation.",
            "how_to_validate_state_update": "Observe `users[msg.sender].cumulativeProductScalingFactor`. It should be updated to the current `stakeScalingFactor`.",
            "has_conditional_updates": false,
            "summary_of_update": "The `cumulativeProductScalingFactor` for the user is updated to the current global `stakeScalingFactor`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "The count of how many times the global stake scaling factor has been reset or updated since the user last interacted with the pool.",
            "why_is_is_important": "It is used in conjunction with `stakeResetSnapshots` to accurately calculate a user's rewards across multiple scaling factor reset periods.",
            "when_is_it_updated": "It is updated within `_updateUserStake` during a claim or unstake operation.",
            "how_to_validate_state_update": "Observe `users[msg.sender].stakeResetCount`. It should be updated to the current `stakeResetCount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The `stakeResetCount` for the user is updated to the current global `stakeResetCount`.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}