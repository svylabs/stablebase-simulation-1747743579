{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The 'amount' parameter should be a positive integer representing the amount of tokens to unstake.",
      "The 'amount' should be less than or equal to the user's current stake.",
      "If frontend address and fee are used, then the frontend address should be a valid Ethereum address, and the fee should be a non-negative integer.",
      "The 'msg.sender' must have a stake greater than 0 in the StabilityPool contract."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake and Reward Updates",
        "state_update_descriptions": [
          "User's stake is reduced by the unstaked amount: users[msg.sender].stake -= _amount",
          "User's reward snapshot is updated: user.rewardSnapshot = totalRewardPerToken",
          "User's collateral snapshot is updated: user.collateralSnapshot = totalCollateralPerToken",
          "User's cumulativeProductScalingFactor is updated: user.cumulativeProductScalingFactor = stakeScalingFactor",
          "User's stakeResetCount is updated: user.stakeResetCount = stakeResetCount",
          "SBR reward snapshot is updated for the user: sbrRewardSnapshots[msg.sender].rewardSnapshot = totalSbrRewardPerToken (if applicable)",
          "SBR reward status is updated to CLAIMED if distribution ended: sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution.CLAIMED (if applicable)"
        ]
      },
      {
        "category": "Total Stake Update",
        "state_update_descriptions": [
          "Total staked amount is reduced: totalStakedRaw -= _amount"
        ]
      },
      {
        "category": "Token Transfers and Reward Claim",
        "state_update_descriptions": [
          "Staking tokens are transferred from the contract to the user: stakingToken.transfer(msg.sender, _amount)",
          "Rewards are transferred to the user: stakingToken.transfer(msg.sender, pendingReward - rewardFee) (if applicable)",
          "Collateral is transferred to the user: msg.sender.call{value: pendingCollateral - collateralFee}(\"\") (if applicable)",
          "SBR rewards are minted for the user: sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee) (if applicable)",
          "Reward and collateral are claimed and transferred to the user and frontend (if applicable), based on fees."
        ]
      },
      {
        "category": "Reward Sender Update",
        "state_update_descriptions": [
          "If totalStakedRaw becomes 0, reward distribution from stableBaseCDP might be disabled: IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false) (if applicable)"
        ]
      },
      {
        "category": "SBR Rewards Distribution",
        "state_update_descriptions": [
          "SBR rewards are added based on time elapsed if SBR reward distribution is active: _addSBRRewards() (if applicable)"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake and Reward Validation",
        "rule_descriptions": [
          "users[msg.sender].stake should be less than or equal to initial stake minus unstaked amount.",
          "users[msg.sender].rewardSnapshot should be equal to totalRewardPerToken at the time of unstaking.",
          "users[msg.sender].collateralSnapshot should be equal to totalCollateralPerToken at the time of unstaking.",
          "users[msg.sender].cumulativeProductScalingFactor should be equal to stakeScalingFactor at the time of unstaking.",
          "users[msg.sender].stakeResetCount should be equal to stakeResetCount at the time of unstaking.",
          "If sbrRewardDistributionStatus is ENDED, sbrRewardSnapshots[msg.sender].status should be equal to CLAIMED.",
          "sbrRewardSnapshots[msg.sender].rewardSnapshot should be equal to totalSbrRewardPerToken at the time of unstaking, if SBR rewards are active."
        ]
      },
      {
        "category": "Total Stake Validation",
        "rule_descriptions": [
          "totalStakedRaw should be less than or equal to its initial value minus the unstaked amount."
        ]
      },
      {
        "category": "Token Balance Validation",
        "rule_descriptions": [
          "The user's staking token balance should increase by the unstaked amount.",
          "Contract's staking token balance should decrease by unstaked amount, rewards, and fees."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "An 'Unstaked' event must be emitted with the user's address and the unstaked amount.",
          "A 'RewardClaimed' event must be emitted with the user's address, reward amount, reward fee, collateral amount and collateral fee (if applicable).",
          "A 'DFireRewardClaimed' event must be emitted with the user's address, SBR reward amount, and SBR reward fee if SBR rewards were claimed (if applicable)."
        ]
      },
      {
        "category": "Stake Reset Parameter Validation",
        "rule_descriptions": [
          "Verify the consistency of stake scaling factor, total reward per token, total collateral per token, and total SBR reward per token in stakeResetSnapshots."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Reflects the current amount of tokens the user has staked in the pool. Incorrect accounting leads to incorrect reward calculation or unstake failures. Directly influences the amount of reward user can get and amount user can unstake. Without accurate stake tracking, the entire StabilityPool's functionality breaks down. Updated only if amount is greater than zero",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the user's stake is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the specified amount (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the StabilityPool.",
            "why_is_is_important": "Represents the total stake in the StabilityPool. Used for calculating reward distribution and checking for total pool status. Incorrect total staked calculations affect reward distribution accuracy. Updated only if amount is greater than zero",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if totalStakedRaw is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total amount of staked tokens by the specified amount (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP.setCanStabilityPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "Determines if the StabilityPool is eligible to receive rewards.",
            "why_is_is_important": "Halts reward distribution when no tokens are staked to prevent sending rewards to an empty pool. Updated only if totalStakedRaw is zero and rewardSenderActive is true",
            "when_is_it_updated": "When all tokens have been unstaked from the StabilityPool.",
            "how_to_validate_state_update": "Check if IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false) is called successfully",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the ability to receive rewards to false on the reward distribution contract if totalStakedRaw is zero.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the users current stake relative to scaling factors.",
            "why_is_is_important": "Ensures user stakes accurately reflect cumulative scaling factor changes. Updated only if cumulativeProductScalingFactor is not zero",
            "when_is_it_updated": "Whenever the user's effective stake needs to be adjusted based on stake resets.",
            "how_to_validate_state_update": "Verify that user.stake has been correctly updated",
            "has_conditional_updates": true,
            "summary_of_update": "The users stake is updated using the _getUserEffectiveStake() function if their cumulativeProductScalingFactor is not 0",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks a cumulative product of scaling factors applied to the user's stake.",
            "why_is_is_important": "Necessary for adjusting user stakes correctly, particularly after stake resets or scaling factor changes. This always happens",
            "when_is_it_updated": "Whenever the user's stake is adjusted or reset.",
            "how_to_validate_state_update": "Verify that user.cumulativeProductScalingFactor matches stakeScalingFactor",
            "has_conditional_updates": false,
            "summary_of_update": "User's cumulative product scaling factor is updated to the current stakeScalingFactor.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of stake resets a user has experienced.",
            "why_is_is_important": "Used for calculating the user's effective stake and rewards based on stake reset snapshots. This always happens",
            "when_is_it_updated": "Whenever a stake reset occurs.",
            "how_to_validate_state_update": "Verify that user.stakeResetCount matches stakeResetCount",
            "has_conditional_updates": false,
            "summary_of_update": "User's stake reset count is updated to the current stakeResetCount.",
            "conditions": []
          },
          {
            "state_variable_name": "Internal Call _addSBRRewards",
            "type": "Internal Call",
            "what_does_it_track": "Handles the process of adding SBR rewards based on elapsed time and distribution rate.",
            "why_is_is_important": "Ensures the correct amount of SBR rewards are added to the pool during the distribution period. This only happens if the sbrRewardDistributionStatus is not ended",
            "when_is_it_updated": "When SBR rewards are actively being distributed.",
            "how_to_validate_state_update": "Verify that the internal function _addSBRRewards is called when rewards distribution is not ended.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds SBR rewards to the pool if the distribution is ongoing.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward distribution.",
            "why_is_is_important": "Controls whether SBR rewards are actively distributed or not. updated if timestamp is greater than end time",
            "when_is_it_updated": "When the reward distribution period has ended.",
            "how_to_validate_state_update": "Verify that sbrRewardDistributionStatus changes to SBRRewardDistribution.ENDED when timestamp exceeds end time.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes the SBR reward distribution status to ENDED if the current timestamp is greater than the distribution end time.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used as the starting point for calculating rewards. Happens only when rewards distribution is started",
            "when_is_it_updated": "When SBR rewards are added.",
            "how_to_validate_state_update": "Verify that lastSBRRewardDistributedTime is updated to block.timestamp.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last SBR reward distribution time to the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total SBR reward per token.",
            "why_is_is_important": "Used for calculating the amount of SBR rewards a user is entitled to. only updated if rewards distribution is started and tokens are staked",
            "when_is_it_updated": "When SBR rewards are added and there are tokens staked.",
            "how_to_validate_state_update": "Verify that totalSbrRewardPerToken is incremented by a calculated amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increments total SBR reward per token based on the amount of time elapsed and the distribution rate.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of SBR reward lost due to precision errors.",
            "why_is_is_important": "Accounts for precision errors in SBR reward distribution. updated if rewards distribution is started and tokens are staked",
            "when_is_it_updated": "When SBR rewards are added and there are tokens staked.",
            "how_to_validate_state_update": "Verify that sbrRewardLoss is updated based on the difference between the calculated reward and the actual reward distributed.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward loss based on the difference between the calculated reward and the amount actually distributed.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used as the starting point for calculating rewards. This initializes the time only when distribution has not yet started",
            "when_is_it_updated": "When the SBR reward distribution is about to start.",
            "how_to_validate_state_update": "Verify that lastSBRRewardDistributedTime is updated to block.timestamp.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the last SBR reward distribution time to the current block timestamp if the distribution hasn't started yet.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the end time of SBR reward distribution.",
            "why_is_is_important": "Determines the duration of the SBR reward distribution. This initializes the time only when distribution has not yet started",
            "when_is_it_updated": "When the SBR reward distribution is about to start.",
            "how_to_validate_state_update": "Verify that sbrRewardDistributionEndTime is set to block.timestamp + 365 days.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the SBR reward distribution end time to 365 days from the current block timestamp if the distribution hasn't started yet.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward distribution.",
            "why_is_is_important": "Indicates whether SBR rewards are actively being distributed. updated only when rewards distribution has not yet started",
            "when_is_it_updated": "When the SBR reward distribution is about to start.",
            "how_to_validate_state_update": "Verify that sbrRewardDistributionStatus is updated to SBRRewardDistribution.STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the SBR reward distribution status to STARTED if the distribution hasn't started yet.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "User Rewards Claim",
            "type": "Internal Call",
            "what_does_it_track": "Calculate and transfer pending rewards, collateral, and SBR rewards to the user.",
            "why_is_is_important": "Allows users to collect rewards based on their stake. Rewards are calculated and claimed in this step",
            "when_is_it_updated": "Each time a user unstakes.",
            "how_to_validate_state_update": "Check if pending reward, collateral, and sbr rewards are correctly calculated.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculate and transfer pending rewards, collateral, and SBR rewards to the user.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks whether SBR rewards have been claimed.",
            "why_is_is_important": "Prevents users from claiming rewards multiple times. Status only updates if distribution has ended and rewards are claimed",
            "when_is_it_updated": "When the distribution ends and rewards are claimed.",
            "how_to_validate_state_update": "Verify sbrRewardSnapshots[msg.sender].status is updated to SBRRewardDistribution.CLAIMED if SBR reward distribution has ended.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward snapshot status to CLAIMED if the distribution has ended.",
            "conditions": [
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBR reward snapshot of a user.",
            "why_is_is_important": "Used to calculate the amount of SBR rewards the user is entitled to. Updated when rewards are distributed",
            "when_is_it_updated": "When the user claims rewards.",
            "how_to_validate_state_update": "Verify that sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to totalSbrRewardPerToken if rewards distribution is not ended.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current total SBR reward per token if rewards distribution is not ended.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the reward snapshot of a user.",
            "why_is_is_important": "Used to calculate the amount of rewards the user is entitled to. Rewards are added to user's account",
            "when_is_it_updated": "When the user claims rewards.",
            "how_to_validate_state_update": "Verify that user.rewardSnapshot is updated to totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot to the current total reward per token.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral snapshot of a user.",
            "why_is_is_important": "Used to calculate the amount of collateral the user is entitled to. Collateral is added to user's account",
            "when_is_it_updated": "When the user claims rewards.",
            "how_to_validate_state_update": "Verify that user.collateralSnapshot is updated to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot to the current total collateral per token.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}