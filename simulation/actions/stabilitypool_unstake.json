{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "Amount must be greater than 0.",
      "Amount must be less than or equal to user's current stake.",
      "If unstaking via frontend, frontend address and fee must be valid.",
      "Amount should be within reasonable bounds to prevent integer overflow."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Update",
        "state_update_descriptions": [
          "Decrease user's stake: `users[msg.sender].stake -= _amount;`",
          "Decrease total staked amount: `totalStakedRaw -= _amount;`"
        ]
      },
      {
        "category": "Reward Claim and Distribution",
        "state_update_descriptions": [
          "Calculate and transfer pending rewards (SBR, collateral, and staking token) to the user, deducting any fees.",
          "Update user's reward snapshots: `user.rewardSnapshot = totalRewardPerToken;`, `user.collateralSnapshot = totalCollateralPerToken;`, `sbrRewardSnapshots[msg.sender].rewardSnapshot = totalSbrRewardPerToken;`",
          "Transfer fees to the frontend (if a frontend address and fee are specified).",
          "Potentially mint sbrToken to user."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfer unstaked tokens from the StabilityPool to the user: `stakingToken.transfer(msg.sender, _amount);`"
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "Potentially add SBR rewards, updating `totalSbrRewardPerToken`, `sbrRewardLoss`, and `lastSBRRewardDistributedTime`.",
          "Potentially set `sbrRewardDistributionEndTime` and `sbrRewardDistributionStatus` if SBR distribution is starting.",
          "Potentially set `rewardSenderActive` to false if `totalStakedRaw` becomes zero."
        ]
      },
      {
        "category": "Scaling Factor Update",
        "state_update_descriptions": [
          "Update user's cumulativeProductScalingFactor and stakeResetCount"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Balance",
        "rule_descriptions": [
          "User's staking token balance should increase by the unstaked amount.",
          "User's stake (`users[msg.sender].stake`) should be decreased by the unstaked amount."
        ]
      },
      {
        "category": "Total Staked",
        "rule_descriptions": [
          "Total staked amount (`totalStakedRaw`) should decrease by the unstaked amount.",
          "If `totalStakedRaw` becomes 0, `stableBaseCDP.setCanStabilityPoolReceiveRewards(false)` should be called."
        ]
      },
      {
        "category": "Reward State",
        "rule_descriptions": [
          "User's reward snapshots should reflect the current global reward per token values.",
          "Contract's reward-related variables should be consistent with amounts claimed during unstake."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "`Unstaked` event should be emitted.",
          "`RewardClaimed` event should be emitted.",
          "`DFireRewardClaimed` event should be emitted (if applicable)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "StabilityPool",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens the user has staked in the StabilityPool.",
            "why_is_is_important": "Reflects the user's current stake, which is used to calculate rewards and collateral claimable.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the user's stake is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the specified amount (_amount).",
            "conditions": [
              "_amount > 0 - The amount to unstake must be greater than zero"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the StabilityPool.",
            "why_is_is_important": "Used to calculate reward distribution and determine if reward sending should be deactivated when totalStakedRaw reaches zero.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if totalStakedRaw is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked amount by the specified amount (_amount).",
            "conditions": [
              "_amount > 0 - The amount to unstake must be greater than zero"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP.setCanStabilityPoolReceiveRewards(false)",
            "type": "bool",
            "what_does_it_track": "Whether reward can be distributed or not",
            "why_is_is_important": "Stops reward distribution when there are no more tokens staked.",
            "when_is_it_updated": "When totalStakedRaw becomes zero.",
            "how_to_validate_state_update": "Check if `stableBaseCDP.setCanStabilityPoolReceiveRewards(false)` is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Deactivates reward distribution from stableBaseCDP when totalStakedRaw reaches zero and rewardSenderActive is true.",
            "conditions": [
              "totalStakedRaw == 0 - When no more tokens are staked in the pool",
              "rewardSenderActive - Only if the reward sender is active"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR rewards distributed per token.",
            "why_is_is_important": "Used to calculate the SBR rewards claimable by users.",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is active.",
            "how_to_validate_state_update": "Verify the calculations for timeElapsed, sbrReward, _sbrReward, _totalSbrRewardPerToken, totalSbrRewardPerToken, and sbrRewardLoss.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total SBR reward per token based on the time elapsed since the last distribution and the SBR distribution rate.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED - The SBR reward distribution period hasn't ended",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED - The SBR reward distribution has started"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the loss amount of SBR",
            "why_is_is_important": "Accumulates any dust that wasn't distributed because of int division",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is active.",
            "how_to_validate_state_update": "Verify the calculations for timeElapsed, sbrReward, _sbrReward, _totalSbrRewardPerToken, totalSbrRewardPerToken, and sbrRewardLoss.",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks any loss of SBR rewards due to precision errors during distribution calculation.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED - The SBR reward distribution period hasn't ended",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED - The SBR reward distribution has started"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks last SBR distribution time",
            "why_is_is_important": "It represents the time of last sbr distribution, from which the rewards are calculated",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is not started.",
            "how_to_validate_state_update": "check if lastSBRRewardDistributedTime is equal to block.timestamp",
            "has_conditional_updates": true,
            "summary_of_update": "sets the lastSBRRewardDistributedTime with block.timestamp",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED - The SBR reward distribution period hasn't ended",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED - SBR reward distribution hasn't started"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks last SBR distribution end time",
            "why_is_is_important": "It represents the end time of sbr distribution",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is not started.",
            "how_to_validate_state_update": "check if sbrRewardDistributionEndTime is equal to block.timestamp + 365 days",
            "has_conditional_updates": true,
            "summary_of_update": "sets the sbrRewardDistributionEndTime with block.timestamp + 365 days",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED - The SBR reward distribution period hasn't ended",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED - SBR reward distribution hasn't started"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "The state of sbr distribution",
            "why_is_is_important": "It represents the start of sbr distribution, which affects the flow",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is not started.",
            "how_to_validate_state_update": "Check the enum value of sbrRewardDistributionStatus",
            "has_conditional_updates": true,
            "summary_of_update": "Sets sbrRewardDistributionStatus to STARTED",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED - The SBR reward distribution period hasn't ended",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED - SBR reward distribution hasn't started"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's reward snapshot",
            "why_is_is_important": "Used to calculate pending rewards for the user.",
            "when_is_it_updated": "During `_claim` if the user has a non-zero cumulativeProductScalingFactor.",
            "how_to_validate_state_update": "Calculate pendingReward, pendingCollateral, and pendingSbrRewards using the formulas in `userPendingRewardAndCollateral` and check that rewardSnapshot, collateralSnapshot and sbrRewardSnapshots[msg.sender].rewardSnapshot are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's reward snapshot to the current total reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0 - The user has a non-zero cumulative product scaling factor, meaning they have staked before"
            ]
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's collateral snapshot",
            "why_is_is_important": "Used to calculate pending collateral for the user.",
            "when_is_it_updated": "During `_claim` if the user has a non-zero cumulativeProductScalingFactor.",
            "how_to_validate_state_update": "Calculate pendingReward, pendingCollateral, and pendingSbrRewards using the formulas in `userPendingRewardAndCollateral` and check that rewardSnapshot, collateralSnapshot and sbrRewardSnapshots[msg.sender].rewardSnapshot are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's collateral snapshot to the current total collateral per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0 - The user has a non-zero cumulative product scaling factor, meaning they have staked before"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The reward snapshot for user",
            "why_is_is_important": "Used to calculate pending SBR rewards for the user.",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is not ended and the user has a non-zero cumulativeProductScalingFactor.",
            "how_to_validate_state_update": "Calculate pendingReward, pendingCollateral, and pendingSbrRewards using the formulas in `userPendingRewardAndCollateral` and check that rewardSnapshot, collateralSnapshot and sbrRewardSnapshots[msg.sender].rewardSnapshot are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current total SBR reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0 - The user has a non-zero cumulative product scaling factor, meaning they have staked before",
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED - The SBR reward distribution period hasn't ended"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "uint8",
            "what_does_it_track": "The state of sbr claim for user",
            "why_is_is_important": "Prevents further SBR reward claims after the distribution has ended.",
            "when_is_it_updated": "During `_claim` if SBR reward distribution is ended and the status is not already CLAIMED.",
            "how_to_validate_state_update": "Check the enum value of `sbrRewardSnapshots[msg.sender].status`",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the user's SBR reward snapshot status to CLAIMED when SBR reward distribution has ended and the status is not already CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED - SBR reward distribution period has ended",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED - The user has not claimed rewards"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks user's stake",
            "why_is_is_important": "Represents the stake",
            "when_is_it_updated": "When claim happens.",
            "how_to_validate_state_update": "Verify that user.stake is updated using the `_getUserEffectiveStake` function.",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts user's stake based on scaling factors and reset snapshots using internal function `_getUserEffectiveStake`.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0 - The user has a non-zero cumulative product scaling factor, meaning they have staked before"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks product scaling factor",
            "why_is_is_important": "Maintains correct tracking of stake over time.",
            "when_is_it_updated": "Always during claim.",
            "how_to_validate_state_update": "Verify that cumulativeProductScalingFactor is updated to the current stakeScalingFactor and stakeResetCount is updated to the current stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulative product scaling factor to the current stake scaling factor.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the stake reset count for the user.",
            "why_is_is_important": "Maintains correct tracking of stake over time.",
            "when_is_it_updated": "Always during claim.",
            "how_to_validate_state_update": "Verify that stakeResetCount is updated to the current stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stake reset count to the current stake reset count.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, _amount)",
            "type": "function_call",
            "what_does_it_track": "Tracks the transfer of tokens.",
            "why_is_is_important": "Ensures that the unstaked tokens are sent to the user's address.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if the stakingToken.transfer(msg.sender, _amount) is called and successful. Also verify the emitted Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the unstaked tokens to the user.",
            "conditions": [
              "_amount > 0 - The amount to unstake must be greater than zero"
            ]
          },
          {
            "state_variable_name": "stakingToken.transfer(msg.sender, pendingReward - rewardFee)",
            "type": "function_call",
            "what_does_it_track": "Tracks the transfer of reward tokens.",
            "why_is_is_important": "Sends pending reward to the user",
            "when_is_it_updated": "When user has pending rewards.",
            "how_to_validate_state_update": "Check if the stakingToken.transfer(msg.sender, pendingReward - rewardFee) is called and successful. Also verify the emitted Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the pending reward to the user, minus any fees.",
            "conditions": [
              "pendingReward != 0 - User has pending rewards to claim"
            ]
          },
          {
            "state_variable_name": "stakingToken.transfer(frontend, rewardFee)",
            "type": "function_call",
            "what_does_it_track": "Tracks the fee transfer",
            "why_is_is_important": "Sends fee to the frontend",
            "when_is_it_updated": "When there is rewardFee",
            "how_to_validate_state_update": "Check if the stakingToken.transfer(frontend, rewardFee) is called and successful. Also verify the emitted Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward fees to the frontend address.",
            "conditions": [
              "rewardFee > 0 - There is a reward fee to be paid",
              "pendingReward != 0 - User has pending rewards to claim"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee)",
            "type": "function_call",
            "what_does_it_track": "Tracks the minting of sbr rewards",
            "why_is_is_important": "Mints the reward for the user",
            "when_is_it_updated": "When there are pending rewards",
            "how_to_validate_state_update": "Check if the sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee) is called and successful. Also verify the emitted Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the user, minus any fees.",
            "conditions": [
              "pendingSbrRewards != 0 - User has pending SBR rewards to claim"
            ]
          },
          {
            "state_variable_name": "sbrToken.mint(frontend, sbrFee)",
            "type": "function_call",
            "what_does_it_track": "Tracks the sbr fee transfer",
            "why_is_is_important": "Mints sbr fee for the frontend",
            "when_is_it_updated": "When there is sbr fee",
            "how_to_validate_state_update": "Check if the sbrToken.mint(frontend, sbrFee) is called and successful. Also verify the emitted Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the frontend address, representing fees.",
            "conditions": [
              "sbrFee > 0 - There is an SBR fee to be paid",
              "pendingSbrRewards != 0 - User has pending SBR rewards to claim"
            ]
          }
        ]
      },
      {
        "contract_name": "Address",
        "state_updated": [
          {
            "state_variable_name": "msg.sender.call{value: pendingCollateral - collateralFee}(\"\")",
            "type": "function_call",
            "what_does_it_track": "The msg.sender collateral transfer",
            "why_is_is_important": "Sends accrued collateral to user",
            "when_is_it_updated": "When pendingCollateral is not zero",
            "how_to_validate_state_update": "Check if the msg.sender.call{value: pendingCollateral - collateralFee}(\"\") is called and successful",
            "has_conditional_updates": true,
            "summary_of_update": "Sends collateral reward to user, minus fee",
            "conditions": [
              "pendingCollateral != 0 - User has pending collateral to claim"
            ]
          },
          {
            "state_variable_name": "frontend.call{value: collateralFee}(\"\")",
            "type": "function_call",
            "what_does_it_track": "The frontend collateral fee transfer",
            "why_is_is_important": "Sends accrued collateral fees to frontend",
            "when_is_it_updated": "When collateralFee is not zero",
            "how_to_validate_state_update": "Check if the frontend.call{value: collateralFee}(\"\") is called and successful",
            "has_conditional_updates": true,
            "summary_of_update": "Sends collateral fee to frontend",
            "conditions": [
              "collateralFee > 0 - Collateral fee is to be paid",
              "pendingCollateral != 0 - User has pending collateral to claim"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function unstake(uint256 amount) external {\n        unstake(amount, msg.sender, 0);\n    }\nfunction unstake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStakedRaw -= _amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "DFIREToken"
            }
          ]
        }
      }
    ]
  }
}