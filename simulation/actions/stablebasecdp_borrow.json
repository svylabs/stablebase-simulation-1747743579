{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Must be a valid safeId that exists and is owned by the caller.",
      "amount: Must be a non-zero amount that does not exceed the maximum borrowable amount for the given safe.",
      "amount: The borrow amount should be greater than or equal to the MINIMUM_DEBT.",
      "shieldingRate: Should be a valid shielding rate in basis points.",
      "nearestSpotInLiquidationQueue:  A safe id that exists in the liquidation queue or 0.",
      "nearestSpotInRedemptionQueue: A safe id that exists in the redemption queue or 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the borrowedAmount of the safe by adding the borrowed amount.",
          "Updates the totalBorrowedAmount of the safe by adding the borrowed amount.",
          "Updates the weight of the safe based on the shielding rate and existing borrowings. The weight determines the redemption fee.",
          "Updates the feePaid of the safe by adding the shielding fee."
        ]
      },
      {
        "category": "Token Minting",
        "state_update_descriptions": [
          "Mints SBD tokens to the borrower, subtracting any shielding fees and adding any refunds.",
          "Mints SBD tokens to the contract itself to distribute as fees if mint parameter is true during fee distribution."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes fees to SBR stakers and the stability pool.",
          "Burns any refunded fees from the contract if the canRefund parameter is greater than zero and mint parameter is true."
        ]
      },
      {
        "category": "Doubly Linked Lists",
        "state_update_descriptions": [
          "Upserts the safe into the redemption queue based on its weight.",
          "Upserts the safe into the liquidation queue based on its borrowAmount per unit collateral ratio.",
          "Updates the prev pointers in doubly linked list of redemption and liquidation queues."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Increases the totalDebt of the protocol."
        ]
      },
      {
        "category": "Liquidation Snapshots",
        "state_update_descriptions": [
          "Updates liquidation snapshots with cumulative collateral and debt per unit collateral values."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "Increases the total collateral by the amount of collateral increased"
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "Updates the protocol mode from Bootstrap to Normal if debt is above threshold"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safe.borrowedAmount should increase by the borrow amount.",
          "safe.totalBorrowedAmount should increase by the borrow amount.",
          "safe.feePaid should increase by the shielding fee amount.",
          "The weight of the safe should be updated correctly based on the shielding rate and existing borrowings."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The borrower's SBD token balance should increase by the borrowed amount, minus the shielding fee, plus any refunds.",
          "The contract's SBD token balance should increase by the shielding fee amount and decrease by canRefund amount if any refunds are issued."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "The totalDebt of the protocol should increase by the borrowed amount."
        ]
      },
      {
        "category": "Doubly Linked Lists",
        "rule_descriptions": [
          "The safe should be correctly inserted or updated in the redemption queue based on its weight.",
          "The safe should be correctly inserted or updated in the liquidation queue based on its borrowAmount per unit collateral ratio.",
          "The pointers of nodes in the linked lists should be correctly updated."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A Borrowed event should be emitted with the correct parameters (safeId, amount, weight, totalCollateral, totalDebt, nearestSpotInRedemptionQueue, nearestSpotInLiquidationQueue).",
          "A FeeDistributed event should be emitted if a shielding fee is charged.",
          "A FeeRefund event should be emitted if a portion of the fee is refunded."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the collateral amount, borrowed amount, weight, total borrowed amount, and fee paid for each safe.",
            "why_is_is_important": "This is important because it reflects the current state of each safe and impacts liquidation and redemption processes.",
            "when_is_it_updated": "This is updated when a user borrows debt against their collateral.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId to ensure the collateralAmount, borrowedAmount, weight and other relevant fields have been updated as expected. Also, verify that the totalCollateral and totalDebt variables are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's collateralAmount, borrowedAmount, weight, totalBorrowedAmount and feePaid based on the borrow amount and shielding rate. Updates the liquidationSnapshots for inactive debt and collateral.",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks the snapshot of debt and collateral for each safe at the time of the last liquidation event or update.",
            "why_is_is_important": "This is important because it is used to calculate the debt and collateral increase.",
            "when_is_it_updated": "This is updated whenever a safe's collateral or debt is modified and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping for the given safeId to ensure that debtPerCollateralSnapshot and collateralPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral respectively.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation snapshot of a safe, to keep track of inactive debt and collateral. It updates `debtPerCollateralSnapshot` to `cumulativeDebtPerUnitCollateral` and `collateralPerCollateralSnapshot` to `cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral deposited in the protocol.",
            "why_is_is_important": "This is important because it is used to calculate the global collateralization ratio of the protocol.",
            "when_is_it_updated": "This is updated when collateral is added to a safe.",
            "how_to_validate_state_update": "Verify that the totalCollateral variable has been incremented by the collateralIncrease amount, by reading the storage value.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total collateral in the protocol, by collateralIncrease if it exists.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt outstanding in the protocol.",
            "why_is_is_important": "This is important because it is used to calculate the global collateralization ratio of the protocol and determine the protocol mode.",
            "when_is_it_updated": "This is updated when a user borrows debt.",
            "how_to_validate_state_update": "Verify that the totalDebt variable has been incremented by the amount borrowed, by reading the storage value.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total debt in the protocol by the amount borrowed.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operating mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "This is important because it controls certain protocol behaviors and parameters.",
            "when_is_it_updated": "This is updated when the total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE variable to ensure it has been updated to NORMAL when this condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL when the total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Maintains an ordered list of safes for redemption based on their weight.",
            "why_is_is_important": "This is important for prioritizing redemptions and ensuring fairness.",
            "when_is_it_updated": "This is updated when a user borrows, adds collateral, or performs other actions that affect their weight.",
            "how_to_validate_state_update": "Check the doubly linked list contract's state to ensure the safeId has been inserted or updated with the correct weight in the redemption queue.  This involves inspecting the `nodes` mapping, `head`, and `tail` variables.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the redemption queue by inserting or updating the safeId with its corresponding weight. Uses _insert or _update functions to manage linked list.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the ordered doubly linked list.",
            "why_is_is_important": "Pointers to the beginning of the doubly linked list.",
            "when_is_it_updated": "When the first node of the list is removed.",
            "how_to_validate_state_update": "If the safeId's node's previous pointer is 0, check that the `head` variable is updated to the node's next pointer.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the node being removed is the current head.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the ordered doubly linked list.",
            "why_is_is_important": "Pointers to the end of the doubly linked list.",
            "when_is_it_updated": "When the last node of the list is removed.",
            "how_to_validate_state_update": "If the safeId's node's next pointer is 0, check that the `tail` variable is updated to the node's previous pointer.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the node being removed is the current tail.",
            "conditions": [
              "node.next == 0"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Maintains an ordered list of safes for liquidation based on their liquidation ratio.",
            "why_is_is_important": "This is important for prioritizing liquidations and protecting the protocol's solvency.",
            "when_is_it_updated": "This is updated when a user borrows, adds collateral, or performs other actions that affect their liquidation ratio.",
            "how_to_validate_state_update": "Check the doubly linked list contract's state to ensure the safeId has been inserted or updated with the correct ratio in the liquidation queue.  This involves inspecting the `nodes` mapping, `head`, and `tail` variables.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the liquidation queue by inserting or updating the safeId with its corresponding liquidation ratio. Uses _insert or _update functions to manage linked list.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the ordered doubly linked list.",
            "why_is_is_important": "Pointers to the beginning of the doubly linked list.",
            "when_is_it_updated": "When the first node of the list is removed.",
            "how_to_validate_state_update": "If the safeId's node's previous pointer is 0, check that the `head` variable is updated to the node's next pointer.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the node being removed is the current head.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the ordered doubly linked list.",
            "why_is_is_important": "Pointers to the end of the doubly linked list.",
            "when_is_it_updated": "When the last node of the list is removed.",
            "how_to_validate_state_update": "If the safeId's node's next pointer is 0, check that the `tail` variable is updated to the node's previous pointer.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the node being removed is the current tail.",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "This is important for tracking the supply of SBD tokens.",
            "when_is_it_updated": "This is updated when SBD tokens are minted or burned.",
            "how_to_validate_state_update": "Verify that the balance of the msg.sender has been increased by amountToBorrow in the balances mapping.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints SBD tokens to the borrower by increasing the balance of the msg.sender by amountToBorrow.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "This is important for tracking the overall supply of the token.",
            "when_is_it_updated": "This is updated when SBD tokens are minted or burned.",
            "how_to_validate_state_update": "Verify that the total supply of SBD tokens has increased by amountToBorrow, by reading the storage value.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total supply of SBD tokens by amountToBorrow.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative reward per token for stakers.",
            "why_is_is_important": "This is important for calculating the rewards earned by stakers.",
            "when_is_it_updated": "This is updated when new rewards are added to the staking pool.",
            "how_to_validate_state_update": "Check that the rewardToken has transferred _amount tokens from the msg.sender to the DFIREStaking contract. Check that totalRewardPerToken has increased by (_amount * PRECISION) / _totalStake.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token in the DFIREStaking contract.",
            "conditions": [
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative reward per token for stability providers.",
            "why_is_is_important": "This is important for calculating the rewards earned by stability providers.",
            "when_is_it_updated": "This is updated when new rewards are added to the stability pool.",
            "how_to_validate_state_update": "Verify that the stakingToken has transferred _amount tokens from the msg.sender to the StabilityPool contract. Verify that totalRewardPerToken has increased and rewardLoss has been updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token in the StabilityPool contract. Updates rewardLoss.",
            "conditions": [
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR reward per token for stability providers.",
            "why_is_is_important": "This is important for calculating the SBR rewards earned by stability providers.",
            "when_is_it_updated": "This is updated when new SBR rewards are distributed to the stability pool.",
            "how_to_validate_state_update": "If the SBR reward distribution is started, check that lastSBRRewardDistributedTime is updated to block.timestamp, and that totalSbrRewardPerToken and sbrRewardLoss are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total SBR reward per token in the StabilityPool contract. Updates sbrRewardLoss and lastSBRRewardDistributedTime.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of the SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "This is important for managing the distribution of SBR rewards to stability providers.",
            "when_is_it_updated": "This is updated when the SBR reward distribution is started or ended.",
            "how_to_validate_state_update": "If the SBR reward distribution is not started, check that lastSBRRewardDistributedTime is updated to block.timestamp, sbrRewardDistributionEndTime is updated to block.timestamp + 365 days, and sbrRewardDistributionStatus is updated to SBRRewardDistribution.STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Starts the SBR reward distribution in the StabilityPool contract.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks when the SBR reward was last distributed to the Stability Pool.",
            "why_is_is_important": "This is important for distributing fees to SBR stakers.",
            "when_is_it_updated": "This is updated when the SBR reward distribution is started or ended.",
            "how_to_validate_state_update": "If the SBR reward distribution is not started, check that lastSBRRewardDistributedTime is updated to block.timestamp, sbrRewardDistributionEndTime is updated to block.timestamp + 365 days, and sbrRewardDistributionStatus is updated to SBRRewardDistribution.STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the timestamp when the SBR reward was last distributed.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks when the SBR rewards are no longer distributed.",
            "why_is_is_important": "This is important for distributing fees to SBR stakers.",
            "when_is_it_updated": "This is updated when the SBR reward distribution is started or ended.",
            "how_to_validate_state_update": "If the SBR reward distribution is not started, check that lastSBRRewardDistributedTime is updated to block.timestamp, sbrRewardDistributionEndTime is updated to block.timestamp + 365 days, and sbrRewardDistributionStatus is updated to SBRRewardDistribution.STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the time at which the SBR reward distribution ends.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}