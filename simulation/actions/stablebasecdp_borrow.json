{
  "action": {
    "name": "borrow",
    "summary": "Borrow from the protocol",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 1.0
  },
  "action_detail": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Must be a valid, existing safeId that the user owns. Call ownerOf(safeId) to verify.",
      "amount: Must be greater than 0 and must result in safe.borrowedAmount + amount >= MINIMUM_DEBT.",
      "amount: safe.borrowedAmount + amount <= maxBorrowAmount, where maxBorrowAmount is calculated using safe.collateralAmount, fetched price from priceOracle, and liquidationRatio.",
      "shieldingRate: A percentage (in basis points) representing the fee the user is willing to pay. Should be a reasonable value.",
      "nearestSpotInLiquidationQueue: If known, provide a valid node id from safesOrderedForLiquidation. Otherwise, set to 0.",
      "nearestSpotInRedemptionQueue: If known, provide a valid node id from safesOrderedForRedemption. Otherwise, set to 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Increase safe.borrowedAmount by amount.",
          "Increase safe.totalBorrowedAmount by amount.",
          "Increase safe.feePaid by _shieldingFee where _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR.",
          "Update safe.weight based on shieldingRate and existing borrowings. For the first borrow: safe.weight = shieldingRate + get(_minFeeWeightNode).value (if _minFeeWeightNode != 0), or shieldingRate (if _minFeeWeightNode == 0). Subsequent borrows: diff = safe.weight - _minFeeWeight; weightedDiff = (diff * safe.borrowedAmount) / BASIS_POINTS_DIVISOR; newFeeWeight = ((_shieldingFee + weightedDiff) * BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount); safe.weight = _minFeeWeight + newFeeWeight"
        ]
      },
      {
        "category": "Debt and Protocol Mode",
        "state_update_descriptions": [
          "Increase totalDebt by 'amount'.",
          "If totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD and PROTOCOL_MODE is BOOTSTRAP, transition PROTOCOL_MODE to NORMAL."
        ]
      },
      {
        "category": "Token Minting/Burning",
        "state_update_descriptions": [
          "If _shieldingFee > 0, mint SBD tokens to the contract address and potentially burn tokens for refund using sbdToken.mint(address(this), fee) and sbdToken.burn(address(this), canRefund).",
          "Mint SBD tokens to msg.sender by _amountToBorrow, where _amountToBorrow = amount - _shieldingFee + canRefund (if canRefund > 0)."
        ]
      },
      {
        "category": "Doubly Linked Lists",
        "state_update_descriptions": [
          "Update/Insert safeId in safesOrderedForRedemption with the updated weight.",
          "Update/Insert safeId in safesOrderedForLiquidation with the calculated liquidation ratio."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distribute fees to dfireTokenStaking and stabilityPool.",
          "Call dfireTokenStaking.addReward(sbrStakersFee).",
          "Call stabilityPool.addReward(stabilityPoolFee)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "Verify safe.borrowedAmount increased by the correct amount.",
          "Verify safe.totalBorrowedAmount increased by the correct amount.",
          "Verify safe.feePaid increased by the correct shielding fee amount.",
          "Verify safe.weight is updated correctly based on the shielding rate and existing state; if borrowedAmount was 0 before, weight should be shieldingRate + minFeeWeight from safesOrderedForRedemption.",
          "Verify the calculated liquidation ratio is correct.",
          "Verify safeId is correctly upserted in safesOrderedForRedemption and safesOrderedForLiquidation."
        ]
      },
      {
        "category": "Debt and Protocol Mode",
        "rule_descriptions": [
          "Verify totalDebt increased by the borrowed amount.",
          "Verify PROTOCOL_MODE transitioned from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Token Minting/Burning",
        "rule_descriptions": [
          "Verify the user's SBD token balance increased by the borrow amount minus shielding fee, plus any refund if applicable.",
          "Verify that if a shielding fee was applied, the contract's SBD balance increased then decreased by the refund amount (if any)."
        ]
      },
      {
        "category": "Doubly Linked Lists",
        "rule_descriptions": [
          "Verify safeId is correctly inserted/updated in safesOrderedForRedemption with the correct weight.",
          "Verify safeId is correctly inserted/updated in safesOrderedForLiquidation with the correct liquidation ratio."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "Verify that fees were distributed to dfireTokenStaking and stabilityPool according to SBR_FEE_REWARD.",
          "Verify sbdToken.mint to address(this) with fee and sbdToken.burn to address(this) with canRefund.",
          "Verify that canRefund <= fee."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt a safe has accumulated",
            "why_is_is_important": "It determines the risk of the safe and the overall solvency of the protocol.",
            "when_is_it_updated": "It's updated when a user borrows more funds, increasing their debt.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases by the amount borrowed.",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount ever borrowed by a safe, including repaid amounts.",
            "why_is_is_important": "It can be used for historical analysis of borrowing activity and risk assessment.",
            "when_is_it_updated": "It's updated when a user borrows more funds.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases by the amount borrowed.",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "Fees paid by the safe",
            "why_is_is_important": "It tracks the amount of fees the safe has paid, which is important for revenue distribution and accounting.",
            "when_is_it_updated": "It's updated when a shielding fee is paid during the borrowing process.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases by the shielding fee (_shieldingFee).",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT",
              "_shieldingFee > 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The weight/fee rate of a safe, determining its position in the redemption queue.",
            "why_is_is_important": "It influences the order in which safes are redeemed and the fees they pay.",
            "when_is_it_updated": "It's updated based on the shielding rate and existing minimum fee weight.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated based on the shielding rate and the minimum fee weight of existing safes.",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT",
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt in the protocol.",
            "why_is_is_important": "A key metric for assessing the protocol's overall risk and solvency.",
            "when_is_it_updated": "It's updated when a user borrows, increasing the total outstanding debt.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases by the amount borrowed (amount).",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The borrowed amount relative to collateral in the liquidation queue",
            "why_is_is_important": "It keeps track of safes in terms of their liquidation risk",
            "when_is_it_updated": "When a borrow occurs, the safe is updated in the liquidation queue",
            "has_conditional_updates": true,
            "summary_of_update": "The safe's position in the liquidation queue is updated",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The fee rate for safes in the redemption queue",
            "why_is_is_important": "It keeps track of safes in terms of their fee weight",
            "when_is_it_updated": "When a borrow occurs, the safe is updated in the redemption queue",
            "has_conditional_updates": true,
            "summary_of_update": "The safe's position in the redemption queue is updated",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt per unit collateral",
            "why_is_is_important": "Important for calculating debt increase based on collateral",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral",
            "has_conditional_updates": true,
            "summary_of_update": "Updates debtPerCollateralSnapshot with cumulativeDebtPerUnitCollateral",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "The cumulative collateral per unit collateral",
            "why_is_is_important": "Important for calculating collateral increase",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralPerCollateralSnapshot with cumulativeCollateralPerUnitCollateral",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total collateral in the protocol",
            "why_is_is_important": "Important for calculating collateral increase",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral",
            "has_conditional_updates": true,
            "summary_of_update": "Increase by collateralIncrease",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The protocol mode",
            "why_is_is_important": "It determines the operating mode of the protocol (e.g., BOOTSTRAP or NORMAL).",
            "when_is_it_updated": "It's updated when the total debt exceeds a threshold while in BOOTSTRAP mode.",
            "has_conditional_updates": true,
            "summary_of_update": "Switches from BOOTSTRAP to NORMAL mode if the debt exceeds the threshold.",
            "conditions": [
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": [
          {
            "state_variable_name": "price",
            "type": "uint256",
            "what_does_it_track": "The price of the collateral.",
            "why_is_is_important": "It's used to calculate the maximum borrowable amount and assess the safe's risk.",
            "when_is_it_updated": "The price is fetched from the oracle.",
            "has_conditional_updates": true,
            "summary_of_update": "Returns current price.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "Indicates the start of the linked list, important for traversing and ordering safes for redemption or liquidation.",
            "when_is_it_updated": "When a new node is inserted and the list is empty.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated to the ID of the new node.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "Indicates the end of the linked list, important for traversing and ordering safes for redemption or liquidation.",
            "when_is_it_updated": "When a new node is inserted and the list is empty.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated to the ID of the new node.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Nodes in the doubly linked list.",
            "why_is_is_important": "Stores the value, previous, and next pointers for each safe in the list, enabling efficient ordering and traversal.",
            "when_is_it_updated": "When a new node is inserted or an existing node is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Creates or updates the node with the provided value and adjusts the previous and next pointers to maintain the list's order.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Total supply of the token.",
            "why_is_is_important": "It is crucial for tracking the total amount of tokens in circulation, impacting token value and scarcity.",
            "when_is_it_updated": "Minting increases the total supply, burning decreases it.",
            "has_conditional_updates": true,
            "summary_of_update": "Incremented when new tokens are minted and decremented when tokens are burned.",
            "conditions": [
              "to == address(this)"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Balances of accounts.",
            "why_is_is_important": "It keeps track of token ownership, which is fundamental for transferring and using the tokens.",
            "when_is_it_updated": "Transferring tokens, minting, or burning updates the balances of the involved accounts.",
            "has_conditional_updates": true,
            "summary_of_update": "Balances are increased for receivers and decreased for senders during transfers, minting, or burning.",
            "conditions": [
              "to == address(this)"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Cumulative amount of tokens burned.",
            "why_is_is_important": "It provides insight into tokenomics, indicating the amount of tokens removed from circulation, affecting scarcity and value.",
            "when_is_it_updated": "When tokens are burned.",
            "has_conditional_updates": false,
            "summary_of_update": "Incremented by the amount of tokens burned.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalStake",
            "type": "uint",
            "what_does_it_track": "Total stake in the staking pool",
            "why_is_is_important": "Determines reward distribution and overall health of staking pool",
            "when_is_it_updated": "When tokens are staked or unstaked",
            "has_conditional_updates": true,
            "summary_of_update": "Total tokens staked in pool",
            "conditions": [
              "sbrStakersFee > 0"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Total reward per token",
            "why_is_is_important": "Used to calculate rewards",
            "when_is_it_updated": "When reward is added",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks total amount of reward",
            "conditions": [
              "sbrStakersFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Total reward per token",
            "why_is_is_important": "Used to calculate rewards",
            "when_is_it_updated": "When reward is added",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks total amount of reward",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          },
          {
            "state_variable_name": "rewardLoss",
            "type": "uint256",
            "what_does_it_track": "Reward loss",
            "why_is_is_important": "Tracks loss amount of reward",
            "when_is_it_updated": "When reward is added",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks loss of reward",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The status of SBR reward distribution",
            "why_is_is_important": "Tracks status of reward distribution",
            "when_is_it_updated": "During SBR reward distribution",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the status of the SBR reward distribution",
            "conditions": [
              "stabilityPoolFee > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The end time of the SBR reward distribution",
            "why_is_is_important": "Tracks end time of reward distribution",
            "when_is_it_updated": "During SBR reward distribution",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the end time of SBR reward distribution",
            "conditions": [
              "stabilityPoolFee > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The last time SBR reward was distributed",
            "why_is_is_important": "Used to calculate the time elapsed",
            "when_is_it_updated": "During SBR reward distribution",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total SBR reward per token",
            "why_is_is_important": "Used to calculate SBR reward amount",
            "when_is_it_updated": "During SBR reward distribution",
            "has_conditional_updates": true,
            "summary_of_update": "Updates total SBR reward per token",
            "conditions": [
              "stabilityPoolFee > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "The SBR reward loss",
            "why_is_is_important": "Tracks the loss of SBR reward",
            "when_is_it_updated": "During SBR reward distribution",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward loss",
            "conditions": [
              "stabilityPoolFee > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          }
        ]
      }
    ]
  }
}