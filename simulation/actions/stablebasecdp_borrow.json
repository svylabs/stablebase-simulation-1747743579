{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safe ID that exists and is owned by the caller.",
      "amount: The amount of debt to borrow. Must be greater than or equal to MINIMUM_DEBT, and less than or equal to maxBorrowAmount - safe.borrowedAmount.",
      "shieldingRate: The shielding rate to apply to the borrowed amount. Must be a valid percentage (e.g., 0-10000).",
      "nearestSpotInLiquidationQueue: The ID of the nearest safe in the liquidation queue to insert the borrowing safe into the queue. Can be zero.",
      "nearestSpotInRedemptionQueue: The ID of the nearest safe in the redemption queue to insert the borrowing safe into the queue. Can be zero.",
      "The caller must be the owner of the safeId"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe state",
        "state_update_descriptions": [
          "safes[safeId].borrowedAmount is increased by amount.",
          "safes[safeId].totalBorrowedAmount is increased by amount.",
          "safes[safeId].weight is updated based on shieldingRate and existing borrowings.",
          "safes[safeId].feePaid is increased by _shieldingFee."
        ]
      },
      {
        "category": "Total debt",
        "state_update_descriptions": [
          "totalDebt is increased by amount. The totalDebt is updated according to the formula: debt = currentDebt + delta if add is true, debt = currentDebt - delta otherwise."
        ]
      },
      {
        "category": "Doubly Linked List state",
        "state_update_descriptions": [
          "safesOrderedForRedemption is updated with the new safe weight and position in the queue.",
          "safesOrderedForLiquidation is updated with the new borrow ratio and position in the queue."
        ]
      },
      {
        "category": "Token state",
        "state_update_descriptions": [
          "SBD tokens are minted to the borrower's address.",
          "If shieldingFee > 0, SBD tokens are minted to the contract, then distributed to SBR stakers and the stability pool, and any refund burned."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "The liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral if cumulativeDebtPerUnitCollateral has changed since the last update.",
          "The liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral if cumulativeCollateralPerUnitCollateral has changed since the last update."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe state",
        "rule_descriptions": [
          "safe.borrowedAmount should be equal to the initial value plus the borrowed amount.",
          "safe.totalBorrowedAmount should be equal to the initial value plus the borrowed amount.",
          "safe.weight should be updated based on shieldingRate and existing borrowings as per the function's logic.",
          "safe.feePaid should be equal to the initial value plus the shieldingFee.",
          "ownerOf(safeId) should still be equal to msg.sender"
        ]
      },
      {
        "category": "Total debt",
        "rule_descriptions": [
          "totalDebt should be increased by the borrowed amount.",
          "PROTOCOL_MODE should be NORMAL if totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD, and was previously BOOTSTRAP."
        ]
      },
      {
        "category": "Doubly Linked List state",
        "rule_descriptions": [
          "safesOrderedForRedemption should contain safeId with the new safe weight.",
          "safesOrderedForLiquidation should contain safeId with the new borrow ratio."
        ]
      },
      {
        "category": "Token state",
        "rule_descriptions": [
          "The borrower should have received the minted SBD tokens.",
          "If shieldingFee > 0, the contract should have minted, distributed and potentially burned SBD tokens as per the fee distribution logic."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "If cumulativeDebtPerUnitCollateral was updated, then liquidationSnapshots[_safeId].debtPerCollateralSnapshot should equal cumulativeDebtPerUnitCollateral.",
          "If cumulativeCollateralPerUnitCollateral was updated, then liquidationSnapshots[_safeId].collateralPerCollateralSnapshot should equal cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Event emission",
        "rule_descriptions": [
          "A Borrowed event should be emitted with the correct parameters: safeId, amount, safe.weight, totalCollateral, totalDebt, redemptionNode.prev, liquidationNode.prev"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the state of each safe, including collateral, borrowed amount, and other parameters.",
            "why_is_is_important": "Stores the state of each safe, including collateral, borrowed amount, and other parameters.",
            "when_is_it_updated": "When the borrow function is called, after validating several conditions on safe's collateralAmount, borrowedAmount, msg.sender, etc.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId to ensure the borrowedAmount, totalBorrowedAmount and feePaid and collateralAmount are correctly updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount, totalBorrowedAmount and feePaid fields in the safes mapping for the given safeId. Also updates the weight based on shieldingRate and existing borrowings. The collateralAmount field can also be updated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshots.",
            "conditions": [
              "safe.collateralAmount > 0",
              "safe.borrowedAmount + amount <= maxBorrowAmount",
              "safe.borrowedAmount + amount >= MINIMUM_DEBT",
              "ownerOf(safeId) == msg.sender"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks snapshots of cumulative debt and collateral per unit collateral for each safe.",
            "why_is_is_important": "Stores snapshots of cumulative debt and collateral per unit collateral for each safe, used for updating borrowed amount and collateral amount during state updates.",
            "when_is_it_updated": "Before borrowing, if the liquidationSnapshot.collateralPerCollateralSnapshot differs from cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping for the given safeId to ensure debtPerCollateralSnapshot and collateralPerCollateralSnapshot are correctly updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debtPerCollateralSnapshot and collateralPerCollateralSnapshot fields based on cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral respectively. This ensures inactive debt and collateral is properly accounted for.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "variable",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Tracks the total debt in the system. Used to determine protocol mode and overall system risk.",
            "when_is_it_updated": "After updating the safe's state, the totalDebt is updated by the borrow amount.",
            "how_to_validate_state_update": "Check the totalDebt variable to ensure it's correctly updated after the borrow.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalDebt variable is updated by adding the borrow amount.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "variable",
            "what_does_it_track": "Tracks the operating mode of the protocol.",
            "why_is_is_important": "Determines the operating mode of the protocol (BOOTSTRAP or NORMAL). Affects protocol behavior.",
            "when_is_it_updated": "After updating the totalDebt, the PROTOCOL_MODE is checked and potentially updated.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE variable to ensure it's updated to NORMAL when totalDebt exceeds the threshold.",
            "has_conditional_updates": true,
            "summary_of_update": "The PROTOCOL_MODE is updated from BOOTSTRAP to NORMAL if the total debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "variable",
            "what_does_it_track": "Tracks the total collateral deposited in the system.",
            "why_is_is_important": "Tracks the total collateral in the system. Important for calculating system-wide collateralization ratios.",
            "when_is_it_updated": "When collateralIncrease is non-zero during the _updateSafe function.",
            "how_to_validate_state_update": "Check the totalCollateral variable to ensure it is correctly incremented.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalCollateral variable is updated by adding collateralIncrease.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Stores the linked list nodes for both liquidation and redemption queues.",
            "why_is_is_important": "Stores the linked list nodes for both liquidation and redemption queues. Maintains the order of safes based on their collateralization ratio or weight.",
            "when_is_it_updated": "After the borrow amount is updated, the safe's position in both liquidation and redemption queues are updated.",
            "how_to_validate_state_update": "Check the nodes mapping for the given safeId in both safesOrderedForLiquidation and safesOrderedForRedemption to ensure the value, prev, and next fields are correctly updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the nodes mapping by inserting or updating the node corresponding to the safeId in both liquidation and redemption queues.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "variable",
            "what_does_it_track": "Points to the head of the doubly linked list.",
            "why_is_is_important": "Points to the head of the doubly linked list. Used to efficiently iterate through the list.",
            "when_is_it_updated": "When inserting a new node into the linked list.",
            "how_to_validate_state_update": "Check the head variable to ensure it points to the correct node after inserting a new node.",
            "has_conditional_updates": true,
            "summary_of_update": "The head variable is updated when inserting a new node into the linked list.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "variable",
            "what_does_it_track": "Points to the tail of the doubly linked list.",
            "why_is_is_important": "Points to the tail of the doubly linked list. Used to efficiently iterate through the list.",
            "when_is_it_updated": "When inserting a new node into the linked list.",
            "how_to_validate_state_update": "Check the tail variable to ensure it points to the correct node after inserting a new node.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail variable is updated when inserting a new node into the linked list.",
            "conditions": [
              "tail == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalSupply",
            "type": "variable",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "Tracks the total supply of SBD tokens. Important for accounting and calculating token value.",
            "when_is_it_updated": "After the amount to borrow is calculated, SBD tokens are minted and totalSupply is updated.",
            "how_to_validate_state_update": "Check the totalSupply variable to ensure it's correctly updated after minting.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalSupply variable is updated by minting SBD tokens to the borrower.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Stores the balance of SBD tokens for each address.",
            "why_is_is_important": "Stores the balance of SBD tokens for each address. Essential for tracking token ownership.",
            "when_is_it_updated": "After the amount to borrow is calculated, SBD tokens are minted and the borrower's balance is updated.",
            "how_to_validate_state_update": "Check the _balances mapping for the borrower's address to ensure it's correctly updated after minting.",
            "has_conditional_updates": false,
            "summary_of_update": "The _balances mapping is updated by minting SBD tokens to the borrower.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "variable",
            "what_does_it_track": "Tracks the cumulative reward per token for DFIRE staking.",
            "why_is_is_important": "Tracks the cumulative reward per token. Used to calculate rewards for stakers.",
            "when_is_it_updated": "When fees are distributed, and the total stake is not zero.",
            "how_to_validate_state_update": "Verify that the totalRewardPerToken is updated correctly based on the reward amount and total stake.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalRewardPerToken by adding the reward distributed per total stake.",
            "conditions": [
              "totalStake != 0"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the DFIRE token balance of DFIREStaking contract.",
            "why_is_is_important": "Tracks the balance of DFIRE tokens. Since tokens are managed by ERC20 token standards, it is important for value tracking.",
            "when_is_it_updated": "When fees are distributed and the total stake is not zero, funds will be transferred from the contract where borrowed is initiated. The balance of DFIRE token of DFIREStaking contract increases",
            "how_to_validate_state_update": "Verify that the DFIRE token balance of DFIREStaking contract increases as per the reward calculation.",
            "has_conditional_updates": true,
            "summary_of_update": "Update the DFIREStaking contract's DFIRE token balance",
            "conditions": [
              "totalStake != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "variable",
            "what_does_it_track": "Tracks the cumulative reward per token in the stability pool.",
            "why_is_is_important": "Tracks the cumulative reward per token in the stability pool. Used for calculating rewards for liquidity providers.",
            "when_is_it_updated": "When fees are distributed, and the total staked raw is not zero.",
            "how_to_validate_state_update": "Verify that the totalRewardPerToken is updated correctly based on the reward amount and total staked raw.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalRewardPerToken by adding the reward distributed per total staked raw.",
            "conditions": [
              "totalStakedRaw != 0"
            ]
          },
          {
            "state_variable_name": "rewardLoss",
            "type": "variable",
            "what_does_it_track": "Accumulates rounding errors in reward distribution.",
            "why_is_is_important": "Accumulates any rounding errors in reward distribution. Important for maintaining accurate reward accounting.",
            "when_is_it_updated": "When distributing rewards to the stability pool.",
            "how_to_validate_state_update": "Check the rewardLoss variable to ensure it accounts for rounding errors.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the rewardLoss variable based on rounding errors during reward distribution.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the DFID token balance of StabilityPool contract.",
            "why_is_is_important": "Tracks the balance of DFID tokens. Since tokens are managed by ERC20 token standards, it is important for value tracking.",
            "when_is_it_updated": "When fees are distributed and the total staked raw is not zero, funds will be transferred from the contract where borrowed is initiated. The balance of DFID token of StabilityPool contract increases",
            "how_to_validate_state_update": "Verify that the DFID token balance of StabilityPool contract increases as per the reward calculation.",
            "has_conditional_updates": true,
            "summary_of_update": "Update the StabilityPool contract's DFID token balance",
            "conditions": [
              "totalStakedRaw != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}