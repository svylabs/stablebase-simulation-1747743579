{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Valid safeId owned by the caller",
      "amount: Non-zero value, such that safe.borrowedAmount + amount <= maxBorrowAmount and safe.borrowedAmount + amount >= MINIMUM_DEBT",
      "shieldingRate: Value between 0 and BASIS_POINTS_DIVISOR",
      "nearestSpotInLiquidationQueue: Valid safeId in liquidation queue, or 0 for beginning of queue",
      "nearestSpotInRedemptionQueue: Valid safeId in redemption queue, or 0 for beginning of queue"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe",
        "state_update_descriptions": [
          "Update the collateralAmount if cumulative snapshots are different",
          "Update the borrowedAmount based on cumulative snapshots",
          "Update totalBorrowedAmount",
          "Update feePaid",
          "Update weight"
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "Upsert Safe in liquidation queue based on borrowAmount per unit collateral"
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Upsert Safe in redemption queue based on weight"
        ]
      },
      {
        "category": "SBD Token",
        "state_update_descriptions": [
          "Mint SBD tokens to borrower"
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Update totalDebt"
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distribute shielding fees to SBR stakers and Stability Pool",
          "Mint and Burn SBD tokens for fee distribution and refunds"
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Update liquidation snapshot"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe",
        "rule_descriptions": [
          "safe.borrowedAmount should reflect borrowed amount including fees",
          "safe.totalBorrowedAmount should be increased by borrowed amount including fees",
          "safe.feePaid reflects fees paid",
          "safe.weight reflects the outcome of fee distribution"
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "safesOrderedForLiquidation should contain the safeId with the correct borrowAmount per unit collateral ratio"
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "safesOrderedForRedemption should contain safeId with the updated weight"
        ]
      },
      {
        "category": "SBD Token",
        "rule_descriptions": [
          "Borrower's SBD balance increased by the borrow amount (less fees, plus refunds, if any)",
          "Contract's SBD balance temporarily increased for fee distribution"
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "totalDebt should be increased by the borrowed amount"
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "Borrowed event emitted with correct parameters",
          "FeeDistributed event emitted if shieldingFee > 0",
          "FeeRefund event emitted if canRefund > 0"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt borrowed against the collateral in a specific safe.",
            "why_is_is_important": "Reflects the current debt of the safe, which is crucial for calculating liquidation risk.",
            "when_is_it_updated": "Updated when the collateral or debt has changed since the last snapshot.",
            "how_to_validate_state_update": "Check if the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, then borrowedAmount increases by debtIncrease, where debtIncrease = (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the borrowed amount of a specific safe if the collateral or debt has changed since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt borrowed against the collateral in a specific safe.",
            "why_is_is_important": "Reflects the historical debt of the safe.",
            "when_is_it_updated": "Updated when the collateral or debt has changed since the last snapshot.",
            "how_to_validate_state_update": "Check if the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, then totalBorrowedAmount increases by debtIncrease, where debtIncrease = (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total borrowed amount of a specific safe if the collateral or debt has changed since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in a specific safe.",
            "why_is_is_important": "Reflects the current collateral of the safe, which is crucial for calculating liquidation risk.",
            "when_is_it_updated": "Updated when the collateral or debt has changed since the last snapshot.",
            "how_to_validate_state_update": "Check if the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, then collateralAmount increases by collateralIncrease, where collateralIncrease = (_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of a specific safe if the collateral or debt has changed since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system.",
            "why_is_is_important": "Reflects the total amount of collateral in the system.",
            "when_is_it_updated": "Updated when the collateral or debt has changed since the last snapshot.",
            "how_to_validate_state_update": "Check if the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, then totalCollateral increases by collateralIncrease, where collateralIncrease = (_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the system when a safe is updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operating mode of the protocol.",
            "why_is_is_important": "Controls certain protocol behaviors based on the current operating mode.",
            "when_is_it_updated": "Updated when the total debt exceeds the bootstrap mode threshold.",
            "how_to_validate_state_update": "Check if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and the protocol is in BOOTSTRAP mode. If true, PROTOCOL_MODE is changed to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes protocol mode from BOOTSTRAP to NORMAL if total debt exceeds threshold.",
            "conditions": [
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "Tracks the weight of a safe, used for prioritizing redemptions.",
            "why_is_is_important": "Determines the order in which safes are redeemed, influencing fairness and profitability.",
            "when_is_it_updated": "Updated when a user borrows, which influences their position in the redemption queue.",
            "how_to_validate_state_update": "safe.weight is updated based on shieldingRate and existing borrowings. If safe.borrowedAmount == 0 and _minFeeWeightNode == 0, safe.weight = shieldingRate. If safe.borrowedAmount == 0 and _minFeeWeightNode != 0, safe.weight = _minFeeWeight + shieldingRate. If safe.borrowedAmount != 0, newFeeWeight is calculated, and safe.weight = _minFeeWeight + newFeeWeight if shieldingRate > 0.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the weight of a safe based on the shielding rate and existing borrowings.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt borrowed against the collateral in a specific safe.",
            "why_is_is_important": "Reflects the current debt of the safe, which is crucial for calculating liquidation risk.",
            "when_is_it_updated": "Updated when a user borrows more debt against their collateral.",
            "how_to_validate_state_update": "safe.borrowedAmount is increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the borrowed amount of a specific safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt borrowed against the collateral in a specific safe.",
            "why_is_is_important": "Reflects the historical debt of the safe.",
            "when_is_it_updated": "Updated when a user borrows more debt against their collateral.",
            "how_to_validate_state_update": "safe.totalBorrowedAmount is increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total borrowed amount of a specific safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "Tracks the total fees paid by the safe.",
            "why_is_is_important": "Tracks the cumulative fees paid.",
            "when_is_it_updated": "Updated when a user borrows debt and pays a shielding fee.",
            "how_to_validate_state_update": "safe.feePaid is increased by _shieldingFee.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the fee paid by the safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "address",
            "what_does_it_track": "Maintains an ordered list of safes for redemption, prioritized by weight.",
            "why_is_is_important": "Ensures that redemptions are processed in a fair and efficient manner.",
            "when_is_it_updated": "Updated when a user borrows more debt and the safe's weight changes.",
            "how_to_validate_state_update": "Nodes are inserted or updated in the linked lists safesOrderedForRedemption and safesOrderedForLiquidation. Check the upsert function in the OrderedDoublyLinkedList contract.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the redemption queue with the safe's new weight.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "Maintains an ordered list of safes for liquidation, prioritized by their debt-to-collateral ratio.",
            "why_is_is_important": "Ensures that liquidations are processed in a timely and efficient manner to maintain system solvency.",
            "when_is_it_updated": "Updated when a user borrows more debt, which affects their liquidation risk.",
            "how_to_validate_state_update": "Nodes are inserted or updated in the linked lists safesOrderedForRedemption and safesOrderedForLiquidation. Check the upsert function in the OrderedDoublyLinkedList contract.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the liquidation queue with the safe's new ratio.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt outstanding in the system.",
            "why_is_is_important": "Reflects the overall risk exposure of the system.",
            "when_is_it_updated": "Updated when a user borrows more debt.",
            "how_to_validate_state_update": "totalDebt increases by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total debt in the system.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "tracks debtPerCollateralSnapshot for safeId",
            "why_is_is_important": "Stores the cumulative debt per collateral unit for a safe, for accurately calculating debt increases.",
            "when_is_it_updated": "when liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
            "how_to_validate_state_update": "If  liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral is true, liquidationSnapshots[_safeId].debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates debtPerCollateralSnapshot for safeId",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "tracks collateralPerCollateralSnapshot for safeId",
            "why_is_is_important": "Stores the cumulative collateral per collateral unit for a safe, for accurately calculating collateral increases.",
            "when_is_it_updated": "when liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
            "how_to_validate_state_update": "If  liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral is true, liquidationSnapshots[_safeId].collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralPerCollateralSnapshot for safeId",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of each address.",
            "why_is_is_important": "Reflects the amount of SBD tokens held by the borrower.",
            "when_is_it_updated": "Updated when a user borrows debt.",
            "how_to_validate_state_update": "Check mint function, the balance of msg.sender(borrower) increases by _amountToBorrow.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints SBD tokens to the borrower.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of the contract.",
            "why_is_is_important": "Reflects the amount of SBD tokens held by the contract.",
            "when_is_it_updated": "When a user borrows debt and pays a shielding fee.",
            "how_to_validate_state_update": "Check mint function. If shieldingFee > 0, then mints fee amount to the contract",
            "has_conditional_updates": false,
            "summary_of_update": "Mints the shielding fee to the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of the contract.",
            "why_is_is_important": "Reflects the amount of SBD tokens held by the contract.",
            "when_is_it_updated": "When a user borrows debt and some fee can be refunded.",
            "how_to_validate_state_update": "If canRefund > 0, then burns canRefund amount from the contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the refunded fee from the contract.",
            "conditions": [
              "canRefund > 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "Reflects the overall supply of SBD tokens in the system.",
            "when_is_it_updated": "Updated when new SBD tokens are minted.",
            "how_to_validate_state_update": "totalSupply increases by _amountToBorrow when tokens are minted to borrower",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total supply of SBD tokens.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "Reflects the overall supply of SBD tokens in the system.",
            "when_is_it_updated": "Updated when burning refunded tokens.",
            "how_to_validate_state_update": "totalSupply decreases by canRefund when some fee can be refunded.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total supply of SBD tokens.",
            "conditions": [
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative reward per token for stakers.",
            "why_is_is_important": "Used to calculate the rewards earned by each staker.",
            "when_is_it_updated": "Updated when fees are distributed to stakers.",
            "how_to_validate_state_update": "If sbrStakersFee > 0, calls the addReward function in DFIREStaking, totalRewardPerToken will increase by (_amount * PRECISION) / _totalStake",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token for DFIRE stakers.",
            "conditions": [
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative reward per token for stakers in the stability pool.",
            "why_is_is_important": "Used to calculate the rewards earned by each staker in the stability pool.",
            "when_is_it_updated": "Updated when fees are distributed to the stability pool.",
            "how_to_validate_state_update": "Calls the addReward function in StabilityPool, totalRewardPerToken will increase by ((_totalAmount * stakeScalingFactor * precision) / _totalStakedRaw) / precision",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token in the stability pool.",
            "conditions": [
              "totalStakedRaw > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}