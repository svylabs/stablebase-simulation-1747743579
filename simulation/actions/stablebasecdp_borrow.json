{
  "action": {
    "name": "borrow",
    "summary": "Borrow from the protocol",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 1.0
  },
  "action_detail": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Must be a valid and existing safe ID owned by the message sender.",
      "amount: Must be a non-zero amount, within the maximum borrowable limit and greater than or equal to MINIMUM_DEBT. maxBorrowAmount = ((safe.collateralAmount * price * BASIS_POINTS_DIVISOR) / liquidationRatio) / PRECISION and borrowedAmount + amount <= maxBorrowAmount",
      "shieldingRate: A percentage (in basis points) representing the fee for shielding, should be a reasonable value.",
      "nearestSpotInLiquidationQueue: A valid node ID in the liquidation queue, or 0 to indicate the head.",
      "nearestSpotInRedemptionQueue: A valid node ID in the redemption queue, or 0 to indicate the head."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Core Borrowing and Accounting Updates",
        "state_update_descriptions": [
          "safes[safeId].borrowedAmount is increased by amount.",
          "safes[safeId].totalBorrowedAmount is increased by amount.",
          "safes[safeId].feePaid is increased by _shieldingFee.",
          "totalDebt is increased by amount.",
          "sbdToken.mint(msg.sender, _amountToBorrow) where _amountToBorrow = amount - _shieldingFee + canRefund (if any fee is refunded).",
          "safes[safeId].weight is updated based on the shieldingRate, existing borrowing, and minimum fee weight of other safes",
          "safesOrderedForRedemption.upsert(safeId, safe.weight, nearestSpotInRedemptionQueue) updates the redemption queue.",
          "safesOrderedForLiquidation.upsert(safeId, ratio, nearestSpotInLiquidationQueue) updates the liquidation queue.",
          "sbdToken.mint(address(this), fee) mints SBD token to the StableBaseCDP contract to distribute the shielding fee as rewards to stakers and liquidity providers.",
          "dfireTokenStaking.addReward(sbrStakersFee) and stabilityPool.addReward(stabilityPoolFee) may be called inside distributeFees",
          "totalCollateral might be updated in _updateSafe due to inactive debt and collateral updates",
          "cumulativeDebtPerUnitCollateral might be updated in _updateSafe due to inactive debt and collateral updates",
          "cumulativeCollateralPerUnitCollateral might be updated in _updateSafe due to inactive debt and collateral updates",
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated in _updateSafe",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated in _updateSafe"
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "distributeFees(safeId, _shieldingFee, true) distributes fees to SBR stakers and stability pool which involves rewardToken.transferFrom() and potentially sbdToken.burn(address(this), canRefund)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Core Borrowing and Accounting",
        "rule_descriptions": [
          "The borrowed amount of the safe should be increased by the amount borrowed.",
          "The total borrowed amount of the safe should be increased by the amount borrowed.",
          "The total debt of the protocol should be increased by the amount borrowed.",
          "The fee paid by the safe should be increased by the shielding fee.",
          "The SBD token should be minted to the borrower.",
          "The weight of the safe should be updated based on the shielding rate and existing borrowings. If it is the first time borrowing and there are no existing borrowings, the weight is set to the shielding rate. Otherwise, the weight is adjusted based on the minimum fee weight of existing borrowers.",
          "The position of the safe in the redemption queue should be updated based on the new weight.",
          "The position of the safe in the liquidation queue should be updated based on the new ratio (borrowed amount per unit collateral)."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "Fees should be distributed to the SBR stakers and the stability pool.",
          "The SBD token should be minted to the contract to distribute fee",
          "Any refund of the fee should be sent back to the borrower, reducing the amount effectively borrowed."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "increase",
            "what_does_it_track": "Tracks the amount of debt associated with a specific safe.",
            "why_is_is_important": "This function updates the `borrowedAmount` and `collateralAmount` based on cumulative debt and collateral per unit collateral, ensuring consistency with the current global state.",
            "when_is_it_updated": "This is updated at the beginning of the `borrow` function via the `_updateSafe` function.",
            "how_to_validate_state_update": "Check that `safes[_safeId].borrowedAmount` and `safes[_safeId].collateralAmount` have been updated based on the differences in cumulative debt and collateral ratios.",
            "has_conditional_updates": true,
            "summary_of_update": "The `borrowedAmount` is increased by `debtIncrease`, which is calculated based on the difference between `cumulativeDebtPerUnitCollateral` and `liquidationSnapshot.debtPerCollateralSnapshot`.  The `collateralAmount` is increased by `collateralIncrease`, which is calculated based on the difference between `cumulativeCollateralPerUnitCollateral` and `liquidationSnapshot.collateralPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "increase",
            "what_does_it_track": "Tracks the cumulative amount borrowed by a specific safe.",
            "why_is_is_important": "The `totalBorrowedAmount` represents cumulative debt from all borrows for this safe, so it must be kept consistent with the `borrowedAmount`.",
            "when_is_it_updated": "This is updated at the beginning of the `borrow` function via the `_updateSafe` function.",
            "how_to_validate_state_update": "Check that `safes[_safeId].totalBorrowedAmount` has been updated to reflect the increased borrowed amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalBorrowedAmount` is increased by `debtIncrease`, which is calculated based on the difference between `cumulativeDebtPerUnitCollateral` and `liquidationSnapshot.debtPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "update",
            "what_does_it_track": "Tracks the debt per collateral snapshot for liquidation purposes.",
            "why_is_is_important": "This variable needs to be set to the latest cumulative debt in the system to track debt at the time of the snapshot.",
            "when_is_it_updated": "This is updated at the beginning of the `borrow` function via the `_updateSafe` function.",
            "how_to_validate_state_update": "Check that `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` is equal to the current `cumulativeDebtPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `liquidationSnapshot.debtPerCollateralSnapshot` is updated to `cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "increase",
            "what_does_it_track": "Tracks the total collateral in the system.",
            "why_is_is_important": "Represents system wide collateral and must remain accurate.",
            "when_is_it_updated": "This is updated at the beginning of the `borrow` function via the `_updateSafe` function.",
            "how_to_validate_state_update": "Check that `totalCollateral` has been updated to reflect the increased collateral amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalCollateral` is increased by `collateralIncrease`, which is calculated based on the difference between `cumulativeCollateralPerUnitCollateral` and `liquidationSnapshot.collateralPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "increase",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Total debt represents system wide debt, and impacts the PROTOCOL_MODE.",
            "when_is_it_updated": "This is updated at the beginning of the `borrow` function via the `_updateSafe` function.",
            "how_to_validate_state_update": "Verify that `totalDebt` has been increased by `debtIncrease`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalDebt` is increased by `debtIncrease`, which is calculated based on the difference between `cumulativeDebtPerUnitCollateral` and `liquidationSnapshot.debtPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "update",
            "what_does_it_track": "Tracks the fee weight associated with a safe.",
            "why_is_is_important": "This ensures fair fee weight calculation for new borrowers relative to existing borrowers, only when first borrowing.",
            "when_is_it_updated": "This is updated in `handleBorrow`, specifically when `safe.borrowedAmount == 0`.",
            "how_to_validate_state_update": "Check that `safes[safeId].weight` is correctly set to `shieldingRate` or `_minFeeWeight + shieldingRate` based on the specified conditions.",
            "has_conditional_updates": true,
            "summary_of_update": "If it's the first time borrowing (i.e., `safe.borrowedAmount == 0`) and there are no existing borrowings (`_minFeeWeightNode == 0`), `safe.weight` is set to `shieldingRate`. If there are existing borrowings, `safe.weight` is set to `_minFeeWeight + shieldingRate`.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0",
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode != 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "update",
            "what_does_it_track": "Tracks the fee weight associated with a safe.",
            "why_is_is_important": "It updates fee weight based on the weighted average of existing debt and shielding rate.",
            "when_is_it_updated": "This is updated in `handleBorrow`, when `safe.borrowedAmount != 0`.",
            "how_to_validate_state_update": "Verify that `safes[safeId].weight` is updated correctly using the formula provided in the summary.",
            "has_conditional_updates": true,
            "summary_of_update": "If it's not the first time borrowing (i.e., `safe.borrowedAmount != 0`) and `shieldingRate > 0`, `safe.weight` is updated to `_minFeeWeight + newFeeWeight` where `newFeeWeight` is calculated based on weighted average.",
            "conditions": [
              "safe.borrowedAmount != 0",
              "shieldingRate > 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "increase",
            "what_does_it_track": "Tracks the total fees paid by a safe.",
            "why_is_is_important": "Accumulates all shielding fees paid by the Safe.",
            "when_is_it_updated": "This is updated in `handleBorrow`, unconditionally.",
            "how_to_validate_state_update": "Check that `safes[safeId].feePaid` increases by the expected `_shieldingFee` amount.",
            "has_conditional_updates": false,
            "summary_of_update": "`safe.feePaid` is incremented by `_shieldingFee`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "increase",
            "what_does_it_track": "Tracks the current borrowed amount for a safe.",
            "why_is_is_important": "Must increase the borrowed amount to reflect the new borrowing. Important for liquidation calculations and debt tracking.",
            "when_is_it_updated": "This is updated in `handleBorrow`, unconditionally.",
            "how_to_validate_state_update": "Verify that `safes[safeId].borrowedAmount` has been incremented by the `amount` borrowed.",
            "has_conditional_updates": false,
            "summary_of_update": "`safe.borrowedAmount` is incremented by `amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "increase",
            "what_does_it_track": "Tracks the total borrowed amount for a safe.",
            "why_is_is_important": "Tracks all debt from all borrows that have ever occurred. Important for historical data and auditing.",
            "when_is_it_updated": "This is updated in `handleBorrow`, unconditionally.",
            "how_to_validate_state_update": "Check that `safes[safeId].totalBorrowedAmount` has been incremented by the `amount` borrowed.",
            "has_conditional_updates": false,
            "summary_of_update": "`safe.totalBorrowedAmount` is incremented by `amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "_amountToBorrow",
            "type": "increase",
            "what_does_it_track": "Tracks the amount to borrow after accounting for fee refunds.",
            "why_is_is_important": "Used to increase amount to borrow if refund is possible.",
            "when_is_it_updated": "This is updated in `handleBorrow`, based on the `canRefund` amount after fees are distributed.",
            "how_to_validate_state_update": "If `canRefund > 0`, verify that `_amountToBorrow` is increased by `canRefund`.",
            "has_conditional_updates": true,
            "summary_of_update": "`_amountToBorrow` is increased by `canRefund` if `canRefund > 0`.",
            "conditions": [
              "canRefund > 0"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "increase",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Total debt represents system wide debt, and impacts the PROTOCOL_MODE.",
            "when_is_it_updated": "This is updated in `handleBorrow`, after minting SBD tokens.",
            "how_to_validate_state_update": "Verify that `totalDebt` has been increased by `amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The `totalDebt` is increased by `amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "update",
            "what_does_it_track": "Tracks the current operating mode of the protocol.",
            "why_is_is_important": "This dictates the mode the protocol is in. Changing the protocol mode from bootstrap to normal will affect how the protocol functions.",
            "when_is_it_updated": "Updated within the `_updateTotalDebt` function, which is called in `_updateSafe` and `handleBorrow`.",
            "how_to_validate_state_update": "Check if `PROTOCOL_MODE` changes from `BOOTSTRAP` to `NORMAL` when the total debt exceeds the threshold.",
            "has_conditional_updates": true,
            "summary_of_update": "If `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`, then `PROTOCOL_MODE` is set to `SBStructs.Mode.NORMAL`.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "update",
            "what_does_it_track": "Tracks the order of safes for redemptions.",
            "why_is_is_important": "It is important because the queue is used for prioritization and ordering of safes for redemptions.",
            "when_is_it_updated": "The Redemption queue is updated unconditionally in the handleBorrow function",
            "how_to_validate_state_update": "Check that nodes are correctly inserted/updated in `safesOrderedForRedemption` and `safesOrderedForLiquidation` based on the new `weight` and `ratio` respectively. The lists are modified regardless of whether or not any insertion/update occurs, so always check.",
            "has_conditional_updates": false,
            "summary_of_update": "The `safesOrderedForRedemption` linked list is updated/inserted to maintain the correct ordering of safes for redemption purposes based on the safe's weight.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "update",
            "what_does_it_track": "Tracks the order of safes for liquidations.",
            "why_is_is_important": "It is important because the queue is used for prioritization and ordering of safes for liquidations.",
            "when_is_it_updated": "The Liquidation queue is updated unconditionally in the handleBorrow function",
            "how_to_validate_state_update": "Check that nodes are correctly inserted/updated in `safesOrderedForRedemption` and `safesOrderedForLiquidation` based on the new `weight` and `ratio` respectively. The lists are modified regardless of whether or not any insertion/update occurs, so always check.",
            "has_conditional_updates": false,
            "summary_of_update": "The `safesOrderedForLiquidation` linked list is updated/inserted to maintain the correct ordering of safes for liquidation purposes based on the safe's ratio.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "rewardBalance",
            "type": "external_transfer",
            "what_does_it_track": "Tracks the distribution of fees to the DFIREStaking contract.",
            "why_is_is_important": "Used to transfer staking rewards to the DFIREStaking contract.",
            "when_is_it_updated": "Updated in `distributeFees`, when `mint` is true and `feeAdded1` is true.",
            "how_to_validate_state_update": "Check that `DFIREStaking.addReward` is called with the correct `sbrStakersFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `DFIREStaking` contract's reward balance increases when `distributeFees` mints tokens and the SBR stakers fee is added successfully.",
            "conditions": [
              "mint == true",
              "feeAdded1 == true"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "rewardBalance",
            "type": "external_transfer",
            "what_does_it_track": "Tracks the distribution of fees to the StabilityPool.",
            "why_is_is_important": "The `StabilityPool` is part of the reward distribution system and needs to be tracked.",
            "when_is_it_updated": "Updated in `distributeFees`, when `mint` is true and `feeAdded2` is true.",
            "how_to_validate_state_update": "Check that `stabilityPool.addReward` is called with the correct `stabilityPoolFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `StabilityPool`'s reward balance increases when `distributeFees` mints tokens and the stability pool fee is added successfully.",
            "conditions": [
              "mint == true",
              "feeAdded2 == true"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalSupply",
            "type": "decrease",
            "what_does_it_track": "Tracks the supply of SBD tokens.",
            "why_is_is_important": "This burns the refunded fees to return them to the borrower.",
            "when_is_it_updated": "This is updated in the `distributeFees` function, when canRefund > 0 and mint is true",
            "how_to_validate_state_update": "Check that `sbdToken.burn` is called with the correct amount and the contract's balance decreases accordingly.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns `canRefund` amount from the contract.",
            "conditions": [
              "canRefund > 0",
              "mint == true"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "increase",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "The `_amountToBorrow` represents the number of SBD tokens to be minted to the user.",
            "when_is_it_updated": "This is updated in `handleBorrow` when minting SBD tokens to the borrower.",
            "how_to_validate_state_update": "Verify that `sbdToken.mint` is called with the correct parameters and the user's balance increases accordingly.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints `_amountToBorrow` tokens to `msg.sender`.",
            "conditions": []
          },
          {
            "state_variable_name": "totalSupply",
            "type": "increase",
            "what_does_it_track": "Tracks the total supply of SBD tokens when minting to contract.",
            "why_is_is_important": "The `fee` tokens need to be minted to the contract, so they can be distributed among stakers and stability pool.",
            "when_is_it_updated": "This is updated in `distributeFees` when minting SBD tokens to the contract address.",
            "how_to_validate_state_update": "Verify that `sbdToken.mint` is called with the correct parameters, minting `fee` tokens to the contract address.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints `fee` tokens to `address(this)` within distributeFees",
            "conditions": [
              "mint == true"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}