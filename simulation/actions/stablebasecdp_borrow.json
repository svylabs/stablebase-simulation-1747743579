{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should be a valid and existing safeId, meaning a safe with that ID must exist and have collateral.",
      "amount: Should be a non-zero amount to borrow, but not exceeding the maximum borrowable limit. Should be greater than or equal to MINIMUM_DEBT.",
      "shieldingRate: Can be zero or a non-zero value representing the shielding rate in basis points.",
      "nearestSpotInLiquidationQueue: If known, the id of a safe near the desired position in the liquidation queue. If unknown, 0.",
      "nearestSpotInRedemptionQueue: If known, the id of a safe near the desired position in the redemption queue. If unknown, 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State Updates",
        "state_update_descriptions": [
          "Updates the Safe's borrowedAmount by adding the amount borrowed.",
          "Updates the Safe's totalBorrowedAmount by adding the amount borrowed.",
          "Updates the Safe's weight based on shieldingRate and existing borrowings, affecting its position in the redemption queue.",
          "Updates the Safe's feePaid by adding the shielding fee.",
          "Updates the liquidationSnapshots for the safe",
          "Update totalCollateral if there are collateral increase",
          "Update totalDebt"
        ]
      },
      {
        "category": "Token and Fee Distribution",
        "state_update_descriptions": [
          "Mints SBD tokens to the borrower's address.",
          "Distributes fees to the SBR stakers and stability pool.",
          "Burns SBD tokens if a fee refund is available.",
          "Updates cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral if borrowed amount changes, due to interest accrual"
        ]
      },
      {
        "category": "Queue Management",
        "state_update_descriptions": [
          "Updates the position of the safe in the redemption queue.",
          "Updates the position of the safe in the liquidation queue.",
          "Update of the head and tail of the queues"
        ]
      },
      {
        "category": "Protocol Debt",
        "state_update_descriptions": [
          "Update totalDebt of the protocol."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State Validation",
        "rule_descriptions": [
          "safe.borrowedAmount should be equal to pre-borrow borrowedAmount + amount",
          "safe.totalBorrowedAmount should be equal to pre-borrow totalBorrowedAmount + amount",
          "safe.feePaid should be equal to the pre-borrow feePaid plus the calculated shielding fee.",
          "The safe should exist (safe.collateralAmount > 0)"
        ]
      },
      {
        "category": "Token Validation",
        "rule_descriptions": [
          "The borrower's SBD token balance should increase by the borrowed amount minus the shielding fee plus canRefund if it is greater than 0.",
          "Total supply of SBD token should increase by amount.",
          "Contract's SBD balance should increase if there is fee to distribute."
        ]
      },
      {
        "category": "Queue Validation",
        "rule_descriptions": [
          "The safe's position in the redemption and liquidation queues should be correctly updated based on the new borrowed amount and shielding rate.",
          "The weight of safe in safesOrderedForRedemption should be updated",
          "The ratio in safesOrderedForLiquidation should be updated"
        ]
      },
      {
        "category": "Protocol Debt Validation",
        "rule_descriptions": [
          "The totalDebt should be updated based on the amount borrowed. TotalDebt should be equal to pre-borrow totalDebt + amount"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt borrowed against the collateral, the total debt in the system, and adjusts for inactive debt.",
            "why_is_is_important": "Crucial for tracking the debt and collateralization status of each safe and the overall system.",
            "when_is_it_updated": "After the `_updateSafe` function has been called, when the cumulative collateral per unit collateral has changed since the last snapshot, indicating that inactive debt and collateral need to be accounted for.",
            "how_to_validate_state_update": "Check the `safes` mapping for the given `safeId` to see if `borrowedAmount` and `totalBorrowedAmount` are increased. Verify the emitted `SafeUpdated` event contains the correct values for collateralAmount, borrowedAmount, collateralIncrease, debtIncrease, totalCollateral and totalDebt.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `borrowedAmount` and `totalBorrowedAmount` of a safe, increases the `totalCollateral` and `totalDebt`, and updates liquidation snapshots based on cumulative debt and collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt and the protocol mode.",
            "why_is_is_important": "Tracks the total outstanding debt in the system and manages the protocol's operating mode based on the debt level.",
            "when_is_it_updated": "When debt increases or decreases, and a threshold is crossed, the protocol mode might be updated.",
            "how_to_validate_state_update": "Check the `totalDebt` state variable. Verify that the `PROTOCOL_MODE` state variable is updated correctly if totalDebt exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt of the protocol. If the debt exceeds a threshold, the protocol mode is switched from BOOTSTRAP to NORMAL.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "uint256",
            "what_does_it_track": "Tracks borrowed amounts, shielding fees, safe weights, and manages the ordering of safes for redemption and liquidation.",
            "why_is_is_important": "Maintains correct accounting of borrowed amounts, fees, and risk parameters (weight/ratio) for each safe and the system as a whole.",
            "when_is_it_updated": "During each borrow action, adjusting fees, managing safe positions in queues, and minting tokens to the borrower.",
            "how_to_validate_state_update": "Check the `safes` mapping for the given `safeId` and verify `weight`, `borrowedAmount`, `totalBorrowedAmount`, and `feePaid` are updated. Verify that the `safesOrderedForRedemption` and `safesOrderedForLiquidation` linked lists are updated with the correct values. Check that the SBD token is minted to the borrower.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's weight, borrowed amount, total borrowed amount, and fee paid based on the shielding rate.  It also manages the redemption and liquidation queues by inserting/updating nodes in the linked lists. Also updates total debt",
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0",
              "amount < _shieldingFee",
              "_shieldingFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": [
          {
            "state_variable_name": "price",
            "type": "uint256",
            "what_does_it_track": "The current price of the collateral asset.",
            "why_is_is_important": "The price is used to calculate the maximum borrowable amount, ensuring that the CDP remains adequately collateralized.",
            "when_is_it_updated": "The price is fetched every time the borrow function is called.",
            "how_to_validate_state_update": "Check the returned value against the `price` variable in the MockPriceOracle contract.",
            "has_conditional_updates": false,
            "summary_of_update": "Fetches the price from the price oracle. This action does not modify any state, it only reads the state of the `price` variable.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Tracks the order of safes based on their risk parameters, used for redemption and liquidation processes.",
            "why_is_is_important": "Maintains the correct ordering of safes for redemption and liquidation, based on weight (for redemption) and ratio (for liquidation).",
            "when_is_it_updated": "Each time the `borrow` function is called, the safe's position in the redemption and liquidation queues is updated.",
            "how_to_validate_state_update": "Check that the linked list structure is correctly updated by verifying the `prev` and `next` pointers of the inserted/updated node and its neighbors. Inspect the `nodes` mapping to confirm the node's value is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "The `upsert` function either inserts a new node or updates an existing node in the doubly linked list for both redemption and liquidation queues.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the beginning and end of the doubly linked list.",
            "why_is_is_important": "Maintains the correct pointers to the beginning and end of the linked list.",
            "when_is_it_updated": "During the insertion of a new node into the linked list, when the list is empty or when the new node should be the new head or tail.",
            "how_to_validate_state_update": "Check the `head` and `tail` state variables to see if they are updated correctly after insertion. Validate that the `prev` and `next` pointers of the new head/tail node are set to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `head` and `tail` of the doubly linked list during insertion if the list is empty or if the new node becomes the new head/tail.",
            "conditions": [
              "head == 0",
              "nodes[_nearestSpot].value >= node.value",
              "nodes[_nearestSpot].value < node.value"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the beginning and end of the doubly linked list.",
            "why_is_is_important": "Maintains the correct pointers to the beginning and end of the linked list.",
            "when_is_it_updated": "During the removal of a node from the linked list, when the node being removed is the head or tail.",
            "how_to_validate_state_update": "Check the `head` and `tail` state variables to see if they are updated correctly after removal. Validate that the `prev` and `next` pointers of the new head/tail node are set to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `head` and `tail` of the doubly linked list during removal if the node being removed is the head or tail.",
            "conditions": [
              "node.prev == 0",
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of SBD tokens held by each address.",
            "why_is_is_important": "Represents the core function of the protocol - providing stablecoin loans to users.",
            "when_is_it_updated": "Each time a user successfully borrows SBD tokens.",
            "how_to_validate_state_update": "Check the `balanceOf` function to see if the borrower's balance has increased by the minted amount. Verify that a `Transfer` event is emitted with the correct values.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints SBD tokens to the borrower.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of SBD tokens held by the contract.",
            "why_is_is_important": "Ensures fees are correctly distributed and refunds are properly processed.",
            "when_is_it_updated": "During the fee distribution process in `distributeFees`.",
            "how_to_validate_state_update": "Check the `balanceOf` function to see if the contract's balance has changed. Verify that a `Transfer` event is emitted with the correct values.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints and burns SBD tokens to distribute fees and handle refunds.",
            "conditions": [
              "_shieldingFee > 0",
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the staking pool.",
            "why_is_is_important": "Incentivizes users to stake DFIRE tokens, contributing to the stability of the protocol.",
            "when_is_it_updated": "When the `distributeFees` function successfully adds reward to the staking pool.",
            "how_to_validate_state_update": "Check the `totalRewardPerToken` state variable. Verify that a `RewardAdded` event is emitted with the correct amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds reward to the DFIRE staking pool, increasing `totalRewardPerToken`.",
            "conditions": [
              "feeAdded1"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the Stability Pool and the SBR reward distribution status.",
            "why_is_is_important": "Incentivizes users to deposit SBD tokens into the Stability Pool, providing a mechanism for liquidating undercollateralized CDPs.",
            "when_is_it_updated": "When the `distributeFees` function successfully adds reward to the Stability Pool and when SBR rewards are distributed.",
            "how_to_validate_state_update": "Check the `totalRewardPerToken` state variable. Verify that a `RewardAdded` event is emitted with the correct amount. Check for `SBRRewardsAdded` events if SBR rewards are distributed.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds reward to the Stability Pool, increasing `totalRewardPerToken` and potentially updating SBR reward distribution parameters.",
            "conditions": [
              "feeAdded2",
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}