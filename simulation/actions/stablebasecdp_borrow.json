{
  "action": {
    "name": "borrow",
    "summary": "Borrow from the protocol",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 1.0
  },
  "action_detail": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Needs to be a valid safeId (NFT token ID) and its ownership must belong to the message sender (msg.sender).",
      "amount: A non-zero unsigned integer representing the amount of SBD tokens to borrow.",
      "shieldingRate: An unsigned integer representing the shielding rate, expressed in basis points.",
      "nearestSpotInLiquidationQueue: An unsigned integer representing the nearest spot in the liquidation queue.",
      "nearestSpotInRedemptionQueue: An unsigned integer representing the nearest spot in the redemption queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Debt and Collateral Tracking",
        "state_update_descriptions": [
          "cumulativeDebtPerUnitCollateral is updated, affecting the safe's borrowedAmount.",
          "cumulativeCollateralPerUnitCollateral is updated, affecting the safe's collateralAmount.",
          "The total debt of the protocol is increased by the amount borrowed.",
          "The borrowedAmount of the safe is increased by the amount borrowed.",
          "The safe's totalBorrowedAmount is increased by the amount borrowed.",
          "The safe's feePaid is increased by the shielding fee.",
          "SBD tokens are minted to the borrower's address.",
          "A portion of the shielding fee may be refunded to the borrower.",
          "If the total debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD protocol mode is switched from BOOTSTRAP to NORMAL"
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Fees are distributed to the SBR stakers and the Stability Pool. The shielding fee is split, with (fee * SBR_FEE_REWARD) / 10000 going to dfireTokenStaking and the remainder going to the stabilityPool.",
          "The weight of the safe in the redemption queue is updated based on the shielding rate.",
          "The safe is inserted/updated in both the liquidation and redemption queues."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The borrower's SBD token balance should increase by the borrowed amount minus the shielding fee plus any potential fee refund."
        ]
      },
      {
        "category": "Debt Tracking",
        "rule_descriptions": [
          "The total debt in the StableBaseCDP contract should increase by the borrowed amount."
        ]
      },
      {
        "category": "Safe State",
        "rule_descriptions": [
          "The safe's borrowedAmount should increase by the borrowed amount.",
          "The safe's totalBorrowedAmount should increase by the borrowed amount.",
          "The safe's feePaid should increase by the shielding fee amount."
        ]
      },
      {
        "category": "Queue Management",
        "rule_descriptions": [
          "Verify that the Safe's weight in the redemption queue is updated correctly based on the shielding rate.",
          "Verify the safe is placed at the correct place at the redemption queue based on the parameter nearestSpotInRedemptionQueue.",
          "Verify the safe is placed at the correct place at the liquidation queue based on the parameter nearestSpotInLiquidationQueue."
        ]
      },
      {
        "category": "Protocol Mode",
        "rule_descriptions": [
          "Total debt in the StableBaseCDP contract must be greater than or equal to BOOTSTRAP_MODE_DEBT_THRESHOLD to switch from BOOTSTRAP to NORMAL mode"
        ]
      },
      {
        "category": "SBD Token Supply",
        "rule_descriptions": [
          "The total supply of sbdToken must increase by the borrowed amount."
        ]
      },
      {
        "category": "Collateral Amount",
        "rule_descriptions": [
          "The safe's collateral amount should remain unchanged, barring updates due to cumulative debt and collateral changes as described in _updateSafe."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Safe's borrowed amount",
            "why_is_is_important": "Tracks the debt owed by a specific safe, crucial for calculating liquidation thresholds and redemption amounts.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check that `_safe.borrowedAmount` increases by the correct `debtIncrease` amount.  `debtIncrease` is calculated based on cumulative debt and collateral per unit collateral. Check cumulativeCollateralPerUnitCollateral, cumulativeDebtPerUnitCollateral, and _safe.collateralAmount before and after the transaction to make sure that the debtIncrease amount is correctly calculated by expression: `(_safe.collateralAmount *(cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a safe based on cumulative debt and collateral per unit collateral. It increases `_safe.borrowedAmount` by `debtIncrease`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Safe's total borrowed amount",
            "why_is_is_important": "Represents the total debt ever borrowed by the safe.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check that `_safe.totalBorrowedAmount` increases by the correct `debtIncrease` amount. Verify that _safe.totalBorrowedAmount increases by debtIncrease. Check cumulativeCollateralPerUnitCollateral, cumulativeDebtPerUnitCollateral, and _safe.collateralAmount before and after the transaction to make sure that the debtIncrease amount is correctly calculated by expression: `(_safe.collateralAmount *(cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of a safe. It increases `_safe.totalBorrowedAmount` by `debtIncrease`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Safe's collateral amount",
            "why_is_is_important": "Tracks the collateral backing the safe, vital for determining the safe's health and liquidation risk.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check that `_safe.collateralAmount` increases by the correct `collateralIncrease` amount. `collateralIncrease` is calculated based on cumulative collateral. Check cumulativeCollateralPerUnitCollateral, and _safe.collateralAmount before and after the transaction to make sure that the collateralIncrease amount is correctly calculated by expression: `(_safe.collateralAmount *(cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of a safe based on cumulative collateral per unit collateral.  It increases `_safe.collateralAmount` by `collateralIncrease`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Liquidation snapshot's debt per collateral snapshot",
            "why_is_is_important": "Stores the debt per collateral ratio at the time of the snapshot, used for calculating changes in debt.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify that `liquidationSnapshot.debtPerCollateralSnapshot` matches `cumulativeDebtPerUnitCollateral`. Check cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot before and after the transaction to make sure liquidationSnapshot.debtPerCollateralSnapshot equals cumulativeDebtPerUnitCollateral after the transaction",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation snapshot's debt per collateral snapshot. It sets `liquidationSnapshot.debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Liquidation snapshot's collateral per collateral snapshot",
            "why_is_is_important": "Stores the collateral per collateral ratio at the time of the snapshot, used for calculating changes in collateral.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify that `liquidationSnapshot.collateralPerCollateralSnapshot` matches `cumulativeCollateralPerUnitCollateral`. Check cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot before and after the transaction to make sure liquidationSnapshot.collateralPerCollateralSnapshot equals cumulativeCollateralPerUnitCollateral after the transaction",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation snapshot's collateral per collateral snapshot. It sets `liquidationSnapshot.collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total collateral",
            "why_is_is_important": "Represents the total collateral in the system and is a key parameter for assessing overall protocol health.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Ensure `totalCollateral` increases by `collateralIncrease`. Check cumulativeCollateralPerUnitCollateral, and _safe.collateralAmount before and after the transaction to make sure that the collateralIncrease amount is correctly calculated by expression: `(_safe.collateralAmount *(cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`. Then ensure totalCollateral increased by collateralIncrease",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the protocol.  It increases `totalCollateral` by `collateralIncrease`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt",
            "why_is_is_important": "Represents the total outstanding debt in the system and is a key parameter for assessing overall protocol health.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Ensure `totalDebt` increases by `debtIncrease`. Check cumulativeCollateralPerUnitCollateral, cumulativeDebtPerUnitCollateral, and _safe.collateralAmount before and after the transaction to make sure that the debtIncrease amount is correctly calculated by expression: `(_safe.collateralAmount *(cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`. Then ensure totalDebt increased by debtIncrease",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt in the protocol. It increases `totalDebt` by `debtIncrease`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "PROTOCOL_MODE",
            "why_is_is_important": "Controls the operational mode of the protocol, potentially influencing parameters such as liquidation ratios or borrowing limits.",
            "when_is_it_updated": "When the total debt exceeds the bootstrap mode debt threshold.",
            "how_to_validate_state_update": "Check that `PROTOCOL_MODE` transitions from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL` when `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD`. Check the value of BOOTSTRAP_MODE_DEBT_THRESHOLD and totalDebt before and after the transaction. If totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and PROTOCOL_MODE is equal to BOOTSTRAP before the transaction, then PROTOCOL_MODE should be equal to NORMAL after the transaction",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds a certain threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "what_does_it_track": "Safe's weight",
            "why_is_is_important": "Determines the fee paid by the safe during redemptions, influencing the profitability of redemptions and the overall stability of the system.",
            "when_is_it_updated": "Every time a safe borrows, updating its relative position in the redemption queue.",
            "how_to_validate_state_update": "Verify `safe.weight` updates according to the described logic.  If it's the first borrow, it's based on `shieldingRate` or `_minFeeWeight + shieldingRate`.  Otherwise, it is a weighted average. Check that if the `safe.borrowedAmount == 0` before the transaction, then if `_minFeeWeightNode == 0`, `safe.weight` equals shieldingRate, otherwise, `safe.weight` equals `_minFeeWeight + shieldingRate`. Also check that if the `safe.borrowedAmount != 0` before the transaction, then safe.weight equals `_minFeeWeight + newFeeWeight` where `newFeeWeight = ((_shieldingFee + weightedDiff) * BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount)` and `weightedDiff = (diff * safe.borrowedAmount) / BASIS_POINTS_DIVISOR` and `diff = safe.weight - _minFeeWeight`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the weight of the safe, which represents a fee component for redemptions.  Different calculations happen depending on whether it is the first time borrowing or not.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "safe.borrowedAmount != 0",
              "_minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Safe's borrowed amount",
            "why_is_is_important": "Tracks the debt owed by the safe, influencing liquidation risk and redemption amounts.",
            "when_is_it_updated": "Always, when borrowing.",
            "how_to_validate_state_update": "Check that `safe.borrowedAmount` increases by `amount`. Ensure the safe.borrowedAmount after the transaction equals the safe.borrowedAmount before the transaction plus the amount",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the borrowed amount of the safe by the borrow amount. This increases the overall debt of the safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Safe's total borrowed amount",
            "why_is_is_important": "Represents the total debt ever borrowed by the safe.",
            "when_is_it_updated": "Always, when borrowing.",
            "how_to_validate_state_update": "Check that `safe.totalBorrowedAmount` increases by `amount`. Ensure the safe.totalBorrowedAmount after the transaction equals the safe.totalBorrowedAmount before the transaction plus the amount",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total borrowed amount of the safe by the borrow amount.",
            "conditions": []
          },
          {
            "state_variable_name": "safe.feePaid",
            "type": "uint256",
            "what_does_it_track": "Safe's fee paid",
            "why_is_is_important": "Tracks the total fees paid by the safe, impacting profitability and incentivizing responsible borrowing.",
            "when_is_it_updated": "Always, when borrowing.",
            "how_to_validate_state_update": "Check that `safe.feePaid` increases by `_shieldingFee`. Ensure the safe.feePaid after the transaction equals the safe.feePaid before the transaction plus _shieldingFee where `_shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR`",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the fee paid by the safe by the shielding fee amount.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Safes ordered for redemption",
            "why_is_is_important": "Maintains the order in which safes are redeemed, directly influencing the redemption process and the distribution of fees.",
            "when_is_it_updated": "Always, when borrowing.",
            "how_to_validate_state_update": "Verify that the doubly linked list `safesOrderedForRedemption` is updated correctly. Check the `prev` and `next` pointers for the inserted/updated node. Also check that the safes are ordered by their weights in ascending order. Use the get() function of safesOrderedForRedemption to get the node by its id and check the node.value that represents the weight",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the doubly linked list of safes ordered for redemption, based on their weight.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Safes ordered for liquidation",
            "why_is_is_important": "Maintains the order in which safes are liquidated, directly influencing the liquidation process and ensuring that the riskiest safes are liquidated first.",
            "when_is_it_updated": "Always, when borrowing.",
            "how_to_validate_state_update": "Verify that the doubly linked list `safesOrderedForLiquidation` is updated correctly. Check the `prev` and `next` pointers for the inserted/updated node. Use the get() function of safesOrderedForLiquidation to get the node by its id and check the node.value that represents the ratio. Check that safes are ordered by their borrow amount per unit collateral in ascending order",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the doubly linked list of safes ordered for liquidation, based on their borrow amount per unit collateral.",
            "conditions": []
          },
          {
            "state_variable_name": "sbdToken",
            "type": "IMintableToken",
            "what_does_it_track": "SBD token balance of the contract and msg.sender",
            "why_is_is_important": "Manages the supply of SBD tokens, influencing the overall stability and value of the stablecoin.",
            "when_is_it_updated": "When fees are distributed and refunds are issued.",
            "how_to_validate_state_update": "Verify that SBD tokens are minted to the contract and burnt from the contract by canRefund amount and minted to msg.sender. Ensure that `sbdToken.mint(address(this), fee)` is called when _shieldingFee > 0. Ensure that `sbdToken.burn(address(this), canRefund)` is called when `canRefund > 0`. Ensure that `sbdToken.mint(msg.sender, _amountToBorrow)` is always called where `_amountToBorrow = amount - _shieldingFee + canRefund`",
            "has_conditional_updates": true,
            "summary_of_update": "Mints and burns SBD tokens within the contract and to the borrower, distributing fees and potentially refunding amounts.",
            "conditions": [
              "_shieldingFee > 0",
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "dfireTokenStaking",
            "type": "IDFIREStaking",
            "what_does_it_track": "DFIREStaking's reward",
            "why_is_is_important": "Incentivizes users to stake DFIRE tokens, contributing to the stability and security of the system.",
            "when_is_it_updated": "When there is a fee distributed to sbr stakers.",
            "how_to_validate_state_update": "Check that the reward is correctly added to `dfireTokenStaking`. Check that `dfireTokenStaking.addReward(sbrStakersFee)` is called and the `sbrStakersFee` is transferred from the contract to the `dfireTokenStaking` contract where `sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000` and fee is equal to `_shieldingFee`",
            "has_conditional_updates": true,
            "summary_of_update": "Adds a reward to the DFIRE staking contract.",
            "conditions": [
              "sbrStakersFee > 0"
            ]
          },
          {
            "state_variable_name": "stabilityPool",
            "type": "IStabilityPool",
            "what_does_it_track": "StabilityPool's reward",
            "why_is_is_important": "Incentivizes users to provide stability to the system, reducing the risk of liquidations and maintaining peg.",
            "when_is_it_updated": "When there is a fee distributed to the stability pool.",
            "how_to_validate_state_update": "Check that the reward is correctly added to `stabilityPool`. Check that `stabilityPool.addReward(stabilityPoolFee)` is called and the `stabilityPoolFee` is transferred from the contract to the `stabilityPool` contract where `stabilityPoolFee = fee - sbrStakersFee` and fee is equal to `_shieldingFee`",
            "has_conditional_updates": true,
            "summary_of_update": "Adds a reward to the stability pool.",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[to]",
            "type": "uint256",
            "what_does_it_track": "Total supply and account balance",
            "why_is_is_important": "It increases account balance and keeps track of total supply of tokens.",
            "when_is_it_updated": "when sbdToken.mint() is called",
            "how_to_validate_state_update": "Verify the total supply by calling totalSupply() and account balance by calling balanceOf(account). Check the `_balances[to]` value increased by mint amount",
            "has_conditional_updates": false,
            "summary_of_update": "Mints tokens to a specified address, increasing the total supply.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[account]",
            "type": "uint256",
            "what_does_it_track": "Total supply and account balance",
            "why_is_is_important": "It decreases account balance and keeps track of total supply of tokens.",
            "when_is_it_updated": "when sbdToken.burn() is called",
            "how_to_validate_state_update": "Verify the total supply by calling totalSupply() and account balance by calling balanceOf(account). Check the `_balances[account]` value decreased by burn amount",
            "has_conditional_updates": false,
            "summary_of_update": "Burns tokens from a specified address, decreasing the total supply.",
            "conditions": []
          }
        ]
      }
    ]
  }
}