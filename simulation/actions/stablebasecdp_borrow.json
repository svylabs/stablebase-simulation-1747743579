{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid ID of an existing safe owned by the caller (msg.sender).",
      "amount: The amount of debt to borrow. Must be greater than or equal to MINIMUM_DEBT and less than or equal to maxBorrowAmount, which is calculated based on the safe's collateralAmount, the price of the collateral from the priceOracle, and the liquidationRatio.",
      "shieldingRate: The rate of shielding applied to the borrowed amount, expressed in basis points.",
      "nearestSpotInLiquidationQueue: The ID of the nearest safe in the liquidation queue to insert the current safe, used for maintaining the order in the queue. Use 0 if the queue is empty or to insert at the beginning.",
      "nearestSpotInRedemptionQueue: The ID of the nearest safe in the redemption queue to insert the current safe, used for maintaining the order in the queue. Use 0 if the queue is empty or to insert at the beginning."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Data",
        "state_update_descriptions": [
          "safes[safeId].borrowedAmount increases by amount.",
          "safes[safeId].totalBorrowedAmount increases by amount.",
          "safes[safeId].feePaid increases by _shieldingFee.",
          "safes[safeId].weight is updated based on shieldingRate and existing minimum fee weight."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "totalDebt increases by amount."
        ]
      },
      {
        "category": "Token Minting",
        "state_update_descriptions": [
          "SBD tokens are minted to the borrower (msg.sender) for the amount _amountToBorrow (amount - _shieldingFee + canRefund)."
        ]
      },
      {
        "category": "Doubly Linked List",
        "state_update_descriptions": [
          "safesOrderedForRedemption is updated with safeId and safe.weight, either inserting or updating the node.",
          "safesOrderedForLiquidation is updated with safeId and ratio (borrowAmount per unit collateral), either inserting or updating the node."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Fees are distributed to SBR stakers and the stability pool.",
          "SBD tokens might be minted to the contract and then burned if canRefund > 0."
        ]
      },
      {
        "category": "SBR Staking and Stability Pool Rewards Distribution",
        "state_update_descriptions": [
          "If _shieldingFee > 0, DFIREStaking.addReward() is called with (fee * SBR_FEE_REWARD) / 10000.",
          "If _shieldingFee > 0 and DFIREStaking.addReward() returns true, StabilityPool.addReward() is called with the remaining fee amount.",
          "If _shieldingFee > 0 and DFIREStaking.addReward() returns false, StabilityPool.addReward() is called with the total fee amount."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "totalCollateral may be updated depending on the result of `_updateSafe` function"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "State Validation",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be increased by the amount borrowed.",
          "safes[safeId].totalBorrowedAmount should be increased by the amount borrowed.",
          "safes[safeId].feePaid should be increased by the shielding fee (_shieldingFee).",
          "The borrower (msg.sender) should have received _amountToBorrow SBD tokens.",
          "totalDebt should be increased by amount."
        ]
      },
      {
        "category": "Queue Validation",
        "rule_descriptions": [
          "Verify that the safe is correctly inserted/updated in safesOrderedForRedemption with the correct weight.",
          "Verify that the safe is correctly inserted/updated in safesOrderedForLiquidation with the correct ratio."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "Check the emitted events: Borrowed, FeeDistributed (if applicable), FeeRefund (if applicable)."
        ]
      },
      {
        "category": "Snapshot Validation",
        "rule_descriptions": [
          "Validate liquidationSnapshots[_safeId] is updated correctly."
        ]
      },
      {
        "category": "Total Collateral Validation",
        "rule_descriptions": [
          "Validate the updated value of totalCollateral"
        ]
      },
      {
        "category": "Fee Distribution Validation",
        "rule_descriptions": [
          "If shieldingFee (_shieldingFee) > 0, verify that the correct amount of fees was distributed to the DFIREStaking contract and the StabilityPool contract, according to the SBR_FEE_REWARD ratio.",
          "If shieldingFee (_shieldingFee) > 0, verify the minted and burned amount of SBD tokens at the contract."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral in a specific safe.",
            "why_is_is_important": "Tracks the amount of collateral deposited in a safe.",
            "when_is_it_updated": "Updated when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the SafeUpdated event for the change in `collateralAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount is increased by `collateralIncrease`, calculated based on cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt in a specific safe.",
            "why_is_is_important": "Tracks the amount of debt borrowed against the collateral.",
            "when_is_it_updated": "Updated when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the SafeUpdated event for the change in `debtAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount is increased by `debtIncrease`, calculated based on cumulative debt per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt in a specific safe.",
            "why_is_is_important": "Tracks the total debt borrowed against the collateral.",
            "when_is_it_updated": "Updated when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the SafeUpdated event for the change in `debtAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total borrowed amount is increased by `debtIncrease`, calculated based on cumulative debt per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the system.",
            "why_is_is_important": "Tracks the total collateral in the system.",
            "when_is_it_updated": "Updated when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the SafeUpdated event for the change in `totalCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral is increased by `collateralIncrease`, calculated based on cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "Tracks the total debt in the system.",
            "when_is_it_updated": "Updated when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the SafeUpdated event for the change in `totalDebt`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt is increased by `debtIncrease`, calculated based on cumulative debt per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId]",
            "type": "LiquidationSnapshot",
            "what_does_it_track": "Snapshot of debt and collateral per collateral at the time of last update.",
            "why_is_is_important": "Tracks liquidation snapshot per safe id.",
            "when_is_it_updated": "Updated when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the SafeUpdated event for `debtIncrease` and `collateralIncrease` to validate the update.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` to current `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral` respectively.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "Tracks the protocol mode, switching between BOOTSTRAP and NORMAL.",
            "when_is_it_updated": "Updated when `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`.",
            "how_to_validate_state_update": "Monitor the PROTOCOL_MODE state variable or related events to confirm the switch.",
            "has_conditional_updates": true,
            "summary_of_update": "PROTOCOL_MODE is changed to NORMAL.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The debt borrowed amount for a safe.",
            "why_is_is_important": "Tracks the debt amount for a safe.",
            "when_is_it_updated": "Updated in `handleBorrow` function. Always.",
            "how_to_validate_state_update": "Check Borrowed event for the updated amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the `borrowedAmount` by `amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total debt borrowed amount for a safe.",
            "why_is_is_important": "Tracks the total debt amount for a safe.",
            "when_is_it_updated": "Updated in `handleBorrow` function. Always.",
            "how_to_validate_state_update": "Check Borrowed event and safe state to validate.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the `totalBorrowedAmount` by `amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "The total fee amount paid for a safe.",
            "why_is_is_important": "Tracks the total fee paid for a safe.",
            "when_is_it_updated": "Updated in `handleBorrow` function. Always.",
            "how_to_validate_state_update": "Check FeeDistributed event for the updated fee amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the `feePaid` by `_shieldingFee`.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "DoublyLinkedList",
            "what_does_it_track": "Order of safes based on their liquidation ratio.",
            "why_is_is_important": "Maintains the order of safes for liquidation.",
            "when_is_it_updated": "Updated in `handleBorrow` function when borrowing.",
            "how_to_validate_state_update": "Check the LiquidationQueueUpdated event.",
            "has_conditional_updates": false,
            "summary_of_update": "Upserts the safe in the liquidation queue with a new ratio.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "DoublyLinkedList",
            "what_does_it_track": "Order of safes based on their shielding rate.",
            "why_is_is_important": "Maintains the order of safes for redemption.",
            "when_is_it_updated": "Updated in `handleBorrow` function when borrowing.",
            "how_to_validate_state_update": "Check the RedemptionQueueUpdated event.",
            "has_conditional_updates": false,
            "summary_of_update": "Upserts the safe in the redemption queue with a new weight.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt in the system.",
            "why_is_is_important": "Keeps track of the cumulative debt in the system.",
            "when_is_it_updated": "Updated in `handleBorrow` function when minting SBD tokens.",
            "how_to_validate_state_update": "Check Borrowed event for the updated debt amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The total debt is increased by `amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The fee weight amount for a safe",
            "why_is_is_important": "Used to determine fee weight for a safe",
            "when_is_it_updated": "Updated in `handleBorrow` function. When first time borrowing and `_minFeeWeightNode == 0`.",
            "how_to_validate_state_update": "Check Borrowed event for the new `weight` amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `safe.weight` to a new weight amount",
            "conditions": [
              "safe.borrowedAmount == 0 && _minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The fee weight amount for a safe",
            "why_is_is_important": "Used to determine fee weight for a safe",
            "when_is_it_updated": "Updated in `handleBorrow` function.",
            "how_to_validate_state_update": "Check Borrowed event for the new `weight` amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `safe.weight` to a new weight amount",
            "conditions": [
              "safe.borrowedAmount > 0 && shieldingRate > 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The fee weight amount for a safe",
            "why_is_is_important": "Used to determine fee weight for a safe",
            "when_is_it_updated": "Updated in `handleBorrow` function.",
            "how_to_validate_state_update": "Check Borrowed event for the new `weight` amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `safe.weight` to a new weight amount",
            "conditions": [
              "safe.borrowedAmount == 0 && _minFeeWeightNode != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "The token balance of the contract.",
            "why_is_is_important": "Maintains the token balance of the contract, minting tokens to the contract.",
            "when_is_it_updated": "Updated in the `distributeFees` function, when minting is true.",
            "how_to_validate_state_update": "Check the FeeDistributed event to validate the amount minted.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints `fee` amount of tokens to the contract.",
            "conditions": [
              "mint"
            ]
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "The token balance of the contract.",
            "why_is_is_important": "Maintains the token balance of the contract, burning tokens from the contract.",
            "when_is_it_updated": "Updated in the `distributeFees` function, when canRefund > 0 and mint is true.",
            "how_to_validate_state_update": "Check the FeeDistributed event to validate the amount burned.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns `canRefund` amount of tokens from the contract.",
            "conditions": [
              "canRefund > 0",
              "mint"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Total supply of the token.",
            "why_is_is_important": "Keeps track of the total supply of the token.",
            "when_is_it_updated": "Updated in the `distributeFees` function, when minting is true.",
            "how_to_validate_state_update": "Check the Transfer events to validate the changes in total supply.",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply is increased by `fee` when minting and decreased by `canRefund` when burning.",
            "conditions": [
              "mint"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The token balance of the receiver.",
            "why_is_is_important": "Updates the balance of the receiver when minting new tokens.",
            "when_is_it_updated": "Updated in the `handleBorrow` function.",
            "how_to_validate_state_update": "Check the Transfer event to validate the amount minted.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints `_amountToBorrow` tokens to `msg.sender`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Rewards distributed to DFIRE stakers.",
            "why_is_is_important": "Adds reward to the DFIRE staking pool.",
            "when_is_it_updated": "Updated in `distributeFees` function, when `feeAdded1` is true.",
            "how_to_validate_state_update": "Check the RewardAdded event in the DFIREStaking contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls `dfireTokenStaking.addReward` with `sbrStakersFee`.",
            "conditions": [
              "feeAdded1"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Rewards distributed to DFIRE stakers.",
            "why_is_is_important": "Transfers reward tokens to this contract, therefore changing `_balances[msg.sender]`",
            "when_is_it_updated": "Updated in `addReward` function, when `_totalStake != 0`.",
            "how_to_validate_state_update": "Check the Transfer event in the rewardToken contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls rewardToken.transferFrom with `_amount`.",
            "conditions": [
              "_totalStake != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Rewards distributed to Stability Pool stakers.",
            "why_is_is_important": "Adds reward to the Stability Pool.",
            "when_is_it_updated": "Updated in `distributeFees` function, when `feeAdded2` is true.",
            "how_to_validate_state_update": "Check the RewardAdded event in the StabilityPool contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls `stabilityPool.addReward` with `stabilityPoolFee`.",
            "conditions": [
              "feeAdded2"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Rewards distributed to stability pool stakers.",
            "why_is_is_important": "Transfers reward tokens to this contract, therefore changing `_balances[msg.sender]`",
            "when_is_it_updated": "Updated in `addReward` function, when `_totalStakedRaw != 0`.",
            "how_to_validate_state_update": "Check the Transfer event in the stakingToken contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls stakingToken.transferFrom with `_amount`.",
            "conditions": [
              "_totalStakedRaw != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}