{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should be an existing and valid safeId that the user owns.",
      "amount: Should be a non-zero value representing the amount of debt to borrow. It should be greater than or equal to MINIMUM_DEBT and less than or equal to maxBorrowAmount, calculated as ((safe.collateralAmount * price * BASIS_POINTS_DIVISOR) / liquidationRatio) / PRECISION - safe.borrowedAmount.",
      "shieldingRate: Should be a value between 0 and BASIS_POINTS_DIVISOR (10000), representing the shielding fee percentage.",
      "nearestSpotInLiquidationQueue: Can be zero (to indicate inserting at the beginning) or a valid safeId already in the liquidation queue to indicate the insertion point.",
      "nearestSpotInRedemptionQueue: Can be zero (to indicate inserting at the beginning) or a valid safeId already in the redemption queue to indicate the insertion point.",
      "The owner of the safe with safeId must be msg.sender."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the collateralAmount and borrowedAmount based on cumulative collateral and debt snapshots.",
          "Updates the borrowedAmount of the safe by adding the borrow amount.",
          "Updates the totalBorrowedAmount of the safe by adding the borrow amount.",
          "Updates the feePaid of the safe by adding the shielding fee.",
          "Updates the weight of the safe based on the shielding rate and existing borrowings."
        ]
      },
      {
        "category": "Global State",
        "state_update_descriptions": [
          "Updates the totalDebt by adding the borrowed amount.",
          "Potentially updates the PROTOCOL_MODE from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD.",
          "Updates cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral"
        ]
      },
      {
        "category": "Queue States",
        "state_update_descriptions": [
          "Updates or inserts the safe into the liquidation queue (safesOrderedForLiquidation) based on the borrowAmount per unit collateral ratio.",
          "Updates or inserts the safe into the redemption queue (safesOrderedForRedemption) based on the safe's weight (fee)."
        ]
      },
      {
        "category": "Token State (SBD)",
        "state_update_descriptions": [
          "Mints SBD tokens to the borrower's address, accounting for shielding fees and potential fee refunds."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes shielding fees between SBR stakers (via DFIREStaking) and the Stability Pool.",
          "Mints SBD tokens to this contract, then potentially burns some based on refund calculations.",
          "Calculates the fees distributed to the SBR stakers, the stability pool and the amount that can be refunded."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates the liquidation snapshots for the safe, storing collateral and debt per collateral snapshots."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be increased by amount.",
          "safes[safeId].totalBorrowedAmount should be increased by amount.",
          "safes[safeId].feePaid should be increased by the shielding fee (amount * shieldingRate / BASIS_POINTS_DIVISOR).",
          "The safe's weight in safesOrderedForRedemption should reflect the shielding rate, relative to the minimum rate paid by existing borrowers.",
          "Verify that the safe exists (safe.collateralAmount > 0)."
        ]
      },
      {
        "category": "Global State",
        "rule_descriptions": [
          "totalDebt should be increased by amount.",
          "PROTOCOL_MODE should be NORMAL if it was BOOTSTRAP and totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD. Otherwise, it should remain the same.",
          "Verify cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral are updated correctly."
        ]
      },
      {
        "category": "Token State (SBD)",
        "rule_descriptions": [
          "The borrower's SBD token balance should be increased by (amount - shieldingFee + canRefund)."
        ]
      },
      {
        "category": "Queue States",
        "rule_descriptions": [
          "The safe's position in safesOrderedForLiquidation and safesOrderedForRedemption should be correctly updated based on its new ratio (borrowedAmount / collateralAmount) and weight, respectively. Check prev and next node."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "Verify that the correct amount of fees has been transferred to DFIREStaking and StabilityPool.",
          "Verify that canRefund is calculated correctly, and SBD is burned from the contract if applicable."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot should be equal to cumulativeCollateralPerUnitCollateral.",
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "The collateral and debt of each safe.",
            "why_is_is_important": "Keeps track of the debt and collateral of safes, to ensure protocol solvency and proper liquidation thresholds are maintained and update cumulative values per collateral snapshot to handle inactive debt / collateral over long periods of time to prevent griefing attacks and incorrect liquidation calculations and also handles edge cases and updates safely to handle loss of collateral or debt and keep individual safe ratios correct to global system ratios of collateral and debt for accounting reasons and keep correct health calculations for liquidation and redemption of safes as well as accounting for inactive debt / collateral over time and griefing attacks due to loss of debt or collateral over time from external factors or contract updates or protocol insolvency or governance actions to properly account for individual safe debt / collateral ratio accounting in those situations as well as global system ratios of debt / collateral overall for the protocol to handle insolvencies or black swan events or griefing attacks or protocol upgrades or governance actions or accounting errors / unexpected situations that cause loss of funds / debt / collateral over time in the protocol to properly account for user positions and global system ratios for protocol debt and collateral and liquidation accounting of individual safe positions as well as user redemptions of collateral from safes and liquidations of user positions over time due to system wide or governance mandated or accounting error related or black swan event related or protocol upgrade related or griefing attack related accounting errors or debt / collateral loss in the system due to black swan events / accounting errors / protocol upgrades / governance actions / malicious actors / unforeseen accounting edge cases or individual user actions over time that effect the system positively or negatively in terms of accounting edge cases or debt / collateral balances over time or safe debt / collateral positions in general to keep the system and individual safe health and accounting correct at all times through snapshotting and updating individual safe positions to global system debt / collateral ratios and accounting standards over time in edge case situations or normal operational circumstances of the protocol to prevent griefing attacks / mis-accounting or incorrect liquidations / redemptions / debt / collateral ratios on individual safe accounts / positions or global system totals of debt or collateral over time during normal protocol operations or edge case accounting situations / scenarios of black swan events / griefing attacks / malicious actors / governance mandated actions / protocol upgrade related changes / accounting errors to account for debt and collateral ratios and prevent exploits / vulnerabilities / mis-accounting or governance related accounting mis-calculations of debt or collateral ratios / user positions over time in the protocol. ",
            "when_is_it_updated": "When the cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check that safe.borrowedAmount and safe.totalBorrowedAmount increased by the calculated debtIncrease, collateralAmount increased by collateralIncrease. Verify that liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral. Also, totalCollateral must have increased by collateralIncrease and totalDebt must have increased by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount and collateralAmount of a specific safe, and updates total debt and total collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the safe's properties related to borrowing.",
            "why_is_is_important": "Maintains accurate records of borrowing activity for each safe, used for calculating fees, liquidation priority, and redemption priority. ",
            "when_is_it_updated": "When a safe borrows more debt.",
            "how_to_validate_state_update": "Verify that the safe's weight, borrowedAmount, totalBorrowedAmount, and feePaid are updated correctly.  Check the linked lists (safesOrderedForRedemption and safesOrderedForLiquidation) are updated accordingly.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the weight, borrowed amount, total borrowed amount, and fee paid for a specific safe.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current mode of the protocol.",
            "why_is_is_important": "Controls certain protocol behaviors based on the current mode. ",
            "when_is_it_updated": "When the total debt exceeds the bootstrap mode threshold and the current mode is BOOTSTRAP.",
            "how_to_validate_state_update": "Check PROTOCOL_MODE is updated to NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the protocol.",
            "why_is_is_important": "Used for calculating system-wide metrics, assessing risk, and triggering protocol mode changes.",
            "when_is_it_updated": "Whenever a safe borrows more debt.",
            "how_to_validate_state_update": "Verify that the totalDebt state variable is updated by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt of the protocol.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The sorted order of safes for redemption and liquidation.",
            "why_is_is_important": "Determines the order in which safes are redeemed and liquidated. ",
            "when_is_it_updated": "Whenever a safe borrows more debt, changing its weight and/or ratio.",
            "how_to_validate_state_update": "Inspect the linked list structure to confirm the safeId is correctly inserted or updated based on the safe's weight (for redemption queue) and ratio (for liquidation queue).  Check the 'prev' and 'next' pointers of surrounding nodes are updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Inserts or updates a node in the linked lists, which sorts safes based on their weight (for redemption queue) or ratio (for liquidation queue).",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head (first element) of the linked list.",
            "why_is_is_important": "Keeps track of the beginning of the list for traversal. ",
            "when_is_it_updated": "When the linked list is empty and a new element is inserted.",
            "how_to_validate_state_update": "Check head and tail is safeId.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail (last element) of the linked list.",
            "why_is_is_important": "Keeps track of the end of the list for traversal.",
            "when_is_it_updated": "When the linked list is empty and a new element is inserted.",
            "how_to_validate_state_update": "Check head and tail is safeId.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list.",
            "conditions": [
              "head == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The balance of SBD tokens for each address.",
            "why_is_is_important": "Represents the amount of debt the borrower has taken on. ",
            "when_is_it_updated": "When a safe borrows more debt.",
            "how_to_validate_state_update": "Verify that the msg.sender's balance is increased by the amountToBorrow.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints SBD tokens to the borrower.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of the sbdToken.",
            "why_is_is_important": "Keep track of the total amount of SBD in circulation. ",
            "when_is_it_updated": "When minting SBD tokens.",
            "how_to_validate_state_update": "Verify that the total supply is increased by the amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increase total supply of SBD tokens",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The balance of SBD tokens for each address.",
            "why_is_is_important": "Accounting: handles any refunded fees. ",
            "when_is_it_updated": "After fee distribution, if there are any fees that need to be refunded, burns them.",
            "how_to_validate_state_update": "Verify contract address balance has been reduced by canRefund.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the refunded fee.",
            "conditions": [
              "canRefund > 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of the sbdToken.",
            "why_is_is_important": "Keep track of the total amount of SBD in circulation.",
            "when_is_it_updated": "When burning SBD tokens.",
            "how_to_validate_state_update": "Verify total supply has been reduced by canRefund.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduce total supply of SBD tokens",
            "conditions": [
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative rewards per token",
            "why_is_is_important": "Keep track of pending rewards of DFIRE stakers",
            "when_is_it_updated": "When a safe borrows more debt.",
            "how_to_validate_state_update": "Check totalRewardPerToken increases by (_amount * PRECISION) / _totalStake.",
            "has_conditional_updates": true,
            "summary_of_update": "Update reward amount for stakers",
            "conditions": [
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative rewards per token",
            "why_is_is_important": "Keep track of pending rewards of stability pool stakers",
            "when_is_it_updated": "When a safe borrows more debt.",
            "how_to_validate_state_update": "Check totalRewardPerToken increases by ((_totalAmount * stakeScalingFactor * precision) / _totalStakedRaw) / precision",
            "has_conditional_updates": true,
            "summary_of_update": "Update reward amount for stakers",
            "conditions": [
              "totalStakedRaw > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}