{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should be an existing and valid safeId corresponding to an existing Safe.",
      "amount: Should be a non-zero amount and ensure that safe.borrowedAmount + amount >= MINIMUM_DEBT.",
      "amount: Ensure that safe.borrowedAmount + amount <= maxBorrowAmount where maxBorrowAmount = ((safe.collateralAmount * price * BASIS_POINTS_DIVISOR) / liquidationRatio) / PRECISION",
      "shieldingRate: A percentage representing the shielding fee to be applied. This value impacts the safe's weight in the redemption queue.",
      "nearestSpotInLiquidationQueue: A hint to the doubly linked list where the safe should be inserted, it can be zero.",
      "nearestSpotInRedemptionQueue: A hint to the doubly linked list where the safe should be inserted, it can be zero."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Core",
        "state_update_descriptions": [
          "Update borrowedAmount in the safe's storage",
          "Update totalBorrowedAmount in the safe's storage",
          "Update the total debt (totalDebt) of the protocol",
          "Mint SBD tokens to the borrower (msg.sender)"
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Update feePaid in the safe's storage",
          "Distribute fees to SBR stakers (DFIREStaking contract) and stability pool (StabilityPool contract)",
          "Mint SBD tokens to the contract (StableBaseCDP)",
          "Potentially burn SBD tokens from the contract if refunding the borrower",
          "Update DFIREStaking contract's reward state",
          "Update StabilityPool contract's reward state"
        ]
      },
      {
        "category": "Queue Management",
        "state_update_descriptions": [
          "Update weight in the safe's storage",
          "Update the safe's position in the liquidation queue (safesOrderedForLiquidation)",
          "Update the safe's position in the redemption queue (safesOrderedForRedemption)"
        ]
      },
      {
        "category": "Accounting",
        "state_update_descriptions": [
          "Update liquidationSnapshots[_safeId] if necessary",
          "Update cumulativeDebtPerUnitCollateral if liquidationSnapshots[_safeId] is updated",
          "Update cumulativeCollateralPerUnitCollateral if liquidationSnapshots[_safeId] is updated",
          "Update totalCollateral if cumulativeCollateralPerUnitCollateral is updated"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Core",
        "rule_descriptions": [
          "safe.borrowedAmount should be increased by amount",
          "safe.totalBorrowedAmount should be increased by amount",
          "totalDebt should be increased by amount",
          "The borrower (msg.sender) SBD balance should reflect the borrowed amount"
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "safe.feePaid should reflect the shielding fee",
          "DFIREStaking contract should reflect the rewards distributed to it",
          "StabilityPool contract should reflect the rewards distributed to it",
          "If canRefund > 0, fee is refunded to borrower and _amountToBorrow increased by canRefund",
          "SBD balance of the StableBaseCDP contract should reflect minting and burning during fee distribution and refund"
        ]
      },
      {
        "category": "Queue Management",
        "rule_descriptions": [
          "safe.weight should be updated correctly based on shieldingRate and existing borrowers",
          "The liquidation queue (safesOrderedForLiquidation) should be updated with the new ratio for the safe",
          "The redemption queue (safesOrderedForRedemption) should be updated with the new weight for the safe"
        ]
      },
      {
        "category": "Accounting",
        "rule_descriptions": [
          "liquidationSnapshots[_safeId] should be updated if necessary",
          "cumulativeDebtPerUnitCollateral should be updated if liquidationSnapshots[_safeId] is updated",
          "cumulativeCollateralPerUnitCollateral should be updated if liquidationSnapshots[_safeId] is updated",
          "totalCollateral should be updated if cumulativeCollateralPerUnitCollateral is updated"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt amount associated with a specific safe.",
            "why_is_is_important": "Reflects the accurate debt of the safe and is crucial for calculating liquidation ratios and overall system solvency, ensuring proper risk management.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, indicating a change in the debt-to-collateral ratio.",
            "how_to_validate_state_update": "_safe.borrowedAmount should increase by debtIncrease, which is calculated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of the safe by adding debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the historical total debt amount associated with a specific safe.",
            "why_is_is_important": "Reflects the total debt borrowed over time, useful for historical analysis and auditing of safe activity.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, signifying a change in the debt-to-collateral ratio.",
            "how_to_validate_state_update": "_safe.totalBorrowedAmount should increase by debtIncrease, which is calculated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of the safe by adding debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Debt per collateral snapshot.",
            "why_is_is_important": "The debt per collateral snapshot is updated to maintain an accurate record of the debt-to-collateral ratio at different points in time. This is essential for accurately calculating cumulative debt increases and ensuring fair liquidation processes.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, indicating that a rebalancing is needed.",
            "how_to_validate_state_update": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt per collateral snapshot of the liquidation snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount associated with a specific safe.",
            "why_is_is_important": "Reflects the accurate collateral amount of the safe and is crucial for calculating liquidation ratios and overall system solvency.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, reflecting changes in collateral.",
            "how_to_validate_state_update": "_safe.collateralAmount should increase by collateralIncrease, which is calculated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of the safe by adding collateralIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Collateral per collateral snapshot.",
            "why_is_is_important": "The collateral per collateral snapshot is updated to maintain an accurate record of the debt-to-collateral ratio at different points in time. This is essential for accurately calculating cumulative collateral increases and ensuring fair liquidation processes.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, adjustment required.",
            "how_to_validate_state_update": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot should be equal to cumulativeCollateralPerUnitCollateral",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral per collateral snapshot of the liquidation snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system.",
            "why_is_is_important": "Reflects the overall health and solvency of the protocol. Used in various calculations such as calculating liquidation ratios.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral, impacting the overall collateral pool.",
            "how_to_validate_state_update": "totalCollateral should increase by collateralIncrease, which is calculated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral by adding collateralIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "revert",
            "type": "require",
            "what_does_it_track": "Check the amount is sufficient to pay the fee.",
            "why_is_is_important": "Prevents borrowing if the amount is insufficient to cover the shielding fee, maintaining protocol integrity.",
            "when_is_it_updated": "If the amount is less than the shielding fee, thus invalidating the transaction.",
            "how_to_validate_state_update": "The transaction will revert if borrowed amount is not sufficient to pay the fee",
            "has_conditional_updates": true,
            "summary_of_update": "If the amount is less than the shielding fee, the transaction will revert.",
            "conditions": [
              "amount < _shieldingFee"
            ]
          },
          {
            "state_variable_name": "safes[safeId]",
            "type": "uint256",
            "what_does_it_track": "Safe's borrow information",
            "why_is_is_important": "Records how much has been borrowed, total borrowed, and the fees paid for a specific safe, essential for accurate accounting and risk assessment.",
            "when_is_it_updated": "If the owner of safeId is the message sender, the borrow information will be updated",
            "how_to_validate_state_update": "safe.borrowedAmount should increase by amount. safe.totalBorrowedAmount should increase by amount. safe.feePaid should increase by _shieldingFee",
            "has_conditional_updates": true,
            "summary_of_update": "Update safe attributes such as borrowedAmount, totalBorrowedAmount and feePaid",
            "conditions": [
              "ownerOf(safeId) == msg.sender"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "Borrowing weight",
            "why_is_is_important": "Records the weight used to calculate fees, important for fee distribution and protocol incentives.",
            "when_is_it_updated": "If it is the first time borrowing and there are no existing borrowings, the weight is set to the shielding rate.",
            "how_to_validate_state_update": "safe.weight should be equal to shieldingRate",
            "has_conditional_updates": true,
            "summary_of_update": "Update weight in safe",
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "Borrowing weight",
            "why_is_is_important": "Records the weight used to calculate fees, important for fee distribution and protocol incentives.",
            "when_is_it_updated": "If it is the first time borrowing and there are existing borrowings, the weight is adjusted based on the minimum existing fee weight.",
            "how_to_validate_state_update": "safe.weight should be equal to _minFeeWeight + shieldingRate",
            "has_conditional_updates": true,
            "summary_of_update": "Update weight in safe",
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode != 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "Borrowing weight",
            "why_is_is_important": "Records the weight used to calculate fees, important for fee distribution and protocol incentives.",
            "when_is_it_updated": "If it is not the first time borrowing and the shielding rate is greater than 0, the weight is updated based on the shielding rate and existing fee weight.",
            "how_to_validate_state_update": "safe.weight should be equal to _minFeeWeight + newFeeWeight, newFeeWeight is calculated with the formula newFeeWeight = ((_shieldingFee + weightedDiff) * BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount)",
            "has_conditional_updates": true,
            "summary_of_update": "Update weight in safe",
            "conditions": [
              "safe.borrowedAmount != 0",
              "shieldingRate > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "struct",
            "what_does_it_track": "Tracks the order of safes for redemption.",
            "why_is_is_important": "Maintains the correct order for fair redemption and liquidation processes, crucial for protocol stability and user trust.",
            "when_is_it_updated": "Always, to maintain the order of safes for redemption based on their weight.",
            "how_to_validate_state_update": "Nodes in safesOrderedForRedemption should be updated based on upsert function, reflecting the new weight of the safe",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the linked list nodes in the redemption and liquidation queues.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "struct",
            "what_does_it_track": "Tracks the order of safes for liquidation.",
            "why_is_is_important": "Maintains the correct order for fair redemption and liquidation processes, crucial for protocol stability and user trust.",
            "when_is_it_updated": "Always, to maintain the order of safes for liquidation based on their collateralization ratio.",
            "how_to_validate_state_update": "Nodes in safesOrderedForLiquidation should be updated based on upsert function, reflecting the new collateralization ratio of the safe",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the linked list nodes in the redemption and liquidation queues.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of the borrower.",
            "why_is_is_important": "Increases the borrower's SBD token balance, representing the borrowed amount, enabling them to use the borrowed funds.",
            "when_is_it_updated": "Always, as the borrower receives the borrowed amount in SBD tokens.",
            "how_to_validate_state_update": "Balance of msg.sender should increase by amountToBorrow",
            "has_conditional_updates": false,
            "summary_of_update": "Mints SBD tokens to the borrower.",
            "conditions": []
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Total supply of SBD token",
            "why_is_is_important": "Reflects the newly minted tokens and contributes to the overall SBD supply, important for tracking the total circulating supply.",
            "when_is_it_updated": "Always, whenever new SBD tokens are minted.",
            "how_to_validate_state_update": "totalSupply should increase by amount",
            "has_conditional_updates": false,
            "summary_of_update": "Mint SBD tokens to this contract",
            "conditions": []
          },
          {
            "state_variable_name": "balanceOf(address(this))",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of the contract.",
            "why_is_is_important": "Adjusts the contract's SBD balance when a fee refund occurs, ensuring accurate accounting of fees within the protocol.",
            "when_is_it_updated": "If canRefund is greater than 0, indicating a portion of the fee is being refunded.",
            "how_to_validate_state_update": "The balance of the contract must be reduced by canRefund",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens to the contract.",
            "conditions": [
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(address(this))",
            "type": "uint256",
            "what_does_it_track": "Reward token balance of DFIREStaking contract.",
            "why_is_is_important": "If staking pool can receive reward, the sbrStakersFee will be added to staking pool reward, incentivizing participation in the staking pool.",
            "when_is_it_updated": "If the sbrStakersFee is greater than 0 and if there are total stake, DFIREStaking receives the reward.",
            "how_to_validate_state_update": "rewardToken balance of DFIREStaking contract should increase by sbrStakersFee",
            "has_conditional_updates": true,
            "summary_of_update": "Reward token transferred from msg.sender to DFIREStaking contract.",
            "conditions": [
              "sbrStakersFee > 0",
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(address(this))",
            "type": "uint256",
            "what_does_it_track": "Staking token balance of StabilityPool contract.",
            "why_is_is_important": "If stability pool can receive reward, the stabilityPoolFee will be added to stability pool reward, incentivizing providing stability.",
            "when_is_it_updated": "If the stabilityPoolFee is greater than 0 and there is total staked raw, StabilityPool receives the fee.",
            "how_to_validate_state_update": "stakingToken balance of StabilityPool contract should increase by stabilityPoolFee",
            "has_conditional_updates": true,
            "summary_of_update": "Staking token transferred from msg.sender to StabilityPool contract.",
            "conditions": [
              "stabilityPoolFee > 0",
              "totalStakedRaw > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Protocol mode",
            "why_is_is_important": "Updates the protocol mode which allows the protocol to change its behavior and rules.",
            "when_is_it_updated": "If debt exceeds the bootstrap threshold while the protocol is in bootstrap mode, it switches to normal mode.",
            "how_to_validate_state_update": "PROTOCOL_MODE should be NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "Change protocol mode from bootstrap to normal",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt",
            "why_is_is_important": "Reflects the debt in the protocol and reflects the overall health of the CDP.",
            "when_is_it_updated": "Always, representing the sum of all outstanding debt in the system.",
            "how_to_validate_state_update": "totalDebt should increase by amount",
            "has_conditional_updates": false,
            "summary_of_update": "Update total debt",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}