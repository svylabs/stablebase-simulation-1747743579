{
  "action": {
    "name": "Borrow",
    "summary": "Borrows debt against collateral in a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` should correspond to an existing safe owned by the caller.",
      "The `amount` should be a non-zero value representing the amount of debt to borrow.",
      "The `amount` should be set such that `safe.borrowedAmount + amount >= MINIMUM_DEBT`.",
      "The `amount` should be set such that `safe.borrowedAmount + amount <= maxBorrowAmount`, where `maxBorrowAmount = ((safe.collateralAmount * price * BASIS_POINTS_DIVISOR) / liquidationRatio) / PRECISION`.",
      "The `shieldingRate` should be a percentage between 0 and 10000 (inclusive), representing the shielding fee.",
      "The `nearestSpotInLiquidationQueue` can be set to 0, or an existing `safeId` in the liquidation queue.",
      "The `nearestSpotInRedemptionQueue` can be set to 0, or an existing `safeId` in the redemption queue.",
      "The caller must be the owner of the safe with the given `safeId`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the borrowed amount of the safe (`safes[safeId].borrowedAmount += amount`).",
          "Updates the total borrowed amount of the safe (`safes[safeId].totalBorrowedAmount += amount`).",
          "Updates the fee paid by the safe (`safes[safeId].feePaid += _shieldingFee`).",
          "Updates the weight of the safe based on shieldingRate and existing borrowings. The weight determines the position in the redemption queue.",
          "Updates the safe's position in the liquidation queue based on the ratio of borrowed amount per unit collateral."
        ]
      },
      {
        "category": "Global State",
        "state_update_descriptions": [
          "Updates the total debt of the protocol (`totalDebt += amount`).",
          "Distributes fees to SBR stakers and the stability pool.",
          "Mints SBD tokens to the borrower and potentially this contract.",
          "Burns refunded fees from this contract if applicable."
        ]
      },
      {
        "category": "Doubly Linked List State",
        "state_update_descriptions": [
          "Updates the safe's position in the redemption queue (`safesOrderedForRedemption.upsert`).",
          "Updates the safe's position in the liquidation queue (`safesOrderedForLiquidation.upsert`)."
        ]
      },
      {
        "category": "Liquidation Snapshot State",
        "state_update_descriptions": [
          "Updates the safe's collateral and borrowed amount based on cumulative collateral and debt per unit collateral, using liquidation snapshots (if applicable)."
        ]
      },
      {
        "category": "Token State",
        "state_update_descriptions": [
          "Mints SBD tokens to the borrower (`sbdToken.mint(msg.sender, _amountToBorrow)`).",
          "Potentially mints SBD tokens to the contract (if shieldingFee > 0)",
          "Potentially burns SBD tokens from the contract (if canRefund > 0, indicating a fee refund)"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "The `safes[safeId].borrowedAmount` should be greater than or equal to the amount borrowed before, plus the new amount.",
          "The `safes[safeId].totalBorrowedAmount` should be greater than or equal to the total borrowed amount before, plus the new amount.",
          "The `safes[safeId].feePaid` should be greater than or equal to the amount before, plus the shielding fee.",
          "The borrower's address should still be the owner of the safe (`ownerOf(safeId) == msg.sender`).",
          "The final `safe.borrowedAmount` should be greater than or equal to `MINIMUM_DEBT`."
        ]
      },
      {
        "category": "Global State",
        "rule_descriptions": [
          "The total debt of the protocol (`totalDebt`) should be greater than or equal to the total debt before, plus the borrowed amount.",
          "The borrower's SBD token balance should increase by the borrowed amount (minus shielding fee, plus any fee refund)"
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `Borrowed` event should be emitted, containing the `safeId`, `amount`, `weight`, `totalCollateral`, `totalDebt`, `nearestSpotInRedemptionQueue` and `nearestSpotInLiquidationQueue`.",
          "A `FeeDistributed` event should be emitted, containing `safeId`, `feePaid`, `mint`, `sbrStakersFee`, `stabilityPoolFee`, and `canRefund`.",
          "If there is a fee refund, a `FeeRefund` event should be emitted.",
          "A `SafeUpdated` event should be emitted if the safe's collateral or debt was updated based on cumulative values.",
          "A `RedemptionQueueUpdated` should be emitted.",
          "A `LiquidationQueueUpdated` should be emitted."
        ]
      },
      {
        "category": "External Contract Interactions",
        "rule_descriptions": [
          "The `sbdToken.mint` function should be called with the borrower's address and the net borrowed amount (amount - shieldingFee + canRefund).",
          "The `dfireTokenStaking.addReward` function should be called if `sbrStakersFee > 0`.",
          "The `stabilityPool.addReward` function should be called.",
          "The `sbdToken.burn` should be called with the contract's address and the refund amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The debt associated with a specific safe.",
            "why_is_is_important": "Ensures that the borrowed amount is up-to-date with the current cumulative debt, affecting liquidation thresholds and overall risk assessment of the safe.",
            "when_is_it_updated": "When the cumulative debt per unit of collateral has changed since the last liquidation snapshot.",
            "how_to_validate_state_update": "Compare the difference between cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot, multiply it by safe.collateralAmount, and divide by PRECISION. Ensure this value is added to safe.borrowedAmount and safe.totalBorrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a specific safe by accounting for changes in cumulative debt.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The aggregate debt across all safes.",
            "why_is_is_important": "Reflects the overall risk and solvency of the protocol, crucial for stability and governance decisions.",
            "when_is_it_updated": "When the cumulative debt per unit of collateral changes and a safe's debt is updated.",
            "how_to_validate_state_update": "Verify that the increase in debt calculated in the previous step is also added to the totalDebt state variable.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total outstanding debt in the system.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral backing a specific safe.",
            "why_is_is_important": "Impacts the safe's liquidation threshold and overall health; crucial for maintaining the collateralization ratio.",
            "when_is_it_updated": "When the cumulative collateral per unit of collateral changes since the last snapshot.",
            "how_to_validate_state_update": "Compare the difference between cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot, multiply it by safe.collateralAmount and divide by PRECISION. Check that the result is added to safe.collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of a specific safe to reflect changes in cumulative collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The aggregate collateral backing all outstanding debt.",
            "why_is_is_important": "Reflects the protocol's solvency and capacity to absorb liquidations, essential for overall stability.",
            "when_is_it_updated": "When cumulative collateral changes and a safe's collateral is updated.",
            "how_to_validate_state_update": "Verify that the collateral increase calculated in the previous step is added to the totalCollateral state variable.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral held by the protocol.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "A fee weight associated with the safe, influencing redemption order.",
            "why_is_is_important": "Establishes a base weight for fee calculation and redemption prioritization.",
            "when_is_it_updated": "When a safe borrows for the first time and there are no existing borrowings.",
            "how_to_validate_state_update": "Check that safe.weight is equal to shieldingRate.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the initial weight for a safe if it's the first time borrowing and no other borrowings exist.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "A fee weight adjusted for existing borrowings.",
            "why_is_is_important": "Ensures fairness for new borrowers by relating their fee to the minimum rate paid by existing borrowers.",
            "when_is_it_updated": "When a safe borrows for the first time and other borrowings exist.",
            "how_to_validate_state_update": "Check that safe.weight is equal to the minimum fee weight plus the shielding rate",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the initial weight for a safe based on the minimum existing fee weight.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode != 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "A fee weight that determines redemption priority.",
            "why_is_is_important": "Maintains a fair distribution of fees and redemption priority among borrowers.",
            "when_is_it_updated": "When a safe borrows additional debt and has an existing borrowed amount.",
            "how_to_validate_state_update": "Validate that the new fee weight is calculated correctly based on the formula provided and that `safe.weight` is updated accordingly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the weight of a safe based on its borrowed amount and shielding rate.",
            "conditions": [
              "safe.borrowedAmount != 0",
              "shieldingRate > 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The outstanding debt for a particular safe.",
            "why_is_is_important": "Crucial for tracking individual debt levels, impacting liquidation risks and overall system solvency.",
            "when_is_it_updated": "Every time a safe borrows additional debt.",
            "how_to_validate_state_update": "Ensure that `safe.borrowedAmount` increases by the input `amount`",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the borrowed amount for a given safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt borrowed by a safe over time.",
            "why_is_is_important": "Tracks the total debt accrued, potentially used for historical analysis or reward calculations.",
            "when_is_it_updated": "Every time a safe borrows additional debt.",
            "how_to_validate_state_update": "Ensure that `safe.totalBorrowedAmount` increases by the input `amount`",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total borrowed amount for a given safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "Cumulative fees paid by a safe.",
            "why_is_is_important": "Tracks revenue generated from each safe, useful for protocol accounting and incentive design.",
            "when_is_it_updated": "Each time a safe borrows, the shielding fee is added.",
            "how_to_validate_state_update": "Ensure that `safe.feePaid` increases by `_shieldingFee`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total fees paid by a safe.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The operational mode of the protocol.",
            "why_is_is_important": "Governs protocol behavior, potentially affecting parameters and risk management strategies.",
            "when_is_it_updated": "When total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD while in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Verify that PROTOCOL_MODE is set to NORMAL when the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the protocol from BOOTSTRAP to NORMAL mode when debt exceeds a threshold.",
            "conditions": [
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "address",
            "what_does_it_track": "It tracks a list of safes ordered based on weight",
            "why_is_is_important": "It is important to determine the order in which safes are redeemed",
            "when_is_it_updated": "When a safe borrows",
            "how_to_validate_state_update": "Check that the Linked List is updated based on the parameters safeId, safe.weight and nearestSpotInRedemptionQueue",
            "has_conditional_updates": false,
            "summary_of_update": "The doubly linked list for redemption queue is updated",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "It tracks a list of safes ordered based on borrowAmount per unit collateral",
            "why_is_is_important": "It is important to determine the order in which safes are liquidated",
            "when_is_it_updated": "When a safe borrows",
            "how_to_validate_state_update": "Check that the Linked List is updated based on the parameters safeId, ratio and nearestSpotInLiquidationQueue",
            "has_conditional_updates": false,
            "summary_of_update": "The doubly linked list for liquidation queue is updated",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "sbdToken",
            "type": "IMintableToken",
            "what_does_it_track": "The SBD token contract.",
            "why_is_is_important": "Ensures the contract has sufficient tokens to distribute as rewards.",
            "when_is_it_updated": "When the shielding fee is greater than zero.",
            "how_to_validate_state_update": "Verify that the contract's balance increases by the shielding fee amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBD tokens to the contract for fee distribution.",
            "conditions": [
              "_shieldingFee > 0"
            ]
          },
          {
            "state_variable_name": "sbdToken",
            "type": "IMintableToken",
            "what_does_it_track": "The SBD token contract.",
            "why_is_is_important": "Provides the borrower with the borrowed SBD tokens.",
            "when_is_it_updated": "Each time a safe borrows.",
            "how_to_validate_state_update": "Verify that the msg.sender's balance increases by `_amountToBorrow`.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints SBD tokens to the borrower.",
            "conditions": []
          },
          {
            "state_variable_name": "sbdToken",
            "type": "IMintableToken",
            "what_does_it_track": "The SBD token contract.",
            "why_is_is_important": "Reduces the contract's SBD balance by the refunded amount.",
            "when_is_it_updated": "When a refund is available after fee distribution.",
            "how_to_validate_state_update": "Verify that the contract's balance decreases by the amount refunded.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens from the contract when a refund is available.",
            "conditions": [
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the reward that each staker will earn",
            "why_is_is_important": "It represents amount of reward tokens each staked token will earn",
            "when_is_it_updated": "When fees are distributed and staking contract addReward returns true",
            "how_to_validate_state_update": "Check that totalRewardPerToken increases by `(_amount * PRECISION) / _totalStake`",
            "has_conditional_updates": true,
            "summary_of_update": "Reward is added to DFIREStaking contract",
            "conditions": [
              "_shieldingFee > 0",
              "dfireTokenStaking.addReward(sbrStakersFee) == true"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks rewards that each staker will earn",
            "why_is_is_important": "It represents amount of reward tokens each staked token will earn",
            "when_is_it_updated": "When fees are distributed and addReward returns true",
            "how_to_validate_state_update": "totalRewardPerToken += _rewardPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "Rewards are added to the stability pool contract",
            "conditions": [
              "_shieldingFee > 0",
              "stabilityPool.addReward(stabilityPoolFee) == true"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function borrow(\n        uint256 safeId,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n\n        // Fetch the price of the collateral from the oracle\n        uint256 price = priceOracle.fetchPrice();\n\n        // Calculate the maximum borrowable amount\n        uint256 maxBorrowAmount = ((\n            (safe.collateralAmount * price * BASIS_POINTS_DIVISOR)\n        ) / liquidationRatio) / PRECISION;\n\n        // Check if the requested amount is within the maximum borrowable limits\n        require(\n            safe.borrowedAmount + amount <= maxBorrowAmount,\n            \"Borrow amount exceeds the limit\"\n        );\n        require(\n            safe.borrowedAmount + amount >= MINIMUM_DEBT,\n            \"Invalid borrow amount\"\n        );\n\n        handleBorrow(\n            safeId,\n            safe,\n            amount,\n            shieldingRate,\n            nearestSpotInLiquidationQueue,\n            nearestSpotInRedemptionQueue\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction handleBorrow(\n        uint256 safeId,\n        Safe storage safe,\n        uint256 amount,\n        uint256 shieldingRate,\n        uint256 nearestSpotInLiquidationQueue,\n        uint256 nearestSpotInRedemptionQueue\n    ) internal {\n        // Safe storage currentSafe = safes[_safeId];\n        require(\n            ownerOf(safeId) == msg.sender,\n            \"Only the Safe owner can borrow\"\n        );\n        uint256 _shieldingFee = (amount * shieldingRate) / BASIS_POINTS_DIVISOR;\n        uint256 _minFeeWeightNode = safesOrderedForRedemption.getHead();\n        // Is first time borrowing\n        if (safe.borrowedAmount == 0) {\n            if (_minFeeWeightNode == 0) {\n                // There are no existing borrowings, so the fee is the minimum rate\n                safe.weight = shieldingRate;\n            } else {\n                uint256 _minFeeWeight = safesOrderedForRedemption\n                    .get(_minFeeWeightNode)\n                    .value;\n                // Adjust the fee percentage based on the minimum value, so the new borrowers don't start from the beginning.\n                // This is to keep it fair for new borrowers, and is only an accounting trick.\n                // Fee for new borrowers is in relation to the minimum rate paid by the existing borrowers\n                safe.weight = _minFeeWeight + shieldingRate;\n            }\n        } else {\n            uint256 _minFeeWeight = safesOrderedForRedemption\n                .get(_minFeeWeightNode)\n                .value;\n            // ShieldingRate is always in relation to the minimum rate paid by the existing borrowers\n            uint256 diff = safe.weight - _minFeeWeight;\n            uint256 weightedDiff = (diff * safe.borrowedAmount) /\n                BASIS_POINTS_DIVISOR;\n\n            uint256 newFeeWeight = ((_shieldingFee + weightedDiff) *\n                BASIS_POINTS_DIVISOR) / (safe.borrowedAmount + amount);\n\n            // No need to charge the already borrowed amount as it has already been charged, just update the relative rate.\n            if (shieldingRate > 0) {\n                safe.weight = _minFeeWeight + newFeeWeight;\n            }\n        }\n        if (amount < _shieldingFee) {\n            revert(\"Borrowed amount is not sufficient to pay the fee\");\n        }\n        uint _amountToBorrow = amount - _shieldingFee;\n        safe.borrowedAmount += amount;\n        safe.totalBorrowedAmount += amount;\n        safe.feePaid += _shieldingFee;\n\n        // Calculate the ratio (borrowAmount per unit collateral)\n        uint256 ratio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n\n        IDoublyLinkedList.Node memory redemptionNode = safesOrderedForRedemption\n            .upsert(safeId, safe.weight, nearestSpotInRedemptionQueue);\n\n        IDoublyLinkedList.Node\n            memory liquidationNode = safesOrderedForLiquidation.upsert(\n                safeId,\n                ratio,\n                nearestSpotInLiquidationQueue\n            );\n\n        uint256 feePaid;\n        uint256 canRefund;\n        if (_shieldingFee > 0) {\n            (feePaid, canRefund) = distributeFees(safeId, _shieldingFee, true);\n        }\n        if (canRefund > 0) {\n            _amountToBorrow += canRefund;\n            emit FeeRefund(safeId, canRefund);\n        }\n        // Mint SBD tokens to the borrower\n        require(sbdToken.mint(msg.sender, _amountToBorrow), \"Mint failed\");\n        _updateTotalDebt(totalDebt, amount, true);\n        // Emit the Borrow event\n        emit Borrowed(\n            safeId,\n            amount,\n            safe.weight,\n            totalCollateral,\n            totalDebt,\n            redemptionNode.prev,\n            liquidationNode.prev\n        );\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction get(uint256 id) external view override returns (Node memory) {\n        return nodes[id];\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}