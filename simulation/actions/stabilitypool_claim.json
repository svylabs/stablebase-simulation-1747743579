{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "The user must have a stake greater than 0 in the StabilityPool to claim rewards.",
      "If a frontend address and fee are provided: The frontend address must be a valid Ethereum address and the fee must be a valid percentage, i.e., between 0 and 10000 (BASIS_POINTS_DIVISOR).",
      "If no frontend address or fee are provided, the default values are used (no fee charged)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Rewards",
        "state_update_descriptions": [
          "The user's reward snapshot is updated to the current totalRewardPerToken.",
          "The user's collateral snapshot is updated to the current totalCollateralPerToken.",
          "Pending staking token rewards are transferred to the user, after frontend fee deduction, if any rewards are pending.",
          "Pending collateral rewards (ETH) are transferred to the user, after frontend fee deduction, if any collateral is pending.",
          "Pending SBR rewards are minted for the user, after frontend fee deduction, if any SBR rewards are pending."
        ]
      },
      {
        "category": "SBR Rewards Distribution",
        "state_update_descriptions": [
          "If the SBR reward distribution is in NOT_STARTED state, its status is updated to STARTED, lastSBRRewardDistributedTime is set to the current block timestamp, and sbrRewardDistributionEndTime is set to 365 days from the current block timestamp.",
          "If the SBR reward distribution is in STARTED state, new SBR rewards are calculated based on the time elapsed since the last distribution and the distribution rate; these rewards are added to the totalSbrRewardPerToken.",
          "If the SBR reward distribution is in STARTED state, the sbrRewardDistributionStatus may be updated to ENDED if block.timestamp exceeds sbrRewardDistributionEndTime."
        ]
      },
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "The user's cumulativeProductScalingFactor is updated to the current stakeScalingFactor.",
          "The user's stakeResetCount is updated to the current stakeResetCount.",
          "The user's effective stake is recalculated and updated."
        ]
      },
      {
        "category": "Frontend Fees",
        "state_update_descriptions": [
          "Fees (staking rewards, collateral, and SBR rewards) are transferred to the specified frontend address if a frontend address and fee are provided and the calculated fees are greater than zero."
        ]
      },
      {
        "category": "SBR Reward Snapshot",
        "state_update_descriptions": [
          "If sbrRewardDistributionStatus is not ENDED, sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to totalSbrRewardPerToken.",
          "If sbrRewardDistributionStatus is ENDED, sbrRewardSnapshots[msg.sender].status is updated to CLAIMED."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Rewards",
        "rule_descriptions": [
          "The user's rewardSnapshot should be equal to the totalRewardPerToken after the claim.",
          "The user's collateralSnapshot should be equal to the totalCollateralPerToken after the claim."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "If pendingReward > 0, the user's staking token balance should increase by (pendingReward - rewardFee), and the frontend's staking token balance should increase by rewardFee.",
          "If pendingCollateral > 0,  the user's ETH balance should increase by (pendingCollateral - collateralFee), and the frontend's ETH balance should increase by collateralFee.",
          "If pendingSbrRewards > 0, the user's DFIRE token balance should increase by (pendingSbrRewards - sbrFee), and the frontend's DFIRE token balance should increase by sbrFee."
        ]
      },
      {
        "category": "SBR Rewards",
        "rule_descriptions": [
          "If sbrRewardDistributionStatus is ENDED, then sbrRewardSnapshots[msg.sender].status should be equal to CLAIMED."
        ]
      },
      {
        "category": "Stake",
        "rule_descriptions": [
          "The user's stake should be updated according to the current stake scaling factor.  Specifically, user.stake should reflect the current effective stake as calculated by _getUserEffectiveStake(user)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate the amount of SBR rewards to distribute over time, ensuring accurate reward distribution based on time elapsed since the last distribution and also the reward distribution endtime is updated.",
            "when_is_it_updated": "Updated when the SBR reward distribution status is not ended.",
            "how_to_validate_state_update": "Check if lastSBRRewardDistributedTime is updated to block.timestamp and sbrRewardDistributionEndTime is updated to block.timestamp + 365 days if the distribution status is NOT_STARTED. If the distribution status is STARTED, verify that totalSbrRewardPerToken is updated based on the time elapsed since the last distribution and the distribution rate.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time SBR rewards were distributed. Can also update sbrRewardDistributionEndTime, totalSbrRewardPerToken and sbrRewardLoss",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots",
            "type": "mapping(address => struct)",
            "what_does_it_track": "Tracks the SBR reward snapshots for each user.",
            "why_is_is_important": "Used to calculate the pending SBR rewards for the user when claiming rewards.",
            "when_is_it_updated": "Updated when the SBR reward distribution status is not ended. If the SBR reward distribution has ended, the status is updated to CLAIMED.",
            "how_to_validate_state_update": "Check if sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to totalSbrRewardPerToken. If SBRRewardDistribution has ended, verify sbrRewardSnapshots[msg.sender].status is updated to CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the reward snapshot for the user to keep track of SBR rewards.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "users",
            "type": "mapping(address => struct)",
            "what_does_it_track": "Tracks user information, including stake, reward snapshot, and collateral snapshot.",
            "why_is_is_important": "Used to calculate the pending rewards and collateral for the user when claiming rewards.",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Verify that user.rewardSnapshot is updated to totalRewardPerToken and user.collateralSnapshot is updated to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the reward and collateral snapshots for the user.",
            "conditions": []
          },
          {
            "state_variable_name": "users",
            "type": "mapping(address => struct)",
            "what_does_it_track": "Tracks user information, including stake, reward snapshot, and collateral snapshot.",
            "why_is_is_important": "Used to calculate the pending rewards and collateral for the user when claiming rewards and the final stake",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Check if user.stake is updated based on _getUserEffectiveStake(user).",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts the user's stake based on scaling factors. Also updates scaling factor and reset count.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users",
            "type": "mapping(address => struct)",
            "what_does_it_track": "Tracks user information, including stake, reward snapshot, and collateral snapshot.",
            "why_is_is_important": "Used to calculate the pending rewards and collateral for the user when claiming rewards and the final stake",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Verify that user.cumulativeProductScalingFactor is updated to stakeScalingFactor and user.stakeResetCount is updated to stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's scaling factor and stake reset count.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward distribution.",
            "why_is_is_important": "Determines whether SBR rewards are still being distributed and allows correct calculations.",
            "when_is_it_updated": "Updated when the SBR reward distribution period has ended.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is updated to ENDED if the current block timestamp is greater than sbrRewardDistributionEndTime.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status if the distribution period has ended.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total SBR reward per token.",
            "why_is_is_important": "Used to calculate the SBR rewards for each user based on their stake.",
            "when_is_it_updated": "Updated when SBR rewards are being distributed and there are tokens staked.",
            "how_to_validate_state_update": "Verify that totalSbrRewardPerToken is updated based on the calculated reward and that sbrRewardLoss is adjusted to account for any rounding errors.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total SBR reward per token.",
            "conditions": [
              "totalStakedRaw > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the loss in SBR rewards due to rounding errors.",
            "why_is_is_important": "Ensures that all SBR rewards are accounted for, even with rounding errors.",
            "when_is_it_updated": "Updated when SBR rewards are being distributed and there are tokens staked.",
            "how_to_validate_state_update": "Check if sbrRewardLoss is updated by the calculation that handles rounding errors.",
            "has_conditional_updates": true,
            "summary_of_update": "Keeps track of any loss in SBR rewards due to rounding errors.",
            "conditions": [
              "totalStakedRaw > 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Tracks the token balances of each user.",
            "why_is_is_important": "Ensures that users receive their earned rewards.",
            "when_is_it_updated": "Updated when a user claims rewards and has pending rewards.",
            "how_to_validate_state_update": "Verify that the stakingToken.transfer function is called to transfer pendingReward - rewardFee to msg.sender.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward tokens to the user.",
            "conditions": [
              "pendingReward != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBR tokens.",
            "why_is_is_important": "Increases the supply of SBR tokens to distribute rewards to users.",
            "when_is_it_updated": "Updated when a user claims rewards and has pending SBR rewards.",
            "how_to_validate_state_update": "Verify that the sbrToken.mint function is called to mint pendingSbrRewards - sbrFee to msg.sender.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to the user.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Tracks the token balances of each user.",
            "why_is_is_important": "Ensure that users receive their earned SBR rewards.",
            "when_is_it_updated": "Updated when a user claims rewards and has pending SBR rewards.",
            "how_to_validate_state_update": "Verify that the sbrToken.mint function is called to mint pendingSbrRewards - sbrFee to msg.sender.",
            "has_conditional_updates": true,
            "summary_of_update": "Update the balance of SBR tokens for the user and frontend.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}