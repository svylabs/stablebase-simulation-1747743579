{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "User must have stake > 0 (users[msg.sender].stake > 0).",
      "No parameters for basic claim().",
      "Frontend address and fee for claim(address, uint256)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Reward and Collateral Claim",
        "state_update_descriptions": [
          "User's reward snapshot updated to totalRewardPerToken.",
          "User's collateral snapshot updated to totalCollateralPerToken.",
          "stakingToken transferred from StabilityPool to user (minus fee).",
          "ETH transferred from StabilityPool to user (minus fee).",
          "sbrToken minted and transferred to user (minus fee)."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "SBR rewards may be added if distribution is active.",
          "User's SBR reward snapshot updated or status set to CLAIMED."
        ]
      },
      {
        "category": "Stake Management",
        "state_update_descriptions": [
          "User's effective stake recalculated.",
          "User's cumulativeProductScalingFactor updated to stakeScalingFactor.",
          "User's stakeResetCount updated to stakeResetCount."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Reward and Collateral Balances",
        "rule_descriptions": [
          "stakingToken balance of user increased by claim amount (minus fee), validated with stakingToken.balanceOf(user).",
          "ETH balance of user increased by claim amount (minus fee).",
          "sbrToken balance of user increased by claim amount (minus fee), validated with sbrToken.balanceOf(user)."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "RewardClaimed event emitted with user, reward, rewardFee, collateral, collateralFee.",
          "DFireRewardClaimed event emitted (if SBR rewards claimed) with user, sbrReward, sbrRewardFee."
        ]
      },
      {
        "category": "Internal State Consistency",
        "rule_descriptions": [
          "users[msg.sender].rewardSnapshot == totalRewardPerToken.",
          "users[msg.sender].collateralSnapshot == totalCollateralPerToken.",
          "users[msg.sender].cumulativeProductScalingFactor == stakeScalingFactor.",
          "users[msg.sender].stakeResetCount == stakeResetCount.",
          "sbrRewardSnapshots[msg.sender].status == SBRRewardDistribution.CLAIMED (if applicable)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate the amount of SBR rewards to distribute over time. It is important for accurately distributing rewards and tracking progress of the distribution process across multiple claim calls from users. It affects reward calculations for all users.",
            "when_is_it_updated": "Updated when SBR reward distribution is active, a claim is made, and user has stake > 0.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime and sbrRewardDistributionEndTime. Ensure that sbrRewardDistributionStatus is STARTED. Then calculate sbrReward based on the formula: sbrReward = timeElapsed * sbrDistributionRate. Verify the totalSbrRewardPerToken update using: totalSbrRewardPerToken += ((_sbrReward * stakeScalingFactor * precision) / totalStakedRaw) / precision;. Also, confirm the sbrRewardLoss update with the formula: sbrRewardLoss = _sbrReward - ((_totalSbrRewardPerToken * totalStakedRaw * precision) / stakeScalingFactor) / precision.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the lastSBRRewardDistributedTime to the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of the SBR reward distribution.",
            "why_is_is_important": "Controls the flow of SBR reward distribution, determining whether rewards are still being distributed or if the distribution period has ended. It is important for the overall reward claiming calculation.",
            "when_is_it_updated": "Updated if the current status is not ENDED and the user has stake > 0.",
            "how_to_validate_state_update": "Check the value of block.timestamp and sbrRewardDistributionEndTime. Verify that sbrRewardDistributionStatus transitions to ENDED only when block.timestamp > sbrRewardDistributionEndTime.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the status of SBR reward distribution to ENDED if the current block timestamp exceeds the distribution end time, otherwise starts the distribution if it has not yet.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total SBR reward distributed per token.",
            "why_is_is_important": "Used to determine the amount of SBR rewards a user can claim. Changes to this variable directly impact user rewards and the overall economics of the protocol.",
            "when_is_it_updated": "Updated when SBR reward distribution is active, there is a non-zero total staked amount, and user has stake > 0.",
            "how_to_validate_state_update": "Check the value of timeElapsed (block.timestamp - lastSBRRewardDistributedTime), sbrDistributionRate, stakeScalingFactor, precision, totalStakedRaw, and sbrRewardLoss. Ensure that the update to totalSbrRewardPerToken is calculated as: totalSbrRewardPerToken += ((_sbrReward * stakeScalingFactor * precision) / totalStakedRaw) / precision, where _sbrReward = sbrReward + sbrRewardLoss.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the cumulative SBR reward per token, which affects how much SBR each user is entitled to. It increases based on time elapsed, distribution rate, and total staked amount.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "totalStakedRaw > 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of undistributed SBR rewards due to precision loss.",
            "why_is_is_important": "Ensures that any undistributed SBR rewards due to precision loss are accounted for and carried over to the next distribution, preventing loss of rewards over time.",
            "when_is_it_updated": "Updated when SBR reward distribution is active, there is a non-zero total staked amount, and user has stake > 0.",
            "how_to_validate_state_update": "Validate the prior values of _sbrReward and totalSbrRewardPerToken with totalStakedRaw and stakeScalingFactor. Ensure the update is as per sbrRewardLoss = _sbrReward - ((_totalSbrRewardPerToken * totalStakedRaw * precision) / stakeScalingFactor) / precision.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the amount of SBR reward that could not be distributed due to precision loss. Accumulates any remainder from SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "totalStakedRaw > 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed. Storing the latest time",
            "why_is_is_important": "Essential for timing the reward distribution precisely, ensuring accurate calculations throughout the entire process.",
            "when_is_it_updated": "Updated when SBR reward distribution has not yet started and user has stake > 0.",
            "how_to_validate_state_update": "Verify that lastSBRRewardDistributedTime is set to block.timestamp, sbrRewardDistributionEndTime is set to block.timestamp + 365 days, and sbrRewardDistributionStatus is set to STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the last SBR reward distributed time to the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the end time for SBR reward distribution.",
            "why_is_is_important": "Defines the period during which SBR rewards are distributed, ensuring clarity and reliability in the reward system.",
            "when_is_it_updated": "Updated when SBR reward distribution has not yet started and user has stake > 0.",
            "how_to_validate_state_update": "Check that the SBR reward end time is properly set to the current block timestamp plus 365 days.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the SBR reward distribution end time to the current block timestamp plus 365 days.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of the SBR reward distribution.",
            "why_is_is_important": "Signifies the commencement of SBR reward distribution, which is crucial for initializing and managing the rewards system effectively.",
            "when_is_it_updated": "Updated when SBR reward distribution has not yet started and user has stake > 0.",
            "how_to_validate_state_update": "Validate that the status transitions from NOT_STARTED to STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the SBR reward distribution status to STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "pendingReward",
            "type": "uint256",
            "what_does_it_track": "Tracks the pending reward for a user.",
            "why_is_is_important": "Crucial for calculating how much rewards user is entitled to. Determines the transfer amount from the contract to the user.",
            "when_is_it_updated": "Updated when user has some stake in pool and _claim function is called.",
            "how_to_validate_state_update": "Verify `pendingReward`, `pendingCollateral`, and `pendingSbrRewards` based on the formula in `userPendingRewardAndCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates pending reward, collateral, and SBR rewards for the user based on their stake and the reward/collateral/SBR reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "pendingCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the pending collateral for a user.",
            "why_is_is_important": "Crucial for calculating how much rewards user is entitled to. Determines the transfer amount from the contract to the user.",
            "when_is_it_updated": "Updated when user has some stake in pool and _claim function is called.",
            "how_to_validate_state_update": "Verify `pendingReward`, `pendingCollateral`, and `pendingSbrRewards` based on the formula in `userPendingRewardAndCollateral`. Check value transferred to user via stakingToken.transfer and collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates pending reward, collateral, and SBR rewards for the user based on their stake and the reward/collateral/SBR reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "pendingSbrRewards",
            "type": "uint256",
            "what_does_it_track": "Tracks the pending SBR rewards for a user.",
            "why_is_is_important": "Crucial for calculating how much rewards user is entitled to. Determines the transfer amount from the contract to the user.",
            "when_is_it_updated": "Updated when user has some stake in pool and _claim function is called.",
            "how_to_validate_state_update": "Verify `pendingReward`, `pendingCollateral`, and `pendingSbrRewards` based on the formula in `userPendingRewardAndCollateral`. Check value minted for the user.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates pending reward, collateral, and SBR rewards for the user based on their stake and the reward/collateral/SBR reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's reward snapshot.",
            "why_is_is_important": "This snapshot is used to calculate the user's pending rewards. It ensures that the user only receives rewards accumulated since their last claim or stake action.",
            "when_is_it_updated": "Updated in the `_updateRewards` function during the claim process.",
            "how_to_validate_state_update": "Check that `user.rewardSnapshot` is assigned the value of `totalRewardPerToken`. Verify that the user's reward snapshot is updated to the current total reward per token.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot to the current total reward per token.",
            "conditions": [
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's collateral snapshot.",
            "why_is_is_important": "This snapshot is used to calculate the user's pending collateral. It ensures that the user only receives collateral accumulated since their last claim or stake action.",
            "when_is_it_updated": "Updated in the `_updateRewards` function during the claim process.",
            "how_to_validate_state_update": "Check that `user.collateralSnapshot` is assigned the value of `totalCollateralPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot to the current total collateral per token.",
            "conditions": [
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's SBR reward snapshot.",
            "why_is_is_important": "This snapshot is used to calculate the user's pending SBR rewards. It ensures that the user only receives SBR rewards accumulated since their last claim or stake action.",
            "when_is_it_updated": "Updated in the `_updateRewards` function during the claim process, if the SBR reward distribution is not ended.",
            "how_to_validate_state_update": "Verify that `sbrRewardSnapshots[msg.sender].rewardSnapshot` is assigned the value of `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current total SBR reward per token.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks the user's SBR reward status.",
            "why_is_is_important": "Tracks that the user has already claimed their rewards",
            "when_is_it_updated": "Updated in the `_updateRewards` function during the claim process, if the SBR reward distribution is ended and the user has not claimed their rewards.",
            "how_to_validate_state_update": "Verify that `sbrRewardSnapshots[msg.sender].status` is updated to `SBRRewardDistribution.CLAIMED`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward status to CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's effective stake.",
            "why_is_is_important": "Keeps track of user's stake relative to the current scaling factor. Important for calculating future rewards.",
            "when_is_it_updated": "Updated in _updateUserStake after rewards and collateral are paid out.",
            "how_to_validate_state_update": "Calculate stake using _getUserEffectiveStake and compare it with user.stake after this update",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts user's stake based on stakeScalingFactor.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's cumulative product scaling factor.",
            "why_is_is_important": "Important for tracking stake changes. Required to calculate reward at the time of unstake or claim.",
            "when_is_it_updated": "Updated in _updateUserStake after rewards and collateral are paid out.",
            "how_to_validate_state_update": "Check that user.cumulativeProductScalingFactor is set to stakeScalingFactor",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulative product scaling factor.",
            "conditions": [
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's stake reset count.",
            "why_is_is_important": "Important for tracking stake resets. Required to calculate reward at the time of unstake or claim.",
            "when_is_it_updated": "Updated in _updateUserStake after rewards and collateral are paid out.",
            "how_to_validate_state_update": "Check that user.stakeResetCount is set to stakeResetCount",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stake reset count.",
            "conditions": [
              "user.stake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of staking tokens held by each address.",
            "why_is_is_important": "Reflects accurate token balance",
            "when_is_it_updated": "Updated when pendingReward > 0 in the _updateRewards function.",
            "how_to_validate_state_update": "Check that stakingToken.transfer is called with parameters msg.sender and pendingReward - rewardFee",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases contract balance and increase user balance",
            "conditions": [
              "pendingReward != 0",
              "user.stake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBR tokens.",
            "why_is_is_important": "Ensures the total supply reflects new tokens",
            "when_is_it_updated": "Updated when pendingSbrRewards > 0 in the _updateRewards function.",
            "how_to_validate_state_update": "Check that sbrToken.mint is called with parameters msg.sender and pendingSbrRewards - sbrFee",
            "has_conditional_updates": true,
            "summary_of_update": "Increases total supply of SBR tokens and updates user balance.",
            "conditions": [
              "pendingSbrRewards != 0",
              "user.stake > 0"
            ]
          },
          {
            "state_variable_name": "balanceOf",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of SBR tokens held by each address.",
            "why_is_is_important": "Reflects user's reward balance.",
            "when_is_it_updated": "Updated when pendingSbrRewards > 0 in the _updateRewards function.",
            "how_to_validate_state_update": "Check that sbrToken.mint is called with parameters msg.sender and pendingSbrRewards - sbrFee",
            "has_conditional_updates": true,
            "summary_of_update": "Increases user balance of SBR tokens.",
            "conditions": [
              "pendingSbrRewards != 0",
              "user.stake > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}