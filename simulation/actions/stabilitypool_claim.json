{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "No parameters are required for the basic `claim()` function.",
      "The `claim(address frontend, uint256 fee)` variant requires specifying a frontend address and fee amount.",
      "Frontend can be address(0) to indicate no frontend.",
      "Fee can be 0 to indicate no fee being charged."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Reward Updates",
        "state_update_descriptions": [
          "Updates the user's reward snapshot (user.rewardSnapshot) to the current totalRewardPerToken.",
          "Updates the user's collateral snapshot (user.collateralSnapshot) to the current totalCollateralPerToken.",
          "Updates the user's SBR reward snapshot (sbrRewardSnapshots[msg.sender].rewardSnapshot) to the current totalSbrRewardPerToken, if SBR reward distribution is not ended.",
          "Sets the user's SBR reward snapshot status (sbrRewardSnapshots[msg.sender].status) to CLAIMED if SBR reward distribution is ended and the status is not already CLAIMED.",
          "Transfers pending staking token rewards to the user (msg.sender).",
          "Transfers pending collateral rewards (ETH) to the user (msg.sender).",
          "Mints pending SBR rewards to the user (msg.sender)."
        ]
      },
      {
        "category": "Fee Updates",
        "state_update_descriptions": [
          "Calculates and transfers reward fees to the frontend address if a frontend address and fee are specified.",
          "Calculates and transfers collateral fees to the frontend address if a frontend address and fee are specified.",
          "Calculates and mints SBR reward fees to the frontend address if a frontend address and fee are specified."
        ]
      },
      {
        "category": "User Stake Updates",
        "state_update_descriptions": [
          "Adjusts the user's effective stake based on stakeScalingFactor.",
          "Updates the user's cumulativeProductScalingFactor to the current stakeScalingFactor.",
          "Updates the user's stakeResetCount to the current stakeResetCount."
        ]
      },
      {
        "category": "SBR Reward Distribution Updates",
        "state_update_descriptions": [
          "Potentially updates the lastSBRRewardDistributedTime to block.timestamp.",
          "Potentially updates the sbrRewardDistributionEndTime to block.timestamp + 365 days.",
          "Potentially updates the sbrRewardDistributionStatus to STARTED.",
          "Potentially updates the sbrRewardDistributionStatus to ENDED.",
          "Potentially updates totalSbrRewardPerToken.",
          "Potentially updates sbrRewardLoss."
        ]
      },
      {
        "category": "Event Emission",
        "state_update_descriptions": [
          "Emits a RewardClaimed event with information about the claimed rewards and fees.",
          "Emits a DFireRewardClaimed event with information about the claimed SBR rewards and fees, if SBR reward > 0.",
          "Emits SBRRewardsAdded event if applicable."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Reward Balance Validation",
        "rule_descriptions": [
          "The user's balance of the staking token (stakingToken) should increase by approximately the amount of pending rewards minus any fees.  Note that exact comparisons might fail due to rewardLoss/dust.",
          "The user's ETH balance should increase by approximately the amount of pending collateral minus any fees. Note that exact comparisons might fail due to collateralLoss/dust.",
          "The user's balance of the SBR token (sbrToken) should increase by approximately the amount of pending SBR rewards minus any fees. Note that exact comparisons might fail due to sbrRewardLoss/dust."
        ]
      },
      {
        "category": "Snapshot Validation",
        "rule_descriptions": [
          "user.rewardSnapshot should be equal to totalRewardPerToken.",
          "user.collateralSnapshot should be equal to totalCollateralPerToken.",
          "If sbrRewardDistributionStatus != ENDED, sbrRewardSnapshots[msg.sender].rewardSnapshot should be equal to totalSbrRewardPerToken.  Otherwise sbrRewardSnapshots[msg.sender].status should be equal to CLAIMED."
        ]
      },
      {
        "category": "Stake Validation",
        "rule_descriptions": [
          "user.cumulativeProductScalingFactor should be equal to stakeScalingFactor.",
          "user.stakeResetCount should be equal to stakeResetCount.",
          "user.stake should reflect the updated effective stake after claiming rewards. It can be checked by calling `_getUserEffectiveStake` with the updated `UserInfo`. Due to scaling factor changes, direct comparison to the previous stake is not straightforward; verify the effective stake calculation.",
          "Call the `getUser` function to fetch the updated `UserInfo` and then manually run `_getUserEffectiveStake` on that user."
        ]
      },
      {
        "category": "SBR Distribution Validation",
        "rule_descriptions": [
          "If sbrRewardDistributionStatus changes, verify that it transitions correctly (NOT_STARTED -> STARTED -> ENDED).",
          "If SBR rewards are added, check that totalSbrRewardPerToken increases accordingly."
        ]
      },
      {
        "category": "Fee Validation",
        "rule_descriptions": [
          "If a frontend address and fee are specified, the frontend's balance of the staking token (stakingToken) should increase by the reward fee.",
          "If a frontend address and fee are specified, the frontend's ETH balance should increase by the collateral fee.",
          "If a frontend address and fee are specified, the frontend's balance of the SBR token (sbrToken) should increase by the SBR reward fee."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate the time elapsed for SBR reward distribution and to ensure rewards are distributed fairly over time. Without keeping track of time, rewards will not be distributed correctly.",
            "when_is_it_updated": "Updated when claim function is called and sbrRewardDistributionStatus is not ENDED.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime and sbrRewardDistributionEndTime and whether sbrRewardDistributionStatus is STARTED. Verify that sbrRewardLoss is updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the lastSBRRewardDistributedTime to the current block timestamp if SBR rewards distribution is active.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the current status of the SBR reward distribution.",
            "why_is_is_important": "Determines whether SBR rewards are currently being distributed, affecting reward calculations. Without proper state management, SBR reward would be incorrect.",
            "when_is_it_updated": "Updated when claim function is called and the current timestamp exceeds the reward end time.",
            "how_to_validate_state_update": "Check the value of sbrRewardDistributionStatus, which should be ENDED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status to ENDED if the current block timestamp is past the distribution end time.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR reward per token.",
            "why_is_is_important": "Used to calculate the SBR rewards owed to each user, ensuring accurate reward distribution. Without correct reward calculation, users can be under or over rewarded.",
            "when_is_it_updated": "Updated when claim function is called and the distribution is active.",
            "how_to_validate_state_update": "Verify the timeElapsed and sbrReward calculation, and check how totalSbrRewardPerToken and sbrRewardLoss are updated. Ensure the SBRRewardsAdded event is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total SBR reward per token based on the time elapsed and distribution rate.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR reward loss.",
            "why_is_is_important": "Used to track the dust amount of SBR rewards and added to the next reward distribution. Without correct reward calculation, users can be under or over rewarded.",
            "when_is_it_updated": "Updated when claim function is called and the distribution is active.",
            "how_to_validate_state_update": "Verify the timeElapsed and sbrReward calculation, and check how totalSbrRewardPerToken and sbrRewardLoss are updated. Ensure the SBRRewardsAdded event is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward loss based on the time elapsed and distribution rate.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate the time elapsed for SBR reward distribution and to ensure rewards are distributed fairly over time. Without keeping track of time, rewards will not be distributed correctly.",
            "when_is_it_updated": "Updated only once when SBR rewards are distributed the first time.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime, sbrRewardDistributionEndTime and sbrRewardDistributionStatus. Verify they are initialized correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the last SBR reward distribution time to the current block timestamp if SBR rewards have not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the end time of the SBR reward distribution.",
            "why_is_is_important": "Used to determine when SBR rewards will stop being distributed, ensuring the distribution period is correctly managed. Without the correct end time, rewards may be distributed indefinitely.",
            "when_is_it_updated": "Updated only once when SBR rewards are distributed the first time.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime, sbrRewardDistributionEndTime and sbrRewardDistributionStatus. Verify they are initialized correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the SBR reward distribution end time to 365 days from the current block timestamp if SBR rewards have not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the current status of the SBR reward distribution.",
            "why_is_is_important": "Determines whether SBR rewards are currently being distributed, affecting reward calculations. Without proper state management, SBR reward would be incorrect.",
            "when_is_it_updated": "Updated only once when SBR rewards are distributed the first time.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime, sbrRewardDistributionEndTime and sbrRewardDistributionStatus. Verify they are initialized correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status to STARTED if SBR rewards have not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "uint256",
            "what_does_it_track": "Tracks pending reward, collateral and SBR rewards for the user.",
            "why_is_is_important": "Calculate pending reward, collateral and SBR rewards for the user.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check if userPendingRewardAndCollateral function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates the pending reward, collateral, and SBR rewards for the user using the userPendingRewardAndCollateral function.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's reward snapshot.",
            "why_is_is_important": "Used to calculate the user's pending rewards, ensuring rewards are calculated from the last snapshot. Without correct snapshotting, users will not be rewarded correctly.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check that user.rewardSnapshot is equal to totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot to the current totalRewardPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's collateral snapshot.",
            "why_is_is_important": "Used to calculate the user's pending collateral, ensuring collateral is calculated from the last snapshot. Without correct snapshotting, users will not be rewarded correctly.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check that user.collateralSnapshot is equal to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot to the current totalCollateralPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's SBR reward snapshot.",
            "why_is_is_important": "Used to calculate the user's pending SBR rewards, ensuring rewards are calculated from the last snapshot. Without correct snapshotting, users will not be rewarded correctly.",
            "when_is_it_updated": "Updated when claim function is called and the distribution has not ended.",
            "how_to_validate_state_update": "Check that sbrRewardSnapshots[msg.sender].rewardSnapshot is equal to totalSbrRewardPerToken.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current totalSbrRewardPerToken.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks the user's SBR reward status.",
            "why_is_is_important": "Used to check whether or not to calculate SBR reward.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check that sbrRewardSnapshots[msg.sender].status is equal to SBRRewardDistribution.CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward status to CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "Tracks user stake.",
            "why_is_is_important": "Update user stake.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check that user.stake is updated by calling _getUserEffectiveStake function.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates user stake by calling _getUserEffectiveStake.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's cumulative product scaling factor.",
            "why_is_is_important": "Used to adjust user's stake and rewards, ensuring accuracy during stake resets. Without updating scaling factor, users will not be rewarded correctly after each reset.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check that user.cumulativeProductScalingFactor is equal to stakeScalingFactor.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulative product scaling factor to the current stakeScalingFactor.",
            "conditions": []
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's stake reset count.",
            "why_is_is_important": "Used to adjust user's stake and rewards, ensuring accuracy during stake resets. Without updating reset count, users will not be rewarded correctly after each reset.",
            "when_is_it_updated": "Updated when claim function is called.",
            "how_to_validate_state_update": "Check that user.stakeResetCount is equal to stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stake reset count to the current stakeResetCount.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "N/A",
            "type": "address",
            "what_does_it_track": "Reward amount of the user.",
            "why_is_is_important": "Transfer reward to msg.sender.",
            "when_is_it_updated": "Updated when claim function is called and pendingReward is not zero.",
            "how_to_validate_state_update": "Check the return value of stakingToken.transfer function.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward to msg.sender by calling stakingToken.transfer function.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "address",
            "what_does_it_track": "Reward fee amount for the frontend.",
            "why_is_is_important": "Transfer reward fee to the frontend.",
            "when_is_it_updated": "Updated when claim function is called, pendingReward is not zero and rewardFee is positive.",
            "how_to_validate_state_update": "Check the return value of stakingToken.transfer function.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward fee to the frontend by calling stakingToken.transfer function.",
            "conditions": [
              "pendingReward != 0",
              "rewardFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "N/A",
            "type": "address",
            "what_does_it_track": "SBR Reward amount of the user.",
            "why_is_is_important": "Mint SBR reward to msg.sender.",
            "when_is_it_updated": "Updated when claim function is called and pendingSbrRewards is not zero.",
            "how_to_validate_state_update": "Check the return value of sbrToken.mint function.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints sbrToken to msg.sender by calling sbrToken.mint function.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "address",
            "what_does_it_track": "SBR Fee amount of the frontend.",
            "why_is_is_important": "Mint SBR fee to the frontend.",
            "when_is_it_updated": "Updated when claim function is called, pendingSbrRewards is not zero and sbrFee is positive.",
            "how_to_validate_state_update": "Check the return value of sbrToken.mint function.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints sbrToken to frontend by calling sbrToken.mint function.",
            "conditions": [
              "pendingSbrRewards != 0",
              "sbrFee > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      }
    ]
  }
}