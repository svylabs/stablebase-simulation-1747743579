{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "The msg.sender must have a stake greater than 0 in the StabilityPool to claim rewards.",
      "The frontend address should be a valid address and can be the zero address if no fee is desired.",
      "The fee should be a value between 0 and BASIS_POINTS_DIVISOR (inclusive)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Info",
        "state_update_descriptions": [
          "UserInfo for msg.sender is updated to reflect the latest reward and collateral snapshots.",
          "User's stake might be updated based on stakeScalingFactor and stakeResetSnapshots."
        ]
      },
      {
        "category": "Reward and Collateral Distribution",
        "state_update_descriptions": [
          "Staking token (DFIDToken) is transferred to the user (msg.sender) and the frontend if a fee is specified.",
          "Collateral (ETH) is transferred to the user and the frontend if a fee is specified.",
          "SBR token (DFIREToken) is minted and transferred to the user and the frontend if a fee is specified."
        ]
      },
      {
        "category": "SBR Rewards",
        "state_update_descriptions": [
          "totalSbrRewardPerToken might be updated if sbrRewardDistributionStatus is not ENDED.",
          "sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to totalSbrRewardPerToken.",
          "sbrRewardSnapshots[msg.sender].status may be updated to CLAIMED if sbrRewardDistributionStatus is ENDED."
        ]
      },
      {
        "category": "Contract State",
        "state_update_descriptions": [
          "totalRewardPerToken and totalCollateralPerToken are read to calculate pending rewards and collateral.",
          "totalStakedRaw, stakeScalingFactor, stakeResetCount, stakeResetSnapshots, sbrRewardDistributionStatus, lastSBRRewardDistributedTime, sbrDistributionRate, sbrRewardLoss may be updated (specifically in _addSBRRewards).",
          "totalRewardPerToken, totalCollateralPerToken, and totalSbrRewardPerToken can also be updated."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "RewardClaimed event is emitted with the user's address, reward, rewardFee, collateral, and collateralFee.",
          "DFireRewardClaimed event is emitted with the user's address, sbrReward, and sbrRewardFee, if sbrReward > 0.",
          "SBRRewardsAdded event might be emitted if the SBR reward distribution is active."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Info",
        "rule_descriptions": [
          "user.rewardSnapshot should be equal to totalRewardPerToken after claim",
          "user.collateralSnapshot should be equal to totalCollateralPerToken after claim",
          "user.cumulativeProductScalingFactor should be equal to stakeScalingFactor after claim",
          "user.stakeResetCount should be equal to stakeResetCount after claim",
          "user.stake should be updated based on the effective stake calculation"
        ]
      },
      {
        "category": "Reward Balances",
        "rule_descriptions": [
          "The user's DFIDToken balance should increase by (pendingReward - rewardFee)",
          "If rewardFee > 0, the frontend's DFIDToken balance should increase by rewardFee",
          "If pendingCollateral > 0, the user's ETH balance should increase by (pendingCollateral - collateralFee)",
          "If collateralFee > 0, the frontend's ETH balance should increase by collateralFee",
          "If pendingSbrRewards > 0, the user's DFIREToken balance should increase by (pendingSbrRewards - sbrFee)",
          "If sbrFee > 0, the frontend's DFIREToken balance should increase by sbrFee"
        ]
      },
      {
        "category": "SBR Rewards",
        "rule_descriptions": [
          "If sbrRewardDistributionStatus is not ENDED, sbrRewardSnapshots[msg.sender].rewardSnapshot should be equal to totalSbrRewardPerToken.",
          "If sbrRewardDistributionStatus is ENDED and sbrRewardSnapshots[msg.sender].status is not CLAIMED, sbrRewardSnapshots[msg.sender].status should be CLAIMED."
        ]
      },
      {
        "category": "Contract State",
        "rule_descriptions": [
          "totalRewardPerToken, totalCollateralPerToken, totalSbrRewardPerToken, stakeScalingFactor, and stakeResetCount may be updated during claim execution, specifically within the `_addSBRRewards` function if the SBR reward distribution is active, and these updates should be reflected accordingly."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "write",
            "what_does_it_track": "The last time SBR rewards were distributed.",
            "why_is_is_important": "To update the total SBR rewards based on the time elapsed since the last distribution.",
            "when_is_it_updated": "At the beginning of the _claim function, before calculating and transferring rewards, if SBR rewards distribution is not ended",
            "how_to_validate_state_update": "Check if the sbrRewardDistributionStatus is not ENDED. Then, ensure that lastSBRRewardDistributedTime is updated to the current block timestamp and totalSbrRewardPerToken is increased based on the time elapsed and the distribution rate. Also verifies SBRrewardLoss.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last distribution timestamp to the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "write",
            "what_does_it_track": "The cumulative SBR reward per token.",
            "why_is_is_important": "To track the total SBR rewards per token for all users.",
            "when_is_it_updated": "At the beginning of the _claim function, if SBR rewards distribution is not ended.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is not ENDED. Then, confirm totalSbrRewardPerToken is increased proportionally to the time elapsed and distribution rate. The update also takes into account any SBR reward loss.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total SBR reward per token based on the distribution rate and time elapsed.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "write",
            "what_does_it_track": "The amount of SBR rewards lost due to rounding errors.",
            "why_is_is_important": "To account for any rounding errors in SBR reward distribution.",
            "when_is_it_updated": "At the beginning of the _claim function, if SBR rewards distribution is not ended, if rewards are not distributed perfectly.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is not ENDED. Then, confirm sbrRewardLoss is updated to reflect the difference between the calculated SBR reward and the distributed SBR reward.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the amount of SBR rewards lost due to rounding errors.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "write",
            "what_does_it_track": "The last time SBR rewards were distributed.",
            "why_is_is_important": "To initialize the SBR reward distribution parameters.",
            "when_is_it_updated": "If SBR reward distribution hasn't started.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is NOT_STARTED. Then, verify that lastSBRRewardDistributedTime is set to the current block timestamp, sbrRewardDistributionEndTime is set to the current timestamp + 365 days, and sbrRewardDistributionStatus is set to STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the last distribution timestamp to the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "write",
            "what_does_it_track": "The time when SBR reward distribution ends.",
            "why_is_is_important": "To initialize the SBR reward distribution parameters.",
            "when_is_it_updated": "If SBR reward distribution hasn't started.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is NOT_STARTED. Then, verify that lastSBRRewardDistributedTime is set to the current block timestamp, sbrRewardDistributionEndTime is set to the current timestamp + 365 days, and sbrRewardDistributionStatus is set to STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the end time for SBR reward distribution to 365 days from the current timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "write",
            "what_does_it_track": "The status of the SBR reward distribution.",
            "why_is_is_important": "To initialize the SBR reward distribution parameters.",
            "when_is_it_updated": "If SBR reward distribution hasn't started.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is NOT_STARTED. Then, verify that lastSBRRewardDistributedTime is set to the current block timestamp, sbrRewardDistributionEndTime is set to the current timestamp + 365 days, and sbrRewardDistributionStatus is set to STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the status of SBR reward distribution to STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "write",
            "what_does_it_track": "The status of the SBR reward distribution.",
            "why_is_is_important": "To finalize the SBR reward distribution.",
            "when_is_it_updated": "If the current timestamp is after the SBR reward distribution end time.",
            "how_to_validate_state_update": "Check if the current block timestamp is greater than sbrRewardDistributionEndTime and sbrRewardDistributionStatus is STARTED. Then, confirm that sbrRewardDistributionStatus is set to ENDED.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the status of SBR reward distribution to ENDED.",
            "conditions": [
              "block.timestamp > sbrRewardDistributionEndTime",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "read",
            "what_does_it_track": "Total rewards per token.",
            "why_is_is_important": "To calculate the pending rewards and collateral for the user.",
            "when_is_it_updated": "Always, to take a snapshot of reward tokens, collateral and SBR reward tokens to the user's struct, if user has stake.",
            "how_to_validate_state_update": "Call userPendingRewardAndCollateral to calculate pending rewards. Compare this value with the stored reward, collateral and SBR rewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Used in calculation of user rewards.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "read",
            "what_does_it_track": "Total collateral per token.",
            "why_is_is_important": "To calculate the pending rewards and collateral for the user.",
            "when_is_it_updated": "Always, to take a snapshot of reward tokens, collateral and SBR reward tokens to the user's struct, if user has stake.",
            "how_to_validate_state_update": "Call userPendingRewardAndCollateral to calculate pending collateral. Compare this value with the stored reward, collateral and SBR rewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Used in calculation of user collateral.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "read",
            "what_does_it_track": "Total SBR rewards per token.",
            "why_is_is_important": "To calculate the pending SBR rewards for the user.",
            "when_is_it_updated": "To take a snapshot of SBR rewards if the rewards distribution is active.",
            "how_to_validate_state_update": "Call userPendingRewardAndCollateral to calculate pending SBR rewards. Compare this value with the snapshot SBR rewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Used in calculation of user SBR rewards.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "rewardSnapshot",
            "type": "write",
            "what_does_it_track": "The user's reward snapshot.",
            "why_is_is_important": "To take a snapshot of totalRewardPerToken so that user is paid out only for the current rewards.",
            "when_is_it_updated": "After rewards are calculated.",
            "how_to_validate_state_update": "Get UserInfo struct from users mapping using msg.sender. Verify user.rewardSnapshot is now equal to totalRewardPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's reward snapshot to the current total reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "collateralSnapshot",
            "type": "write",
            "what_does_it_track": "The user's collateral snapshot.",
            "why_is_is_important": "To take a snapshot of totalCollateralPerToken so that user is paid out only for the current collateral.",
            "when_is_it_updated": "After collateral is calculated.",
            "how_to_validate_state_update": "Get UserInfo struct from users mapping using msg.sender. Verify user.collateralSnapshot is now equal to totalCollateralPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's collateral snapshot to the current total collateral per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "rewardSnapshot",
            "type": "write",
            "what_does_it_track": "The user's SBR reward snapshot.",
            "why_is_is_important": "To take a snapshot of totalSbrRewardPerToken so that user is paid out only for the current SBR rewards.",
            "when_is_it_updated": "After SBR rewards are calculated, before the SBR distribution is ended.",
            "how_to_validate_state_update": "Verify sbrRewardSnapshots[msg.sender].rewardSnapshot is now equal to totalSbrRewardPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current total SBR reward per token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "status",
            "type": "write",
            "what_does_it_track": "The user's SBR reward claim status.",
            "why_is_is_important": "To keep track of SBR reward claim status.",
            "when_is_it_updated": "After SBR rewards are calculated, after the SBR distribution is ended, if user has not claimed SBR tokens yet.",
            "how_to_validate_state_update": "Verify sbrRewardSnapshots[msg.sender].status is now equal to SBRRewardDistribution.CLAIMED",
            "has_conditional_updates": true,
            "summary_of_update": "If SBR reward distribution is ended, updates the status to CLAIMED",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "stakingToken",
            "type": "external_call",
            "what_does_it_track": "The staking token contract.",
            "why_is_is_important": "To transfer the pending rewards to the user.",
            "when_is_it_updated": "If there are pending rewards to be claimed by the user.",
            "how_to_validate_state_update": "Check stakingToken.transfer is called with msg.sender and pendingReward - rewardFee and also confirms successful transfer.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers pending rewards to the user, deducting any fees.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "stakingToken",
            "type": "external_call",
            "what_does_it_track": "The staking token contract.",
            "why_is_is_important": "To transfer the reward fee to the frontend.",
            "when_is_it_updated": "If there are pending rewards and a reward fee to be transferred to the frontend.",
            "how_to_validate_state_update": "Check stakingToken.transfer is called with frontend and rewardFee and also confirms successful transfer.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward fee to the frontend.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingReward != 0",
              "rewardFee > 0"
            ]
          },
          {
            "state_variable_name": "collateral",
            "type": "transfer",
            "what_does_it_track": "The pending collateral.",
            "why_is_is_important": "To transfer the pending collateral to the user.",
            "when_is_it_updated": "If there is pending collateral to be claimed by the user.",
            "how_to_validate_state_update": "Check msg.sender.call{value: pendingCollateral - collateralFee} is called and confirms successful transfer.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers pending collateral to the user, deducting any fees.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingCollateral != 0"
            ]
          },
          {
            "state_variable_name": "collateralFee",
            "type": "transfer",
            "what_does_it_track": "The collateral fee.",
            "why_is_is_important": "To transfer the collateral fee to the frontend.",
            "when_is_it_updated": "If there is pending collateral and a collateral fee to be transferred to the frontend.",
            "how_to_validate_state_update": "Check frontend.call{value: collateralFee} is called and confirms successful transfer.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers collateral fee to the frontend.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingCollateral != 0",
              "collateralFee > 0"
            ]
          },
          {
            "state_variable_name": "sbrToken",
            "type": "external_call",
            "what_does_it_track": "The SBR token contract.",
            "why_is_is_important": "To mint and transfer the pending SBR rewards to the user.",
            "when_is_it_updated": "If there are pending SBR rewards to be claimed by the user.",
            "how_to_validate_state_update": "Check sbrToken.mint is called with msg.sender and pendingSbrRewards - sbrFee and also confirms successful minting.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints pending SBR rewards to the user, deducting any fees.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "sbrToken",
            "type": "external_call",
            "what_does_it_track": "The SBR token contract.",
            "why_is_is_important": "To transfer the SBR fee to the frontend.",
            "when_is_it_updated": "If there are pending SBR rewards and a fee to be transferred to the frontend.",
            "how_to_validate_state_update": "Check sbrToken.mint is called with frontend and sbrFee and also confirms successful minting.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR fee to the frontend.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingSbrRewards != 0",
              "sbrFee > 0"
            ]
          },
          {
            "state_variable_name": "stake",
            "type": "write",
            "what_does_it_track": "The user's stake.",
            "why_is_is_important": "To update the user's stake.",
            "when_is_it_updated": "After rewards are claimed.",
            "how_to_validate_state_update": "Check that user.stake is updated by calling _getUserEffectiveStake",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's stake to the current effective stake.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "cumulativeProductScalingFactor",
            "type": "write",
            "what_does_it_track": "The user's cumulative product scaling factor.",
            "why_is_is_important": "To update user's scaling factor and reset count.",
            "when_is_it_updated": "Always, after updating stake.",
            "how_to_validate_state_update": "Get UserInfo struct from users mapping using msg.sender. Verify user.cumulativeProductScalingFactor is now equal to stakeScalingFactor and user.stakeResetCount is equal to stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulative product scaling factor to the current stake scaling factor.",
            "conditions": []
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "write",
            "what_does_it_track": "The user's stake reset count.",
            "why_is_is_important": "To update user's stake reset count.",
            "when_is_it_updated": "Always, after updating stake.",
            "how_to_validate_state_update": "Get UserInfo struct from users mapping using msg.sender. Verify user.cumulativeProductScalingFactor is now equal to stakeScalingFactor and user.stakeResetCount is equal to stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stake reset count to the current stake reset count.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "transfer",
            "what_does_it_track": "The balance of the user.",
            "why_is_is_important": "To transfer the pending rewards to the user.",
            "when_is_it_updated": "When there are pending rewards to be claimed by the user.",
            "how_to_validate_state_update": "Check that the transfer function is called with the correct parameters.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers the pending rewards to the user.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingReward != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mint",
            "what_does_it_track": "The balance of the user.",
            "why_is_is_important": "To mint the SBR rewards to the user.",
            "when_is_it_updated": "When there are pending SBR rewards to be claimed by the user.",
            "how_to_validate_state_update": "Check that the _mint function is called with the correct parameters.",
            "has_conditional_updates": false,
            "summary_of_update": "Mints the SBR rewards to the user.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "write",
            "what_does_it_track": "The total supply of the SBR token.",
            "why_is_is_important": "To update the total supply of the SBR token.",
            "when_is_it_updated": "When there are pending SBR rewards to be claimed by the user.",
            "how_to_validate_state_update": "Check that the _totalSupply is updated correctly.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total supply of the SBR token.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0",
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}