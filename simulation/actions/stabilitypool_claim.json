{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "The user must have a stake greater than 0 to claim rewards. Check `users[msg.sender].stake > 0`.",
      "Frontend address and fee can be set to zero if no fee is desired for the claim. If a frontend address is specified, it must be a valid address.",
      "The fee must be within the allowed range (0 to BASIS_POINTS_DIVISOR).",
      "Check if the user has pending rewards or collateral. This can be done by checking the user's rewardSnapshot, collateralSnapshot and stakeResetCount against the current totalRewardPerToken, totalCollateralPerToken, stakeResetCount, and relevant stakeResetSnapshots.",
      "If `sbrRewardDistributionStatus` is not `ENDED`, ensure `_addSBRRewards()` logic is appropriately simulated to update `totalSbrRewardPerToken` and relevant state variables."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Rewards",
        "state_update_descriptions": [
          "User's rewardSnapshot is updated to totalRewardPerToken.",
          "User's collateralSnapshot is updated to totalCollateralPerToken.",
          "If SBR reward distribution is not ended, user's SBR reward snapshot is updated to totalSbrRewardPerToken. Otherwise, user's SBR reward snapshot status is set to CLAIMED.",
          "Pending reward tokens are transferred from the StabilityPool to the user, minus any frontend fee. This involves a call to `stakingToken.transfer(msg.sender, pendingReward - rewardFee)`.",
          "Pending collateral (ETH) is transferred from the StabilityPool to the user, minus any frontend fee. This involves a `msg.sender.call{value: pendingCollateral - collateralFee}(\"\")`.",
          "Pending SBR rewards are minted and transferred to the user, minus any frontend fee. This involves a call to `sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee)`."
        ]
      },
      {
        "category": "SBR Rewards Distribution",
        "state_update_descriptions": [
          "If SBR reward distribution is not started, it will be initiated. lastSBRRewardDistributedTime is set to block.timestamp, sbrRewardDistributionEndTime is set to block.timestamp + 365 days, and sbrRewardDistributionStatus is set to STARTED.",
          "If SBR reward distribution is started, SBR rewards are added based on the time elapsed since the last distribution, the distribution rate, and the total staked amount.  totalSbrRewardPerToken and sbrRewardLoss are updated accordingly. If block.timestamp exceeds sbrRewardDistributionEndTime, sbrRewardDistributionStatus is set to ENDED and timeElapsed is adjusted."
        ]
      },
      {
        "category": "User Stake Adjustment",
        "state_update_descriptions": [
          "User's stake is adjusted based on the current stakeScalingFactor via `_getUserEffectiveStake`.",
          "User's cumulativeProductScalingFactor is updated to the current stakeScalingFactor.",
          "User's stakeResetCount is updated to the current stakeResetCount."
        ]
      },
      {
        "category": "Contract State",
        "state_update_descriptions": [
          "totalRewardPerToken may be updated due to reward additions (via `addReward`).",
          "totalCollateralPerToken may be updated due to collateral reward additions (via `addCollateralReward`).",
          "totalSbrRewardPerToken is updated if SBR rewards are distributed."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "RewardClaimed event is emitted, logging the user, reward amount, reward fee, collateral amount, and collateral fee.",
          "DFireRewardClaimed event is emitted (if sbrReward > 0), logging the user, SBR reward amount, and SBR reward fee.",
          "SBRRewardsAdded event is emitted if SBR rewards are distributed, logging the last distribution time, current time, reward amount, and total reward per token."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Balances",
        "rule_descriptions": [
          "User's staking token balance should increase by the pending reward amount, minus the frontend fee. Check `stakingToken.balanceOf(user)`.",
          "User's ETH balance should increase by the pending collateral amount, minus the frontend fee. Check `user.balance`.",
          "User's SBR token balance should increase by the pending SBR reward amount, minus the frontend fee. Check `sbrToken.balanceOf(user)`.",
          "User's stake should be updated to reflect current stake scaling factor. `users[user].stake` should equal the effective stake based on `stakeScalingFactor` and `stakeResetSnapshots`."
        ]
      },
      {
        "category": "Contract State",
        "rule_descriptions": [
          "stakingToken's balance in StabilityPool should decrease by the amount of rewards claimed (minus fees).  Check `stakingToken.balanceOf(StabilityPool)`.",
          "StabilityPool's ETH balance should decrease by the amount of collateral claimed (minus fees). Check `StabilityPool.balance`.",
          "totalRewardPerToken, totalCollateralPerToken, and totalSbrRewardPerToken should be updated correctly if rewards and collateral were added since the user's last claim.",
          "sbrRewardDistributionStatus should be ENDED if the current block timestamp is greater than the end time and the distribution was ongoing.",
          "Verify that `users[msg.sender].rewardSnapshot` equals `totalRewardPerToken`.",
          "Verify that `users[msg.sender].collateralSnapshot` equals `totalCollateralPerToken`.",
          "If applicable, verify that `sbrRewardSnapshots[msg.sender].rewardSnapshot` equals `totalSbrRewardPerToken`."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A RewardClaimed event should be emitted with the correct parameters.",
          "If applicable, a DFireRewardClaimed event should be emitted with the correct parameters.",
          "If SBR rewards are added, an SBRRewardsAdded event should be emitted with the correct parameters."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "It is important for calculating the SBR rewards to be distributed over time. It helps determine the time elapsed since the last distribution, which is used to calculate the amount of SBR rewards to add to the pool. This ensures accurate reward distribution to stakers. If SBR reward distribution is NOT_STARTED, it initializes `lastSBRRewardDistributedTime` to the current block timestamp, sets `sbrRewardDistributionEndTime` to block.timestamp + 365 days and sets `sbrRewardDistributionStatus` to STARTED. If the current block timestamp exceeds `sbrRewardDistributionEndTime`, it sets `sbrRewardDistributionStatus` to ENDED and adjusts `timeElapsed` accordingly. It then calculates the `sbrReward` based on `timeElapsed` and `sbrDistributionRate`. If `totalStakedRaw` is greater than 0, it calculates `_sbrReward`, `_totalSbrRewardPerToken`, and updates `totalSbrRewardPerToken` and `sbrRewardLoss` accordingly. Finally, it emits an `SBRRewardsAdded` event with the updated values, including lastSBRRewardDistributedTime, block.timestamp, sbrReward, and totalSbrRewardPerToken. Afterwards the lastSBRRewardDistributedTime is updated to block.timestamp regardless of any conditional outcome. This state variable tracks the time of the last SBR reward distribution, ensuring accurate calculation of rewards for stakers over time. By updating the last distribution time after calculating and applying rewards, the contract ensures that future reward calculations are based on the most up-to-date information, maintaining fairness and transparency in the reward distribution process. If sbrRewardDistributionStatus is NOT_STARTED, it initializes the reward distribution parameters. This ensures that the SBR reward distribution mechanism functions correctly from the start and that rewards are calculated and distributed accurately to stakers based on predefined parameters such as the distribution rate and time frame. Setting the distribution status to STARTED ensures that the reward distribution mechanism is activated and that rewards are calculated and distributed accurately to stakers over time.",
            "when_is_it_updated": "It is updated when SBR reward distribution is started but not ended, or when it is NOT_STARTED and needs to be initialized.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime before and after the execution. If sbrRewardDistributionStatus was STARTED, the value will be updated to the current block timestamp. If sbrRewardDistributionStatus was NOT_STARTED, verify it's initialized to the current block timestamp, sbrRewardDistributionEndTime is set to block.timestamp + 365 days and sbrRewardDistributionStatus is set to STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time SBR reward was distributed to the current block timestamp, but only if `sbrRewardDistributionStatus` is not ENDED. If `sbrRewardDistributionStatus` is NOT_STARTED, it also initializes `sbrRewardDistributionEndTime` and sets `sbrRewardDistributionStatus` to STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "users",
            "type": "mapping",
            "what_does_it_track": "Tracks user specific information like stake, reward snapshots, collateral snapshots, cumulative product scaling factor and stake reset count.",
            "why_is_is_important": "It is important for calculating the pending rewards and collateral for each user. This ensures that each user receives the correct amount of rewards and collateral based on their stake and the overall rewards and collateral accumulated in the pool.",
            "when_is_it_updated": "It is updated when a user claims their rewards. The snapshots are updated to record the current total rewards and collateral per token at the time of claiming, and the stake and stakeResetCount are updated to reflect the latest stake.",
            "how_to_validate_state_update": "Fetch the user info before and after calling claim and check the rewardSnapshot, collateralSnapshot and stakeResetCount. The rewardSnapshot and collateralSnapshot should be updated to the current totalRewardPerToken and totalCollateralPerToken respectively. The stake and stakeResetCount should be updated to the latest stake, based on scaling factor.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's rewardSnapshot and collateralSnapshot to the current totalRewardPerToken and totalCollateralPerToken respectively, and updates the stake and stakeResetCount based on the stakeScalingFactor.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks the snapshot of SBR rewards for each user.",
            "why_is_is_important": "It is important for calculating the pending SBR rewards for each user. It is the reference point for the rewards a user has already earned. By updating the snapshots, the contract ensures that each user receives the correct amount of SBR rewards based on their stake and the overall SBR rewards accumulated in the pool. If sbrRewardDistributionStatus is ENDED, it sets sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution.CLAIMED. This indicates that the user has claimed their SBR rewards and should no longer receive further distributions until the next distribution period. This helps prevent over-claiming of rewards and ensures accurate distribution over time.",
            "when_is_it_updated": "It is updated when a user claims their rewards and the SBR reward distribution has not ended, or when SBR rewards distribution has ended.",
            "how_to_validate_state_update": "Check the value of sbrRewardSnapshots[msg.sender].rewardSnapshot before and after the execution. If sbrRewardDistributionStatus is not ENDED the rewardSnapshot should be updated; otherwise, the status will be updated to CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current totalSbrRewardPerToken. If sbrRewardDistributionStatus is ENDED, sets status to CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative reward per token.",
            "why_is_is_important": "This is NOT updated in claim function. Updated when rewards are added to the pool.",
            "when_is_it_updated": "This is NOT updated in claim function. Updated when rewards are added to the pool.",
            "how_to_validate_state_update": "Check the totalRewardPerToken before and after execution. It should remain unchanged.",
            "has_conditional_updates": false,
            "summary_of_update": "No update. The total reward per token remains unchanged during a claim.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per token.",
            "why_is_is_important": "This is NOT updated in claim function. Updated when collateral rewards are added to the pool or during liquidations.",
            "when_is_it_updated": "This is NOT updated in claim function. Updated when collateral rewards are added to the pool or during liquidations.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken before and after execution. It should remain unchanged.",
            "has_conditional_updates": false,
            "summary_of_update": "No update. The total collateral per token remains unchanged during a claim.",
            "conditions": []
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR reward per token.",
            "why_is_is_important": "It is important for calculating the pending SBR rewards for each user. It represents the total SBR rewards distributed per token staked.",
            "when_is_it_updated": "This is updated in the `_addSBRRewards` function which is called within `_claim`, if `sbrRewardDistributionStatus != SBRRewardDistribution.ENDED`.",
            "how_to_validate_state_update": "Check the totalSbrRewardPerToken before and after execution. It may be updated in the `_addSBRRewards` function which is called within `_claim`, if `sbrRewardDistributionStatus != SBRRewardDistribution.ENDED`.",
            "has_conditional_updates": false,
            "summary_of_update": "No direct update. Total SBR reward per token is not directly updated in the `claim` function. It is updated in the `_addSBRRewards` function which is called within `_claim`, if `sbrRewardDistributionStatus != SBRRewardDistribution.ENDED`",
            "conditions": []
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Scaling factor to adjust user stake.",
            "why_is_is_important": "Used to adjust user stake during stake reset.",
            "when_is_it_updated": "It is not updated during a claim. It is updated during stake reset.",
            "how_to_validate_state_update": "Verify stakeScalingFactor has not changed before and after the transaction",
            "has_conditional_updates": false,
            "summary_of_update": "The stakeScalingFactor is not modified during a claim operation.",
            "conditions": []
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of stake resets.",
            "why_is_is_important": "Tracks the number of stake resets to calculate user rewards accurately.",
            "when_is_it_updated": "It is not updated during a claim. It is updated during stake reset.",
            "how_to_validate_state_update": "Verify stakeResetCount has not changed before and after the transaction",
            "has_conditional_updates": false,
            "summary_of_update": "The stakeResetCount is not modified during a claim operation.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each address.",
            "why_is_is_important": "It is important for maintaining the correct balance of tokens for each user. It ensures that each user receives the correct amount of reward tokens based on their stake and the overall rewards accumulated in the pool.",
            "when_is_it_updated": "It is updated when the contract transfers reward tokens to the user (msg.sender) and frontend.",
            "how_to_validate_state_update": "Check the balance of the msg.sender and frontend before and after calling claim. The balance of msg.sender should increase by pendingReward - rewardFee, and the balance of frontend should increase by rewardFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward tokens to the user and the frontend.",
            "conditions": [
              "pendingReward != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each address.",
            "why_is_is_important": "It is important for maintaining the correct balance of SBR tokens for each user. It ensures that each user receives the correct amount of SBR tokens based on their stake and the overall SBR rewards accumulated in the pool.",
            "when_is_it_updated": "It is updated when the contract mints SBR tokens to the user (msg.sender) and frontend.",
            "how_to_validate_state_update": "Check the balance of msg.sender and frontend before and after calling claim. The balance of msg.sender should increase by pendingSbrRewards - sbrFee, and the balance of frontend should increase by sbrFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to the user and the frontend.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBR tokens.",
            "why_is_is_important": "It is important for tracking the total amount of SBR tokens in circulation.",
            "when_is_it_updated": "It is updated when the contract mints SBR tokens to the user (msg.sender) and frontend.",
            "how_to_validate_state_update": "Check the total supply of SBR tokens before and after the execution. It should increase by pendingSbrRewards (minus fees) + sbrFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total supply of SBR tokens.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}