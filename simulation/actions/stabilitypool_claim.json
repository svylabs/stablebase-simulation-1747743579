{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "No parameters are needed for the basic claim function, as it uses msg.sender to identify the user.",
      "For the overloaded claim function with frontend and fee, determine a valid address for 'frontend' (this could be a zero address if no fee is desired).",
      "For the overloaded claim function, set 'fee' to a reasonable value between 0 and BASIS_POINTS_DIVISOR (inclusive) representing the percentage of rewards to be given as a fee to the frontend. Check contract's BASIS_POINTS_DIVISOR."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Reward Snapshots",
        "state_update_descriptions": [
          "The user's rewardSnapshot is updated to the current totalRewardPerToken."
        ]
      },
      {
        "category": "Reward Snapshots",
        "state_update_descriptions": [
          "The user's collateralSnapshot is updated to the current totalCollateralPerToken."
        ]
      },
      {
        "category": "Reward Snapshots",
        "state_update_descriptions": [
          "If the SBR reward distribution is not ended, the user's sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to the current totalSbrRewardPerToken."
        ]
      },
      {
        "category": "Reward Snapshots",
        "state_update_descriptions": [
          "If the SBR reward distribution is ended, the sbrRewardSnapshots[msg.sender].status is updated to CLAIMED."
        ]
      },
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "User's stake is updated based on the current stakeScalingFactor if stakeScalingFactor is greater than minimumScalingFactor."
        ]
      },
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "User's cumulativeProductScalingFactor is updated to the current stakeScalingFactor."
        ]
      },
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "User's stakeResetCount is updated to the current stakeResetCount."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "stakingToken (reward token) is transferred to the user."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "stakingToken (reward token) is transferred to the frontend if fee > 0."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "Native token (collateral) is transferred to the user."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "Native token (collateral) is transferred to the frontend if fee > 0."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "sbrToken is minted to the user."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "sbrToken is minted to the frontend if fee > 0."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "lastSBRRewardDistributedTime may be updated if SBR rewards distribution is active."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "sbrRewardDistributionEndTime may be updated if SBR reward distribution has not started."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "sbrRewardDistributionStatus may be updated to STARTED or ENDED depending on the current status and elapsed time."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "totalSbrRewardPerToken may be updated if there are SBR rewards to distribute and totalStakedRaw > 0."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "sbrRewardLoss may be updated if there are SBR rewards to distribute and totalStakedRaw > 0."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Reward Snapshots",
        "rule_descriptions": [
          "The user's rewardSnapshot should be equal to the totalRewardPerToken after the claim."
        ]
      },
      {
        "category": "Reward Snapshots",
        "rule_descriptions": [
          "The user's collateralSnapshot should be equal to the totalCollateralPerToken after the claim."
        ]
      },
      {
        "category": "Reward Snapshots",
        "rule_descriptions": [
          "If SBR reward distribution is not ended, then the sbrRewardSnapshots[msg.sender].rewardSnapshot should be equal to the totalSbrRewardPerToken."
        ]
      },
      {
        "category": "Reward Snapshots",
        "rule_descriptions": [
          "If SBR reward distribution is ended, then the sbrRewardSnapshots[msg.sender].status should be equal to CLAIMED."
        ]
      },
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stake should be updated based on the stakeScalingFactor."
        ]
      },
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's cumulativeProductScalingFactor should be equal to the current stakeScalingFactor."
        ]
      },
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stakeResetCount should be equal to the current stakeResetCount."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The user's stakingToken (reward token) balance should increase by the pendingReward amount, minus any fee."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The frontend, if specified and fee is greater than 0, should have its stakingToken (reward token) balance increase by the rewardFee amount."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The user's native token (collateral) balance should increase by the pendingCollateral amount, minus any fee, if there is pending collateral."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The frontend, if specified and fee is greater than 0, should have its native token (collateral) balance increase by the collateralFee amount, if there is pending collateral."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The user's sbrToken balance should increase by the pendingSbrRewards amount, minus any fee, if there is pending sbr rewards."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The frontend, if specified and fee is greater than 0, should have its sbrToken balance increase by the sbrFee amount, if there is pending sbr rewards."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender]",
            "type": "mapping",
            "what_does_it_track": "Tracks user's stake, reward snapshot, collateral snapshot, cumulative product scaling factor and stake reset count.",
            "why_is_is_important": "Tracks user specific info (stake, rewards, etc.).",
            "when_is_it_updated": "When a user calls the `claim` function to claim rewards, collateral and SBR rewards.",
            "how_to_validate_state_update": "Check the user's stake, rewardSnapshot, collateralSnapshot, cumulativeProductScalingFactor, and stakeResetCount after the claim.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's rewardSnapshot, collateralSnapshot, cumulativeProductScalingFactor and stakeResetCount based on current global values. Also potentially reduces the user's stake based on the current scaling factor.",
            "conditions": [
              "User stake is greater than zero."
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative rewards per token.",
            "why_is_is_important": "It is the cumulative rewards per token and is used to calculate user-specific rewards.",
            "when_is_it_updated": "When new SBR rewards are added, based on time elapsed and distribution rate, during claim. This occurs in the `_addSBRRewards` function.",
            "how_to_validate_state_update": "Compare the value of totalRewardPerToken before and after the execution of _addSBRRewards, if the conditions are met it should be higher. This value is only updated in the _addSBRRewards function which is called at the beginning of the _claim function if sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
            "has_conditional_updates": true,
            "summary_of_update": "This value is updated within the _addSBRRewards function if the sbrRewardDistributionStatus is STARTED. This is used to track rewards.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative collateral per token.",
            "why_is_is_important": "Cumulative collateral per token, used to calculate user-specific collateral.",
            "when_is_it_updated": "When new SBR rewards are added, based on time elapsed and distribution rate, during claim. This occurs in the `_addSBRRewards` function.",
            "how_to_validate_state_update": "Compare the value of totalCollateralPerToken before and after the execution of _addSBRRewards, if the conditions are met it should be higher. This value is only updated in the _addSBRRewards function which is called at the beginning of the _claim function if sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
            "has_conditional_updates": true,
            "summary_of_update": "This value is updated within the _addSBRRewards function if the sbrRewardDistributionStatus is STARTED. This is used to track collateral.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative SBR reward per token.",
            "why_is_is_important": "Cumulative SBR reward per token, used to calculate user-specific SBR rewards.",
            "when_is_it_updated": "When new SBR rewards are added, based on time elapsed and distribution rate, during claim. This occurs in the `_addSBRRewards` function.",
            "how_to_validate_state_update": "Compare the value of totalSbrRewardPerToken before and after the execution of _addSBRRewards, if the conditions are met it should be higher. This value is only updated in the _addSBRRewards function which is called at the beginning of the _claim function if sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
            "has_conditional_updates": true,
            "summary_of_update": "This value is updated within the _addSBRRewards function if the sbrRewardDistributionStatus is STARTED. Tracks SBR rewards.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of undistributed SBR rewards due to precision loss.",
            "why_is_is_important": "Accumulates dust from SBR reward distribution to ensure no rewards are lost due to precision issues.",
            "when_is_it_updated": "When new SBR rewards are added and there is a difference between the calculated reward and the distributed reward. Occurs within `_addSBRRewards`.",
            "how_to_validate_state_update": "Verify that sbrRewardLoss is updated correctly by checking its value before and after the _addSBRRewards function call. The new value should reflect the difference between the calculated reward and the distributed reward.",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates dust from SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Timestamp of the last SBR reward distribution.",
            "why_is_is_important": "Used to calculate time elapsed for SBR reward distribution.",
            "when_is_it_updated": "When the `_addSBRRewards` function is called during the claim process.",
            "how_to_validate_state_update": "Check the value before and after the execution of the _addSBRRewards function to see that it has been updated to `block.timestamp`.",
            "has_conditional_updates": true,
            "summary_of_update": "Keeps track of the last time sbr rewards were distributed.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Timestamp of the SBR reward distribution end time.",
            "why_is_is_important": "Used to determine the end of SBR reward distribution.",
            "when_is_it_updated": "When the sbr reward distribution has not yet started. Occurs within `_addSBRRewards`.",
            "how_to_validate_state_update": "Check the value before and after the execution of _addSBRRewards to see that it has been updated to `block.timestamp + 365 days`.",
            "has_conditional_updates": true,
            "summary_of_update": "Keeps track of the end time of the sbr reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Status of the SBR reward distribution.",
            "why_is_is_important": "Tracks whether SBR reward distribution is NOT_STARTED, STARTED, or ENDED.",
            "when_is_it_updated": "When the claim function is called and the SBR distribution status changes. Occurs within `_addSBRRewards`.",
            "how_to_validate_state_update": "Check the value before and after the execution of _addSBRRewards to see that it has been updated to the correct enum value based on the conditions.",
            "has_conditional_updates": true,
            "summary_of_update": "Keeps track of the status of the sbr reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "mapping",
            "what_does_it_track": "Tracks the user's SBR reward snapshot.",
            "why_is_is_important": "Used to calculate pending SBR rewards for the user.",
            "when_is_it_updated": "When a user claims rewards.",
            "how_to_validate_state_update": "Verify that the rewardSnapshot is updated to the current totalSbrRewardPerToken.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot to the current totalSbrRewardPerToken.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "mapping",
            "what_does_it_track": "Tracks the user's SBR reward status.",
            "why_is_is_important": "Tracks whether the user has claimed their SBR rewards.",
            "when_is_it_updated": "When a user claims rewards and SBR distribution is ended.",
            "how_to_validate_state_update": "Verify that the status is updated to CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward status to CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "stakingToken balance",
            "type": "ERC20 Token",
            "what_does_it_track": "The balance of staking tokens held by the StabilityPool contract.",
            "why_is_is_important": "Tracks the amount of staking tokens available for distribution as rewards.",
            "when_is_it_updated": "When `pendingReward` is greater than zero and after fees are calculated.",
            "how_to_validate_state_update": "Check the stakingToken balance of StabilityPool before and after the `claim` execution. The balance should decrease by `pendingReward - rewardFee` if the user is claiming and `rewardFee` if a frontend is specified and fees are taken.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to the user (msg.sender) and potentially a frontend address.  Reduces the stakingToken balance of StabilityPool.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "sbrToken total supply",
            "type": "ERC20 Token",
            "what_does_it_track": "The total supply of sbrToken.",
            "why_is_is_important": "Tracks the total amount of SBR tokens in circulation.",
            "when_is_it_updated": "When `pendingSbrRewards` is greater than zero, and after fees are calculated.",
            "how_to_validate_state_update": "Check the total supply of sbrToken before and after the `claim` execution. The total supply should increase by `pendingSbrRewards - sbrFee` for the user and `sbrFee` if a frontend is specified and fees are taken.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to the user (msg.sender) and potentially a frontend address. Increases the sbrToken total supply.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}