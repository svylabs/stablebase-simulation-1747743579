{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "No parameters are required for this specific 'claim()' function call."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Specific State Updates in StabilityPool",
        "state_update_descriptions": [
          "The user's (msg.sender) 'rewardSnapshot' is updated to the current 'totalRewardPerToken' value.",
          "The user's (msg.sender) 'collateralSnapshot' is updated to the current 'totalCollateralPerToken' value.",
          "The user's (msg.sender) 'sbrRewardSnapshots.rewardSnapshot' is updated to the current 'totalSbrRewardPerToken' value, if the SBR reward distribution has not ended.",
          "The user's (msg.sender) 'sbrRewardSnapshots.status' is set to 'SBRRewardDistribution.CLAIMED' if the SBR reward distribution has ended and the user had not yet claimed.",
          "The user's (msg.sender) 'cumulativeProductScalingFactor' is updated to the current 'stakeScalingFactor'.",
          "The user's (msg.sender) 'stakeResetCount' is updated to the current 'stakeResetCount'.",
          "The user's (msg.sender) 'stake' is re-calculated and updated based on the 'getUserEffectiveStake' logic."
        ]
      },
      {
        "category": "Global SBR Reward Distribution State Updates in StabilityPool",
        "state_update_descriptions": [
          "If 'sbrRewardDistributionStatus' was 'NOT_STARTED', it changes to 'STARTED'.",
          "If 'sbrRewardDistributionStatus' was 'STARTED' and 'block.timestamp' exceeds 'sbrRewardDistributionEndTime', it changes to 'ENDED'.",
          "'lastSBRRewardDistributedTime' is updated to 'block.timestamp'.",
          "If 'sbrRewardDistributionStatus' was 'NOT_STARTED', 'sbrRewardDistributionEndTime' is set to 'block.timestamp + 365 days'.",
          "If SBR rewards are being added (i.e., 'sbrRewardDistributionStatus' is 'STARTED' or was 'NOT_STARTED' and just became 'STARTED'), 'totalSbrRewardPerToken' is increased based on the elapsed time and 'sbrDistributionRate' and 'totalStakedRaw'.",
          "If SBR rewards are being added, 'sbrRewardLoss' might be updated."
        ]
      },
      {
        "category": "Token Balance Updates",
        "state_update_descriptions": [
          "The 'stakingToken' (DFIDToken) balance of 'msg.sender' increases by the calculated 'pendingReward' amount.",
          "The 'stakingToken' (DFIDToken) balance of the 'StabilityPool' contract decreases by the calculated 'pendingReward' amount.",
          "The native collateral balance of 'msg.sender' increases by the calculated 'pendingCollateral' amount.",
          "The native collateral balance of the 'StabilityPool' contract decreases by the calculated 'pendingCollateral' amount.",
          "The 'sbrToken' (DFIREToken) balance of 'msg.sender' increases by the calculated 'pendingSbrRewards' amount due to token minting."
        ]
      },
      {
        "category": "Token Supply Updates",
        "state_update_descriptions": [
          "The 'sbrToken' (DFIREToken) 'totalSupply' increases by the calculated 'pendingSbrRewards' amount if 'pendingSbrRewards' is greater than 0."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Pre-conditions",
        "rule_descriptions": [
          "The user (msg.sender) must have a 'stake' greater than 0 in the StabilityPool to be able to claim rewards."
        ]
      },
      {
        "category": "User Specific State Validations",
        "rule_descriptions": [
          "Assert that 'StabilityPool.users[msg.sender].rewardSnapshot' is equal to 'StabilityPool.totalRewardPerToken' after the transaction.",
          "Assert that 'StabilityPool.users[msg.sender].collateralSnapshot' is equal to 'StabilityPool.totalCollateralPerToken' after the transaction.",
          "Assert that 'StabilityPool.users[msg.sender].cumulativeProductScalingFactor' is equal to 'StabilityPool.stakeScalingFactor' after the transaction.",
          "Assert that 'StabilityPool.users[msg.sender].stakeResetCount' is equal to 'StabilityPool.stakeResetCount' after the transaction.",
          "If 'StabilityPool.sbrRewardDistributionStatus' is not 'ENDED' after the transaction, assert that 'StabilityPool.sbrRewardSnapshots[msg.sender].rewardSnapshot' is equal to 'StabilityPool.totalSbrRewardPerToken'.",
          "If 'StabilityPool.sbrRewardDistributionStatus' is 'ENDED' after the transaction and it was not 'CLAIMED' before, assert that 'StabilityPool.sbrRewardSnapshots[msg.sender].status' is 'SBRRewardDistribution.CLAIMED'."
        ]
      },
      {
        "category": "Global Pool State Validations",
        "rule_descriptions": [
          "Assert that 'StabilityPool.lastSBRRewardDistributedTime' is equal to 'block.timestamp' after the transaction.",
          "If 'StabilityPool.sbrRewardDistributionStatus' was 'NOT_STARTED' before the transaction, assert it is now 'STARTED' and 'sbrRewardDistributionEndTime' is 'block.timestamp + 365 days'.",
          "If 'StabilityPool.sbrRewardDistributionStatus' was 'STARTED' and 'block.timestamp' is greater than 'sbrRewardDistributionEndTime' before the transaction, assert 'StabilityPool.sbrRewardDistributionStatus' is now 'ENDED'.",
          "If SBR rewards were added during execution, assert that 'StabilityPool.totalSbrRewardPerToken' has increased, and 'StabilityPool.sbrRewardLoss' has been updated accordingly."
        ]
      },
      {
        "category": "Token Balance Validations",
        "rule_descriptions": [
          "Assert that the 'DFIDToken.balanceOf(msg.sender)' has increased by the 'pendingReward' amount calculated before the transaction.",
          "Assert that the native collateral balance of 'msg.sender' has increased by the 'pendingCollateral' amount calculated before the transaction.",
          "Assert that the 'DFIREToken.balanceOf(msg.sender)' has increased by the 'pendingSbrRewards' amount calculated before the transaction.",
          "Assert that the 'DFIDToken.balanceOf(StabilityPool_address)' has decreased by the 'pendingReward' amount calculated before the transaction.",
          "Assert that the native collateral balance of 'StabilityPool_address' has decreased by the 'pendingCollateral' amount calculated before the transaction."
        ]
      },
      {
        "category": "Token Supply Validations",
        "rule_descriptions": [
          "If 'pendingSbrRewards' was greater than 0, assert that 'DFIREToken.totalSupply' has increased by the 'pendingSbrRewards' amount."
        ]
      },
      {
        "category": "Event Emission Validations",
        "rule_descriptions": [
          "Assert that a 'RewardClaimed' event was emitted with 'msg.sender' as the user and the correct 'totalReward', 'rewardFrontendFee' (which should be 0), 'totalCollateral', and 'collateralFrontendFee' (which should be 0).",
          "If the calculated 'pendingSbrRewards' was greater than 0, assert that a 'DFireRewardClaimed' event was emitted with 'msg.sender' as the user, and the correct 'amount' and 'frontendFee' (which should be 0).",
          "If SBR rewards were added during the execution (i.e., 'sbrRewardDistributionStatus' was 'NOT_STARTED' or 'STARTED' and rewards were distributed), assert that an 'SBRRewardsAdded' event was emitted with the correct 'lastTime', 'currentTime', 'rewardAmount', and 'totalRewardPerToken'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the `totalRewardPerToken` value at the moment the user claims rewards, serving as a baseline for future reward calculations.",
            "why_is_is_important": "Ensures that future reward calculations correctly account for rewards accrued since the last claim, preventing double-claiming and ensuring accurate distribution.",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Verify that 'rewardSnapshot' for the user is updated to the current 'totalRewardPerToken' at the time of claim.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's reward snapshot is updated to the current `totalRewardPerToken` to record the state for future reward calculations.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the `totalCollateralPerToken` value at the moment the user claims rewards, serving as a baseline for future collateral reward calculations.",
            "why_is_is_important": "Ensures that future collateral reward calculations correctly account for collateral rewards accrued since the last claim.",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Verify that 'collateralSnapshot' for the user is updated to the current 'totalCollateralPerToken' at the time of claim.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's collateral snapshot is updated to the current `totalCollateralPerToken` to record the state for future collateral reward calculations.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the scaling factor at which the user's stake was last accounted for reward and collateral calculations.",
            "why_is_is_important": "Essential for accurately calculating the user's effective stake and proportional rewards, especially after global `stakeScalingFactor` adjustments.",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Verify that 'cumulativeProductScalingFactor' for the user is updated to the current 'stakeScalingFactor' at the time of claim.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's cumulative product scaling factor is updated to the current global `stakeScalingFactor`.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of times the global stake scaling factor has been reset since the user's last interaction.",
            "why_is_is_important": "Used in conjunction with `stakeResetSnapshots` to correctly calculate a user's pending rewards across multiple scaling factor resets.",
            "when_is_it_updated": "Updated every time a user claims rewards.",
            "how_to_validate_state_update": "Verify that 'stakeResetCount' for the user is updated to the current global 'stakeResetCount'.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's stake reset count is updated to the current global `stakeResetCount`.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Represents the user's adjusted stake in the Stability Pool after applying all relevant scaling factors.",
            "why_is_is_important": "Ensures that the user's stake accurately reflects its value relative to the total staked amount, considering any protocol-level adjustments.",
            "when_is_it_updated": "Updated when a user claims rewards, specifically if `user.cumulativeProductScalingFactor` is not zero.",
            "how_to_validate_state_update": "If `user.cumulativeProductScalingFactor` is not zero, verify that 'stake' is recalculated based on the current 'stakeScalingFactor' and the user's last `cumulativeProductScalingFactor`.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's effective stake is adjusted based on the current `stakeScalingFactor` and their previous `cumulativeProductScalingFactor`.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the `totalSbrRewardPerToken` value at the moment the user claims SBR rewards, serving as a baseline for future SBR reward calculations.",
            "why_is_is_important": "Ensures accurate calculation of pending SBR rewards for users who have not yet claimed them, preventing inaccuracies in distribution.",
            "when_is_it_updated": "Updated if `sbrRewardDistributionStatus` is not 'ENDED' when a user claims rewards.",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` is not 'ENDED', verify that 'rewardSnapshot' for `msg.sender` is updated to the current 'totalSbrRewardPerToken'.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's SBR reward snapshot is updated to the current `totalSbrRewardPerToken` if the SBR reward distribution is still active.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Indicates whether a user has claimed their SBR rewards after the distribution has concluded.",
            "why_is_is_important": "Prevents users from claiming SBR rewards multiple times after the distribution period has finished.",
            "when_is_it_updated": "Updated if the `sbrRewardDistributionStatus` is 'ENDED' and the user's status is not yet 'CLAIMED'.",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` is 'ENDED' and the user's SBR reward status is not 'CLAIMED', verify it's set to 'CLAIMED'.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's SBR reward distribution status is marked as 'CLAIMED' if the overall distribution has ended and the user hasn't claimed yet.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The current state of the SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "Controls whether SBR rewards are currently being accumulated and distributed, ensuring rewards are only added during the defined period.",
            "when_is_it_updated": "Potentially updated at the beginning of the `_claim` function, based on `block.timestamp` and `sbrRewardDistributionEndTime`.",
            "how_to_validate_state_update": "If distribution was 'STARTED' and current time is past 'sbrRewardDistributionEndTime', verify it changes to 'ENDED'. If 'NOT_STARTED', verify it changes to 'STARTED'.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the status of SBR reward distribution based on elapsed time or initial state.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED && block.timestamp > sbrRewardDistributionEndTime",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp of the most recent calculation and distribution of SBR rewards.",
            "why_is_is_important": "Used to calculate the time elapsed for accruing new SBR rewards in subsequent reward additions.",
            "when_is_it_updated": "Updated when SBR rewards are added (i.e., `_addSBRRewards` is called), either at the start or during the distribution period.",
            "how_to_validate_state_update": "If distribution was 'STARTED' or 'NOT_STARTED', verify it's set to 'block.timestamp'.",
            "has_conditional_updates": true,
            "summary_of_update": "Records the timestamp of the last SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp at which the SBR reward distribution is scheduled to conclude.",
            "why_is_is_important": "Defines the fixed duration for which SBR rewards will be distributed, ensuring a predictable reward schedule.",
            "when_is_it_updated": "Only updated once, when `sbrRewardDistributionStatus` transitions from `NOT_STARTED` to `STARTED`.",
            "how_to_validate_state_update": "If distribution was 'NOT_STARTED', verify it's set to 'block.timestamp + 365 days'.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the end time for SBR reward distribution when it first starts.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBR reward that has been distributed per unit of staked capital.",
            "why_is_is_important": "Central to calculating each user's proportional share of SBR rewards based on their stake and time.",
            "when_is_it_updated": "Updated when `_addSBRRewards` is called and `totalStakedRaw` is greater than 0, reflecting newly added SBR rewards.",
            "how_to_validate_state_update": "If distribution is 'STARTED' and 'totalStakedRaw' is greater than 0, verify its increase based on calculated SBR reward per token.",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates the total SBR reward per token distributed over time.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Small, undistributable amounts of SBR rewards that accumulate due to precision issues in calculations.",
            "why_is_is_important": "Ensures that even minute amounts of SBR rewards are accounted for and carried over to future distributions, preventing loss of tokens.",
            "when_is_it_updated": "Updated when `_addSBRRewards` is called and `totalStakedRaw` is greater than 0.",
            "how_to_validate_state_update": "If distribution is 'STARTED' and 'totalStakedRaw' is greater than 0, verify its update based on remaining SBR reward after distribution.",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks any remainder of SBR rewards that could not be perfectly distributed among existing stakes.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[StabilityPool]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFID tokens held by the StabilityPool contract.",
            "why_is_is_important": "Reflects the reduction in DFID tokens managed by the StabilityPool as rewards are claimed.",
            "when_is_it_updated": "Decreased when `stakingToken.transfer` is called to distribute DFID rewards to the user and the frontend (if applicable).",
            "how_to_validate_state_update": "If `pendingReward` is not zero, verify that the StabilityPool's DFID balance decreases by `pendingReward - rewardFee` and `rewardFee` (if greater than 0).",
            "has_conditional_updates": true,
            "summary_of_update": "The StabilityPool's balance of DFID tokens decreases as rewards are transferred to the user and the frontend.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFID tokens owned by the claiming user.",
            "why_is_is_important": "Represents the direct claim of DFID rewards by the user.",
            "when_is_it_updated": "Increased when `stakingToken.transfer` is called to send DFID rewards to `msg.sender`.",
            "how_to_validate_state_update": "If `pendingReward` is not zero, verify that the user's DFID balance increases by `pendingReward - rewardFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's balance of DFID tokens increases as their staking rewards are transferred.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "_balances[frontend]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFID tokens accumulated by the specified frontend address.",
            "why_is_is_important": "Accounts for the fees collected by the frontend for facilitating the claim action.",
            "when_is_it_updated": "Increased when `stakingToken.transfer` is called to send the `rewardFee` to the `frontend` address.",
            "how_to_validate_state_update": "If `pendingReward` is not zero and `rewardFee` is greater than 0, verify that the frontend's DFID balance increases by `rewardFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The frontend's balance of DFID tokens increases if a reward fee is applied and transferred.",
            "conditions": [
              "pendingReward != 0",
              "rewardFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of DFIRE tokens in circulation.",
            "why_is_is_important": "Reflects the inflationary aspect of DFIRE rewards, impacting the overall token economics.",
            "when_is_it_updated": "Increased when `sbrToken.mint` is called to create and distribute DFIRE rewards.",
            "how_to_validate_state_update": "If `pendingSbrRewards` is not zero, verify that the DFIREToken total supply increases by `pendingSbrRewards - sbrFee` (for user) and `sbrFee` (for frontend).",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of DFIRE tokens increases as new tokens are minted for rewards.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFIRE tokens owned by the claiming user.",
            "why_is_is_important": "Represents the direct claim of DFIRE rewards by the user.",
            "when_is_it_updated": "Increased when `sbrToken.mint` is called to mint and send DFIRE rewards to `msg.sender`.",
            "how_to_validate_state_update": "If `pendingSbrRewards` is not zero, verify that the user's DFIRE balance increases by `pendingSbrRewards - sbrFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's balance of DFIRE tokens increases as their SBR rewards are minted and transferred.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_balances[frontend]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFIRE tokens accumulated by the specified frontend address.",
            "why_is_is_important": "Accounts for the SBR fees collected by the frontend for facilitating the claim action.",
            "when_is_it_updated": "Increased when `sbrToken.mint` is called to mint and send the `sbrFee` to the `frontend` address.",
            "how_to_validate_state_update": "If `pendingSbrRewards` is not zero and `sbrFee` is greater than 0, verify that the frontend's DFIRE balance increases by `sbrFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "The frontend's balance of DFIRE tokens increases if an SBR reward fee is applied and transferred.",
            "conditions": [
              "pendingSbrRewards != 0",
              "sbrFee > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}