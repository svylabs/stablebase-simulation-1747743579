{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "User must have a stake greater than 0 in the StabilityPool.",
      "Optional frontend address and fee can be specified to distribute a portion of the rewards as a fee.  If no frontend or fee is specified, use the default claim function.",
      "If a frontend and fee are specified, the fee must be within reasonable bounds (e.g., less than 100%) and the frontend address must be a valid address."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Reward and Collateral Calculation",
        "state_update_descriptions": [
          "Calculate pending reward, collateral, and SBR rewards for the user.",
          "Update user's rewardSnapshot to totalRewardPerToken.",
          "Update user's collateralSnapshot to totalCollateralPerToken.",
          "Potentially update sbrRewardSnapshots[msg.sender].rewardSnapshot to totalSbrRewardPerToken, depending on SBR distribution status.",
          "Potentially update sbrRewardSnapshots[msg.sender].status to CLAIMED, depending on SBR distribution status."
        ]
      },
      {
        "category": "Token and ETH Transfers",
        "state_update_descriptions": [
          "Transfer staking tokens (DFIDToken, an IERC20) to the user, minus any reward fee.",
          "Transfer staking tokens (DFIDToken) to the frontend as a reward fee, if applicable.",
          "Transfer ETH collateral to the user, minus any collateral fee.",
          "Transfer ETH collateral to the frontend as a collateral fee, if applicable.",
          "Mint SBR tokens (DFIREToken, an IMintableToken) to the user, minus any SBR fee.",
          "Mint SBR tokens (DFIREToken) to the frontend as an SBR fee, if applicable."
        ]
      },
      {
        "category": "Stake Management",
        "state_update_descriptions": [
          "Adjust the user's effective stake based on scaling factors.",
          "Update user.cumulativeProductScalingFactor to stakeScalingFactor.",
          "Update user.stakeResetCount to stakeResetCount."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "Potentially update the SBR reward distribution status (start or end distribution).",
          "Potentially update lastSBRRewardDistributedTime and sbrRewardDistributionEndTime.",
          "Potentially update totalSbrRewardPerToken."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Reward and Collateral Validation",
        "rule_descriptions": [
          "User's rewardSnapshot should equal totalRewardPerToken.",
          "User's collateralSnapshot should equal totalCollateralPerToken.",
          "If SBR distribution is ongoing, sbrRewardSnapshots[msg.sender].rewardSnapshot should equal totalSbrRewardPerToken.",
          "If SBR distribution is ended, sbrRewardSnapshots[msg.sender].status should be CLAIMED."
        ]
      },
      {
        "category": "Balance Validation",
        "rule_descriptions": [
          "User's DFIDToken (staking token) balance should increase by the reward amount, minus any reward fee.",
          "User's ETH balance should increase by the collateral amount, minus any collateral fee.",
          "User's DFIREToken (SBR token) balance should increase by the SBR reward amount, minus any SBR fee.",
          "If a frontend fee is specified, the frontend's DFIDToken, ETH, and/or DFIREToken balances should increase by the respective fee amounts."
        ]
      },
      {
        "category": "Stake Validation",
        "rule_descriptions": [
          "User's stake should be updated correctly based on scaling factors and stake resets.",
          "User's cumulativeProductScalingFactor should equal stakeScalingFactor.",
          "User's stakeResetCount should equal stakeResetCount."
        ]
      },
      {
        "category": "SBR Distribution Validation",
        "rule_descriptions": [
          "If SBR distribution status changed from NOT_STARTED, lastSBRRewardDistributedTime and sbrRewardDistributionEndTime should be updated.",
          "If SBR distribution status changed to ENDED, timeElapsed should be correctly calculated.",
          "totalSbrRewardPerToken should reflect added SBR rewards, if any."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users",
            "type": "mapping",
            "what_does_it_track": "Tracks user's stake, reward snapshot, collateral snapshot, cumulative product scaling factor and stake reset count.",
            "why_is_is_important": "Tracks user specific stake information, rewards and snapshots.",
            "when_is_it_updated": "When a user claims their rewards.",
            "how_to_validate_state_update": "Check the values of stake, rewardSnapshot, collateralSnapshot, cumulativeProductScalingFactor, and stakeResetCount for the msg.sender in the users mapping after the claim function is executed.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates user's stake, rewardSnapshot, collateralSnapshot, cumulativeProductScalingFactor, and stakeResetCount.  It also updates the sbrRewardSnapshots for the user.",
            "conditions": [
              "User's stake is greater than 0. if (user.stake > 0)"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks the user's snapshot of totalSbrRewardPerToken and the status of their SBR reward claim.",
            "why_is_is_important": "Tracks user specific SBR reward snapshot and status.",
            "when_is_it_updated": "When a user claims rewards, specifically SBR rewards.",
            "how_to_validate_state_update": "Check the values of rewardSnapshot and status for the msg.sender in the sbrRewardSnapshots mapping after the claim function is executed. Verify they match the expected state based on the conditions.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates user's SBR reward snapshot and status. If sbrRewardDistributionStatus is not ENDED, updates rewardSnapshot. Otherwise, updates status to CLAIMED if it was not already CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus is not ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "state variable",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed, the end time of the distribution, and the status of the distribution.",
            "why_is_is_important": "Tracks the time of the last SBR reward distribution, the end time, and the status of the distribution.",
            "when_is_it_updated": "When the claim function is called and the SBR reward distribution is active.",
            "how_to_validate_state_update": "Check if lastSBRRewardDistributedTime is updated to the current block.timestamp. Check if sbrRewardDistributionEndTime and sbrRewardDistributionStatus are updated correctly depending on the initial sbrRewardDistributionStatus.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates lastSBRRewardDistributedTime to block.timestamp. Potentially updates sbrRewardDistributionEndTime and sbrRewardDistributionStatus if distribution has not started or if the current timestamp exceeds the end time.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "block.timestamp > sbrRewardDistributionEndTime",
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "state variable",
            "what_does_it_track": "Tracks the end time of the SBR reward distribution.",
            "why_is_is_important": "Tracks the end time of the SBR reward distribution.",
            "when_is_it_updated": "Only when the claim function is called and the SBR reward distribution has not started.",
            "how_to_validate_state_update": "If sbrRewardDistributionStatus was NOT_STARTED, check that sbrRewardDistributionEndTime is equal to block.timestamp + 365 days after the claim function is executed.",
            "has_conditional_updates": true,
            "summary_of_update": "If the SBR reward distribution has not started, the sbrRewardDistributionEndTime is set to block.timestamp + 365 days.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "state variable",
            "what_does_it_track": "Tracks whether the SBR reward distribution is in the NOT_STARTED, STARTED, or ENDED state.",
            "why_is_is_important": "Tracks the status of the SBR reward distribution.",
            "when_is_it_updated": "When a user calls claim and SBR rewards are being processed.",
            "how_to_validate_state_update": "Check that sbrRewardDistributionStatus changes from NOT_STARTED to STARTED or from STARTED to ENDED depending on the conditions.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardDistributionStatus. If the distribution hasn't started, it's set to STARTED. If the block timestamp exceeds the end time, it's set to ENDED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED",
              "block.timestamp > sbrRewardDistributionEndTime",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "state variable",
            "what_does_it_track": "Tracks the cumulative SBR reward per token distributed to stakers.",
            "why_is_is_important": "Tracks total SBR reward per token.",
            "when_is_it_updated": "When a user claims and the SBR reward distribution is STARTED and totalStakedRaw > 0",
            "how_to_validate_state_update": "Check that totalSbrRewardPerToken increases by the correct amount based on the formula in the code. totalSbrRewardPerToken += ((_sbrReward * stakeScalingFactor * precision) / totalStakedRaw) / precision;",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalSbrRewardPerToken based on time elapsed, sbrDistributionRate, and totalStakedRaw.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "state variable",
            "what_does_it_track": "Tracks any loss in SBR reward due to calculation inaccuracies.",
            "why_is_is_important": "Tracks the amount of SBR reward loss.",
            "when_is_it_updated": "When a user claims rewards and the SBR reward distribution is STARTED and totalStakedRaw > 0",
            "how_to_validate_state_update": "Verify that the sbrRewardLoss is correctly updated according to the formula after the claim function is executed.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates sbrRewardLoss based on reward calculation inaccuracies.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "state variable",
            "what_does_it_track": "Tracks scaling factor of the user's stake.",
            "why_is_is_important": "Tracks current stake scaling factor.",
            "when_is_it_updated": "When a user claims rewards.",
            "how_to_validate_state_update": "Verify that the user.cumulativeProductScalingFactor is updated to the current stakeScalingFactor.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user.cumulativeProductScalingFactor to stakeScalingFactor.",
            "conditions": []
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "state variable",
            "what_does_it_track": "Tracks the number of stake resets the user has experienced.",
            "why_is_is_important": "Tracks current stake reset count.",
            "when_is_it_updated": "When a user claims rewards.",
            "how_to_validate_state_update": "Verify that the user.stakeResetCount is updated to the current stakeResetCount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user.stakeResetCount to stakeResetCount.",
            "conditions": []
          },
          {
            "state_variable_name": "users",
            "type": "mapping",
            "what_does_it_track": "Tracks the effective stake of the user.",
            "why_is_is_important": "Reflects the adjusted stake based on scaling factors.",
            "when_is_it_updated": "When user claims rewards, stake is recalculated using `_getUserEffectiveStake`.",
            "how_to_validate_state_update": "Verify that `user.stake` is updated based on the logic in `_getUserEffectiveStake`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's stake based on stakeScalingFactor and stakeResetSnapshots.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "transfer",
            "type": "external contract interaction",
            "what_does_it_track": "Tracks the transfer of reward tokens.",
            "why_is_is_important": "Transfers reward tokens to the user and frontend.",
            "when_is_it_updated": "When a user has pending rewards to claim.",
            "how_to_validate_state_update": "Check that the balance of the user increases by (pendingReward - rewardFee) and the balance of the frontend increases by rewardFee after the transfer function is called.  Also check that the contract's balance decreases by pendingReward.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to the user and a fee to the frontend, if applicable. This involves calling the transfer function of the stakingToken (DFIDToken).",
            "conditions": [
              "pendingReward != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "mint",
            "type": "external contract interaction",
            "what_does_it_track": "Tracks the minting of SBR tokens.",
            "why_is_is_important": "Mints SBR tokens to the user and frontend.",
            "when_is_it_updated": "When a user has pending SBR rewards to claim.",
            "how_to_validate_state_update": "Check that the balance of the user increases by (pendingSbrRewards - sbrFee) and the balance of the frontend increases by sbrFee after the mint function is called. Also check that the total supply of DFIREToken increases by pendingSbrRewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to the user and a fee to the frontend, if applicable. This involves calling the mint function of the sbrToken (DFIREToken).",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "state variable",
            "what_does_it_track": "Keeps track of total supply of token.",
            "why_is_is_important": "Keeps track of the total supply of the token",
            "when_is_it_updated": "When a user has pending SBR rewards to claim.",
            "how_to_validate_state_update": "Verify that total supply matches the minted tokens",
            "has_conditional_updates": false,
            "summary_of_update": "The `_totalSupply` variable is updated when minting tokens to user",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks balance of user addresses",
            "why_is_is_important": "Keep track of balances of accounts.",
            "when_is_it_updated": "When a user has pending SBR rewards to claim.",
            "how_to_validate_state_update": "The user balance must increase when minting SBR tokens",
            "has_conditional_updates": false,
            "summary_of_update": "The _balances mapping from address to balance is updated for user when tokens are minted.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "receive",
            "type": "external contract interaction",
            "what_does_it_track": "Tracks the transfer of collateral (ETH).",
            "why_is_is_important": "Transfers collateral (ETH) to the user and a fee to the frontend.",
            "when_is_it_updated": "When a user has pending collateral to claim.",
            "how_to_validate_state_update": "Verify that the contract's ETH balance decreases by (pendingCollateral - collateralFee) and the frontend's ETH balance increases by collateralFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers collateral (ETH) to the user and a fee to the frontend, if applicable. This involves calling the `receive` function.",
            "conditions": [
              "pendingCollateral != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}