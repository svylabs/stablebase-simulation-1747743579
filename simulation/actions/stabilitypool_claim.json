{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their rewards.",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "To claim rewards using the default `claim()` function (no parameters), no parameters are needed; the function uses `msg.sender` to identify the user and claim rewards accordingly.",
      "Alternatively, `claim(address frontend, uint256 fee)` allows specifying a frontend address and a fee (in basis points). If calling this version, provide the appropriate address for the frontend and the fee amount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Reward Updates",
        "state_update_descriptions": [
          "User's reward snapshot is updated to the current totalRewardPerToken.",
          "User's collateral snapshot is updated to the current totalCollateralPerToken.",
          "If SBR reward distribution is not ended, user's SBR reward snapshot is updated to the current totalSbrRewardPerToken.",
          "If SBR reward distribution is ended and the user hasn't claimed SBR rewards, the user's SBR reward status is set to CLAIMED.",
          "Pending reward is calculated and transferred to the user (minus fee), if any.",
          "Pending collateral is calculated and transferred to the user (minus fee), if any.",
          "Pending SBR rewards are calculated and minted to the user (minus fee), if any."
        ]
      },
      {
        "category": "Stake Updates",
        "state_update_descriptions": [
          "User's stake is adjusted based on scaling factors.",
          "User's cumulativeProductScalingFactor is updated to the current stakeScalingFactor.",
          "User's stakeResetCount is updated to the current stakeResetCount."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "If SBR rewards are being distributed, the function checks if the distribution end time has been reached.",
          "If the distribution end time has been reached, the status is set to ENDED.",
          "SBR rewards are calculated and added to the totalSbrRewardPerToken, considering any loss."
        ]
      },
      {
        "category": "Events Emitted",
        "state_update_descriptions": [
          "RewardClaimed event is emitted with user address, reward amount, reward fee, collateral amount and collateral fee.",
          "DFireRewardClaimed event is emitted (if sbrReward > 0) with user address, sbrReward amount and sbrReward fee.",
          "SBRRewardsAdded event is emitted if SBR rewards were added."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Reward Balance",
        "rule_descriptions": [
          "User's staking token balance should increase by the claimed reward amount minus fees, if any reward was pending.",
          "Frontend's staking token balance should increase by the reward fee, if any.",
          "User's ETH balance should increase by the claimed collateral amount minus fees, if any collateral was pending.",
          "Frontend's ETH balance should increase by the collateral fee, if any.",
          "User's SBR token balance should increase by the claimed SBR reward amount minus fees, if any SBR reward was pending.",
          "Frontend's SBR token balance should increase by the SBR reward fee, if any."
        ]
      },
      {
        "category": "User Info",
        "rule_descriptions": [
          "User's rewardSnapshot should be equal to totalRewardPerToken.",
          "User's collateralSnapshot should be equal to totalCollateralPerToken.",
          "If SBR reward distribution is ongoing, the sbrRewardSnapshots[msg.sender].rewardSnapshot should equal totalSbrRewardPerToken.",
          "If SBR reward distribution has ended and the user hasn't claimed SBR rewards, sbrRewardSnapshots[msg.sender].status should be SBRRewardDistribution.CLAIMED.",
          "User's stake, cumulativeProductScalingFactor, and stakeResetCount should be updated according to the logic in _updateUserStake."
        ]
      },
      {
        "category": "SBR Reward Distribution Status",
        "rule_descriptions": [
          "If the current block timestamp is greater than sbrRewardDistributionEndTime, then sbrRewardDistributionStatus should be SBRRewardDistribution.ENDED.",
          "lastSBRRewardDistributedTime should be updated to the current block timestamp.",
          "totalSbrRewardPerToken should be correctly updated according to the amount of SBR rewards added.",
          "sbrRewardLoss should be correctly updated according to the amount of SBR rewards added."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "StabilityPool",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed to calculate new rewards.",
            "why_is_is_important": "Ensures accurate calculation of SBR rewards over time by tracking the last distribution time.",
            "when_is_it_updated": "When the SBR reward distribution is active, updates the last distribution time. It's updated at the start and during the distribution.",
            "how_to_validate_state_update": "Check if lastSBRRewardDistributedTime is updated to block.timestamp and sbrRewardDistributionEndTime is updated to block.timestamp + 365 days if sbrRewardDistributionStatus is NOT_STARTED.  If sbrRewardDistributionStatus is STARTED, check if the totalSbrRewardPerToken, sbrRewardLoss, and lastSBRRewardDistributedTime are updated based on the formulas within _addSBRRewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time SBR rewards were distributed.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the end time for the SBR reward distribution period.",
            "why_is_is_important": "Defines the duration of the SBR reward program, ensuring it concludes at the intended time.",
            "when_is_it_updated": "Initialized when SBR reward distribution starts or when timeElapsed is calculated. It's only updated at the start.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionEndTime is updated to block.timestamp + 365 days if sbrRewardDistributionStatus is NOT_STARTED. If block.timestamp > sbrRewardDistributionEndTime, check if sbrRewardDistributionStatus is set to ENDED and timeElapsed is updated to sbrRewardDistributionEndTime - lastSBRRewardDistributedTime",
            "has_conditional_updates": true,
            "summary_of_update": "Sets or updates the end time for SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the current state of the SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "Controls the SBR reward distribution process, ensuring rewards are only calculated and distributed within the active period.",
            "when_is_it_updated": "Updated at the beginning and end of the distribution based on time elapsed and distribution settings.",
            "how_to_validate_state_update": "Verify that sbrRewardDistributionStatus transitions from NOT_STARTED to STARTED and from STARTED to ENDED according to conditions",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the status of SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative SBR reward distributed per staked token.",
            "why_is_is_important": "Used to calculate individual user SBR rewards based on their stake and the accumulated reward per token.",
            "when_is_it_updated": "Updated whenever SBR rewards are added, accumulating rewards over time.",
            "how_to_validate_state_update": "Confirm that totalSbrRewardPerToken is increased by the calculated amount. Check that sbrRewardLoss is updated by the calculated loss",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates the total SBR reward per token.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks any loss of SBR rewards that might occur due to rounding during calculations.",
            "why_is_is_important": "Helps account for any discrepancies in SBR reward distribution due to calculation inaccuracies.",
            "when_is_it_updated": "Updated whenever SBR rewards are added.",
            "how_to_validate_state_update": "Verify that sbrRewardLoss is set according to the calculation.",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks any loss of SBR rewards due to rounding errors.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "pendingReward, pendingCollateral, pendingSbrRewards",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of rewards, collateral and SBR rewards a user has yet to claim.",
            "why_is_is_important": "Ensures users receive the correct amount of rewards based on their stake and the current state of the StabilityPool.",
            "when_is_it_updated": "Updated when a user claims their rewards.",
            "how_to_validate_state_update": "Validate that pendingReward, pendingCollateral, and pendingSbrRewards are calculated correctly based on the user's stake and snapshots using the function userPendingRewardAndCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates pending rewards, collateral, and SBR rewards for the user.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's reward snapshot at the time of claiming.",
            "why_is_is_important": "Used to calculate the user's pending rewards since their last claim.",
            "when_is_it_updated": "Updated when a user claims their rewards.",
            "how_to_validate_state_update": "Verify that user.rewardSnapshot and user.collateralSnapshot are updated to totalRewardPerToken and totalCollateralPerToken respectively.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's collateral snapshot at the time of claiming.",
            "why_is_is_important": "Used to calculate the user's pending collateral since their last claim.",
            "when_is_it_updated": "Updated when a user claims their collateral.",
            "how_to_validate_state_update": "Verify that user.collateralSnapshot is updated to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's SBR reward snapshot at the time of claiming.",
            "why_is_is_important": "Used to calculate the user's pending SBR rewards since their last claim.",
            "when_is_it_updated": "Updated when a user claims their SBR rewards.",
            "how_to_validate_state_update": "Ensure that sbrRewardSnapshots[msg.sender].rewardSnapshot is updated to totalSbrRewardPerToken when the distribution is not ended. If the distribution is ended, check sbrRewardSnapshots[msg.sender].status is updated to CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks the user's SBR reward claim status.",
            "why_is_is_important": "Used to indicate that the user claimed their SBR rewards",
            "when_is_it_updated": "Updated when a user claims their SBR rewards and the distribution is ended.",
            "how_to_validate_state_update": "Ensure that sbrRewardSnapshots[msg.sender].status is updated to CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward status to CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's effective stake, adjusted for scaling factors.",
            "why_is_is_important": "Ensures the user's stake is accurately represented for reward calculations.",
            "when_is_it_updated": "Updated when a user claims rewards.",
            "how_to_validate_state_update": "Verify user.stake is updated using _getUserEffectiveStake function based on stakeScalingFactor and stakeResetSnapshots",
            "has_conditional_updates": false,
            "summary_of_update": "Adjusts the user's stake based on the current scaling factor.",
            "conditions": []
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative scaling factor applied to the user's stake.",
            "why_is_is_important": "Used in stake calculations for accurate reward distribution.",
            "when_is_it_updated": "Updated when a user claims rewards.",
            "how_to_validate_state_update": "Verify user.cumulativeProductScalingFactor is updated to stakeScalingFactor and user.stakeResetCount is updated to stakeResetCount",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's cumulative product scaling factor.",
            "conditions": []
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of stake resets the user has experienced.",
            "why_is_is_important": "Used to calculate the user's stake across stake resets.",
            "when_is_it_updated": "Updated when a user claims rewards.",
            "how_to_validate_state_update": "Verify user.stakeResetCount is updated to stakeResetCount",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's stake reset count.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "msg.sender balance",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's balance of reward tokens.",
            "why_is_is_important": "Increases the user's balance of reward tokens.",
            "when_is_it_updated": "When a user claims their rewards.",
            "how_to_validate_state_update": "Check if stakingToken.transfer is called with (msg.sender, pendingReward - rewardFee).",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to the user.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "frontend balance",
            "type": "uint256",
            "what_does_it_track": "Tracks the frontend's balance of reward tokens.",
            "why_is_is_important": "Increases the frontend's balance of reward tokens by the fee amount.",
            "when_is_it_updated": "When a user claims their rewards and a reward fee is applicable.",
            "how_to_validate_state_update": "Check if stakingToken.transfer is called with (frontend, rewardFee).",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward fee to the frontend.",
            "conditions": [
              "rewardFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "msg.sender balance",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's balance of SBR tokens.",
            "why_is_is_important": "Increases the user's balance of SBR tokens.",
            "when_is_it_updated": "When a user claims their SBR rewards.",
            "how_to_validate_state_update": "Check if sbrToken.mint is called with (msg.sender, pendingSbrRewards - sbrFee).",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the user.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "frontend balance",
            "type": "uint256",
            "what_does_it_track": "Tracks the frontend's balance of SBR tokens.",
            "why_is_is_important": "Increases the frontend's balance of SBR tokens by the fee amount.",
            "when_is_it_updated": "When a user claims their SBR rewards and a fee is applicable.",
            "how_to_validate_state_update": "Check if sbrToken.mint is called with (frontend, sbrFee).",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the frontend as a fee.",
            "conditions": [
              "sbrFee > 0"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Track the total supply of SBR tokens",
            "why_is_is_important": "The supply is the basis of the SBR token economy",
            "when_is_it_updated": "Whenever the SBR token is minted",
            "how_to_validate_state_update": "Check if the total supply of SBR token is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Update total supply of SBR token",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function claim() external {\n        UserInfo storage user = users[msg.sender];\n        if (user.stake > 0) {\n            _claim(user, msg.sender, 0);\n        }\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}