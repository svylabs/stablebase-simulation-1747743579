{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "`safeId` must be the ID of an existing Safe (CDP) on the `StableBaseCDP` contract.",
      "The transaction signer (`msg.sender`) must be the current owner of the Safe identified by `safeId`.",
      "The Safe identified by `safeId` must have a `borrowedAmount` of 0 *after* any accrued debt and collateral updates are applied by the `_updateSafe` internal function (i.e., all debt must have been repaid prior to closing)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State Updates",
        "state_update_descriptions": [
          "The `Safe` struct corresponding to `safeId` in the `safes` mapping will be updated via `_updateSafe` prior to closure. This update will account for accrued debt and collateral based on `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`.",
          "The `Safe` struct corresponding to `safeId` in the `safes` mapping will be deleted, effectively removing the CDP from the contract's active records."
        ]
      },
      {
        "category": "Liquidation Snapshot Updates",
        "state_update_descriptions": [
          "The `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` will be updated to `cumulativeCollateralPerUnitCollateral`.",
          "The `liquidationSnapshots[safeId].debtPerCollateralSnapshot` will be updated to `cumulativeDebtPerUnitCollateral`."
        ]
      },
      {
        "category": "Total Protocol State Updates",
        "state_update_descriptions": [
          "The `totalCollateral` will first be increased by any `collateralIncrease` calculated in `_updateSafe`, and then decreased by the final `safe.collateralAmount` immediately before deletion, reflecting the return of collateral to the owner.",
          "The `totalDebt` will be increased by any `debtIncrease` calculated in `_updateSafe`."
        ]
      },
      {
        "category": "NFT Ownership and Approval Updates",
        "state_update_descriptions": [
          "The ownership of the NFT (representing the Safe) will be transferred from the current owner to `address(0)` (burned), making the token non-existent.",
          "The balance of Safe NFTs for the previous owner of `safeId` will be decremented by 1.",
          "Any existing token approval for `safeId` will be cleared (`_tokenApprovals[safeId]` set to `address(0)`)."
        ]
      },
      {
        "category": "Protocol Mode Update",
        "state_update_descriptions": [
          "If `PROTOCOL_MODE` is `BOOTSTRAP` and `totalDebt` (after internal updates) exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`, `PROTOCOL_MODE` will switch to `NORMAL`."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State Validation",
        "rule_descriptions": [
          "Verify that querying `safes[safeId]` returns a struct with default values (e.g., all fields as 0), indicating the Safe has been removed.",
          "Verify that calling `ownerOf(safeId)` on the `StableBaseCDP` contract returns `address(0)` (the zero address), confirming the Safe NFT has been burned.",
          "Verify that `balanceOf(previousOwnerOfSafe)` for the `StableBaseCDP` contract has decreased by 1."
        ]
      },
      {
        "category": "Total Protocol State Validation",
        "rule_descriptions": [
          "Verify that `totalCollateral` has decreased by `collateralAmount` of the closed safe (as reported in the `SafeClosed` event), relative to its state *after* the `_updateSafe` call but *before* the collateral deduction in `closeSafe`.",
          "Verify that `totalDebt` matches the value emitted in the `SafeClosed` event, accounting for any `debtIncrease` from `_updateSafe`."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "Verify that a `SafeUpdated` event was emitted if the `_updateSafe` function resulted in changes to the safe's collateral or debt.",
          "Verify that a `RemovedSafe` event was emitted for the `safeId`.",
          "Verify that a `Transfer` event was emitted with `from` as the previous owner of `safeId`, `to` as `address(0)`, and `tokenId` as `safeId`.",
          "Verify that a `SafeClosed` event was emitted with the correct `safeId`, `refundedCollateral` (which is the `safe.collateralAmount` at the time of closure), and the final `totalCollateral` and `totalDebt`."
        ]
      },
      {
        "category": "External Balance Validation",
        "rule_descriptions": [
          "Verify that the `msg.sender`'s native token balance (e.g., Ether for an ETH-backed CDP) has increased by the `collateralAmount` of the closed safe, as it is refunded during the closure process."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The current amount of debt (stablecoins) borrowed against the Safe.",
            "why_is_is_important": "It reflects the actual outstanding debt of the Safe before closure, ensuring all accrued debt is accounted for and that the pre-condition safe.borrowedAmount == 0 can be checked effectively (meaning no debt should remain).",
            "when_is_it_updated": "During the call to _updateSafe if there's a discrepancy between liquidationSnapshot.collateralPerCollateralSnapshot and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that safe.borrowedAmount is updated by the debtIncrease calculated based on cumulativeDebtPerUnitCollateral and the safe's previous debtPerCollateralSnapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowedAmount for the specific safeId is increased to account for accrued debt due to system-wide changes (if any).",
            "conditions": [
              "This update occurs if the liquidation snapshot's collateral-per-collateral-snapshot is not equal to the cumulative-collateral-per-unit-collateral. This typically means there have been changes in the system's overall collateral or debt values that affect the safe's actual borrowed and collateral amounts due to interest accrual or yield.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative sum of all debt ever borrowed against the Safe, including accrued interest.",
            "why_is_is_important": "It keeps a record of the total debt that was ever associated with the Safe, useful for historical data or fee calculations, especially before the Safe is closed\u611f\u89c9\u5230",
            "when_is_it_updated": "During the call to _updateSafe if there's a discrepancy between liquidationSnapshot.collateralPerCollateralSnapshot and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that safe.totalBorrowedAmount is updated by the debtIncrease calculated based on cumulativeDebtPerUnitCollateral and the safe's previous debtPerCollateralSnapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "The totalBorrowedAmount for the specific safeId is increased to account for accrued debt due to system-wide changes (if any).",
            "conditions": [
              "This update occurs if the liquidation snapshot's collateral-per-collateral-snapshot is not equal to the cumulative-collateral-per-unit-collateral. This typically means there have been changes in the system's overall collateral or debt values that affect the safe's actual borrowed and collateral amounts due to interest accrual or yield.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the cumulativeDebtPerUnitCollateral at the time of the last Safe update, used to calculate accrued debt.",
            "why_is_is_important": "It ensures future calculations of accrued debt for this Safe are based on the correct starting point, effectively 'resetting' the accrual calculation from this point.",
            "when_is_it_updated": "During the call to _updateSafe if there's a discrepancy between liquidationSnapshot.collateralPerCollateralSnapshot and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].debtPerCollateralSnapshot is set to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "The debtPerCollateralSnapshot for the specified safeId is updated to the current cumulativeDebtPerUnitCollateral.",
            "conditions": [
              "This update occurs if the liquidation snapshot's collateral-per-collateral-snapshot is not equal to the cumulative-collateral-per-unit-collateral. This typically means there have been changes in the system's overall collateral or debt values that affect the safe's actual borrowed and collateral amounts due to interest accrual or yield.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The current amount of collateral held in the Safe.",
            "why_is_is_important": "It reflects the actual collateral backing the Safe's debt before closure, ensuring the correct amount is returned to the user\u611f\u89c9\u5230",
            "when_is_it_updated": "During the call to _updateSafe if there's a discrepancy between liquidationSnapshot.collateralPerCollateralSnapshot and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that safe.collateralAmount is updated by the collateralIncrease calculated based on cumulativeCollateralPerUnitCollateral and the safe's previous collateralPerCollateralSnapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateralAmount for the specific safeId is increased to account for accrued collateral due to system-wide changes (if any).",
            "conditions": [
              "This update occurs if the liquidation snapshot's collateral-per-collateral-snapshot is not equal to the cumulative-collateral-per-unit-collateral. This typically means there have been changes in the system's overall collateral or debt values that affect the safe's actual borrowed and collateral amounts due to interest accrual or yield.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the cumulativeCollateralPerUnitCollateral at the time of the last Safe update, used to calculate accrued collateral.",
            "why_is_is_important": "It ensures future calculations of accrued collateral for this Safe are based on the correct starting point, effectively 'resetting' the accrual calculation from this point.",
            "when_is_it_updated": "During the call to _updateSafe if there's a discrepancy between liquidationSnapshot.collateralPerCollateralSnapshot and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].collateralPerCollateralSnapshot is set to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateralPerCollateralSnapshot for the specified safeId is updated to the current cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "This update occurs if the liquidation snapshot's collateral-per-collateral-snapshot is not equal to the cumulative-collateral-per-unit-collateral. This typically means there have been changes in the system's overall collateral or debt values that affect the safe's actual borrowed and collateral amounts due to interest accrual or yield.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held across all active Safes in the system.",
            "why_is_is_important": "It maintains an accurate record of the total collateralized value within the protocol, reflecting the true state before the Safe is closed\u611f\u89c9\u5230",
            "when_is_it_updated": "During the call to _updateSafe if there's a discrepancy between liquidationSnapshot.collateralPerCollateralSnapshot and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that totalCollateral is updated by adding the collateralIncrease amount to its previous value.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral in the system is increased by the collateralIncrease amount calculated for the specific safe (if any).",
            "conditions": [
              "This update occurs if the liquidation snapshot's collateral-per-collateral-snapshot is not equal to the cumulative-collateral-per-unit-collateral. This typically means there have been changes in the system's overall collateral or debt values that affect the safe's actual borrowed and collateral amounts due to interest accrual or yield.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The sum of all outstanding debt (stablecoins) across all active Safes in the system.",
            "why_is_is_important": "It maintains an accurate record of the total stablecoin debt within the protocol, reflecting the true state before the Safe is closed\u611f\u89c9\u5230",
            "when_is_it_updated": "During the call to _updateTotalDebt (which is called by _updateSafe), if there's an debtIncrease due to interest accrual.",
            "how_to_validate_state_update": "Verify that totalDebt is updated by adding the debtIncrease amount to its previous value.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt in the system is increased by the debtIncrease amount calculated for the specific safe (if any).",
            "conditions": [
              "The update to totalDebt is dependent on the debtIncrease calculated within _updateSafe. This debtIncrease is only non-zero if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
              "Requires safe.borrowedAmount == 0 after this update for the closeSafe function to proceed, but the update itself is based on system-wide changes before the borrowedAmount == 0 check in closeSafe and contributes to meeting that condition if it accrues debt that brings it above 0, or if it was already 0, it remains 0 (assuming no interest accrual if debt is 0)."
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol, influencing parameters like fees or liquidations.",
            "why_is_is_important": "This mode change affects various protocol behaviors, signifying a shift in the system's stability and maturity, even when closing a Safe can cause this threshold to be crossed (though typically it's new debt causing this).",
            "when_is_it_updated": "During the call to _updateTotalDebt (which is called by _updateSafe), if the updated totalDebt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Verify that PROTOCOL_MODE transitions from BOOTSTRAP to NORMAL only if the new totalDebt surpasses BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol's operating mode might switch from BOOTSTRAP to NORMAL if the total debt crosses a threshold.",
            "conditions": [
              "PROTOCOL_MODE changes from BOOTSTRAP to NORMAL only if the totalDebt after the update exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD.",
              "Requires safe.borrowedAmount == 0 after the _updateSafe call for closeSafe function to proceed. This mode change is a side effect of totalDebt being updated within _updateSafe if the conditions are met. If debt accrues and pushes totalDebt over the threshold, the mode changes before the Safe is actually removed and collateral returned, but the borrowedAmount == 0 check in closeSafe would still need to pass (meaning the debt of the current Safe must have been zero)."
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held across all active Safes in the system.",
            "why_is_is_important": "It maintains an accurate record of the total collateralized value within the protocol by removing the collateral of the now-closed Safe. This is crucial for overall system health and calculations (e.g., collateralization ratio).",
            "when_is_it_updated": "In the closeSafe function, after the _updateSafe call and the safe.borrowedAmount == 0 check, the totalCollateral is reduced by the safe.collateralAmount.",
            "how_to_validate_state_update": "Verify that totalCollateral is decreased by the value of safe.collateralAmount (which is collateralAmount in the function scope).",
            "has_conditional_updates": false,
            "summary_of_update": "The total collateral in the system is decreased by the collateral amount of the closed Safe.",
            "conditions": [
              "The closeSafe function requires safe.borrowedAmount == 0 after the _updateSafe call for the safe to be closed and this deletion to occur.",
              "The collateralAmount of the safeId must be non-zero for totalCollateral to actually decrease (although the operation is attempted regardless)."
            ]
          },
          {
            "state_variable_name": "safes[safeId]",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "Stores all active Safe positions, indexed by their unique safeId.",
            "why_is_is_important": "It marks the Safe as inactive and frees up storage, ensuring no further operations can be performed on it and its state is removed from the active safes list\u611f\u5230",
            "when_is_it_updated": "When the closeSafe function is called and the safe.borrowedAmount is 0, leading to a call to _removeSafe.",
            "how_to_validate_state_update": "Verify that the entry for _safeId is completely removed from the safes mapping.",
            "has_conditional_updates": false,
            "summary_of_update": "The Safe struct corresponding to safeId is deleted from the safes mapping, effectively removing the Safe.",
            "conditions": [
              "The closeSafe function requires safe.borrowedAmount == 0 after the _updateSafe call for the safe to be closed and this deletion to occur.",
              "safeId must correspond to an existing Safe in the mapping for its deletion to have an effect. "
            ]
          },
          {
            "state_variable_name": "_tokenApprovals[tokenId]",
            "type": "mapping(uint256 => address)",
            "what_does_it_track": "The approved address for a specific ERC721 token.",
            "why_is_is_important": "Ensures that after burning (closing) the Safe, no address retains approval to transfer the non-existent token, preventing potential misuse or confusion regarding ownership of a burned NFT\u611f\u5230",
            "when_is_it_updated": "During the _update call (part of _burn which is part of _removeSafe), if the token had a previous owner (from != address(0)), its approval is cleared.",
            "how_to_validate_state_update": "Verify that the approval for tokenId is cleared by setting it to address(0) in _tokenApprovals.",
            "has_conditional_updates": true,
            "summary_of_update": "Any existing ERC721 approval for the safeId (token ID) is revoked.",
            "conditions": [
              "The from address (previous owner) must not be address(0). This check is internal to _update which is called by _burn.",
              "The closeSafe function requires safe.borrowedAmount == 0 after _updateSafe for _removeSafe to be called, which in turn calls _burn and then _update.",
              "The auth address (authorized caller) must not be address(0) or emitEvent must be true for this block to execute, but the approval is always cleared if from != address(0) regardless of emitEvent or auth conditions for revoking approval. "
            ]
          },
          {
            "state_variable_name": "_balances[from]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The number of ERC721 tokens (Safes) owned by a specific address.",
            "why_is_is_important": "It accurately reflects the number of active Safes owned by an address after one has been closed/burned, maintaining correct ERC721 token accounting\u611f\u5230",
            "when_is_it_updated": "During the _update call (part of _burn which is part of _removeSafe), if the token had a previous owner (from != address(0)), their balance is reduced.",
            "how_to_validate_state_update": "Verify that the balance of the from address is decremented by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "The ERC721 token balance of the previous owner of the safeId is decremented by one.",
            "conditions": [
              "The from address (previous owner) must not be address(0). This check is internal to _update which is called by _burn.",
              "The closeSafe function requires safe.borrowedAmount == 0 after _updateSafe for _removeSafe to be called, which in turn calls _burn and then _update.",
              "to (receiver of NFT) must not be address(0) for _balances[to] to be incremented, but for burning, to is address(0), so only the _balances[from] decrement is relevant here. "
            ]
          },
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "mapping(uint256 => address)",
            "what_does_it_track": "The owner of a specific ERC721 token (Safe).",
            "why_is_is_important": "This formally burns the NFT representation of the Safe, ensuring it can no longer be owned or transferred and is removed from the active supply.",
            "when_is_it_updated": "During the _update call (part of _burn which is part of _removeSafe), the owner of the safeId is set to address(0).",
            "how_to_validate_state_update": "Verify that the owner of tokenId is set to address(0) in the _owners mapping.",
            "has_conditional_updates": false,
            "summary_of_update": "The ownership of the safeId (token ID) is transferred to the zero address, effectively marking it as burned.",
            "conditions": [
              "The closeSafe function requires safe.borrowedAmount == 0 after _updateSafe for _removeSafe to be called, which in turn calls _burn and then _update.",
              "No other specific conditions for this update itself, as to is explicitly address(0) when burning the token.\u611f\u5230"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}