{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "`safeId` must exist.",
      "`msg.sender` must be the Safe's owner.",
      "`borrowedAmount` must be 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe",
        "state_update_descriptions": [
          "Remove Safe from `safes` mapping.",
          "Burn NFT associated with the Safe."
        ]
      },
      {
        "category": "Collateral",
        "state_update_descriptions": [
          "Decrease `totalCollateral`."
        ]
      },
      {
        "category": "Debt",
        "state_update_descriptions": [
          "Update `totalDebt` based on cumulative interest.",
          "Update `PROTOCOL_MODE` if necessary."
        ]
      },
      {
        "category": "ERC721",
        "state_update_descriptions": [
          "Update NFT owner to address(0).",
          "Decrease NFT balance of previous owner."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe",
        "rule_descriptions": [
          "`safes[safeId]` should not exist.",
          "`ownerOf(safeId)` should return `address(0)`."
        ]
      },
      {
        "category": "Collateral",
        "rule_descriptions": [
          "`totalCollateral` should decrease by the closed Safe's collateral amount."
        ]
      },
      {
        "category": "Debt",
        "rule_descriptions": [
          "`totalDebt` should reflect cumulative interest and repayments.",
          "If `totalDebt` is above `BOOTSTRAP_MODE_DEBT_THRESHOLD`, `PROTOCOL_MODE` should be `NORMAL`."
        ]
      },
      {
        "category": "ERC721",
        "rule_descriptions": [
          "`balanceOf(owner)` should decrease by 1."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the state of each Safe (CDP) in the system.",
            "why_is_is_important": "Maintaining an accurate mapping of active safes is crucial for tracking collateralization, debt, and user positions.  Deleting a safe ensures that closed positions are no longer considered in system calculations and prevents accidental interactions with a closed safe's data. Also, ensure borrowedAmount == 0, otherwise, the closing will fail and state update will not occur. That's why it's conditional. collateralAmount is also sent to msg.sender and this can be checked as well to validate the safe closure. totalCollateral is reduced by collateralAmount. The safe is then deleted using delete safes[_safeId]. This removes the mapping for the safe id. An event RemovedSafe is emitted to show the safe was closed, and _burn is called on the safe to remove the NFT associated with it. The NFT balances are also updated as part of the _burn call flow. Also totalCollateral is reduced by collateralAmount. This can be used to validate it as well. Before all this happens, updateSafe is called to update the safe state.",
            "when_is_it_updated": "Updated when a Safe is closed, removing the Safe's data.",
            "how_to_validate_state_update": "Check if the collateralAmount for the specified safeId has been transferred to the msg.sender. Also, check the event `SafeClosed` that emits the `safeId` and `refundedCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The Safe struct at safes[safeId] is deleted, effectively removing the Safe from the mapping.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt in the system.",
            "why_is_is_important": "Tracking total debt is essential for assessing the overall risk and health of the protocol. It helps in determining system-wide collateralization ratios and triggering necessary actions like liquidations or stability pool interventions. Changes to PROTOCOL_MODE influence system behavior based on the total debt level.",
            "when_is_it_updated": "Updated when a Safe's borrowed amount changes, reflecting accrued interest or adjustments to the debt level.",
            "how_to_validate_state_update": "Verify that totalDebt is updated correctly by checking the emitted SafeUpdated event, and verifying that it is now `totalDebt + debtIncrease` and that collateralIncrease is also correctly reflected in the event.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalDebt` is updated if the liquidation snapshot indicates a change in debt since the last update. It increases by debtIncrease if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`. If `PROTOCOL_MODE` is `BOOTSTRAP` and `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`, `PROTOCOL_MODE` is set to `NORMAL`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral held within the protocol.",
            "why_is_is_important": "Tracking total collateral is crucial for evaluating the system's solvency and ensuring adequate backing for the outstanding debt. It's a key input for calculating collateralization ratios and assessing the protocol's ability to withstand market volatility.",
            "when_is_it_updated": "Updated when a Safe's collateral amount changes, reflecting deposits, withdrawals, or adjustments due to price fluctuations.",
            "how_to_validate_state_update": "Verify that totalCollateral is updated correctly by checking the emitted SafeUpdated event, and verifying that it is now `totalCollateral + collateralIncrease`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalCollateral` is updated if the liquidation snapshot indicates a change in collateral since the last update. It increases by collateralIncrease if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operating mode of the protocol (e.g., `BOOTSTRAP`, `NORMAL`).",
            "why_is_is_important": "The protocol mode influences the behavior of certain functions or system parameters. Transitioning from `BOOTSTRAP` to `NORMAL` might enable or disable features based on the debt level and overall system stability.",
            "when_is_it_updated": "Updated when the total debt crosses the `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "how_to_validate_state_update": "Check if `PROTOCOL_MODE` is `NORMAL` after the function call, and if the condition `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD` was met.",
            "has_conditional_updates": true,
            "summary_of_update": "The `PROTOCOL_MODE` state variable is updated from `BOOTSTRAP` to `NORMAL` if the total debt exceeds the `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is currently in `BOOTSTRAP` mode.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the NFT balances of addresses. Used for ERC721 token ownership tracking.",
            "why_is_is_important": "Accurate tracking of NFT ownership is crucial for the proper functioning of the ERC721 token standard. Burning an NFT removes it from circulation and updates the ownership records to reflect this change.",
            "when_is_it_updated": "Updated when an NFT is burned using `_burn`, which is called during `closeSafe`.",
            "how_to_validate_state_update": "Check _balances, and _owners mappings. The _burn function calls the internal function _update which updates the _balances and _owners mappings. In particular the the NFT is transferred to the zero address and the balance is decreased.",
            "has_conditional_updates": false,
            "summary_of_update": "The `_burn` function effectively destroys the NFT associated with the Safe by transferring it to the zero address. This involves updating the `_balances` mapping (decreasing the previous owner's balance) and the `_owners` mapping (setting the owner to the zero address).",
            "conditions": [
              "None"
            ]
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of each NFT (tokenId). Used for ERC721 token ownership tracking.",
            "why_is_is_important": "Accurate tracking of NFT ownership is crucial for the proper functioning of the ERC721 token standard. Burning an NFT removes it from circulation and updates the ownership records to reflect this change.",
            "when_is_it_updated": "Updated when an NFT is transferred or burned using `_update`, which is called by `_burn` during `closeSafe`.",
            "how_to_validate_state_update": "Check _balances, and _owners mappings. The _burn function calls the internal function _update which updates the _balances and _owners mappings. In particular the the NFT is transferred to the zero address and the balance is decreased.",
            "has_conditional_updates": false,
            "summary_of_update": "The `_burn` function effectively destroys the NFT associated with the Safe by transferring it to the zero address. This involves updating the `_balances` mapping (decreasing the previous owner's balance) and the `_owners` mapping (setting the owner to the zero address).",
            "conditions": [
              "None"
            ]
          },
          {
            "state_variable_name": "_tokenApprovals",
            "type": "mapping",
            "what_does_it_track": "Tracks the approvals granted for each NFT (tokenId). Used for ERC721 token approvals.",
            "why_is_is_important": "Accurate tracking of NFT approvals is crucial for ensuring secure and authorized token transfers. Clearing approvals during burning prevents unintended or malicious use of prior approvals on a token that no longer exists.",
            "when_is_it_updated": "Updated when an NFT is approved, unapproved, transferred, or burned. Approval is cleared during burning via _update.",
            "how_to_validate_state_update": "Validate _tokenApprovals mapping. When burning (in `_burn` and `_update`) token approvals are cleared.",
            "has_conditional_updates": true,
            "summary_of_update": "The `_tokenApprovals` mapping is updated to clear any existing approvals for the token being burned. This ensures that no addresses retain approval rights over the burned token.",
            "conditions": [
              "auth != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}