{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` parameter must correspond to an existing Safe (CDP) owned by the user calling the `closeSafe` function.",
      "The Safe identified by `safeId` must have a `borrowedAmount` of 0. If the `borrowedAmount` is not 0, the transaction will revert.",
      "The user must be the owner of the Safe identified by `safeId`. The `_onlyOwner` modifier enforces this constraint."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Closure",
        "state_update_descriptions": [
          "The `safes` mapping at the index `safeId` is deleted, effectively removing the Safe from the system.",
          "The ERC721 token (NFT) representing the Safe (CDP) is burned, removing it from circulation."
        ]
      },
      {
        "category": "Safe Update",
        "state_update_descriptions": [
          "The cumulative debt and collateral per unit collateral are updated to account for changes since the last update of the safe.",
          "The borrowed amount of the safe is updated based on the cumulative debt and collateral per unit collateral.",
          "The collateral amount of the safe is updated based on the cumulative debt and collateral per unit collateral."
        ]
      },
      {
        "category": "Total Supply Update",
        "state_update_descriptions": [
          "The total collateral amount is decreased by the amount of collateral in the closed Safe.",
          "The total debt amount remains the same due to the `require(safe.borrowedAmount == 0)`."
        ]
      },
      {
        "category": "Collateral Transfer",
        "state_update_descriptions": [
          "The collateral amount is transferred from the contract to the user that called closeSafe."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Closure",
        "rule_descriptions": [
          "The Safe identified by `safeId` should be removed from the `safes` mapping. `safes[safeId]` should no longer contain any data.",
          "The Safe's collateral (identified by safeId) ERC721 token must be burned."
        ]
      },
      {
        "category": "Collateral Transfer",
        "rule_descriptions": [
          "The collateral amount associated with the closed Safe should be transferred back to the user who initiated the `closeSafe` function call.  The user's ETH balance should increase by the `collateralAmount`."
        ]
      },
      {
        "category": "Total Collateral Update",
        "rule_descriptions": [
          "The `totalCollateral` state variable should be decreased by the `collateralAmount` of the closed Safe. `totalCollateral` should be equal to the previous value minus the `collateralAmount`."
        ]
      },
      {
        "category": "Total Debt Update",
        "rule_descriptions": [
          "The `totalDebt` state variable should remain unchanged because the function requires `safe.borrowedAmount == 0`. If a safe is closed with `borrowedAmount > 0` then this function reverts. `totalDebt` will remain the same."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Updates the borrowed amount of a Safe based on cumulative debt per unit collateral.",
            "why_is_is_important": "Keeps the borrowed amount accurate and reflects the current debt situation for the Safe.",
            "when_is_it_updated": "When the cumulative collateral per unit collateral has changed since the last snapshot, indicating a change in the overall debt.",
            "how_to_validate_state_update": "Check if the borrowed amount has increased by the calculated debt increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases _safe.borrowedAmount by the calculated debt increase based on cumulative debt per unit collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Updates the total borrowed amount of a Safe.",
            "why_is_is_important": "Maintains an accurate record of the total borrowed amount for the Safe.",
            "when_is_it_updated": "When cumulative debt per unit collateral has changed.",
            "how_to_validate_state_update": "Check if the total borrowed amount has increased by the calculated debt increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases _safe.totalBorrowedAmount by the calculated debt increase.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Updates the debtPerCollateralSnapshot.",
            "why_is_is_important": "Stores the debt per collateral snapshot for accurate debt calculation over time.",
            "when_is_it_updated": "When the cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify that liquidationSnapshot.debtPerCollateralSnapshot is updated to the current cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates liquidationSnapshot.debtPerCollateralSnapshot to cumulativeDebtPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Updates the collateral amount of a Safe based on cumulative collateral per unit collateral.",
            "why_is_is_important": "Keeps the collateral amount accurate and reflects the current collateral situation for the Safe.",
            "when_is_it_updated": "When the cumulative collateral per unit collateral has changed.",
            "how_to_validate_state_update": "Check if the collateral amount has increased by the calculated collateral increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases _safe.collateralAmount by the calculated collateral increase.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Updates the collateralPerCollateralSnapshot.",
            "why_is_is_important": "Stores the collateral per collateral snapshot for accurate collateral calculation over time.",
            "when_is_it_updated": "When cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify that liquidationSnapshot.collateralPerCollateralSnapshot is updated to the current cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates liquidationSnapshot.collateralPerCollateralSnapshot to cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Updates the total collateral.",
            "why_is_is_important": "Maintains a global view of the total collateral in the system.",
            "when_is_it_updated": "When the cumulative collateral per unit collateral has changed.",
            "how_to_validate_state_update": "Check if totalCollateral has increased by the calculated collateral increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases totalCollateral by the calculated collateral increase.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Updates the total debt.",
            "why_is_is_important": "Maintains a global view of the total debt in the system.",
            "when_is_it_updated": "When cumulative debt per unit collateral has changed.",
            "how_to_validate_state_update": "Check if totalDebt has increased by the calculated debt increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases totalDebt by the calculated debt increase.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Updates the protocol mode.",
            "why_is_is_important": "Controls the operational mode of the protocol based on debt levels.",
            "when_is_it_updated": "When the total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD and the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Verify that PROTOCOL_MODE is updated to NORMAL when the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates PROTOCOL_MODE from BOOTSTRAP to NORMAL.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Updates totalCollateral.",
            "why_is_is_important": "Reflects the correct total collateral after a Safe is closed.",
            "when_is_it_updated": "When closing a Safe, totalCollateral will be reduced by the Safe's collateralAmount if the Safe's borrowedAmount is zero.",
            "how_to_validate_state_update": "Check if totalCollateral is reduced by safe.collateralAmount when the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalCollateral by safe.collateralAmount.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "Safe",
            "what_does_it_track": "Removes the Safe from the safes mapping.",
            "why_is_is_important": "Removes the Safe from the active safes mapping.",
            "when_is_it_updated": "Always, when the _removeSafe function is called during the closeSafe function.",
            "how_to_validate_state_update": "Verify that safes[_safeId] is deleted from the mapping.",
            "has_conditional_updates": false,
            "summary_of_update": "Deletes safes[_safeId] from the mapping.",
            "conditions": [
              "Always"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721",
        "state_updated": [
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "Decreases the balance of the previous owner of the NFT representing the Safe.",
            "why_is_is_important": "Maintains the correct NFT balance for the previous owner of the Safe NFT.",
            "when_is_it_updated": "When the Safe NFT is being transferred, and the previous owner is not the zero address. This occurs during the _burn function, which is called by _removeSafe.",
            "how_to_validate_state_update": "Check if the balance of the previous owner has decreased by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Decrements _balances[from] by 1.",
            "conditions": [
              "from != address(0)"
            ]
          },
          {
            "state_variable_name": "_balances[to]",
            "type": "uint256",
            "what_does_it_track": "Increases the balance of the new owner of the NFT representing the Safe. However, in the context of _burn, 'to' is address(0).",
            "why_is_is_important": "Maintains the correct NFT balance for the new owner of the Safe NFT.",
            "when_is_it_updated": "When the Safe NFT is being transferred to a new owner. However, in this case, during the _burn function, the Safe is being destroyed, so 'to' is address(0), and this condition is never met.",
            "how_to_validate_state_update": "Check if the balance of the new owner has increased by 1. However, this does not happen in closeSafe since 'to' is address(0).",
            "has_conditional_updates": true,
            "summary_of_update": "Increments _balances[to] by 1. This does not happen in closeSafe.",
            "conditions": [
              "to != address(0)"
            ]
          },
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "address",
            "what_does_it_track": "Updates the owner of the NFT representing the Safe to the zero address, effectively burning the NFT.",
            "why_is_is_important": "Removes the Safe NFT by assigning its ownership to the zero address.",
            "when_is_it_updated": "Always, when the _update function is called with 'to' set to address(0) during the _burn function called by _removeSafe.",
            "how_to_validate_state_update": "Verify that _owners[tokenId] is updated to address(0).",
            "has_conditional_updates": false,
            "summary_of_update": "Updates _owners[tokenId] to address(0).",
            "conditions": [
              "Always"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}