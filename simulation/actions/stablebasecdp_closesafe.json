{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "safeId: This parameter represents the ID of the Safe to be closed. It must be an existing Safe ID owned by the caller (msg.sender).  First, call `balanceOf(address owner)` with `msg.sender` as the owner, which returns the number of safes the owner has, then call `tokenOfOwnerByIndex(address owner, uint256 index)` with `msg.sender` as owner and an index within the range of the number of safes the owner has to get the safeId. ",
      "The Safe must have a borrowedAmount of 0, otherwise the transaction will revert. Check that `safes[safeId].borrowedAmount == 0` before execution.",
      "The caller (msg.sender) must be the owner of the Safe (safeId). Verify that `ownerOf(safeId) == msg.sender` before execution.",
      "Ensure that the contract is not in a paused or maintenance state that would prevent closing a Safe."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Closure",
        "state_update_descriptions": [
          "The specified safe (safes[safeId]) is removed from the safes mapping.",
          "The associated ERC721 token is burned (ownership transferred to address(0)), emitting a Transfer event with `to` address as `address(0)`.",
          "Collateral of the safe is transferred to the message sender (msg.sender)."
        ]
      },
      {
        "category": "Accounting Updates",
        "state_update_descriptions": [
          "Total collateral is decreased by the collateral amount of the closed safe (totalCollateral -= collateralAmount).",
          "Cumulative debt and collateral per unit collateral are updated based on the _updateSafe function, potentially adjusting the safe's borrowed amount and collateral amount before closing.",
          "Total debt is updated if _updateSafe modifies the borrowed amount.",
          "The liquidation snapshot for the safe is updated with the cumulative debt and collateral per unit collateral before the safe is closed."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "A SafeClosed event is emitted, indicating the safe has been closed.",
          "A RemovedSafe event is emitted, indicating the safe has been removed."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Closure Validation",
        "rule_descriptions": [
          "safes[safeId] should no longer exist in the safes mapping, i.e., accessing it should return default values.",
          "The totalCollateral should be decreased by the collateralAmount of the closed safe.",
          "The ERC721 token associated with the safeId should be burned and no longer owned by anyone.",
          "Check that the collateral amount has been transferred to the `msg.sender`."
        ]
      },
      {
        "category": "Accounting Validation",
        "rule_descriptions": [
          "The totalDebt should reflect any changes made by _updateSafe before closing.",
          "Cumulative debt and collateral per unit collateral should be correctly updated based on protocol operation."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "Verify that the SafeClosed event was emitted with the correct parameters (safeId, collateralAmount, totalCollateral, totalDebt).",
          "Verify that the RemovedSafe event was emitted with the correct parameters (safeId, safe).",
          "Verify that the `Transfer` event is emitted with the parameters that reflect the token is transferred to address `0`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId]",
            "type": "mapping",
            "what_does_it_track": "Tracks the Safe (CDP) information.",
            "why_is_is_important": "Maintains the list of active safes.",
            "when_is_it_updated": "When a Safe is closed.",
            "how_to_validate_state_update": "Check that safes[safeId].borrowedAmount is zero before proceeding.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the Safe from the safes mapping if the borrowed amount is zero.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral in the system.",
            "why_is_is_important": "Used for calculating the collateralization ratio and system health.",
            "when_is_it_updated": "When a Safe is closed.",
            "how_to_validate_state_update": "Verify that totalCollateral is decremented by the amount of collateral in the closed safe.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total collateral by the collateral amount of the closed Safe.",
            "conditions": []
          },
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount borrowed for the Safe.",
            "why_is_is_important": "Keeps track of debt changes.",
            "when_is_it_updated": "Before closing, adding or withdrawing collateral, borrowing or repaying debt.",
            "how_to_validate_state_update": "Verify that `_safe.borrowedAmount` is increased by `debtIncrease` if the condition is met. Also verify `_safe.totalBorrowedAmount` is increased by `debtIncrease`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount if the cumulative debt per unit collateral has changed since the last update.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral for the Safe.",
            "why_is_is_important": "Keeps track of collateral changes.",
            "when_is_it_updated": "Before closing, adding or withdrawing collateral, borrowing or repaying debt.",
            "how_to_validate_state_update": "Verify that `_safe.collateralAmount` is increased by `collateralIncrease` if the condition is met",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount if the cumulative collateral per unit collateral has changed since the last update.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operating mode of the protocol.",
            "why_is_is_important": "Controls certain protocol behaviors based on the total debt.",
            "when_is_it_updated": "When the total debt is updated.",
            "how_to_validate_state_update": "If `debt` is greater than `BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE` is `BOOTSTRAP`, then `PROTOCOL_MODE` must change to `NORMAL`.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the protocol from BOOTSTRAP mode to NORMAL mode if the total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral in the system.",
            "why_is_is_important": "Keeps track of changes in the total collateral.",
            "when_is_it_updated": "When a Safe is updated.",
            "how_to_validate_state_update": "Verify that `totalCollateral` is increased by `collateralIncrease` when the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral by the collateral increase.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Used for calculating the collateralization ratio and system health.",
            "when_is_it_updated": "When a Safe is updated, borrowed, or repaid.",
            "how_to_validate_state_update": "If `add` is true, then `totalDebt` should equal `currentDebt + delta`. Otherwise `totalDebt` should equal `currentDebt - delta`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt of the system.",
            "conditions": [
              "add == true"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721Base",
        "state_updated": [
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of each Safe's NFT.",
            "why_is_is_important": "Manages ownership of the Safe NFTs.",
            "when_is_it_updated": "When a Safe is closed.",
            "how_to_validate_state_update": "Check that `_owners[tokenId]` is set to address(0)",
            "has_conditional_updates": false,
            "summary_of_update": "Removes ownership of the Safe's NFT, effectively burning it.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[from]",
            "type": "mapping",
            "what_does_it_track": "Tracks the number of tokens owned by an address.",
            "why_is_is_important": "Maintains the token balance for each address.",
            "when_is_it_updated": "When a token is transferred or burned.",
            "how_to_validate_state_update": "If `from` is not address(0), then verify that `_balances[from]` is decremented by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the balance of the previous owner.",
            "conditions": [
              "from != address(0)"
            ]
          },
          {
            "state_variable_name": "_tokenApprovals[tokenId]",
            "type": "mapping",
            "what_does_it_track": "Tracks single-token approvals.",
            "why_is_is_important": "Manages approvals for individual tokens.",
            "when_is_it_updated": "When a token is transferred or burned.",
            "how_to_validate_state_update": "Check that `_tokenApprovals[tokenId]` is set to `address(0)`.",
            "has_conditional_updates": false,
            "summary_of_update": "Clears any existing approval for the token.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}