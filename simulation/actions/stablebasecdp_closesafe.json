{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "safeId: This should be an existing, valid safeId for which the user is the owner. Check that safes[safeId] exists and that ownerOf(safeId) == msg.sender.",
      "borrowedAmount: Verify that safes[safeId].borrowedAmount == 0. Safe cannot be closed if there is outstanding debt."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId] is deleted from the mapping."
        ]
      },
      {
        "category": "Collateral Transfer",
        "state_update_descriptions": [
          "collateralAmount belonging to the safe is transferred to the msg.sender.",
          "totalCollateral is decreased by safe.collateralAmount."
        ]
      },
      {
        "category": "NFT State",
        "state_update_descriptions": [
          "The NFT associated with the safeId is burned (ownership transferred to address(0))."
        ]
      },
      {
        "category": "Liquidation Snapshot and Borrowed Amount",
        "state_update_descriptions": [
          "Liquidation snapshots are updated with cumulative collateral and debt information.",
          "Borrowed amount of the safe might increase based on cumulative collateral and debt updates during the call to `_updateSafe`."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "totalDebt might be updated if there is any debt increase during the `_updateSafe` function due to cumulative updates."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Closure",
        "rule_descriptions": [
          "The Safe with safeId should be removed from the safes mapping, meaning safes[safeId] should not exist or return default values.",
          "The totalCollateral should be decreased by the collateralAmount of the closed Safe.",
          "The totalDebt should remain the same, accounting for potential debt increases in the `_updateSafe` function (due to cumulative updates), but should be equivalent to the debt before closing the safe plus any debt increase that occurred during `_updateSafe`."
        ]
      },
      {
        "category": "NFT Burning",
        "rule_descriptions": [
          "The NFT corresponding to the safeId should be burned, meaning the ownerOf(safeId) should return address(0)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt accumulated by the Safe.",
            "why_is_is_important": "Ensures that the debt is correctly calculated before closing the Safe.",
            "when_is_it_updated": "Before transferring collateral back to the user, only if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the difference between the current and previous borrowed amounts after the function execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of the Safe based on the difference between `cumulativeDebtPerUnitCollateral` and `liquidationSnapshot.debtPerCollateralSnapshot`.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "_safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt accumulated by the Safe.",
            "why_is_is_important": "Ensures that the total debt is correctly calculated before closing the Safe.",
            "when_is_it_updated": "Before transferring collateral back to the user, only if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the difference between the current and previous total borrowed amounts after the function execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of the Safe based on the difference between `cumulativeDebtPerUnitCollateral` and `liquidationSnapshot.debtPerCollateralSnapshot`.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral deposited in the Safe.",
            "why_is_is_important": "Ensures that the collateral is correctly calculated before closing the Safe.",
            "when_is_it_updated": "Before transferring collateral back to the user, only if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the difference between the current and previous collateral amounts after the function execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of the Safe based on the difference between `cumulativeCollateralPerUnitCollateral` and `liquidationSnapshot.collateralPerCollateralSnapshot`.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots.debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt per collateral snapshot for the Safe.",
            "why_is_is_important": "Maintains a snapshot of the debt per collateral for accurate calculations.",
            "when_is_it_updated": "Before transferring collateral back to the user, only if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the value of `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` after the function execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `liquidationSnapshot.debtPerCollateralSnapshot` to `cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots.collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral per collateral snapshot for the Safe.",
            "why_is_is_important": "Maintains a snapshot of the collateral per collateral for accurate calculations.",
            "when_is_it_updated": "Before transferring collateral back to the user, only if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the value of `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot` after the function execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `liquidationSnapshot.collateralPerCollateralSnapshot` to `cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system.",
            "why_is_is_important": "Maintains an accurate count of the total collateral.",
            "when_is_it_updated": "Before removing the Safe, only if `safe.borrowedAmount == 0`.",
            "how_to_validate_state_update": "Check the difference between the current and previous total collateral amounts after the function execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total collateral by the collateral amount of the Safe.",
            "conditions": [
              "`safe.borrowedAmount == 0`"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "Reflects the total outstanding debt in the system.",
            "when_is_it_updated": "If `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`",
            "how_to_validate_state_update": "Check totalDebt before and after the transaction. If the condition is met, totalDebt should increase by debtIncrease. If the condition is not met, totalDebt should remain unchanged.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalDebt by adding debtIncrease if the condition is met in _updateSafe.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "safes[safeId]",
            "type": "Safe",
            "what_does_it_track": "Individual Safe details.",
            "why_is_is_important": "Removes the Safe, freeing up storage.",
            "when_is_it_updated": "Always, when closing the safe.",
            "how_to_validate_state_update": "Check that `safes[safeId]` returns default values after execution.",
            "has_conditional_updates": false,
            "summary_of_update": "Deletes the safe from the `safes` mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "Manages the protocol's operating mode based on the total debt.",
            "when_is_it_updated": "If `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP` within _updateTotalDebt function.",
            "how_to_validate_state_update": "Check the value of `PROTOCOL_MODE` before and after the transaction. It should change from `BOOTSTRAP` to `NORMAL` if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes the `PROTOCOL_MODE` from `BOOTSTRAP` to `NORMAL`.",
            "conditions": [
              "`debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`"
            ]
          },
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "address",
            "what_does_it_track": "Ownership of the NFT representing the Safe.",
            "why_is_is_important": "Removes the NFT associated with the Safe.",
            "when_is_it_updated": "Always when _burn is called by _removeSafe.",
            "how_to_validate_state_update": "Call `ownerOf(safeId)` after execution; it should return the zero address.",
            "has_conditional_updates": false,
            "summary_of_update": "Sets the owner of the token associated with the `safeId` to the zero address, effectively burning the token.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "The number of tokens owned by a given address.",
            "why_is_is_important": "Maintains an accurate count of token ownership.",
            "when_is_it_updated": "Always when _burn is called by _removeSafe.",
            "how_to_validate_state_update": "Check that `balanceOf(previousOwner)` is decremented by 1 after execution.",
            "has_conditional_updates": false,
            "summary_of_update": "Decrements the balance of the previous owner in the `_balances` mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "_tokenApprovals[tokenId]",
            "type": "address",
            "what_does_it_track": "Approved address for a token.",
            "why_is_is_important": "Revokes any existing approvals for the token.",
            "when_is_it_updated": "Always when _burn is called by _removeSafe. This clears the approval.",
            "how_to_validate_state_update": "Call `getApproved(safeId)` after execution; it should return the zero address.",
            "has_conditional_updates": false,
            "summary_of_update": "Sets the approved address for the `safeId` to the zero address.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}