{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "safeId must correspond to an existing Safe (check safes[safeId] exists and is not already closed).",
      "msg.sender must be the owner of the Safe. The function has a modifier _onlyOwner(safeId) that checks this.",
      "The Safe's borrowedAmount must be 0. The function explicitly requires this before proceeding."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Update borrowed amount based on cumulative debt per unit collateral and liquidation snapshot. This may increase the borrowedAmount.",
          "Update collateral amount based on cumulative collateral per unit collateral and liquidation snapshot. This may increase the collateralAmount.",
          "Remove the Safe from the safes mapping using delete safes[safeId], making it inaccessible.",
          "Burn the NFT representing the Safe by calling _burn(safeId). This effectively destroys the NFT."
        ]
      },
      {
        "category": "Global State",
        "state_update_descriptions": [
          "Decrease totalCollateral by the safe's final collateralAmount (after any updates during _updateSafe).",
          "Update totalDebt based on any debt increase during the _updateSafe call (if any debt was added).",
          "Set PROTOCOL_MODE from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD. This only occurs once."
        ]
      },
      {
        "category": "Accounting and Balances",
        "state_update_descriptions": [
          "Transfer the safe's final collateralAmount (after any updates during _updateSafe) to msg.sender using a direct ETH transfer."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates liquidationSnapshot.debtPerCollateralSnapshot to cumulativeDebtPerUnitCollateral if they are different",
          "Updates liquidationSnapshot.collateralPerCollateralSnapshot to cumulativeCollateralPerUnitCollateral if they are different"
        ]
      },
      {
        "category": "NFT ownership",
        "state_update_descriptions": [
          "The NFT representing the safe is burned using _burn(safeId). This involves updating the owner mapping (_owners) to address(0) and decrementing the balance of the previous owner in _balances."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Closure",
        "rule_descriptions": [
          "safes[safeId] should no longer exist (attempting to read its properties should revert or return default values).",
          "The NFT representing the safe (tokenId equal to safeId) should no longer be owned by anyone (ownerOf(safeId) == address(0))."
        ]
      },
      {
        "category": "Collateral Transfer",
        "rule_descriptions": [
          "msg.sender's ETH balance should increase by the safe's final collateralAmount.",
          "totalCollateral should decrease by the safe's final collateralAmount."
        ]
      },
      {
        "category": "Debt State",
        "rule_descriptions": [
          "totalDebt should reflect any debt increase that occurred during the _updateSafe call prior to closure.  It may be unchanged or slightly higher."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A SafeClosed event should be emitted with the correct safeId, final collateralAmount, totalCollateral, and totalDebt.",
          "A RemovedSafe event should be emitted with the correct safeId and the safe's details (collateralAmount, borrowedAmount, etc. - BEFORE the safe is deleted, reflecting its state just prior to deletion).",
          "A Transfer event should be emitted with from equal to the owner of the Safe, to equal to address(0), and tokenId equal to safeId. This signifies the burning of the NFT."
        ]
      },
      {
        "category": "Debt State",
        "rule_descriptions": [
          "safe.borrowedAmount must be equal to 0 prior to calling this function."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt amount associated with a specific safe.",
            "why_is_is_important": "Ensures accurate debt tracking for each safe, reflecting changes in the overall system debt.",
            "when_is_it_updated": "Updated when the cumulative debt per unit collateral changes.",
            "how_to_validate_state_update": "Check if _safe.borrowedAmount is increased by the specified formula.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount of the safe is updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt borrowed by a Safe.",
            "why_is_is_important": "Reflects the total amount of debt ever borrowed by a safe. Used for tracking cumulative debt.",
            "when_is_it_updated": "Updated when the cumulative debt per unit collateral changes.",
            "how_to_validate_state_update": "Verify _safe.totalBorrowedAmount increases by the same amount as  _safe.borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total borrowed amount of the safe is incremented.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount of a Safe.",
            "why_is_is_important": "Maintains an accurate collateralization ratio for each safe.",
            "when_is_it_updated": "Updated when cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check that _safe.collateralAmount is increased by a specific amount. The amount should be (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)* _safe.collateralAmount / PRECISION",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount of the safe is updated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral deposited in the protocol.",
            "why_is_is_important": "Reflects the overall amount of collateral in the system and impacts system solvency.",
            "when_is_it_updated": "Updated when collateral amount of a safe is updated.",
            "how_to_validate_state_update": "Confirm that totalCollateral increases by the same amount as _safe.collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral in the system is increased.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Keeps track of the total debt in the protocol.",
            "why_is_is_important": "Used to calculate protocol solvency.",
            "when_is_it_updated": "Updated when debts are updated",
            "how_to_validate_state_update": "Ensure totalDebt is updated by calling the internal function _updateTotalDebt with the right parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt in the system is updated, by calling internal function",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral deposited in the protocol.",
            "why_is_is_important": "Reflects the overall amount of collateral in the system and impacts system solvency.",
            "when_is_it_updated": "Updated when collateral is withdrawn due to Safe closure.",
            "how_to_validate_state_update": "Check that totalCollateral is reduced by safe.collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral is reduced by collateralAmount of safe to be closed.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "struct",
            "what_does_it_track": "Stores the state of all active safes",
            "why_is_is_important": "Critical for managing and tracking all active safes.",
            "when_is_it_updated": "Updated when a safe is closed",
            "how_to_validate_state_update": "Verify that the 'safes' mapping at index _safeId is deleted, hence returning default values (zeroes).",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the Safe from the 'safes' mapping, effectively deleting the Safe's data.",
            "conditions": []
          },
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "address",
            "what_does_it_track": "The owner of an NFT",
            "why_is_is_important": "Used to verify ownership",
            "when_is_it_updated": "The NFT representing the safe is burned.",
            "how_to_validate_state_update": "Check that the owner of tokenId becomes zero address",
            "has_conditional_updates": false,
            "summary_of_update": "The owner of tokenId becomes zero address",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "ERC721A",
        "state_updated": [
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "The balance of an address",
            "why_is_is_important": "Used to determine the number of tokens owned by an address.",
            "when_is_it_updated": "When an NFT is being transfered or burned.",
            "how_to_validate_state_update": "Check that the balance of from address is reduced by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduce the balance of from address by 1",
            "conditions": [
              "from != address(0)"
            ]
          },
          {
            "state_variable_name": "_balances[to]",
            "type": "uint256",
            "what_does_it_track": "The balance of an address",
            "why_is_is_important": "Used to determine the number of tokens owned by an address.",
            "when_is_it_updated": "When an NFT is being transfered or minted.",
            "how_to_validate_state_update": "Check that the balance of to address is increased by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the balance of to address by 1",
            "conditions": [
              "to != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}