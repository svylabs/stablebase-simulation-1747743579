{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "The safeId must correspond to an existing Safe in the safes mapping.",
      "The borrowedAmount of the Safe must be 0.",
      "The address of the message sender (msg.sender) must be the owner of the Safe (checked by _onlyOwner modifier)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Data Update",
        "state_update_descriptions": [
          "Updates the borrowed amount based on cumulativeDebtPerUnitCollateral.",
          "Updates the collateral amount based on cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Global Debt Update",
        "state_update_descriptions": [
          "Updates the total debt of the protocol."
        ]
      },
      {
        "category": "Global Collateral Update",
        "state_update_descriptions": [
          "Updates the total collateral of the protocol."
        ]
      },
      {
        "category": "Safe Removal",
        "state_update_descriptions": [
          "Removes the Safe from the safes mapping.",
          "Burns the ERC721 token associated with the Safe."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfers the collateral amount to the message sender."
        ]
      },
      {
        "category": "ERC721 State Updates",
        "state_update_descriptions": [
          "Updates the owner of the ERC721 token representing the Safe to the zero address, effectively burning it.",
          "Updates balances of the previous owner and the zero address.",
          "Clears any approvals associated with the token."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "The Safe with the given safeId should no longer exist in the safes mapping.",
          "The ERC721 token associated with the safeId should no longer exist."
        ]
      },
      {
        "category": "Global State",
        "rule_descriptions": [
          "The total collateral should be decreased by the collateralAmount of the closed Safe.",
          "The total debt should reflect the debt removed from the closed Safe."
        ]
      },
      {
        "category": "Token Ownership",
        "rule_descriptions": [
          "The owner of the token ID corresponding to the safeId should be the zero address.",
          "The balance of the original owner should decrease by 1."
        ]
      },
      {
        "category": "User Balance",
        "rule_descriptions": [
          "The user (msg.sender) balance should increase by the collateralAmount of the closed Safe."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId]",
            "type": "mapping",
            "what_does_it_track": "Stores the Safe structs associated with each safeId, tracking collateral and borrowed amounts.",
            "why_is_is_important": "This mapping is crucial for tracking active CDPs and their associated debt/collateral. Removing a Safe signifies its closure and the release of collateral.",
            "when_is_it_updated": "Updated when a Safe is closed through the `closeSafe` function, removing the Safe from active management.",
            "how_to_validate_state_update": "Check if the safe with the given safeId no longer exists in the `safes` mapping.",
            "has_conditional_updates": true,
            "summary_of_update": "The Safe with ID `safeId` is removed from the `safes` mapping, effectively closing the CDP.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral across all active safes.",
            "why_is_is_important": "Reflects the total collateral backing the system, crucial for stability and solvency calculations.",
            "when_is_it_updated": "Updated when a Safe is closed by reducing the total collateral.",
            "how_to_validate_state_update": "Verify that the `totalCollateral` is reduced by the `collateralAmount` of the closed Safe.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral is decreased by the collateral amount of the closed safe.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount borrowed for specific safe.",
            "why_is_is_important": "Ensure the borrowed amount for a specific safe is up to date.",
            "when_is_it_updated": "During _updateSafe, when there is a difference in cumulativeDebtPerUnitCollateral",
            "how_to_validate_state_update": "Check that `_safe.borrowedAmount` and `_safe.totalBorrowedAmount` are increased by `debtIncrease` if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the borrowed amount if cumulativeDebtPerUnitCollateral has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total borrowed amount for specific safe.",
            "why_is_is_important": "Ensure the total borrowed amount for a specific safe is up to date.",
            "when_is_it_updated": "During _updateSafe, when there is a difference in cumulativeDebtPerUnitCollateral",
            "how_to_validate_state_update": "Check that `_safe.totalBorrowedAmount` is increased by `debtIncrease` if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the total borrowed amount if cumulativeDebtPerUnitCollateral has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount for specific safe.",
            "why_is_is_important": "Ensure the collateral amount for a specific safe is up to date.",
            "when_is_it_updated": "During _updateSafe, when there is a difference in cumulativeCollateralPerUnitCollateral",
            "how_to_validate_state_update": "Check that `_safe.collateralAmount` is increased by `collateralIncrease` if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the collateral amount if cumulativeCollateralPerUnitCollateral has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral.",
            "why_is_is_important": "Ensure the total collateral amount is up to date.",
            "when_is_it_updated": "During _updateSafe, when there is a difference in cumulativeCollateralPerUnitCollateral",
            "how_to_validate_state_update": "Check that `totalCollateral` is increased by `collateralIncrease` if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the totalCollateral if cumulativeCollateralPerUnitCollateral has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt.",
            "why_is_is_important": "Ensure the total debt amount is up to date.",
            "when_is_it_updated": "During _updateSafe, when there is a difference in cumulativeDebtPerUnitCollateral",
            "how_to_validate_state_update": "Check that `totalDebt` is increased by `debtIncrease` if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the totalDebt if cumulativeDebtPerUnitCollateral has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the protocol mode (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Controls the operational mode of the protocol, affecting borrowing and liquidation parameters.",
            "when_is_it_updated": "When the total debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD in the _updateTotalDebt function.",
            "how_to_validate_state_update": "Check that `PROTOCOL_MODE` is updated to NORMAL if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if debt crosses threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == 0"
            ]
          },
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "mapping",
            "what_does_it_track": "Mapping of token ID to owner address (for NFT functionality).",
            "why_is_is_important": "Maintains the ownership records for the NFT representation of the Safe.",
            "when_is_it_updated": "When a Safe is closed and the corresponding NFT needs to be burned.",
            "how_to_validate_state_update": "Check that `_owners[tokenId]` has been updated to address(0).",
            "has_conditional_updates": false,
            "summary_of_update": "Burns the NFT token associated with the safe by setting its owner to the zero address.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "_balances[from]",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each address.",
            "why_is_is_important": "Maintain ERC721 standard.",
            "when_is_it_updated": "During token burning.",
            "how_to_validate_state_update": "Check that `_balances[from]` has been decremented.",
            "has_conditional_updates": false,
            "summary_of_update": "Decrements the balance of the previous owner during token burning.",
            "conditions": [
              "from != address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}