{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing Safe owned by the transaction sender (`msg.sender`).",
      "The Safe's `borrowedAmount` must be 0. Closing a Safe with a non-zero borrowed amount will cause the transaction to revert.",
      "The `safeId` should be a valid, existing token ID in the ERC721 contract.",
      "The user calling `closeSafe` must be the owner of the Safe with the given `safeId`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "The `safes` mapping at `safeId` is deleted, effectively removing the Safe's data.",
          "The Safe's collateral is transferred to the msg.sender.",
          "The total collateral (`totalCollateral`) of the contract is decreased by the Safe's collateral amount.",
          "The Safe's borrowed amount and total borrowed amount is updated based on cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral.",
          "The total debt (`totalDebt`) is updated by debt increase or decrease amount.",
          "The NFT token associated with the Safe (tokenId == safeId) is burned, transferring ownership to address(0)."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "The liquidation snapshot is updated with new cumulative debt and collateral per unit collateral ratios."
        ]
      },
      {
        "category": "Token Ownership",
        "state_update_descriptions": [
          "The ownership of the NFT representing the safe is transferred to the zero address, effectively burning it."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE might be changed from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "ERC721 State",
        "state_update_descriptions": [
          "The balance of the owner is decreased by 1 if not burning a non-existent token. Owner of the token is set to zero address.",
          "The approval for the token id is cleared by setting _tokenApprovals[tokenId] to address(0)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Closure",
        "rule_descriptions": [
          "The `safes` mapping should no longer contain an entry for the provided `safeId`. `safes[safeId]` should return default values.",
          "The collateral amount previously associated with the Safe should have been transferred to the transaction sender (msg.sender).",
          "The contract's `totalCollateral` should be decreased by the amount of collateral that was in the closed Safe.",
          "The NFT representing the Safe (tokenId == safeId) should no longer exist (ownerOf(safeId) == address(0))."
        ]
      },
      {
        "category": "Debt Invariance",
        "rule_descriptions": [
          "The total debt should be accurately updated based on the debt increase or decrease amount."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `SafeClosed` event should be emitted, containing the `safeId`, the collateral amount, the final `totalCollateral`, and the final `totalDebt`.",
          "A `RemovedSafe` event should be emitted containing the `safeId` and the Safe struct."
        ]
      },
      {
        "category": "ERC721 State Validation",
        "rule_descriptions": [
          "The owner of the token with tokenId `safeId` should be the zero address (address(0)).",
          "The balance of the original owner should be decremented by 1.",
          "No approvals should exist for the token id `safeId`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt owed by the safe, adjusted for cumulative debt changes.",
            "why_is_is_important": "It's important to update the borrowed amount to reflect changes in the cumulative debt per unit collateral, ensuring accurate debt tracking.",
            "when_is_it_updated": "The `borrowedAmount` is updated when the cumulative collateral per unit collateral has changed since the last update for the safe.",
            "how_to_validate_state_update": "Check that `safe.borrowedAmount` increases by `(_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `borrowedAmount` of a safe is updated to account for accrued debt based on `cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt owed by the safe since the safe was opened, adjusted for cumulative debt changes.",
            "why_is_is_important": "It's important to update the total borrowed amount to reflect changes in the cumulative debt per unit collateral, ensuring accurate debt tracking.",
            "when_is_it_updated": "The `totalBorrowedAmount` is updated when the cumulative collateral per unit collateral has changed since the last update for the safe.",
            "how_to_validate_state_update": "Check that `safe.totalBorrowedAmount` increases by `(_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalBorrowedAmount` of a safe is updated to account for accrued debt based on `cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt per collateral snapshot.",
            "why_is_is_important": "It is crucial to update `debtPerCollateralSnapshot` to keep track of the `cumulativeDebtPerUnitCollateral` at the time of last update.",
            "when_is_it_updated": "The `cumulativeCollateralPerUnitCollateral` has changed since the last update for the safe.",
            "how_to_validate_state_update": "Check that `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` is updated to `cumulativeDebtPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The debt per collateral snapshot(`liquidationSnapshots[_safeId].debtPerCollateralSnapshot`) is updated with `cumulativeDebtPerUnitCollateral` when `cumulativeCollateralPerUnitCollateral` has changed since the last update.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in the safe, adjusted for cumulative collateral changes.",
            "why_is_is_important": "It's important to update the collateral amount to reflect changes in the cumulative collateral per unit collateral, ensuring accurate collateral tracking.",
            "when_is_it_updated": "The `collateralAmount` is updated when `cumulativeCollateralPerUnitCollateral` has changed since the last update for the safe.",
            "how_to_validate_state_update": "Verify that `safe.collateralAmount` increases by `(_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `collateralAmount` of a safe is updated to account for accrued collateral based on `cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral per collateral snapshot.",
            "why_is_is_important": "It is crucial to update `collateralPerCollateralSnapshot` to keep track of the `cumulativeCollateralPerUnitCollateral` at the time of last update.",
            "when_is_it_updated": "The `cumulativeCollateralPerUnitCollateral` has changed since the last update for the safe.",
            "how_to_validate_state_update": "Check that `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot` is updated to `cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral per collateral snapshot(`liquidationSnapshots[_safeId].collateralPerCollateralSnapshot`) is updated with `cumulativeCollateralPerUnitCollateral` when `cumulativeCollateralPerUnitCollateral` has changed since the last update.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks total collateral in the protocol.",
            "why_is_is_important": "It's important to update `totalCollateral` in sync with collateral changes of the safe.",
            "when_is_it_updated": "The `cumulativeCollateralPerUnitCollateral` has changed since the last update for the safe.",
            "how_to_validate_state_update": "Verify that `totalCollateral` increases by `(_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalCollateral` increases by `collateralIncrease` when the collateral per collateral snapshot is not equal to cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks total debt in the protocol.",
            "why_is_is_important": "It's important to update `totalDebt` in sync with debt changes of the safe.",
            "when_is_it_updated": "The `cumulativeCollateralPerUnitCollateral` has changed since the last update for the safe.",
            "how_to_validate_state_update": "Verify that `totalDebt` increases by `(_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalDebt` increases by `debtIncrease` when the collateral per collateral snapshot is not equal to cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total collateral in the protocol.",
            "why_is_is_important": "Total collateral is tracked to keep accounting of the total amount of collateral locked in the protocol.",
            "when_is_it_updated": "When the safe is closed, it is reduced by `collateralAmount` if `safe.borrowedAmount` is 0.",
            "how_to_validate_state_update": "Check that `totalCollateral` decreases by the value of `safe.collateralAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Total collateral is decreased when the safe is closed if it has no borrowed amount.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId]",
            "type": "Safe",
            "what_does_it_track": "Individual safe information.",
            "why_is_is_important": "Removing the safe avoids accounting for stale collateral or debt.",
            "when_is_it_updated": "When a safe is closed, the safe information associated with `safeId` is deleted.",
            "how_to_validate_state_update": "Attempt to read the safe using `safes[safeId]`. It should return default values",
            "has_conditional_updates": true,
            "summary_of_update": "The `safes` mapping is cleared for the given `safeId`.",
            "conditions": [
              "safeId is valid"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721Base",
        "state_updated": [
          {
            "state_variable_name": "_owners[safeId]",
            "type": "address",
            "what_does_it_track": "Ownership of the NFT representing the safe.",
            "why_is_is_important": "Burning the NFT prevents reuse or manipulation of the safe's representation.",
            "when_is_it_updated": "When a safe is closed, the corresponding NFT representing the safe is burned, and the ownership information is cleared.",
            "how_to_validate_state_update": "Check that `_owners[safeId]` returns `address(0)` after the safe is closed.",
            "has_conditional_updates": true,
            "summary_of_update": "The ownership of the NFT representing the safe is cleared.",
            "conditions": [
              "safeId is valid"
            ]
          },
          {
            "state_variable_name": "_balances[owner]",
            "type": "uint256",
            "what_does_it_track": "Token balance of the owner.",
            "why_is_is_important": "Update token balance when a safe is closed.",
            "when_is_it_updated": "When a safe is closed, the token balance of the owner is reduced",
            "how_to_validate_state_update": "Check that `_balances[owner]` decreases by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "The token balance of the owner is reduced by 1.",
            "conditions": [
              "safeId is valid"
            ]
          },
          {
            "state_variable_name": "_tokenApprovals[tokenId]",
            "type": "address",
            "what_does_it_track": "Token approval of a safe.",
            "why_is_is_important": "It prevents accidental calls to the safe.",
            "when_is_it_updated": "When a safe is closed, the token approval is reset.",
            "how_to_validate_state_update": "Check that `_tokenApprovals[safeId]` is set to `address(0)`.",
            "has_conditional_updates": true,
            "summary_of_update": "The token approval of the safe is reset to address(0).",
            "conditions": [
              "safeId is valid"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}