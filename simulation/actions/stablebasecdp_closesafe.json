{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing Safe in the `safes` mapping.",
      "The user calling `closeSafe` must be the owner of the Safe with the given `safeId`. This is enforced by the `_onlyOwner` modifier.",
      "The Safe's `borrowedAmount` must be 0. If it's not, the transaction will revert.",
      "Before execution, ensure the contract has enough collateral to cover the transfer of collateral to the user.",
      "The safe must have `borrowedAmount == 0` before it can be closed."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe",
        "state_update_descriptions": [
          "The `safes` mapping at `safeId` is deleted, effectively removing the Safe."
        ]
      },
      {
        "category": "Collateral Transfer",
        "state_update_descriptions": [
          "The Safe's collateral amount is transferred to the msg.sender (the Safe owner)."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "The total collateral amount is decreased by the collateral amount of the closed Safe (`totalCollateral -= collateralAmount`)."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "If `cumulativeCollateralPerUnitCollateral` or `cumulativeDebtPerUnitCollateral` have changed since the liquidation snapshot was taken, the `borrowedAmount` and `collateralAmount` of the safe are updated according to the formulas within `_updateSafe`."
        ]
      },
      {
        "category": "ERC721 Token",
        "state_update_descriptions": [
          "The ERC721 token associated with the Safe (identified by `safeId`) is burned, removing it from the owner."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "If cumulative debt and collateral have changed, the liquidationSnapshots are updated"
        ]
      },
      {
        "category": "Global State",
        "state_update_descriptions": [
          "The `PROTOCOL_MODE` might be changed from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "A `SafeClosed` event is emitted.",
          "A `RemovedSafe` event is emitted."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe",
        "rule_descriptions": [
          "The `safes` mapping at `safeId` should no longer exist (i.e., `safes[safeId]` should return default values)."
        ]
      },
      {
        "category": "Collateral Transfer",
        "rule_descriptions": [
          "The collateral amount that was in the Safe should have been transferred to the user's address, verified by checking the user's balance."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "The `totalCollateral` state variable should be decreased by the amount of collateral that was in the closed Safe."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "The `totalDebt` state variable should reflect the updated debt amount after accounting for any inactive debt increases or decreases."
        ]
      },
      {
        "category": "ERC721 Token",
        "rule_descriptions": [
          "The ERC721 token with ID `safeId` should no longer be owned by anyone. `ownerOf(safeId)` should return the zero address."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A `SafeClosed` event should be emitted, containing the `safeId` and the amount of collateral refunded to the owner.",
          "A `RemovedSafe` event should be emitted containing the `safeId` and the safe data."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral held by the protocol.",
            "why_is_is_important": "It reflects the total collateral held by the protocol. It is crucial for calculating the collateralization ratio and assessing the overall health of the system.",
            "when_is_it_updated": "It's updated when collateral is either removed from or added to a Safe during the `_updateSafe` function call. This happens only if there is a difference between `liquidationSnapshot.collateralPerCollateralSnapshot` and `cumulativeCollateralPerUnitCollateral` .",
            "how_to_validate_state_update": "Check the `SafeUpdated` and `SafeClosed` events, where the updated `totalCollateral` is emitted. Compare the value before and after the transaction. Also consider edge cases where cumulativeCollateralPerUnitCollateral might be zero.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral in the system is updated based on cumulative collateral changes.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes",
              "`liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt outstanding in the protocol.",
            "why_is_is_important": "It's important for tracking the overall debt in the system, which is crucial for determining the system's solvency and stability. Determines transition to NORMAL mode.",
            "when_is_it_updated": "It's updated in the `_updateSafe` function when debt is either added to or removed from a Safe. This occurs only if  `liquidationSnapshot.debtPerCollateralSnapshot != cumulativeDebtPerUnitCollateral` .",
            "how_to_validate_state_update": "Check the `SafeUpdated` and `SafeClosed` events to validate the change in `totalDebt`. Capture totalDebt prior and post transaction to validate delta. Check if PROTOCOL_MODE is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt in the system is updated based on cumulative debt changes.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes",
              "`liquidationSnapshot.debtPerCollateralSnapshot != cumulativeDebtPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "It indicates whether the protocol is in bootstrap mode or normal mode, affecting certain operations and parameters.",
            "when_is_it_updated": "It is updated in `_updateTotalDebt` function. `PROTOCOL_MODE` switches from `BOOTSTRAP` to `NORMAL` when `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD` .",
            "how_to_validate_state_update": "Check the value of `PROTOCOL_MODE` before and after the `closeSafe` transaction when `totalDebt` is near the `BOOTSTRAP_MODE_DEBT_THRESHOLD`. Inspect emitted events. Also, check the return value of the `mode()` function.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode may change from BOOTSTRAP to NORMAL if total debt exceeds a threshold.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes",
              "`debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`"
            ]
          },
          {
            "state_variable_name": "safes[safeId]",
            "type": "Safe",
            "what_does_it_track": "Data associated with a specific Safe.",
            "why_is_is_important": "Stores the safe information and important for tracking collateral, borrowed amounts, and other parameters related to individual safes.",
            "when_is_it_updated": "It is deleted in `_removeSafe` .",
            "how_to_validate_state_update": "Check if the specific safe is deleted after the transaction by calling `safes(safeId)` after the closeSafe transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The Safe's data is deleted from the `safes` mapping.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId]",
            "type": "LiquidationSnapshot",
            "what_does_it_track": "Snapshot of collateral and debt per collateral for a Safe at a specific point in time.",
            "why_is_is_important": "It is a mapping which stores the debtPerCollateralSnapshot and collateralPerCollateralSnapshot. Important for calculating debt and collateral increases.",
            "when_is_it_updated": "The values are deleted when _removeSafe is called .",
            "how_to_validate_state_update": "After calling `closeSafe`, check `liquidationSnapshots[safeId]` which should return default values (likely 0 for all fields).",
            "has_conditional_updates": false,
            "summary_of_update": "The liquidation snapshot for a Safe is deleted upon closing.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721",
        "state_updated": [
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "address",
            "what_does_it_track": "The owner of a specific Safe's NFT representation.",
            "why_is_is_important": "Maintains a record of token ownership, and the `_burn` function is called in `_removeSafe` when closing a Safe.",
            "when_is_it_updated": "The owner is updated to address(0) in the `_update` function that is called in `_burn` .",
            "how_to_validate_state_update": "Call `ownerOf(safeId)` after `closeSafe` and confirm it returns `address(0)`. Also, check for the `Transfer` event with `to` as `address(0)`.",
            "has_conditional_updates": false,
            "summary_of_update": "The ownership of the NFT is transferred to the zero address (burned).",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes"
            ]
          },
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "The number of tokens owned by a particular address.",
            "why_is_is_important": "Tracks the number of tokens owned by an address.",
            "when_is_it_updated": "Decremented when a token is burned in the `_update` function.  Balances[from] -= 1 where from is the previous owner .",
            "how_to_validate_state_update": "Call `balanceOf(previousOwner)` before and after `closeSafe`. Ensure the balance decreases by 1.",
            "has_conditional_updates": false,
            "summary_of_update": "The token balance of the previous owner decreases.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes"
            ]
          },
          {
            "state_variable_name": "_tokenApprovals[tokenId]",
            "type": "address",
            "what_does_it_track": "Approved address for a specific token.",
            "why_is_is_important": "Stores approved addresses for a token.",
            "when_is_it_updated": "Cleared in `_approve` when a token is burned .",
            "how_to_validate_state_update": "Call `getApproved(safeId)` after `closeSafe`. It should return `address(0)`.",
            "has_conditional_updates": false,
            "summary_of_update": "The approved address for the Safe's NFT is cleared.",
            "conditions": [
              "Safe exists (safeId is valid)",
              "Safe.borrowedAmount == 0",
              "_onlyOwner check passes"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}