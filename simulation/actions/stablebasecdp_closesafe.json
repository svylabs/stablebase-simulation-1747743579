{
  "action": {
    "name": "Close Safe",
    "summary": "Closes an existing CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "probability": 0.3
  },
  "action_detail": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing Safe in the `safes` mapping.",
      "The caller (`msg.sender`) must be the owner of the Safe with the given `safeId`.",
      "The `borrowedAmount` of the Safe must be 0.  If not, the transaction will revert.",
      "Ensure that the contract has enough balance to pay back the collateral to the safe owner. Otherwise, the transfer will fail."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Closure",
        "state_update_descriptions": [
          "Updates the safe's borrowed and collateral amounts based on cumulative debt and collateral per unit (using _updateSafe).",
          "Removes the Safe from the `safes` mapping by deleting the entry at the given `safeId`.",
          "Burns the NFT associated with the `safeId`."
        ]
      },
      {
        "category": "System Debt and Collateral",
        "state_update_descriptions": [
          "Updates the `totalCollateral` by subtracting the collateral amount of the closed Safe.",
          "Updates the `totalDebt` based on any debt increase calculated during the `_updateSafe` call.",
          "Updates the liquidation snapshot for the safe, storing the current cumulative debt and collateral per unit for future calculations."
        ]
      },
      {
        "category": "NFT Ownership",
        "state_update_descriptions": [
          "Transfers the NFT associated with the Safe to the zero address, effectively burning it.",
          "Decrements the balance of the previous owner of the NFT."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Closure",
        "rule_descriptions": [
          "Validate that `safes[safeId]` is deleted, meaning the Safe no longer exists in the mapping.",
          "Validate that the NFT associated with `safeId` is burned, and its owner is the zero address (check using ownerOf(safeId))."
        ]
      },
      {
        "category": "System Debt and Collateral",
        "rule_descriptions": [
          "Validate that `totalCollateral` has been reduced by the collateral amount of the closed Safe.",
          "Validate that `totalDebt` has been updated correctly, accounting for any debt increase during the `_updateSafe` call.",
          "If the `PROTOCOL_MODE` was `BOOTSTRAP`, ensure that it has switched to `NORMAL` if `totalDebt` exceeds the `BOOTSTRAP_MODE_DEBT_THRESHOLD`."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "Validate that a `SafeClosed` event is emitted, containing the `safeId`, `collateralAmount`, updated `totalCollateral`, and updated `totalDebt`.",
          "Validate that a `RemovedSafe` event is emitted, containing the `safeId` and the `Safe` struct data.",
          "Validate that a `Transfer` event is emitted, indicating the NFT was transferred to the zero address."
        ]
      },
      {
        "category": "Balance Transfer",
        "rule_descriptions": [
          "Validate that the collateral amount of the closed Safe has been transferred to the `msg.sender`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Close Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "closeSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Stores all the safes",
            "why_is_is_important": "It is important to ensure that closed safes are removed to prevent reuse and maintain data integrity.",
            "when_is_it_updated": "When a safe is closed after repaying all borrowed amount.",
            "how_to_validate_state_update": "Check if the safe with safeId has been removed from the safes mapping and the collateralAmount has been transferred to msg.sender",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the Safe from the mapping `safes`, essentially deleting the Safe's data associated with safeId.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system.",
            "why_is_is_important": "Reflects the total collateral backing the system, crucial for calculating collateralization ratios and assessing system health.",
            "when_is_it_updated": "When a safe is closed.",
            "how_to_validate_state_update": "Check if `totalCollateral` is reduced by the safe's `collateralAmount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases `totalCollateral` by the `collateralAmount` of the closed safe.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks the liquidation snapshot details for a given `safeId`.",
            "why_is_is_important": "Ensures accurate debt and collateral calculations for liquidation purposes, preventing incorrect liquidations.",
            "when_is_it_updated": "The `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` are updated when the current cumulative values do not match liquidationSnapshot values, indicating changes since the last update.",
            "how_to_validate_state_update": "Verify that `_safe.borrowedAmount`, `_safe.totalBorrowedAmount` are increased by calculated `debtIncrease`, `liquidationSnapshot.debtPerCollateralSnapshot` is updated to `cumulativeDebtPerUnitCollateral`, `_safe.collateralAmount` is increased by `collateralIncrease`, `liquidationSnapshot.collateralPerCollateralSnapshot` is updated to `cumulativeCollateralPerUnitCollateral`, `totalCollateral` increased by `collateralIncrease`, and `totalDebt` is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt and collateral amounts of a Safe based on cumulative snapshots if they are out of sync. Updates `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` with cumulative values.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt in the system.",
            "why_is_is_important": "Critical for maintaining solvency and triggering protocol mode changes based on debt levels.",
            "when_is_it_updated": "When debt is added or subtracted, primarily during borrowing, repaying, or liquidations.",
            "how_to_validate_state_update": "If `add` is true, debt increases by `delta`, otherwise debt decreases by `delta`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt of the protocol, potentially triggering a mode change from BOOTSTRAP to NORMAL if the debt exceeds a threshold.",
            "conditions": [
              "add == true"
            ]
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of each token ID.",
            "why_is_is_important": "It is important for the ERC721 token accounting and preventing the safe from being used again.",
            "when_is_it_updated": "When a Safe is closed.",
            "how_to_validate_state_update": "Check if `_owners[tokenId]` is set to `address(0)` and `_balances` is decremented.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns the ERC721 token associated with the Safe by setting the owner to `address(0)`.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of tokens owned by each address.",
            "why_is_is_important": "Maintains the token balances of different owners.",
            "when_is_it_updated": "During token transfers.",
            "how_to_validate_state_update": "Check if `_balances` is decremented for the previous owner and incremented for the new owner.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the balance of the previous and current owners of the token.",
            "conditions": []
          },
          {
            "state_variable_name": "_tokenApprovals",
            "type": "mapping",
            "what_does_it_track": "Tracks the approved address for a specific token ID.",
            "why_is_is_important": "Maintains the token approvals.",
            "when_is_it_updated": "During token transfers.",
            "how_to_validate_state_update": "Check if approval is cleared for the token.",
            "has_conditional_updates": true,
            "summary_of_update": "Clears the approval for a token when it's transferred or updated.",
            "conditions": [
              "auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function closeSafe(uint256 safeId) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(\n            safe.borrowedAmount == 0,\n            \"Cannot close Safe with borrowed amount\"\n        );\n        uint256 collateralAmount = safe.collateralAmount;\n        totalCollateral -= collateralAmount; // Should we need this or not\n        // Remove the Safe from the mapping\n        _removeSafe(safeId);\n        emit SafeClosed(safeId, collateralAmount, totalCollateral, totalDebt);\n        (bool success, ) = msg.sender.call{value: collateralAmount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}