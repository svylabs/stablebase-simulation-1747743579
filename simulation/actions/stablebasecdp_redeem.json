{
  "action": {
    "name": "Redeem",
    "summary": "Redeems debt.",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "pre_execution_parameter_generation_rules": [
      "amount: A positive integer representing the amount of SBD to redeem. This should be a reasonable amount based on the user's SBD balance.",
      "nearestSpotInLiquidationQueue: A uint256 representing a hint for the location of a safe in the liquidation queue. This can be 0 or a safe ID in the queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "SBD Token Transfers",
        "state_update_descriptions": [
          "SBD tokens are transferred from the message sender to the contract.",
          "SBD tokens are burned from the contract if redeemedAmount > refundedAmount.",
          "SBD tokens are transferred to the safe owner if stabilityPool cannot receive rewards and amountToRefund - ownerFee > 0. A fee is paid for this transfer."
        ]
      },
      {
        "category": "Collateral Updates",
        "state_update_descriptions": [
          "totalCollateral is decreased by collateralAmount + redeemerFee.",
          "Collateral is sent to the msg.sender as a value transfer."
        ]
      },
      {
        "category": "Total Debt Updates",
        "state_update_descriptions": [
          "totalDebt is decreased by redeemedAmount - refundedAmount."
        ]
      },
      {
        "category": "Safe Updates",
        "state_update_descriptions": [
          "The targeted safe's collateralAmount and borrowedAmount are decreased.",
          "Safes can be removed from the liquidation and redemption queues if their borrowedAmount and collateralAmount is close to zero.",
          "Safes can have their position updated in the liquidation queue if their state has been updated."
        ]
      },
      {
        "category": "Redemption Updates",
        "state_update_descriptions": [
          "The redemption's collateralAmount, redeemedAmount and refundedAmount are updated.",
          "Owner fee can be transferred to the stability pool as reward, or sent to the safe owner.",
          "Redeemer fee can be sent to the stability pool as collateral reward, or sent directly to redeemer."
        ]
      },
      {
        "category": "Liquidation Snapshot Updates",
        "state_update_descriptions": [
          "Liquidation snapshots for the safe are updated with cumulative debt and collateral per unit collateral."
        ]
      },
      {
        "category": "Protocol Mode Updates",
        "state_update_descriptions": [
          "PROTOCOL_MODE may be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Redemption Success",
        "rule_descriptions": [
          "redemption.redeemedAmount must equal amount."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "totalCollateral must be decreased by the amount of collateral sent to the redeemer + redeemer fee."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "totalDebt must be decreased by the amount of SBD burned (redeemedAmount - refundedAmount)."
        ]
      },
      {
        "category": "Safe State",
        "rule_descriptions": [
          "If a safe's borrowedAmount is 0 in borrow mode, or collateralAmount is close to zero and borrowedAmount is 0 in exchange mode, it must be removed from both liquidation and redemption queues.",
          "If a safe is not removed, its position in the liquidation queue must be updated based on the new collateral to debt ratio."
        ]
      },
      {
        "category": "SBD Token Balance",
        "rule_descriptions": [
          "The contract's SBD token balance must be decreased by the amount burned (redeemedAmount - refundedAmount)."
        ]
      },
      {
        "category": "Vault State",
        "rule_descriptions": [
          "Vault's collateralAmount and borrowedAmount are decreased by respective amounts.",
          "If vault is completely redeemed it should be removed from queue."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "redemptionId",
        "type": "random_id",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for each redemption request."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral held by the protocol.",
            "why_is_is_important": "Reflects the overall health and collateralization ratio of the system.",
            "when_is_it_updated": "When debt is redeemed for collateral, reducing overall collateral.",
            "how_to_validate_state_update": "Check that totalCollateral is decreased by (collateralAmount + redeemerFee). Verify event 'RedeemedBatch' with correct parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total collateral in the protocol.",
            "conditions": [
              "amount > 0",
              "sbdToken.transferFrom succeeds",
              "PROTOCOL_MODE == SBStructs.Mode.NORMAL"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt in the protocol.",
            "why_is_is_important": "Reflects the overall risk and solvency of the system.",
            "when_is_it_updated": "When debt is redeemed, reducing overall debt.",
            "how_to_validate_state_update": "Check that totalDebt is decreased by (redeemedAmount - refundedAmount). Verify event 'RedeemedBatch' with correct parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total debt in the protocol.",
            "conditions": [
              "amount > 0",
              "sbdToken.transferFrom succeeds",
              "PROTOCOL_MODE == SBStructs.Mode.NORMAL"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "Safe",
            "what_does_it_track": "Tracks the collateral and debt associated with individual safes.",
            "why_is_is_important": "Ensures accurate accounting of individual safe positions.",
            "when_is_it_updated": "Updated before redemption to reflect accrued interest and collateral changes.",
            "how_to_validate_state_update": "Verify that borrowedAmount and totalBorrowedAmount of the safe are increased by debtIncrease. Also verify that collateralAmount of the safe is increased by collateralIncrease. Check that liquidationSnapshot.debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral. Check that event `SafeUpdated` is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount and collateral amount of a specific safe based on cumulative interest.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "Safe exists"
            ]
          },
          {
            "state_variable_name": "ownerOf(_safeId)",
            "type": "address",
            "what_does_it_track": "Tracks the owner of the safe.",
            "why_is_is_important": "To refund the owner of the safe based on the amount of stablecoins that are left after debt is repaid.",
            "when_is_it_updated": "When the owner of the safe is to be refunded.",
            "how_to_validate_state_update": "Verify that sbdToken.transfer is called to transfer (amountToRefund - ownerFee) to the ownerOf(_safeId). Check that event `OwnerRefunded` is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Refund stablecoins back to the owner of the safe.",
            "conditions": [
              "amountToRefund > 0",
              "amountToRefund > ownerFee",
              "sbdToken.transfer succeeds"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "Tracks the fee paid by the safe owner.",
            "why_is_is_important": "To keep track of fees paid by the owner of the safe.",
            "when_is_it_updated": "When the owner fee is paid.",
            "how_to_validate_state_update": "Verify that safe.feePaid is reset to 0, and safe.totalBorrowedAmount is set to 1. Verify that event `OwnerFeePaid` is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset the fee paid by the safe owner.",
            "conditions": [
              "ownerFee > 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Maintains an ordered list of safes for liquidation purposes.",
            "why_is_is_important": "Maintains the integrity and order of the liquidation queue.",
            "when_is_it_updated": "Updated when a safe is fully redeemed or closed.",
            "how_to_validate_state_update": "Verify that safesOrderedForLiquidation.remove(safeId) and safesOrderedForRedemption.remove(safeId) are called. Check that events `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` are emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes safe from the liquidation queue if it's fully redeemed or closed.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Maintains an ordered list of safes for redemption purposes.",
            "why_is_is_important": "Maintains the integrity and order of the redemption queue.",
            "when_is_it_updated": "Updated when a safe is fully redeemed or closed.",
            "how_to_validate_state_update": "Verify that safesOrderedForLiquidation.remove(safeId) and safesOrderedForRedemption.remove(safeId) are called. Check that events `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` are emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes safe from the redemption queue if it's fully redeemed or closed.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Maintains an ordered list of safes for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Ensures the liquidation queue remains accurate and up-to-date.",
            "when_is_it_updated": "Updated when the collateralization ratio changes due to redemption.",
            "how_to_validate_state_update": "Verify that safesOrderedForLiquidation.upsert is called with the safeId and the newRatio. Check that event `LiquidationQueueUpdated` is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue with the new collateralization ratio.",
            "conditions": [
              "safe.borrowedAmount != 0 && borrowMode",
              "!closeToZero(safe.collateralAmount) && safe.borrowedAmount != 0"
            ]
          },
          {
            "state_variable_name": "stabilityPool",
            "type": "IStabilityPool",
            "what_does_it_track": "The contract that handles the stability pool.",
            "why_is_is_important": "To send the fees to the stability pool.",
            "when_is_it_updated": "When the redemption.ownerFee > 0 and the stability pool can receive rewards.",
            "how_to_validate_state_update": "Verify that stabilityPool.addReward is called with redemption.ownerFee. Check that event `OwnerRedemptionFeeDistributed` is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Send the owner fee to the stability pool.",
            "conditions": [
              "redemption.ownerFee > 0",
              "stabilityPoolCanReceiveRewards",
              "stabilityPool.addReward succeeds"
            ]
          },
          {
            "state_variable_name": "msg.sender",
            "type": "address",
            "what_does_it_track": "The address of the message sender.",
            "why_is_is_important": "To refund the owner fee to the user who initiated the redeem action.",
            "when_is_it_updated": "when the owner fee is greater than 0, and the stability pool cannot receive rewards.",
            "how_to_validate_state_update": "Verify that sbdToken.transfer is called with msg.sender and redemption.ownerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Refund the owner fee to the message sender when stabilityPoolCanReceiveRewards is false",
            "conditions": [
              "redemption.ownerFee > 0",
              "!stabilityPoolCanReceiveRewards",
              "sbdToken.transfer succeeds"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the operational mode of the protocol.",
            "why_is_is_important": "Governs protocol behavior and safety mechanisms.",
            "when_is_it_updated": "Updated when total debt exceeds a predefined threshold during bootstrap mode.",
            "how_to_validate_state_update": "Verify that PROTOCOL_MODE is set to SBStructs.Mode.NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Transition the protocol from bootstrap mode to normal mode if debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Amount of collateral deposited in a specific safe.",
            "why_is_is_important": "Reflects the accurate collateralization of each safe.",
            "when_is_it_updated": "When collateral is redeemed.",
            "how_to_validate_state_update": "safe.collateralAmount -= collateralToRedeem; safe.borrowedAmount -= amountToRedeem; safes[_safeId] = safe;",
            "has_conditional_updates": false,
            "summary_of_update": "Decrease the collateral amount of the safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount borrowed against a specific safe.",
            "why_is_is_important": "Reflects the accurate outstanding debt for each safe.",
            "when_is_it_updated": "When debt is redeemed.",
            "how_to_validate_state_update": "safe.collateralAmount -= collateralToRedeem; safe.borrowedAmount -= amountToRedeem; safes[_safeId] = safe;",
            "has_conditional_updates": false,
            "summary_of_update": "Decrease the borrowed amount of the safe.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "Maintains the overall supply and value of the SBD token.",
            "when_is_it_updated": "Updated when SBD is burned during redemption.",
            "how_to_validate_state_update": "Verify that sbdToken.burn is called with address(this) and (_redemption.redeemedAmount - _redemption.refundedAmount). Check event `Burn`.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens, decreasing the total supply.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount",
              "sbdToken.burn succeeds"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD balance of a user.",
            "why_is_is_important": "Accurately reflects a user's SBD holdings.",
            "when_is_it_updated": "When a user redeems SBD, it is transferred from their balance.",
            "how_to_validate_state_update": "Verify that sbdToken.transferFrom is called with msg.sender, address(this), and amount",
            "has_conditional_updates": true,
            "summary_of_update": "Decrease SBD balance of msg.sender.",
            "conditions": [
              "sbdToken.transferFrom succeeds"
            ]
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD balance of the contract.",
            "why_is_is_important": "Accurately reflects the contract's SBD holdings.",
            "when_is_it_updated": "When a user redeems SBD, it is transferred to the contract.",
            "how_to_validate_state_update": "Verify that sbdToken.transferFrom is called with msg.sender, address(this), and amount",
            "has_conditional_updates": true,
            "summary_of_update": "Increase SBD balance of the contract.",
            "conditions": [
              "sbdToken.transferFrom succeeds"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[safeId]",
            "type": "Node",
            "what_does_it_track": "Represents a node in the doubly linked list, storing value (e.g., collateralization ratio), previous, and next pointers.",
            "why_is_is_important": "Maintains the integrity of the doubly linked list used for ordering safes for liquidation or redemption.",
            "when_is_it_updated": "When a safe is fully redeemed or closed, and its corresponding node is removed from the list.",
            "how_to_validate_state_update": "Inspect the doubly linked list to confirm the node associated with safeId has been removed. Check the previous and next pointers of adjacent nodes are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a node from the doubly linked list, representing a safe being fully redeemed or closed.",
            "conditions": [
              "Safe is removed from queue"
            ]
          },
          {
            "state_variable_name": "nodes[safeId]",
            "type": "Node",
            "what_does_it_track": "Represents a node in the doubly linked list, storing value (e.g., collateralization ratio), previous, and next pointers.",
            "why_is_is_important": "Maintains the accurate ordering of safes based on their collateralization ratio for liquidation or redemption.",
            "when_is_it_updated": "When a safe's collateralization ratio changes, requiring its node to be updated and re-inserted.",
            "how_to_validate_state_update": "Confirm the node associated with safeId has its value updated to the new collateralization ratio. Inspect the previous and next pointers to ensure correct ordering within the list.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates a node's value (collateralization ratio) in the doubly linked list and re-inserts it to maintain order.",
            "conditions": [
              "Safe is updated in queue"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first node in the doubly linked list.",
            "why_is_is_important": "To keep track of the head of the linked list.",
            "when_is_it_updated": "When the head node is removed.",
            "how_to_validate_state_update": "Verify that head is updated if the safe being removed is the head node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the head node is removed.",
            "conditions": [
              "safesOrderedForLiquidation.remove(safeId)"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last node in the doubly linked list.",
            "why_is_is_important": "To keep track of the tail of the linked list.",
            "when_is_it_updated": "When the tail node is removed.",
            "how_to_validate_state_update": "Verify that tail is updated if the safe being removed is the tail node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the tail node is removed.",
            "conditions": [
              "safesOrderedForLiquidation.remove(safeId)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of reward per token.",
            "why_is_is_important": "To calculate the amount of reward per token.",
            "when_is_it_updated": "when the owner fee is greater than 0 and the stability pool can receive rewards",
            "how_to_validate_state_update": "Verify that stakingToken.transferFrom is called with address(this) and _amount. Also verify that the reward per token, totalRewardPerToken, and rewardLoss are updated correctly. Check the event `RewardAdded`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the total reward per token.",
            "conditions": [
              "redemption.ownerFee > 0",
              "stabilityPoolCanReceiveRewards",
              "stakingToken.transferFrom succeeds",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral per token.",
            "why_is_is_important": "To calculate the amount of collateral per token.",
            "when_is_it_updated": "when the redeemer fee is greater than 0 and the stability pool can receive rewards",
            "how_to_validate_state_update": "Verify that the totalCollateralPerToken, and collateralLoss are updated correctly. Check the event `CollateralRewardAdded`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the total collateral per token.",
            "conditions": [
              "redemption.redeemerFee > 0",
              "stabilityPoolCanReceiveRewards",
              "msg.value == amount",
              "totalStakedRaw > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function redeem(\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external onlyInNormalMode {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), amount),\n            \"Unable to transfer SBD\"\n        );\n        uint256 price = priceOracle.fetchPrice();\n        uint256 redemptionId = uint256(\n            keccak256(\n                abi.encode(\n                    msg.sender,\n                    amount,\n                    block.number,\n                    safesOrderedForRedemption.getHead()\n                )\n            )\n        );\n\n        SBStructs.Redemption memory _redemption = SBStructs.Redemption({\n            redemptionId: redemptionId,\n            requestedAmount: amount,\n            price: price,\n            redeemedAmount: 0,\n            refundedAmount: 0,\n            processedSpots: 0,\n            collateralAmount: 0,\n            ownerFee: 0,\n            redeemerFee: 0\n        });\n\n        _redemption = _redeemSafes(_redemption, nearestSpotInLiquidationQueue);\n        _redeemToUser(_redemption);\n        totalCollateral -= (_redemption.collateralAmount +\n            _redemption.redeemerFee);\n        require(_redemption.redeemedAmount == amount, \"Redemption failed\");\n        //totalDebt -= _redemption.redeemedAmount;\n        _updateTotalDebt(\n            totalDebt,\n            _redemption.redeemedAmount - _redemption.refundedAmount,\n            false\n        );\n        if (_redemption.redeemedAmount > _redemption.refundedAmount) {\n            require(\n                sbdToken.burn(\n                    address(this),\n                    _redemption.redeemedAmount - _redemption.refundedAmount\n                ),\n                \"Burn failed\"\n            );\n        }\n\n        emit RedeemedBatch(\n            redemptionId,\n            amount,\n            _redemption.collateralAmount,\n            price,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _redeemSafes(\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (SBStructs.Redemption memory) {\n        uint256 processedSpots = redemption.processedSpots;\n        // Target within 1% = 100 points, 100% = 10000 points\n        while (redemption.redeemedAmount < redemption.requestedAmount) {\n            //uint256 spotForUpdate = 0;\n            uint256 head = safesOrderedForRedemption.getHead();\n            (, redemption) = _redeemNode(\n                head,\n                redemption,\n                nearestSpotInLiquidationQueue\n            );\n            processedSpots++;\n        }\n        redemption.processedSpots = processedSpots;\n        return redemption;\n    }\nfunction _redeemNode(\n        uint256 _safeId,\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        // bytes32 _safeId = bytes32(_safeId);\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        uint256 amountToRedeem = redemption.requestedAmount -\n            redemption.redeemedAmount;\n        uint256 collateralToRedeem = (amountToRedeem * PRECISION) /\n            redemption.price;\n        // Amount of collateral to return back to the redeemer\n        uint256 collateralToReturn = collateralToRedeem;\n        // Amount of stablecoins to refund the safe owner\n        uint256 amountToRefund = 0;\n        // Total fee(in percentage terms) paid by the safe owner\n        // Total collateral value of the safe\n        uint256 ownerFee = 0;\n        uint256 redeemerFee = 0;\n        bool borrowMode;\n        (\n            borrowMode,\n            collateralToRedeem,\n            amountToRedeem,\n            amountToRefund,\n            ownerFee,\n            redeemerFee\n        ) = calculateRedemptionAmountsAndFee(\n            safe,\n            amountToRedeem,\n            redemption.price\n        );\n        if (amountToRefund > 0) {\n            if (amountToRefund > ownerFee) {\n                require(\n                    sbdToken.transfer(\n                        ownerOf(_safeId),\n                        amountToRefund - ownerFee\n                    ),\n                    \"Mint failed for owner fee\"\n                );\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    amountToRefund - ownerFee,\n                    ownerFee\n                );\n            } else {\n                // Nothing to pay owner\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    0,\n                    ownerFee\n                );\n            }\n            if (ownerFee > 0) {\n                redemption.ownerFee += ownerFee;\n                safe.feePaid = 0; // Reset the fee paid by the safe owner\n                safe.totalBorrowedAmount = 1; // Not resetting this to 0 to avoid errors\n                emit OwnerFeePaid(redemption.redemptionId, _safeId, ownerFee);\n            }\n        }\n        // Total amount of collateral to return to the redeemer\n        collateralToReturn = collateralToRedeem - redeemerFee;\n        if (redeemerFee > 0) {\n            redemption.redeemerFee += redeemerFee;\n            emit RedeemerFeePaid(\n                redemption.redemptionId,\n                _safeId,\n                collateralToRedeem,\n                collateralToReturn,\n                redeemerFee\n            );\n        }\n        // update target shielding rate\n        return\n            redeemSafe(\n                _safeId,\n                borrowMode,\n                amountToRedeem,\n                amountToRefund,\n                collateralToRedeem,\n                collateralToReturn,\n                safe,\n                nearestSpotInLiquidationQueue,\n                redemption\n            );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction calculateRedemptionAmountsAndFee(\n        Safe memory safe,\n        uint256 amountToRedeem,\n        uint256 collateralPrice\n    )\n        public\n        view\n        returns (\n            bool borrowMode,\n            uint256 _collateralToRedeem,\n            uint256 _amountToRedeem,\n            uint256 _amountToRefund,\n            uint256 _ownerFee,\n            uint256 _redeemerFee\n        )\n    {\n        uint256 collateralValue = (safe.collateralAmount * collateralPrice) /\n            PRECISION;\n        require(\n            collateralValue >=\n                ((safe.borrowedAmount * liquidationRatio) /\n                    BASIS_POINTS_DIVISOR),\n            \"Safe can't be redeemed\"\n        );\n\n        uint256 feePaidPercentage = ((safe.feePaid *\n            BASIS_POINTS_DIVISOR *\n            PRECISION) / safe.totalBorrowedAmount);\n        // Fee tier to apply for this safe(applied to the redeemer)\n        uint256 feeTier = min(\n            feePaidPercentage + REDEMPTION_BASE_FEE * PRECISION,\n            REDEMPTION_LIQUIDATION_FEE * PRECISION\n        );\n        /*\n        If the fee paid is less than REDEMPTION_BASE_FEE, the redemption fee is (feePaid + REDEMPTION_BASE_FEE)\n         */\n        if (feePaidPercentage <= REDEMPTION_BASE_FEE * PRECISION) {\n            if (amountToRedeem >= collateralValue) {\n                // redeem the whole collateral, while refunding stablecoins back to the owner of the safe\n                _amountToRedeem = safe.borrowedAmount;\n                _amountToRefund = collateralValue - _amountToRedeem;\n                _collateralToRedeem = safe.collateralAmount;\n                // OWNER FEE = REDEMPTION BASE FEE for the\n                // toPay = collateralValue * REDEMPTION_BASE_FEE / BASIS_POINTS_DIVISOR\n                // toPay - feePaid\n                uint256 ownerToPay = (collateralValue * REDEMPTION_BASE_FEE) /\n                    BASIS_POINTS_DIVISOR;\n                if (ownerToPay > safe.feePaid) {\n                    _ownerFee = ownerToPay - safe.feePaid;\n                }\n            } else {\n                if (amountToRedeem >= safe.borrowedAmount) {\n                    _amountToRefund = amountToRedeem - safe.borrowedAmount;\n                    _amountToRedeem = safe.borrowedAmount;\n                    _collateralToRedeem =\n                        ((_amountToRedeem + _amountToRefund) * PRECISION) /\n                        collateralPrice;\n                    _ownerFee =\n                        ((_amountToRedeem + _amountToRefund) *\n                            REDEMPTION_BASE_FEE) /\n                        BASIS_POINTS_DIVISOR;\n                    if (_ownerFee > safe.feePaid) {\n                        _ownerFee = _ownerFee - safe.feePaid;\n                    }\n                } else {\n                    _amountToRedeem = amountToRedeem;\n                    _collateralToRedeem =\n                        (amountToRedeem * PRECISION) /\n                        collateralPrice;\n                    _amountToRefund = 0;\n                    _ownerFee = 0;\n                }\n                // No seller fee here\n            }\n        } else {\n            borrowMode = true;\n            if (amountToRedeem >= safe.borrowedAmount) {\n                _amountToRedeem = safe.borrowedAmount;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n            } else {\n                _amountToRedeem = amountToRedeem;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                //amountToRedeem =\n            }\n        }\n        _redeemerFee = ((_collateralToRedeem * feeTier) /\n            BASIS_POINTS_DIVISOR /\n            PRECISION);\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction redeemSafe(\n        uint256 _safeId,\n        bool borrowMode,\n        uint256 amountToRedeem,\n        uint256 amountToRefund,\n        uint256 collateralToRedeem,\n        uint256 collateralToReturn,\n        Safe memory safe,\n        uint256 nearestSpotInLiquidationQueue,\n        SBStructs.Redemption memory redemption\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        //uint256 amountInCollateral = amountToRedeem /\n        safe.collateralAmount -= collateralToRedeem;\n        safe.borrowedAmount -= amountToRedeem;\n        redemption.collateralAmount += collateralToReturn;\n        redemption.redeemedAmount += amountToRedeem + amountToRefund;\n        redemption.refundedAmount += amountToRefund;\n        safes[_safeId] = safe;\n        // If the safe is empty(borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode)\n        // Borrow mode: If fee paid > REDEMPTION_BASE_FEE\n        // Exchange mode; If fee paid <= REDEMPTION_BASE_FEE\n        if (\n            (safe.borrowedAmount == 0 && borrowMode) ||\n            (!borrowMode &&\n                closeToZero(safe.collateralAmount) &&\n                safe.borrowedAmount == 0)\n        ) {\n            _removeSafeFromBothQueues(_safeId);\n        } else {\n            uint256 newRatio = (safe.borrowedAmount * PRECISION) /\n                safe.collateralAmount;\n            IDoublyLinkedList.Node\n                memory liquidationNode = safesOrderedForLiquidation.upsert(\n                    _safeId,\n                    newRatio,\n                    nearestSpotInLiquidationQueue\n                );\n            emit LiquidationQueueUpdated(\n                _safeId,\n                newRatio,\n                liquidationNode.next\n            );\n        }\n        emit Redeemed(\n            redemption.redemptionId,\n            _safeId,\n            amountToRedeem,\n            collateralToRedeem,\n            amountToRefund,\n            redemption.requestedAmount - redemption.redeemedAmount\n        );\n        return (safe, redemption);\n    }\nfunction closeToZero(uint256 value) internal pure returns (bool) {\n        return value < 1e10;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _redeemToUser(SBStructs.Redemption memory redemption) internal {\n        uint256 collateralRefund = 0;\n        if (redemption.ownerFee > 0) {\n            if (stabilityPoolCanReceiveRewards) {\n                require(\n                    stabilityPool.addReward(redemption.ownerFee),\n                    \"Add reward failed\"\n                );\n                emit OwnerRedemptionFeeDistributed(\n                    redemption.redemptionId,\n                    redemption.ownerFee\n                );\n            } else {\n                require(\n                    sbdToken.transfer(msg.sender, redemption.ownerFee),\n                    \"Owner fee refund failed\"\n                );\n            }\n        }\n        if (redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards) {\n            require(\n                stabilityPool.addCollateralReward{\n                    value: redemption.redeemerFee\n                }(redemption.redeemerFee),\n                \"Add collateral reward failed\"\n            );\n        } else {\n            collateralRefund = redemption.redeemerFee;\n        }\n        (bool success, ) = msg.sender.call{\n            value: redemption.collateralAmount + collateralRefund\n        }(\"\");\n        require(success, \"Transfer failed\");\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction transfer(address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}