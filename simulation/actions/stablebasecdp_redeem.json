{
  "action": {
    "name": "Redeem",
    "summary": "Redeems debt.",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "pre_execution_parameter_generation_rules": [
      "amount: The amount of SBD tokens to redeem. Must be greater than 0.",
      "nearestSpotInLiquidationQueue: A hint for the location of the nearest safe in the liquidation queue. This value can be 0 or a valid safe ID.",
      "The msg.sender must have sufficient SBD tokens approved for transfer by the StableBaseCDP contract.",
      "The protocol mode must be in Normal mode for redemption to be allowed."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Debt and Collateral Pool Updates",
        "state_update_descriptions": [
          "totalDebt is updated by subtracting (redemption.redeemedAmount - redemption.refundedAmount).",
          "totalCollateral is decreased by (redemption.collateralAmount + redemption.redeemerFee)."
        ]
      },
      {
        "category": "Safe State Updates",
        "state_update_descriptions": [
          "collateralAmount of the safe being redeemed is reduced by collateralToRedeem.",
          "borrowedAmount of the safe being redeemed is reduced by amountToRedeem.",
          "The safe is removed from the liquidation and redemption queues if it becomes empty (borrowedAmount == 0)."
        ]
      },
      {
        "category": "Redemption Data Updates",
        "state_update_descriptions": [
          "collateralAmount of the redemption struct is increased by collateralToReturn.",
          "redeemedAmount of the redemption struct is increased by amountToRedeem + amountToRefund.",
          "refundedAmount of the redemption struct is increased by amountToRefund.",
          "ownerFee is updated in the redemption struct.",
          "redeemerFee is updated in the redemption struct."
        ]
      },
      {
        "category": "Token and Collateral Transfers",
        "state_update_descriptions": [
          "SBD tokens are transferred from the message sender to the contract.",
          "Collateral (ETH) is transferred from the contract to the message sender.",
          "SBD tokens may be transferred from the contract to the safe owner as a refund.",
          "SBD tokens are burned from the contract."
        ]
      },
      {
        "category": "Queue Management",
        "state_update_descriptions": [
          "Safes are re-ordered or removed from the liquidation queue based on their updated collateralization ratio after redemption. If the safe's collateralization ratio is still below the liquidation ratio it will remain or be re-inserted into the liquidation queue. Otherwise, it will be removed."
        ]
      },
      {
        "category": "Price and Fee Handling",
        "state_update_descriptions": [
          "Price is fetched from the price oracle.",
          "Owner fees might be distributed to the stability pool.",
          "Redeemer fees might be distributed to the stability pool."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Debt and Collateral Pool Validation",
        "rule_descriptions": [
          "The total collateral should decrease by the sum of the collateral amount and the redeemer fee.",
          "Verify that the redemption amount is equal to the requested amount.",
          "The total debt should decrease by the difference between the redeemed amount and the refunded amount."
        ]
      },
      {
        "category": "Safe State Validation",
        "rule_descriptions": [
          "Safe's collateral amount should decrease by collateralToRedeem",
          "Safe's borrowed amount should decrease by amountToRedeem",
          "The safe should be removed from both liquidation and redemption queues if borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode"
        ]
      },
      {
        "category": "Redemption Data Validation",
        "rule_descriptions": [
          "Redemption.collateralAmount should increase by collateralToReturn",
          "Redemption.redeemedAmount should increase by amountToRedeem + amountToRefund",
          "Redemption.refundedAmount should increase by amountToRefund"
        ]
      },
      {
        "category": "Token Transfer Validation",
        "rule_descriptions": [
          "Verify that SBD tokens are transferred from the message sender to the contract.",
          "Verify that SBD tokens are burned if redeemedAmount > refundedAmount."
        ]
      },
      {
        "category": "Stability Pool Reward Validation",
        "rule_descriptions": [
          "If stabilityPoolCanReceiveRewards is true, ownerFee and redeemerFee should be added as reward to StabilityPool, otherwise msg.sender receives ownerFee and redeemerFee.",
          "If stabilityPoolCanReceiveRewards is false, verify that msg.sender receives ownerFee and redeemerFee"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "sbdToken",
            "type": "token_transfer",
            "what_does_it_track": "The transfer of SBD tokens from the redeemer to the contract.",
            "why_is_is_important": "This is the initial step in redeeming debt, ensuring the contract receives the tokens.",
            "when_is_it_updated": "At the beginning of the redeem function, before any redemption logic.",
            "how_to_validate_state_update": "Check the SBD token balance of the message sender decreases by amount and the contract's balance increases by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers SBD tokens from the message sender to the contract.",
            "conditions": [
              "amount > 0",
              "Contract in normal mode",
              "sbdToken.transferFrom succeeds"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "collateral_update",
            "what_does_it_track": "Total collateral held by the contract.",
            "why_is_is_important": "Reflects the reduction in total collateral due to the redemption.",
            "when_is_it_updated": "After the safes have been redeemed and the collateral amount is calculated.",
            "how_to_validate_state_update": "Check the totalCollateral state variable decreases by the redeemed collateral amount plus redeemer fee.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total collateral by subtracting the collateral amount and redeemer fee.",
            "conditions": [
              "_redemption.redeemedAmount == amount"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "debt_update",
            "what_does_it_track": "Total debt of the system.",
            "why_is_is_important": "Reflects the reduction in total debt due to the redemption.",
            "when_is_it_updated": "After the safes have been redeemed and the redeemed amount is calculated.",
            "how_to_validate_state_update": "Check the totalDebt state variable decreases by the redeemed amount, accounting for potential refunds.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt by subtracting the redeemed amount.",
            "conditions": [
              "_redemption.redeemedAmount == amount"
            ]
          },
          {
            "state_variable_name": "sbdToken",
            "type": "token_burn",
            "what_does_it_track": "The amount of SBD tokens burned.",
            "why_is_is_important": "Removes the redeemed SBD tokens from circulation, completing the redemption process.",
            "when_is_it_updated": "If the redeemed amount is greater than the refunded amount, indicating a net reduction in SBD supply.",
            "how_to_validate_state_update": "Check the SBD token balance of the contract decreases by the difference between redeemedAmount and refundedAmount, and the totalSupply decreases by the same amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens from the contract.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "safe_update",
            "what_does_it_track": "The collateral and debt levels of individual safes.",
            "why_is_is_important": "Reflects the decrease in collateral and debt within the safe due to redemption.",
            "when_is_it_updated": "Inside the _redeemSafe function, after calculating the amounts to redeem.",
            "how_to_validate_state_update": "Check the collateralAmount and borrowedAmount of the specific safe decrease by the redeemed amounts.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralAmount and borrowedAmount of a specific safe, if a safe is redeemed.",
            "conditions": [
              "A safe is actually redeemed in _redeemSafes"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation, safesOrderedForRedemption",
            "type": "queue_removal",
            "what_does_it_track": "The presence of safes in the liquidation and redemption queues.",
            "why_is_is_important": "Maintains the integrity of the queues by removing irrelevant safes.",
            "when_is_it_updated": "Inside the _redeemSafe function, after updating the safe's collateral and debt levels.",
            "how_to_validate_state_update": "Check the specific safe is no longer present in either the liquidation or redemption queues.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the liquidation and redemption queues if it becomes empty after redemption.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "queue_update",
            "what_does_it_track": "The order of safes in the liquidation queue.",
            "why_is_is_important": "Ensures safes are correctly ordered for liquidation based on their collateralization ratio.",
            "when_is_it_updated": "If after redemption the safe is not empty.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation linked list contains the safe and it is ordered according to borrowedAmount / collateralAmount",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue with a new ratio.",
            "conditions": [
              "safe.borrowedAmount > 0 && safe.collateralAmount > 0",
              "After redemption, the safe is not empty and still exists"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "debt_calculation",
            "what_does_it_track": "The total outstanding debt of the protocol considering cumulative interest.",
            "why_is_is_important": "Keeps track of the accurate total debt of the protocol considering cumulative interest.",
            "when_is_it_updated": "When a safe is being processed for redemption and cumulative interest needs to be accounted for.",
            "how_to_validate_state_update": "Verify the totalDebt is updated by the appropriate debtIncrease using the formula.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalDebt based on cumulative interest.",
            "conditions": [
              "cumulativeCollateralPerUnitCollateral != liquidationSnapshot.collateralPerCollateralSnapshot"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "collateral_calculation",
            "what_does_it_track": "The cumulative amount of collateral in the protocol.",
            "why_is_is_important": "Keeps track of the accurate collateral amount of the protocol.",
            "when_is_it_updated": "When a safe is being processed for redemption and cumulative interest needs to be accounted for.",
            "how_to_validate_state_update": "Verify the totalCollateral is updated by the appropriate collateralIncrease using the formula.",
            "has_conditional_updates": true,
            "summary_of_update": "Update cumulative interest and collateral amounts.",
            "conditions": [
              "cumulativeCollateralPerUnitCollateral != liquidationSnapshot.collateralPerCollateralSnapshot"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "mode_transition",
            "what_does_it_track": "The mode of the protocol.",
            "why_is_is_important": "Governs state of the protocol.",
            "when_is_it_updated": "When a total debt is greater than bootstrap threshold.",
            "how_to_validate_state_update": "Check the state of PROTOCOL_MODE.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the protocol to normal mode.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalSupply",
            "type": "token_burn",
            "what_does_it_track": "Total supply of SBD tokens.",
            "why_is_is_important": "Reduces the supply of SBD tokens, completing the redemption process.",
            "when_is_it_updated": "Inside the redeem function, when the redeemed amount is greater than the refunded amount.",
            "how_to_validate_state_update": "Check that the total supply of SBD tokens decreases by the burned amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns SBD tokens by calling the burn function.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stabilityPool",
            "type": "reward_distribution",
            "what_does_it_track": "Rewards distributed to the stability pool.",
            "why_is_is_important": "Distributes redemption fees to stability providers, incentivizing participation.",
            "when_is_it_updated": "Inside the _redeemToUser function, if an owner fee exists and the stability pool can receive rewards.",
            "how_to_validate_state_update": "Check the rewards in the stability pool increase by the ownerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds owner fee to the stability pool as a reward if stability pool can receive rewards.",
            "conditions": [
              "redemption.ownerFee > 0",
              "stabilityPoolCanReceiveRewards is true"
            ]
          },
          {
            "state_variable_name": "stabilityPool",
            "type": "reward_distribution",
            "what_does_it_track": "Rewards distributed to the stability pool.",
            "why_is_is_important": "Distributes redemption fees to stability providers, incentivizing participation.",
            "when_is_it_updated": "Inside the _redeemToUser function, if a redeemer fee exists and the stability pool can receive rewards.",
            "how_to_validate_state_update": "Check the collateral rewards in the stability pool increase by the redeemerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds redeemer fee as a collateral reward to the stability pool if stability pool can receive rewards",
            "conditions": [
              "redemption.redeemerFee > 0",
              "stabilityPoolCanReceiveRewards is true"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "queue_update",
            "what_does_it_track": "Membership of the liquidation queue.",
            "why_is_is_important": "Maintains accurate tracking for liquidation purposes.",
            "when_is_it_updated": "Inside _removeSafeFromBothQueues which is called when a safe is fully redeemed.",
            "how_to_validate_state_update": "Check that the safe is no longer in the safesOrderedForLiquidation doubly linked list.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the liquidation queue.",
            "conditions": [
              "safe.borrowedAmount == 0 && borrowMode",
              "!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "queue_update",
            "what_does_it_track": "Membership of the redemption queue.",
            "why_is_is_important": "Maintains accurate tracking for redemption purposes.",
            "when_is_it_updated": "Inside _removeSafeFromBothQueues which is called when a safe is fully redeemed.",
            "how_to_validate_state_update": "Check that the safe is no longer in the safesOrderedForRedemption doubly linked list.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the redemption queue.",
            "conditions": [
              "safe.borrowedAmount == 0 && borrowMode",
              "!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function redeem(\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external onlyInNormalMode {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), amount),\n            \"Unable to transfer SBD\"\n        );\n        uint256 price = priceOracle.fetchPrice();\n        uint256 redemptionId = uint256(\n            keccak256(\n                abi.encode(\n                    msg.sender,\n                    amount,\n                    block.number,\n                    safesOrderedForRedemption.getHead()\n                )\n            )\n        );\n\n        SBStructs.Redemption memory _redemption = SBStructs.Redemption({\n            redemptionId: redemptionId,\n            requestedAmount: amount,\n            price: price,\n            redeemedAmount: 0,\n            refundedAmount: 0,\n            processedSpots: 0,\n            collateralAmount: 0,\n            ownerFee: 0,\n            redeemerFee: 0\n        });\n\n        _redemption = _redeemSafes(_redemption, nearestSpotInLiquidationQueue);\n        _redeemToUser(_redemption);\n        totalCollateral -= (_redemption.collateralAmount +\n            _redemption.redeemerFee);\n        require(_redemption.redeemedAmount == amount, \"Redemption failed\");\n        //totalDebt -= _redemption.redeemedAmount;\n        _updateTotalDebt(\n            totalDebt,\n            _redemption.redeemedAmount - _redemption.refundedAmount,\n            false\n        );\n        if (_redemption.redeemedAmount > _redemption.refundedAmount) {\n            require(\n                sbdToken.burn(\n                    address(this),\n                    _redemption.redeemedAmount - _redemption.refundedAmount\n                ),\n                \"Burn failed\"\n            );\n        }\n\n        emit RedeemedBatch(\n            redemptionId,\n            amount,\n            _redemption.collateralAmount,\n            price,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _redeemSafes(\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (SBStructs.Redemption memory) {\n        uint256 processedSpots = redemption.processedSpots;\n        // Target within 1% = 100 points, 100% = 10000 points\n        while (redemption.redeemedAmount < redemption.requestedAmount) {\n            //uint256 spotForUpdate = 0;\n            uint256 head = safesOrderedForRedemption.getHead();\n            (, redemption) = _redeemNode(\n                head,\n                redemption,\n                nearestSpotInLiquidationQueue\n            );\n            processedSpots++;\n        }\n        redemption.processedSpots = processedSpots;\n        return redemption;\n    }\nfunction _redeemNode(\n        uint256 _safeId,\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        // bytes32 _safeId = bytes32(_safeId);\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        uint256 amountToRedeem = redemption.requestedAmount -\n            redemption.redeemedAmount;\n        uint256 collateralToRedeem = (amountToRedeem * PRECISION) /\n            redemption.price;\n        // Amount of collateral to return back to the redeemer\n        uint256 collateralToReturn = collateralToRedeem;\n        // Amount of stablecoins to refund the safe owner\n        uint256 amountToRefund = 0;\n        // Total fee(in percentage terms) paid by the safe owner\n        // Total collateral value of the safe\n        uint256 ownerFee = 0;\n        uint256 redeemerFee = 0;\n        bool borrowMode;\n        (\n            borrowMode,\n            collateralToRedeem,\n            amountToRedeem,\n            amountToRefund,\n            ownerFee,\n            redeemerFee\n        ) = calculateRedemptionAmountsAndFee(\n            safe,\n            amountToRedeem,\n            redemption.price\n        );\n        if (amountToRefund > 0) {\n            if (amountToRefund > ownerFee) {\n                require(\n                    sbdToken.transfer(\n                        ownerOf(_safeId),\n                        amountToRefund - ownerFee\n                    ),\n                    \"Mint failed for owner fee\"\n                );\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    amountToRefund - ownerFee,\n                    ownerFee\n                );\n            } else {\n                // Nothing to pay owner\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    0,\n                    ownerFee\n                );\n            }\n            if (ownerFee > 0) {\n                redemption.ownerFee += ownerFee;\n                safe.feePaid = 0; // Reset the fee paid by the safe owner\n                safe.totalBorrowedAmount = 1; // Not resetting this to 0 to avoid errors\n                emit OwnerFeePaid(redemption.redemptionId, _safeId, ownerFee);\n            }\n        }\n        // Total amount of collateral to return to the redeemer\n        collateralToReturn = collateralToRedeem - redeemerFee;\n        if (redeemerFee > 0) {\n            redemption.redeemerFee += redeemerFee;\n            emit RedeemerFeePaid(\n                redemption.redemptionId,\n                _safeId,\n                collateralToRedeem,\n                collateralToReturn,\n                redeemerFee\n            );\n        }\n        // update target shielding rate\n        return\n            redeemSafe(\n                _safeId,\n                borrowMode,\n                amountToRedeem,\n                amountToRefund,\n                collateralToRedeem,\n                collateralToReturn,\n                safe,\n                nearestSpotInLiquidationQueue,\n                redemption\n            );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction calculateRedemptionAmountsAndFee(\n        Safe memory safe,\n        uint256 amountToRedeem,\n        uint256 collateralPrice\n    )\n        public\n        view\n        returns (\n            bool borrowMode,\n            uint256 _collateralToRedeem,\n            uint256 _amountToRedeem,\n            uint256 _amountToRefund,\n            uint256 _ownerFee,\n            uint256 _redeemerFee\n        )\n    {\n        uint256 collateralValue = (safe.collateralAmount * collateralPrice) /\n            PRECISION;\n        require(\n            collateralValue >=\n                ((safe.borrowedAmount * liquidationRatio) /\n                    BASIS_POINTS_DIVISOR),\n            \"Safe can't be redeemed\"\n        );\n\n        uint256 feePaidPercentage = ((safe.feePaid *\n            BASIS_POINTS_DIVISOR *\n            PRECISION) / safe.totalBorrowedAmount);\n        // Fee tier to apply for this safe(applied to the redeemer)\n        uint256 feeTier = min(\n            feePaidPercentage + REDEMPTION_BASE_FEE * PRECISION,\n            REDEMPTION_LIQUIDATION_FEE * PRECISION\n        );\n        /*\n        If the fee paid is less than REDEMPTION_BASE_FEE, the redemption fee is (feePaid + REDEMPTION_BASE_FEE)\n         */\n        if (feePaidPercentage <= REDEMPTION_BASE_FEE * PRECISION) {\n            if (amountToRedeem >= collateralValue) {\n                // redeem the whole collateral, while refunding stablecoins back to the owner of the safe\n                _amountToRedeem = safe.borrowedAmount;\n                _amountToRefund = collateralValue - _amountToRedeem;\n                _collateralToRedeem = safe.collateralAmount;\n                // OWNER FEE = REDEMPTION BASE FEE for the\n                // toPay = collateralValue * REDEMPTION_BASE_FEE / BASIS_POINTS_DIVISOR\n                // toPay - feePaid\n                uint256 ownerToPay = (collateralValue * REDEMPTION_BASE_FEE) /\n                    BASIS_POINTS_DIVISOR;\n                if (ownerToPay > safe.feePaid) {\n                    _ownerFee = ownerToPay - safe.feePaid;\n                }\n            } else {\n                if (amountToRedeem >= safe.borrowedAmount) {\n                    _amountToRefund = amountToRedeem - safe.borrowedAmount;\n                    _amountToRedeem = safe.borrowedAmount;\n                    _collateralToRedeem =\n                        ((_amountToRedeem + _amountToRefund) * PRECISION) /\n                        collateralPrice;\n                    _ownerFee =\n                        ((_amountToRedeem + _amountToRefund) *\n                            REDEMPTION_BASE_FEE) /\n                        BASIS_POINTS_DIVISOR;\n                    if (_ownerFee > safe.feePaid) {\n                        _ownerFee = _ownerFee - safe.feePaid;\n                    }\n                } else {\n                    _amountToRedeem = amountToRedeem;\n                    _collateralToRedeem =\n                        (amountToRedeem * PRECISION) /\n                        collateralPrice;\n                    _amountToRefund = 0;\n                    _ownerFee = 0;\n                }\n                // No seller fee here\n            }\n        } else {\n            borrowMode = true;\n            if (amountToRedeem >= safe.borrowedAmount) {\n                _amountToRedeem = safe.borrowedAmount;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n            } else {\n                _amountToRedeem = amountToRedeem;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                //amountToRedeem =\n            }\n        }\n        _redeemerFee = ((_collateralToRedeem * feeTier) /\n            BASIS_POINTS_DIVISOR /\n            PRECISION);\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction redeemSafe(\n        uint256 _safeId,\n        bool borrowMode,\n        uint256 amountToRedeem,\n        uint256 amountToRefund,\n        uint256 collateralToRedeem,\n        uint256 collateralToReturn,\n        Safe memory safe,\n        uint256 nearestSpotInLiquidationQueue,\n        SBStructs.Redemption memory redemption\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        //uint256 amountInCollateral = amountToRedeem /\n        safe.collateralAmount -= collateralToRedeem;\n        safe.borrowedAmount -= amountToRedeem;\n        redemption.collateralAmount += collateralToReturn;\n        redemption.redeemedAmount += amountToRedeem + amountToRefund;\n        redemption.refundedAmount += amountToRefund;\n        safes[_safeId] = safe;\n        // If the safe is empty(borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode)\n        // Borrow mode: If fee paid > REDEMPTION_BASE_FEE\n        // Exchange mode; If fee paid <= REDEMPTION_BASE_FEE\n        if (\n            (safe.borrowedAmount == 0 && borrowMode) ||\n            (!borrowMode &&\n                closeToZero(safe.collateralAmount) &&\n                safe.borrowedAmount == 0)\n        ) {\n            _removeSafeFromBothQueues(_safeId);\n        } else {\n            uint256 newRatio = (safe.borrowedAmount * PRECISION) /\n                safe.collateralAmount;\n            IDoublyLinkedList.Node\n                memory liquidationNode = safesOrderedForLiquidation.upsert(\n                    _safeId,\n                    newRatio,\n                    nearestSpotInLiquidationQueue\n                );\n            emit LiquidationQueueUpdated(\n                _safeId,\n                newRatio,\n                liquidationNode.next\n            );\n        }\n        emit Redeemed(\n            redemption.redemptionId,\n            _safeId,\n            amountToRedeem,\n            collateralToRedeem,\n            amountToRefund,\n            redemption.requestedAmount - redemption.redeemedAmount\n        );\n        return (safe, redemption);\n    }\nfunction closeToZero(uint256 value) internal pure returns (bool) {\n        return value < 1e10;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _redeemToUser(SBStructs.Redemption memory redemption) internal {\n        uint256 collateralRefund = 0;\n        if (redemption.ownerFee > 0) {\n            if (stabilityPoolCanReceiveRewards) {\n                require(\n                    stabilityPool.addReward(redemption.ownerFee),\n                    \"Add reward failed\"\n                );\n                emit OwnerRedemptionFeeDistributed(\n                    redemption.redemptionId,\n                    redemption.ownerFee\n                );\n            } else {\n                require(\n                    sbdToken.transfer(msg.sender, redemption.ownerFee),\n                    \"Owner fee refund failed\"\n                );\n            }\n        }\n        if (redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards) {\n            require(\n                stabilityPool.addCollateralReward{\n                    value: redemption.redeemerFee\n                }(redemption.redeemerFee),\n                \"Add collateral reward failed\"\n            );\n        } else {\n            collateralRefund = redemption.redeemerFee;\n        }\n        (bool success, ) = msg.sender.call{\n            value: redemption.collateralAmount + collateralRefund\n        }(\"\");\n        require(success, \"Transfer failed\");\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction transfer(address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}