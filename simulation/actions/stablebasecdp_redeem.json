{
  "action": {
    "name": "Redeem",
    "summary": "Redeems debt.",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "pre_execution_parameter_generation_rules": [
      "Amount: Generate a positive integer for the amount of SBD to redeem. This value represents the quantity of stablecoins the user wants to exchange for collateral.",
      "nearestSpotInLiquidationQueue: Generate an integer representing a safe ID, which serves as a hint for the location within the liquidation queue to start searching for safes to redeem against. This can be 0 to start from the head, indicating the search should begin from the start of the queue.",
      "The account executing the transaction should have sufficient SBD tokens approved for the contract to transfer. Check sbdToken.allowance(user, StableBaseCDP) >= amount before execution. If not, approve using sbdToken.approve(StableBaseCDP, amount).",
      "Ensure that the contract is in normal mode (PROTOCOL_MODE == SBStructs.Mode.NORMAL). If not, the transaction will revert.",
      "The amount must be greater than zero, otherwise the transaction will revert with 'Amount must be greater than 0'."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "SBD Token Transfers and Burning",
        "state_update_descriptions": [
          "SBD tokens are transferred from the message sender to the StableBaseCDP contract.",
          "If the redeemed amount is greater than the refunded amount, the difference is burned from the StableBaseCDP contract using the sbdToken.burn function."
        ]
      },
      {
        "category": "Collateral and Debt Update",
        "state_update_descriptions": [
          "Total collateral is decreased by the collateral amount plus the redeemer fee.",
          "Total debt is updated, decreasing by the redeemed amount minus the refunded amount. This reflects the overall debt reduction in the system."
        ]
      },
      {
        "category": "Safe Updates",
        "state_update_descriptions": [
          "The collateral and borrowed amounts of affected safes are updated based on the redemption, reflecting the partial or full redemption of the safe's debt.",
          "Safes may be removed from the liquidation and redemption queues if their borrowed amount is zero (or very close to zero, as determined by closeToZero) and borrowMode is true, or if the collateral has been fully redeemed and borrowedAmount is zero, and borrowMode is false."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Owner and redeemer fees may be distributed to the stability pool via stabilityPool.addReward or stabilityPool.addCollateralReward, or refunded to the message sender directly depending on whether the stability pool can receive rewards (stabilityPoolCanReceiveRewards).",
          "Collateral (redemption.collateralAmount + collateralRefund) is transferred to the user via a raw call."
        ]
      },
      {
        "category": "Liquidation Snapshot Updates",
        "state_update_descriptions": [
          "Liquidation snapshots of the safes may be updated with debt and collateral values, ensuring accurate tracking of safe states for future liquidations or redemptions."
        ]
      },
      {
        "category": "Protocol Mode Update",
        "state_update_descriptions": [
          "The protocol mode may change from BOOTSTRAP to NORMAL if total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD, indicating a transition out of the initial bootstrapping phase."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Balance Validation",
        "rule_descriptions": [
          "The redemption must succeed, which includes the require(_redemption.redeemedAmount == amount, \"Redemption failed\") check in the redeem function. This validates that the final state reflects the expected collateral and debt adjustments.",
          "SBD token balance of the user is decreased by the amount redeemed. This can be checked using sbdToken.balanceOf(user).",
          "If SBD tokens were burned, confirm that the total supply of SBD tokens has decreased accordingly. This can be validated with sbdToken.totalSupply()."
        ]
      },
      {
        "category": "Safe State Validation",
        "rule_descriptions": [
          "If a safe is fully redeemed (borrowedAmount is 0 and closeToZero(collateralAmount)), verify it is removed from both the liquidation and redemption queues using safesOrderedForLiquidation.getNode(safeId) and safesOrderedForRedemption.getNode(safeId). These should return nodes with value, prev, and next equal to 0.",
          "If a safe is not fully redeemed, verify its liquidation ratio (borrowedAmount * PRECISION / collateralAmount) is updated correctly in the liquidation queue by checking safesOrderedForLiquidation.getNode(safeId).value.",
          "Also, check safes[safeId].collateralAmount and safes[safeId].borrowedAmount are correctly updated."
        ]
      },
      {
        "category": "Total Debt and Collateral Validation",
        "rule_descriptions": [
          "Verify that the total collateral (totalCollateral) and total debt (totalDebt) are updated correctly after the redemption. The updated values should reflect the redeemed amounts and any fees distributed.",
          "Specifically, totalCollateral should decrease by (redemption.collateralAmount + redemption.redeemerFee), and totalDebt should decrease by (_redemption.redeemedAmount - _redemption.refundedAmount)."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "Verify that the RedeemedBatch event is emitted with the correct parameters (redemptionId, amount, collateralAmount, price, totalCollateral, totalDebt). Ensure that the redemptionId is unique and parameters match the calculated values.",
          "Verify that the Redeemed event is emitted for each safe that was affected by the redemption, confirming the amounts redeemed, collateral exchanged, and refunds issued. Check if the _safeId corresponds to an existing safe.",
          "Conditionally verify that OwnerRefunded event is emitted if there was a refund to the owner. The refund and fee amounts should match the calculated values.",
          "Conditionally verify that OwnerFeePaid event is emitted if the owner paid a fee. The fee amount should match the calculated fee.",
          "Conditionally verify that RedeemerFeePaid event is emitted if the redeemer paid a fee. The collateral amounts should match the calculated values.",
          "If the safe's position in the liquidation queue was updated, verify that a LiquidationQueueUpdated event is emitted, and the newRatio and nextNode values are correct. This applies only to safes that weren't fully redeemed.",
          "If a safe was removed from either queue, verify that SafeRemovedFromLiquidationQueue and/or SafeRemovedFromRedemptionQueue events are emitted, and confirm the safe no longer exists in the respective queue (getNode returns 0).",
          "Verify that the SafeUpdated event is emitted if the safe's collateral or debt amounts were updated, and that collateralIncrease and debtIncrease match the changes."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the contract.",
            "why_is_is_important": "Tracks the overall collateralization of the system. It's important for calculating global collateralization ratios and ensuring system solvency. A decrease reflects collateral leaving the system during redemptions, liquidations, or withdrawals by the contract owner (in extreme circumstances). A discrepancy here indicates incorrect bookkeeping somewhere in the contract logic or external interference with token balances (highly improbable under normal conditions). This discrepancy would have cascading effects throughout the system, influencing parameters like liquidation thresholds and potentially leading to cascading failures in extreme scenarios. Therefore, monitoring totalCollateral provides a system-wide health check and early warning sign of potential malfunctions or attacks. Deviation indicates some SAFEs are undercollateralized beyond acceptable limits, hence impacting stability of the protocol, and requiring immediate investigation to avoid systemic failures. It is also helpful to track if users are withdrawing collateral without repaying debt, or if liquidations are not properly accounting for collateral redistribution, as well as to ensure that the stability pool receives the correct amounts of liquidated collateral, contributing to its intended function of maintaining price stability, which depends on maintaining the peg for the stablecoin, and depends on properly functioning liquidations and redemptions, which depend on keeping track of the total collateral in the system to allow the mechanisms to function as planned and correctly value the collateral in the contract. It's also a basis for governance decisions related to collateralization ratios and system parameters, informing governance on if totalCollateral is sufficient to cover totalDebt and other systemic risks, and in order to determine if adjustments need to be made to the liquidation ratio, redemption fees or other parameters, and hence maintaining overall stability, preventing excessive liquidations/redemptions. If totalCollateral is lower than expected, governance may need to take action to incentivize collateral deposits or reduce outstanding debt, highlighting the role in broader risk management strategies beyond the core smart contract code.. Therefore it is useful for audits as well, as an off-chain verifiable metric, to ensure on-chain calculations are performed correctly and no manipulation of the state is taking place. Therefore, this is very important for the protocol, and to protect user funds, and to ensure the system is behaving as designed and is stable and secure, and the stablecoin is sufficiently backed by collateral. Its failure has cascading and severe consequences on the health of the protocol, hence continuous monitoring through events and off-chain calculations is very important, as well as comparing with other metrics to assess the health of the protocol. ",
            "when_is_it_updated": "After the redemption process, reflecting the collateral returned to the redeemer.",
            "how_to_validate_state_update": "Check the totalCollateral variable before and after the redeem function call. The difference should be equal to (_redemption.collateralAmount + _redemption.redeemerFee).",
            "has_conditional_updates": true,
            "summary_of_update": "Decremented by the sum of collateralAmount and redeemerFee from the redemption.",
            "conditions": [
              "amount > 0",
              "Contract must be in normal mode",
              "sbdToken.transferFrom must succeed",
              "_redemption.redeemedAmount == amount must be true"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Determines certain operational constraints. Moving to NORMAL mode can activate additional features or relax restrictions. Hence important to keep track of the operational status of the protocol and adjust operations in response to it. ",
            "when_is_it_updated": "After updating the total debt, conditionally changes if the debt exceeds a threshold.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE before and after the redeem function call. Verify it transitions from BOOTSTRAP to NORMAL when debt exceeds the threshold.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated to NORMAL if total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt in the system.",
            "why_is_is_important": "Total debt tracks the total amount of debt outstanding in the system. It affects stability and overall systemic risk. ",
            "when_is_it_updated": "When the total debt is updated",
            "how_to_validate_state_update": "Check the totalDebt variable before and after the call to _updateTotalDebt. Verify that the totalDebt increases by delta if add is true, decreases by delta otherwise.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase or decrease of total debt by delta.",
            "conditions": [
              "add == true"
            ]
          },
          {
            "state_variable_name": "sbdToken.burn",
            "type": "function_call",
            "what_does_it_track": "The burning of SBD tokens.",
            "why_is_is_important": "Reduces the supply of SBD, contributing to its price stability. ",
            "when_is_it_updated": "When redeemedAmount exceeds refundedAmount.",
            "how_to_validate_state_update": "Check the return value of the burn function in sbdToken, it must return true.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens from the contract, reducing the total supply.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The collateral amount in a specific safe.",
            "why_is_is_important": "Reflects the accurate state of each safe, essential for calculating collateralization ratios and liquidation thresholds. Failure to correctly track the collateral balance of a safe could lead to inaccurate assessments of its risk profile, resulting in under- or over-collateralization that threatens the stability of the protocol. ",
            "when_is_it_updated": "When a safe is redeemed.",
            "how_to_validate_state_update": "Check the safes mapping for the corresponding safeId, and verify that the values of collateralAmount and borrowedAmount are correctly updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the collateral amount of the safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The borrowed amount in a specific safe.",
            "why_is_is_important": "Reflects the accurate state of each safe, essential for calculating collateralization ratios and liquidation thresholds. Failure to correctly track the debt balance of a safe could lead to inaccurate assessments of its risk profile, resulting in under- or over-collateralization that threatens the stability of the protocol. ",
            "when_is_it_updated": "When a safe is redeemed.",
            "how_to_validate_state_update": "Check the safes mapping for the corresponding safeId, and verify that the values of collateralAmount and borrowedAmount are correctly updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the borrowed amount of the safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.remove",
            "type": "function_call",
            "what_does_it_track": "The liquidation queue.",
            "why_is_is_important": "Maintains an accurate list of safes eligible for liquidation. ",
            "when_is_it_updated": "When a safe is empty.",
            "how_to_validate_state_update": "Verify that the safeId is removed from both the liquidation and redemption queues by checking the safesOrderedForLiquidation and safesOrderedForRedemption doubly linked lists.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the liquidation queue.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.remove",
            "type": "function_call",
            "what_does_it_track": "The redemption queue.",
            "why_is_is_important": "Maintains an accurate list of safes eligible for redemption. ",
            "when_is_it_updated": "When a safe is empty.",
            "how_to_validate_state_update": "Verify that the safeId is removed from both the liquidation and redemption queues by checking the safesOrderedForLiquidation and safesOrderedForRedemption doubly linked lists.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the redemption queue.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "stabilityPool.addReward",
            "type": "function_call",
            "what_does_it_track": "Adds rewards to the stability pool.",
            "why_is_is_important": "Incentivizes participation in the stability pool and redirects a portion of the fees to support it. This mechanism helps to ensure that the stability pool is adequately funded, which is important for maintaining the peg of the stablecoin. Properly funded stability pool allows the protocol to stabilize during times of high volatility, which is crucial for maintaining confidence in the system and attracting users. ",
            "when_is_it_updated": "If the stability pool can receive rewards.",
            "how_to_validate_state_update": "Call the addReward function of the stabilityPool contract. Ensure that reward amount is correctly added to the rewards pool.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds owner fee to the stability pool as a reward.",
            "conditions": [
              "stabilityPoolCanReceiveRewards"
            ]
          },
          {
            "state_variable_name": "stabilityPool.addCollateralReward",
            "type": "function_call",
            "what_does_it_track": "The collateral reward addition to the stability pool.",
            "why_is_is_important": "Further incentivizes stability pool participation and proper reward distribution by directing a portion of the redemption fees towards it. This ensures that the Stability Pool receives sufficient collateral to compensate for potential losses during liquidations and to incentivize participation through collateral rewards. Properly functioning stability pool is essential for maintaining price stability and user confidence in the protocol. ",
            "when_is_it_updated": "When there is a redeemer fee and the stability pool can receive rewards.",
            "how_to_validate_state_update": "Verify that the redeemer fee is added as a collateral reward to the stability pool.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds redeemer fee as a collateral reward to the stability pool.",
            "conditions": [
              "redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.upsert",
            "type": "function_call",
            "what_does_it_track": "The liquidation queue ordering.",
            "why_is_is_important": "Ensures correct ordering of safes for liquidation based on their collateralization ratio. This is crucial for prioritizing the liquidation of the riskiest safes, which helps to minimize potential losses to the system. If the queue is not updated correctly, lower-risk safes might be liquidated before higher-risk safes, leading to inefficiencies and potential instability in the system. ",
            "when_is_it_updated": "When the safe is not empty after redemption.",
            "how_to_validate_state_update": "Check that the liquidation queue is updated for the given safeId with the new ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's position in the liquidation queue.",
            "conditions": [
              "(safe.borrowedAmount != 0 && borrowMode) || (!borrowMode && !closeToZero(safe.collateralAmount) && safe.borrowedAmount != 0)"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "sbdToken.transferFrom",
            "type": "function_call",
            "what_does_it_track": "The transfer of SBD tokens.",
            "why_is_is_important": "Ensures the contract receives the SBD to be redeemed, validating that the redeemer possesses the necessary tokens and initiating the redemption process. Without this transfer, the redemption operation cannot proceed, as the protocol requires the SBD tokens to execute the repayment and corresponding collateral release or redistribution.",
            "when_is_it_updated": "At the beginning of the redemption process.",
            "how_to_validate_state_update": "Check balances of msg.sender and StableBaseCDP contract before and after the transferFrom. The msg.sender's balance should decrease by amount, and the StableBaseCDP balance should increase by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers SBD tokens from the redeemer to the contract.",
            "conditions": [
              "sbdToken.transferFrom must succeed"
            ]
          },
          {
            "state_variable_name": "sbdToken.transfer",
            "type": "function_call",
            "what_does_it_track": "SBD token transfers.",
            "why_is_is_important": "Compensates safe owners when their collateral is used for redemption, maintaining fairness within the protocol and incentivizing participation by ensuring that users receive appropriate refunds for their collateral contributions. By reimbursing safe owners, the contract aligns incentives and promotes the long-term health of the system by retaining user trust. ",
            "when_is_it_updated": "When a safe owner is due a refund during redemption.",
            "how_to_validate_state_update": "Check the return value of sbdToken.transfer. It must return true, and the balance of ownerOf(_safeId) should increase by amountToRefund - ownerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers SBD tokens to the safe owner as a refund.",
            "conditions": [
              "amountToRefund > ownerFee"
            ]
          },
          {
            "state_variable_name": "sbdToken.burn",
            "type": "function_call",
            "what_does_it_track": "Burning of SBD tokens.",
            "why_is_is_important": "Reduces the supply of SBD tokens, crucial for maintaining price stability by adjusting supply to match demand. Burning tokens is a key mechanism for maintaining the peg, hence critical.",
            "when_is_it_updated": "When redeemedAmount is greater than refundedAmount",
            "how_to_validate_state_update": "Verify burn() call in sbdToken is successful by checking the return value to be true. Also check totalBurned variable increments by _redemption.redeemedAmount - _redemption.refundedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens, reducing total supply.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForLiquidation.remove",
            "type": "function_call",
            "what_does_it_track": "The order of safes in the liquidation queue.",
            "why_is_is_important": "Ensures that only relevant safes are considered for liquidation, which is crucial for the efficiency and correctness of the liquidation mechanism. Incorrect handling of safes in this queue could lead to under- or over-liquidation, impacting the stability of the protocol. ",
            "when_is_it_updated": "When the safe is considered empty after redemption.",
            "how_to_validate_state_update": "Verify the safe is removed by checking that nodes[safeId] is reset to its default value, and that the head and tail of the linked list are correctly updated if the safe was the head or tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the liquidation queue.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.remove",
            "type": "function_call",
            "what_does_it_track": "The order of safes in the redemption queue.",
            "why_is_is_important": "Ensures that only relevant safes are considered for redemption, which is crucial for the efficiency and correctness of the redemption mechanism. Incorrect handling of safes in this queue could lead to improper redemption orders and system imbalances. ",
            "when_is_it_updated": "When the safe is considered empty after redemption.",
            "how_to_validate_state_update": "Verify the safe is removed by checking that nodes[safeId] is reset to its default value, and that the head and tail of the linked list are correctly updated if the safe was the head or tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the redemption queue.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.upsert",
            "type": "function_call",
            "what_does_it_track": "The order of safes in the liquidation queue.",
            "why_is_is_important": "Maintains an accurate ordering of safes based on their risk profile. Failure to accurately track safe positions within the queue can lead to incorrect liquidation priorities and potentially exacerbate systemic risk. For example, if a higher-risk safe is not correctly positioned, it may not be liquidated in a timely manner, increasing the overall debt exposure of the system. ",
            "when_is_it_updated": "If a safe is not completely emptied during redemption, and thus remains active.",
            "how_to_validate_state_update": "Verify that the safe's position in the liquidation queue is updated based on the new ratio. Check nodes[safeId] to see prev/next values.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's position in the liquidation queue based on the collateralization ratio.",
            "conditions": [
              "(safe.borrowedAmount != 0 && borrowMode) || (!borrowMode && !closeToZero(safe.collateralAmount) && safe.borrowedAmount != 0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "StabilityPool.addReward",
            "type": "function_call",
            "what_does_it_track": "Transfers SBD tokens to StabilityPool.",
            "why_is_is_important": "Increase StabilityPool balance by transfering a fee to it. Properly funded stability pool allows the protocol to stabilize during times of high volatility, which is crucial for maintaining confidence in the system and attracting users. ",
            "when_is_it_updated": "If stabilityPoolCanReceiveRewards is true.",
            "how_to_validate_state_update": "Check the stakingToken.transferFrom method is called correctly with the redemption.ownerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the ownerFee to the StabilityPool as a reward, increasing the StabilityPool's balance.",
            "conditions": [
              "stabilityPoolCanReceiveRewards",
              "redemption.ownerFee > 0"
            ]
          },
          {
            "state_variable_name": "StabilityPool.addCollateralReward",
            "type": "function_call",
            "what_does_it_track": "Transfers ETH to StabilityPool.",
            "why_is_is_important": "Incentivizes liquidity providers by increasing total collateral in StabilityPool. Properly functioning stability pool is essential for maintaining price stability and user confidence in the protocol. ",
            "when_is_it_updated": "When there is a redeemerFee and stabilityPoolCanReceiveRewards is true.",
            "how_to_validate_state_update": "Verify addCollateralReward is called with {value: redemption.redeemerFee}.",
            "has_conditional_updates": true,
            "summary_of_update": "Pay the redeemerFee in collateral (ETH) to the StabilityPool.",
            "conditions": [
              "redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function redeem(\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external onlyInNormalMode {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), amount),\n            \"Unable to transfer SBD\"\n        );\n        uint256 price = priceOracle.fetchPrice();\n        uint256 redemptionId = uint256(\n            keccak256(\n                abi.encode(\n                    msg.sender,\n                    amount,\n                    block.number,\n                    safesOrderedForRedemption.getHead()\n                )\n            )\n        );\n\n        SBStructs.Redemption memory _redemption = SBStructs.Redemption({\n            redemptionId: redemptionId,\n            requestedAmount: amount,\n            price: price,\n            redeemedAmount: 0,\n            refundedAmount: 0,\n            processedSpots: 0,\n            collateralAmount: 0,\n            ownerFee: 0,\n            redeemerFee: 0\n        });\n\n        _redemption = _redeemSafes(_redemption, nearestSpotInLiquidationQueue);\n        _redeemToUser(_redemption);\n        totalCollateral -= (_redemption.collateralAmount +\n            _redemption.redeemerFee);\n        require(_redemption.redeemedAmount == amount, \"Redemption failed\");\n        //totalDebt -= _redemption.redeemedAmount;\n        _updateTotalDebt(\n            totalDebt,\n            _redemption.redeemedAmount - _redemption.refundedAmount,\n            false\n        );\n        if (_redemption.redeemedAmount > _redemption.refundedAmount) {\n            require(\n                sbdToken.burn(\n                    address(this),\n                    _redemption.redeemedAmount - _redemption.refundedAmount\n                ),\n                \"Burn failed\"\n            );\n        }\n\n        emit RedeemedBatch(\n            redemptionId,\n            amount,\n            _redemption.collateralAmount,\n            price,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _redeemSafes(\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (SBStructs.Redemption memory) {\n        uint256 processedSpots = redemption.processedSpots;\n        // Target within 1% = 100 points, 100% = 10000 points\n        while (redemption.redeemedAmount < redemption.requestedAmount) {\n            //uint256 spotForUpdate = 0;\n            uint256 head = safesOrderedForRedemption.getHead();\n            (, redemption) = _redeemNode(\n                head,\n                redemption,\n                nearestSpotInLiquidationQueue\n            );\n            processedSpots++;\n        }\n        redemption.processedSpots = processedSpots;\n        return redemption;\n    }\nfunction _redeemNode(\n        uint256 _safeId,\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        // bytes32 _safeId = bytes32(_safeId);\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        uint256 amountToRedeem = redemption.requestedAmount -\n            redemption.redeemedAmount;\n        uint256 collateralToRedeem = (amountToRedeem * PRECISION) /\n            redemption.price;\n        // Amount of collateral to return back to the redeemer\n        uint256 collateralToReturn = collateralToRedeem;\n        // Amount of stablecoins to refund the safe owner\n        uint256 amountToRefund = 0;\n        // Total fee(in percentage terms) paid by the safe owner\n        // Total collateral value of the safe\n        uint256 ownerFee = 0;\n        uint256 redeemerFee = 0;\n        bool borrowMode;\n        (\n            borrowMode,\n            collateralToRedeem,\n            amountToRedeem,\n            amountToRefund,\n            ownerFee,\n            redeemerFee\n        ) = calculateRedemptionAmountsAndFee(\n            safe,\n            amountToRedeem,\n            redemption.price\n        );\n        if (amountToRefund > 0) {\n            if (amountToRefund > ownerFee) {\n                require(\n                    sbdToken.transfer(\n                        ownerOf(_safeId),\n                        amountToRefund - ownerFee\n                    ),\n                    \"Mint failed for owner fee\"\n                );\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    amountToRefund - ownerFee,\n                    ownerFee\n                );\n            } else {\n                // Nothing to pay owner\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    0,\n                    ownerFee\n                );\n            }\n            if (ownerFee > 0) {\n                redemption.ownerFee += ownerFee;\n                safe.feePaid = 0; // Reset the fee paid by the safe owner\n                safe.totalBorrowedAmount = 1; // Not resetting this to 0 to avoid errors\n                emit OwnerFeePaid(redemption.redemptionId, _safeId, ownerFee);\n            }\n        }\n        // Total amount of collateral to return to the redeemer\n        collateralToReturn = collateralToRedeem - redeemerFee;\n        if (redeemerFee > 0) {\n            redemption.redeemerFee += redeemerFee;\n            emit RedeemerFeePaid(\n                redemption.redemptionId,\n                _safeId,\n                collateralToRedeem,\n                collateralToReturn,\n                redeemerFee\n            );\n        }\n        // update target shielding rate\n        return\n            redeemSafe(\n                _safeId,\n                borrowMode,\n                amountToRedeem,\n                amountToRefund,\n                collateralToRedeem,\n                collateralToReturn,\n                safe,\n                nearestSpotInLiquidationQueue,\n                redemption\n            );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction calculateRedemptionAmountsAndFee(\n        Safe memory safe,\n        uint256 amountToRedeem,\n        uint256 collateralPrice\n    )\n        public\n        view\n        returns (\n            bool borrowMode,\n            uint256 _collateralToRedeem,\n            uint256 _amountToRedeem,\n            uint256 _amountToRefund,\n            uint256 _ownerFee,\n            uint256 _redeemerFee\n        )\n    {\n        uint256 collateralValue = (safe.collateralAmount * collateralPrice) /\n            PRECISION;\n        require(\n            collateralValue >=\n                ((safe.borrowedAmount * liquidationRatio) /\n                    BASIS_POINTS_DIVISOR),\n            \"Safe can't be redeemed\"\n        );\n\n        uint256 feePaidPercentage = ((safe.feePaid *\n            BASIS_POINTS_DIVISOR *\n            PRECISION) / safe.totalBorrowedAmount);\n        // Fee tier to apply for this safe(applied to the redeemer)\n        uint256 feeTier = min(\n            feePaidPercentage + REDEMPTION_BASE_FEE * PRECISION,\n            REDEMPTION_LIQUIDATION_FEE * PRECISION\n        );\n        /*\n        If the fee paid is less than REDEMPTION_BASE_FEE, the redemption fee is (feePaid + REDEMPTION_BASE_FEE)\n         */\n        if (feePaidPercentage <= REDEMPTION_BASE_FEE * PRECISION) {\n            if (amountToRedeem >= collateralValue) {\n                // redeem the whole collateral, while refunding stablecoins back to the owner of the safe\n                _amountToRedeem = safe.borrowedAmount;\n                _amountToRefund = collateralValue - _amountToRedeem;\n                _collateralToRedeem = safe.collateralAmount;\n                // OWNER FEE = REDEMPTION BASE FEE for the\n                // toPay = collateralValue * REDEMPTION_BASE_FEE / BASIS_POINTS_DIVISOR\n                // toPay - feePaid\n                uint256 ownerToPay = (collateralValue * REDEMPTION_BASE_FEE) /\n                    BASIS_POINTS_DIVISOR;\n                if (ownerToPay > safe.feePaid) {\n                    _ownerFee = ownerToPay - safe.feePaid;\n                }\n            } else {\n                if (amountToRedeem >= safe.borrowedAmount) {\n                    _amountToRefund = amountToRedeem - safe.borrowedAmount;\n                    _amountToRedeem = safe.borrowedAmount;\n                    _collateralToRedeem =\n                        ((_amountToRedeem + _amountToRefund) * PRECISION) /\n                        collateralPrice;\n                    _ownerFee =\n                        ((_amountToRedeem + _amountToRefund) *\n                            REDEMPTION_BASE_FEE) /\n                        BASIS_POINTS_DIVISOR;\n                    if (_ownerFee > safe.feePaid) {\n                        _ownerFee = _ownerFee - safe.feePaid;\n                    }\n                } else {\n                    _amountToRedeem = amountToRedeem;\n                    _collateralToRedeem =\n                        (amountToRedeem * PRECISION) /\n                        collateralPrice;\n                    _amountToRefund = 0;\n                    _ownerFee = 0;\n                }\n                // No seller fee here\n            }\n        } else {\n            borrowMode = true;\n            if (amountToRedeem >= safe.borrowedAmount) {\n                _amountToRedeem = safe.borrowedAmount;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n            } else {\n                _amountToRedeem = amountToRedeem;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                //amountToRedeem =\n            }\n        }\n        _redeemerFee = ((_collateralToRedeem * feeTier) /\n            BASIS_POINTS_DIVISOR /\n            PRECISION);\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction redeemSafe(\n        uint256 _safeId,\n        bool borrowMode,\n        uint256 amountToRedeem,\n        uint256 amountToRefund,\n        uint256 collateralToRedeem,\n        uint256 collateralToReturn,\n        Safe memory safe,\n        uint256 nearestSpotInLiquidationQueue,\n        SBStructs.Redemption memory redemption\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        //uint256 amountInCollateral = amountToRedeem /\n        safe.collateralAmount -= collateralToRedeem;\n        safe.borrowedAmount -= amountToRedeem;\n        redemption.collateralAmount += collateralToReturn;\n        redemption.redeemedAmount += amountToRedeem + amountToRefund;\n        redemption.refundedAmount += amountToRefund;\n        safes[_safeId] = safe;\n        // If the safe is empty(borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode)\n        // Borrow mode: If fee paid > REDEMPTION_BASE_FEE\n        // Exchange mode; If fee paid <= REDEMPTION_BASE_FEE\n        if (\n            (safe.borrowedAmount == 0 && borrowMode) ||\n            (!borrowMode &&\n                closeToZero(safe.collateralAmount) &&\n                safe.borrowedAmount == 0)\n        ) {\n            _removeSafeFromBothQueues(_safeId);\n        } else {\n            uint256 newRatio = (safe.borrowedAmount * PRECISION) /\n                safe.collateralAmount;\n            IDoublyLinkedList.Node\n                memory liquidationNode = safesOrderedForLiquidation.upsert(\n                    _safeId,\n                    newRatio,\n                    nearestSpotInLiquidationQueue\n                );\n            emit LiquidationQueueUpdated(\n                _safeId,\n                newRatio,\n                liquidationNode.next\n            );\n        }\n        emit Redeemed(\n            redemption.redemptionId,\n            _safeId,\n            amountToRedeem,\n            collateralToRedeem,\n            amountToRefund,\n            redemption.requestedAmount - redemption.redeemedAmount\n        );\n        return (safe, redemption);\n    }\nfunction closeToZero(uint256 value) internal pure returns (bool) {\n        return value < 1e10;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _redeemToUser(SBStructs.Redemption memory redemption) internal {\n        uint256 collateralRefund = 0;\n        if (redemption.ownerFee > 0) {\n            if (stabilityPoolCanReceiveRewards) {\n                require(\n                    stabilityPool.addReward(redemption.ownerFee),\n                    \"Add reward failed\"\n                );\n                emit OwnerRedemptionFeeDistributed(\n                    redemption.redemptionId,\n                    redemption.ownerFee\n                );\n            } else {\n                require(\n                    sbdToken.transfer(msg.sender, redemption.ownerFee),\n                    \"Owner fee refund failed\"\n                );\n            }\n        }\n        if (redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards) {\n            require(\n                stabilityPool.addCollateralReward{\n                    value: redemption.redeemerFee\n                }(redemption.redeemerFee),\n                \"Add collateral reward failed\"\n            );\n        } else {\n            collateralRefund = redemption.redeemerFee;\n        }\n        (bool success, ) = msg.sender.call{\n            value: redemption.collateralAmount + collateralRefund\n        }(\"\");\n        require(success, \"Transfer failed\");\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction transfer(address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}