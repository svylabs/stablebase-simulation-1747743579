{
  "action": {
    "name": "Redeem",
    "summary": "Redeems debt.",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "pre_execution_parameter_generation_rules": [
      "amount: The amount of SBD tokens the user wants to redeem. Must be greater than 0.",
      "nearestSpotInLiquidationQueue: A hint to the contract about the nearest spot in the liquidation queue for efficient processing. Can be set to 0 initially.",
      "Ensure that the msg.sender has sufficient SBD tokens to transfer to the contract. Approve the contract before executing the function."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "SBD tokens are transferred from the msg.sender to the StableBaseCDP contract.",
          "SBD tokens are burned from the StableBaseCDP contract.",
          "Collateral (ETH) is transferred to the msg.sender (redeemer)."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Owner fee (if any) is transferred to the StabilityPool contract (if stabilityPoolCanReceiveRewards is true) or to the msg.sender (if stabilityPoolCanReceiveRewards is false).",
          "Redeemer fee (collateral) is transferred to the StabilityPool contract or the redeemer."
        ]
      },
      {
        "category": "Debt and Collateral Tracking",
        "state_update_descriptions": [
          "totalCollateral is decreased by the collateral amount plus the redeemer fee.",
          "totalDebt is decreased by the redeemed amount minus the refunded amount."
        ]
      },
      {
        "category": "Safe Management",
        "state_update_descriptions": [
          "The collateralAmount and borrowedAmount of individual safes are decreased.",
          "Safes might be removed from the liquidation and redemption queues if their borrowedAmount and collateralAmount becomes 0.",
          "Safes' positions in the liquidation queue are updated based on their new collateral ratio.",
          "LiquidationSnapshots are updated to track cumulative debt and collateral."
        ]
      },
      {
        "category": "Protocol State",
        "state_update_descriptions": [
          "PROTOCOL_MODE can be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Redemption Success",
        "rule_descriptions": [
          "The redemption should succeed only if the amount redeemed is equal to the amount requested, or the safe can't be redeemed.",
          "The totalCollateral should decrease by the expected amount based on the redeemed collateral.",
          "The totalDebt should decrease by the amount of SBD burned.",
          "SBD tokens should be transferred from the redeemer, and burned from contract's balance.",
          "Collateral should be transferred to the redeemer.",
          "The safe's collateralAmount and borrowedAmount should be decreased appropriately.",
          "Events such as RedeemedBatch, Redeemed, OwnerFeePaid, RedeemerFeePaid, OwnerRefunded, LiquidationQueueUpdated, and SafeRemovedFromLiquidationQueue must be emitted with the correct parameters if applicable."
        ]
      },
      {
        "category": "Safe State",
        "rule_descriptions": [
          "If a safe's borrowedAmount and collateralAmount becomes 0, it should be removed from both the liquidation and redemption queues.",
          "If a safe's borrowedAmount is not 0, its position in the liquidation queue should be updated based on its new collateral ratio.",
          "LiquidationSnapshots for each safe should be updated with collateralPerCollateralSnapshot and debtPerCollateralSnapshot."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "If stabilityPoolCanReceiveRewards is true, the owner fee should be added as a reward to the StabilityPool contract.",
          "If stabilityPoolCanReceiveRewards is false, the owner fee should be transferred to the msg.sender.",
          "If stabilityPoolCanReceiveRewards is true, the redeemer fee (collateral) should be added as a reward to the StabilityPool contract.",
          "The balances of the involved parties (redeemer, contract, stability pool) should reflect the transfers."
        ]
      },
      {
        "category": "Accounting Integrity",
        "rule_descriptions": [
          "The contract's accounting variables (totalCollateral, totalDebt) should reflect the changes due to the redemption.",
          "The cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral should reflect the changes in total collateral and debt."
        ]
      },
      {
        "category": "Protocol Mode",
        "rule_descriptions": [
          "The protocol mode should switch from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total amount of collateral locked in the protocol.",
            "why_is_is_important": "Reflects the current total collateral supporting the system's debt, directly impacting the protocol's solvency and collateralization ratio. A healthy totalCollateral ensures the system can cover outstanding debt during liquidations or redemptions.",
            "when_is_it_updated": "After successful redemption.",
            "how_to_validate_state_update": "Check the emitted 'RedeemedBatch' event for the final values of totalCollateral and totalDebt. Verify that totalCollateral decreases by the expected amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by the amount of collateral released to the redeemer and any redeemer fees.",
            "conditions": [
              "amount > 0",
              "sbdToken.transferFrom succeeds",
              "PROTOCOL_MODE is NORMAL"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total outstanding debt in the system.",
            "why_is_is_important": "Reflects the current total debt outstanding in the system, indicating the protocol's overall liability. Keeping totalDebt at a manageable level is crucial for maintaining financial stability and minimizing liquidation risks.",
            "when_is_it_updated": "After successful burning of SBD tokens.",
            "how_to_validate_state_update": "Check the emitted 'RedeemedBatch' event and verify the 'totalDebt' value decreases by the expected amount after the transaction. Confirm the SBD burn event.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by the amount of SBD burned, which equals the redeemed amount minus any refunded amount.",
            "conditions": [
              "amount > 0",
              "sbdToken.transferFrom succeeds",
              "PROTOCOL_MODE is NORMAL",
              "_redemption.redeemedAmount > _redemption.refundedAmount",
              "sbdToken.burn is successful"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "Details of each safe (collateral, debt, etc.).",
            "why_is_is_important": "Accurately reflects the current state of each safe, which is essential for calculating correct redemption amounts and fees, and for determining liquidation risks. Maintains data consistency for the protocol.",
            "when_is_it_updated": "Before redemption occurs for a given safe to apply accrued interest.",
            "how_to_validate_state_update": "Check the emitted 'SafeUpdated' event to verify the collateralAmount and borrowedAmount were updated as expected. Compare these values before and after the transaction to validate the changes.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates a specific safe's collateralAmount and borrowedAmount based on cumulative interest and collateral accrual. Updates safe attributes.",
            "conditions": [
              "Conditions within _updateSafe: if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Order of safes for liquidation.",
            "why_is_is_important": "Maintains an accurate order for efficient liquidation processes, preventing unnecessary iterations and optimizing gas costs. Removing empty safes keeps the queue relevant and performant.",
            "when_is_it_updated": "When a safe is fully redeemed and becomes empty.",
            "how_to_validate_state_update": "Check for the 'SafeRemovedFromLiquidationQueue' and 'SafeRemovedFromRedemptionQueue' events, confirming that the safe was indeed removed from both queues. Verify that the safe is no longer present in the doubly linked lists.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the liquidation queue if it becomes empty.",
            "conditions": [
              "safe.borrowedAmount == 0 && borrowMode || !borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Order of safes for redemption.",
            "why_is_is_important": "Maintains an accurate order for efficient redemption processes, optimizing gas costs and ensuring that only relevant safes are considered. Streamlines the redemption process and contributes to overall system efficiency.",
            "when_is_it_updated": "When a safe is fully redeemed and becomes empty.",
            "how_to_validate_state_update": "Check for the 'SafeRemovedFromLiquidationQueue' and 'SafeRemovedFromRedemptionQueue' events, confirming that the safe was indeed removed from both queues. Verify that the safe is no longer present in the doubly linked lists.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the redemption queue if it becomes empty.",
            "conditions": [
              "safe.borrowedAmount == 0 && borrowMode || !borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Dictates which protocol rules are active, influencing interest rates, liquidation thresholds, and other critical parameters. Correct mode transitions are vital for maintaining the protocol's economic incentives and risk management.",
            "when_is_it_updated": "After totalDebt is updated, based on the new value.",
            "how_to_validate_state_update": "Check the value of PROTOCOL_MODE after the transaction to confirm the state transition. Verify that the protocol rules associated with NORMAL mode are now active.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes to NORMAL if debt exceeds threshold and current mode is BOOTSTRAP.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "SBD balances for each address.",
            "why_is_is_important": "Maintains accurate records of SBD holdings, ensuring that the protocol correctly accounts for all SBD tokens and can accurately process transfers, redemptions, and liquidations. Accurate balances are fundamental to financial integrity.",
            "when_is_it_updated": "When burning SBD tokens.",
            "how_to_validate_state_update": "Check for the 'Burn' event and confirm that the contract's SBD balance decreased by the specified amount. Retrieve the contract's balance before and after the transaction to validate the reduction.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the contract's SBD balance.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of SBD tokens.",
            "why_is_is_important": "Reflects the accurate total number of SBD tokens in existence, critical for calculating market capitalization, assessing supply dynamics, and ensuring proper functioning of economic mechanisms within the protocol.",
            "when_is_it_updated": "When burning SBD tokens.",
            "how_to_validate_state_update": "Check the total supply before and after the transaction and confirm the expected decrease. Verify the 'Burn' event to ensure the burned amount matches the reduction in total supply.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total supply of SBD tokens.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD tokens burned.",
            "why_is_is_important": "Tracks the cumulative amount of SBD permanently removed from circulation, providing insights into the token's deflationary mechanisms and influencing its long-term supply dynamics.",
            "when_is_it_updated": "After burning SBD tokens.",
            "how_to_validate_state_update": "Check the emitted 'Burn' event for the amount burned and confirm that the totalBurned increased accordingly. Retrieve the totalBurned value before and after the transaction to validate the update.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases by the amount of SBD tokens burned.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount",
              "sbdToken.burn is successful"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakingToken",
            "type": "IERC20",
            "what_does_it_track": "Underlying token of StabilityPool.",
            "why_is_is_important": "Tracks assets locked in StabilityPool to facilitate liquidations and incentivize stakers. The amount of stakingToken represents the pool's capacity to absorb debt.",
            "when_is_it_updated": "When distributing owner redemption fee.",
            "how_to_validate_state_update": "Check for the 'RewardAdded' event in StabilityPool and verify that the StabilityPool's stakingToken balance has increased by the amount of the owner fee.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the StabilityPool's stakingToken balance if owner fee is positive and rewards can be received.",
            "conditions": [
              "redemption.ownerFee > 0",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Total reward per token.",
            "why_is_is_important": "Tracks rewards for stakers in the StabilityPool, incentivizing participation and stabilizing the system. Distributing rewards encourages users to provide liquidity, improving the pool's efficacy.",
            "when_is_it_updated": "When distributing owner redemption fee.",
            "how_to_validate_state_update": "Check for the 'RewardAdded' event in StabilityPool and calculate expected increase in totalRewardPerToken. Verify that this increase matches the actual change in totalRewardPerToken.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the total reward per token, distributing owner fees to stakers.",
            "conditions": [
              "redemption.ownerFee > 0",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "rewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks undistributed reward due to precision loss.",
            "why_is_is_important": "Maintains accounting accuracy by tracking any undistributed rewards due to rounding errors, ensuring that these small amounts are properly accounted for in future distributions, thus avoiding cumulative inaccuracies.",
            "when_is_it_updated": "When distributing owner redemption fee.",
            "how_to_validate_state_update": "Check for the 'RewardAdded' event in StabilityPool. Verify that rewardLoss is updated correctly to account for any precision loss during the reward distribution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates rewardLoss to reflect any undistributed reward due to precision loss.",
            "conditions": [
              "redemption.ownerFee > 0",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Total collateral per token",
            "why_is_is_important": "Tracks collateral rewards for stakers in the StabilityPool, directly impacting the return on staked assets and incentivizing participation. Higher collateral per token attracts more liquidity, improving liquidation effectiveness.",
            "when_is_it_updated": "When distributing redeemer fee.",
            "how_to_validate_state_update": "Check for the 'CollateralRewardAdded' event in StabilityPool and verify that totalCollateralPerToken is updated as expected based on the redeemer fee.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the total collateral per token by distributing the redeemer fee.",
            "conditions": [
              "redemption.redeemerFee > 0",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks undistributed collateral due to precision loss.",
            "why_is_is_important": "Maintains accounting accuracy of collateral rewards, preventing small discrepancies from accumulating and ensuring precise reward calculations for stakers over time. Ensures all collateral is accounted for.",
            "when_is_it_updated": "When distributing redeemer fee.",
            "how_to_validate_state_update": "Check for the 'CollateralRewardAdded' event in StabilityPool. Verify that collateralLoss is updated correctly to account for any precision loss during the collateral reward distribution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralLoss to reflect any undistributed collateral due to precision loss.",
            "conditions": [
              "redemption.redeemerFee > 0",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function redeem(\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external onlyInNormalMode {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), amount),\n            \"Unable to transfer SBD\"\n        );\n        uint256 price = priceOracle.fetchPrice();\n        uint256 redemptionId = uint256(\n            keccak256(\n                abi.encode(\n                    msg.sender,\n                    amount,\n                    block.number,\n                    safesOrderedForRedemption.getHead()\n                )\n            )\n        );\n\n        SBStructs.Redemption memory _redemption = SBStructs.Redemption({\n            redemptionId: redemptionId,\n            requestedAmount: amount,\n            price: price,\n            redeemedAmount: 0,\n            refundedAmount: 0,\n            processedSpots: 0,\n            collateralAmount: 0,\n            ownerFee: 0,\n            redeemerFee: 0\n        });\n\n        _redemption = _redeemSafes(_redemption, nearestSpotInLiquidationQueue);\n        _redeemToUser(_redemption);\n        totalCollateral -= (_redemption.collateralAmount +\n            _redemption.redeemerFee);\n        require(_redemption.redeemedAmount == amount, \"Redemption failed\");\n        //totalDebt -= _redemption.redeemedAmount;\n        _updateTotalDebt(\n            totalDebt,\n            _redemption.redeemedAmount - _redemption.refundedAmount,\n            false\n        );\n        if (_redemption.redeemedAmount > _redemption.refundedAmount) {\n            require(\n                sbdToken.burn(\n                    address(this),\n                    _redemption.redeemedAmount - _redemption.refundedAmount\n                ),\n                \"Burn failed\"\n            );\n        }\n\n        emit RedeemedBatch(\n            redemptionId,\n            amount,\n            _redemption.collateralAmount,\n            price,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _redeemSafes(\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (SBStructs.Redemption memory) {\n        uint256 processedSpots = redemption.processedSpots;\n        // Target within 1% = 100 points, 100% = 10000 points\n        while (redemption.redeemedAmount < redemption.requestedAmount) {\n            //uint256 spotForUpdate = 0;\n            uint256 head = safesOrderedForRedemption.getHead();\n            (, redemption) = _redeemNode(\n                head,\n                redemption,\n                nearestSpotInLiquidationQueue\n            );\n            processedSpots++;\n        }\n        redemption.processedSpots = processedSpots;\n        return redemption;\n    }\nfunction _redeemNode(\n        uint256 _safeId,\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        // bytes32 _safeId = bytes32(_safeId);\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        uint256 amountToRedeem = redemption.requestedAmount -\n            redemption.redeemedAmount;\n        uint256 collateralToRedeem = (amountToRedeem * PRECISION) /\n            redemption.price;\n        // Amount of collateral to return back to the redeemer\n        uint256 collateralToReturn = collateralToRedeem;\n        // Amount of stablecoins to refund the safe owner\n        uint256 amountToRefund = 0;\n        // Total fee(in percentage terms) paid by the safe owner\n        // Total collateral value of the safe\n        uint256 ownerFee = 0;\n        uint256 redeemerFee = 0;\n        bool borrowMode;\n        (\n            borrowMode,\n            collateralToRedeem,\n            amountToRedeem,\n            amountToRefund,\n            ownerFee,\n            redeemerFee\n        ) = calculateRedemptionAmountsAndFee(\n            safe,\n            amountToRedeem,\n            redemption.price\n        );\n        if (amountToRefund > 0) {\n            if (amountToRefund > ownerFee) {\n                require(\n                    sbdToken.transfer(\n                        ownerOf(_safeId),\n                        amountToRefund - ownerFee\n                    ),\n                    \"Mint failed for owner fee\"\n                );\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    amountToRefund - ownerFee,\n                    ownerFee\n                );\n            } else {\n                // Nothing to pay owner\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    0,\n                    ownerFee\n                );\n            }\n            if (ownerFee > 0) {\n                redemption.ownerFee += ownerFee;\n                safe.feePaid = 0; // Reset the fee paid by the safe owner\n                safe.totalBorrowedAmount = 1; // Not resetting this to 0 to avoid errors\n                emit OwnerFeePaid(redemption.redemptionId, _safeId, ownerFee);\n            }\n        }\n        // Total amount of collateral to return to the redeemer\n        collateralToReturn = collateralToRedeem - redeemerFee;\n        if (redeemerFee > 0) {\n            redemption.redeemerFee += redeemerFee;\n            emit RedeemerFeePaid(\n                redemption.redemptionId,\n                _safeId,\n                collateralToRedeem,\n                collateralToReturn,\n                redeemerFee\n            );\n        }\n        // update target shielding rate\n        return\n            redeemSafe(\n                _safeId,\n                borrowMode,\n                amountToRedeem,\n                amountToRefund,\n                collateralToRedeem,\n                collateralToReturn,\n                safe,\n                nearestSpotInLiquidationQueue,\n                redemption\n            );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction calculateRedemptionAmountsAndFee(\n        Safe memory safe,\n        uint256 amountToRedeem,\n        uint256 collateralPrice\n    )\n        public\n        view\n        returns (\n            bool borrowMode,\n            uint256 _collateralToRedeem,\n            uint256 _amountToRedeem,\n            uint256 _amountToRefund,\n            uint256 _ownerFee,\n            uint256 _redeemerFee\n        )\n    {\n        uint256 collateralValue = (safe.collateralAmount * collateralPrice) /\n            PRECISION;\n        require(\n            collateralValue >=\n                ((safe.borrowedAmount * liquidationRatio) /\n                    BASIS_POINTS_DIVISOR),\n            \"Safe can't be redeemed\"\n        );\n\n        uint256 feePaidPercentage = ((safe.feePaid *\n            BASIS_POINTS_DIVISOR *\n            PRECISION) / safe.totalBorrowedAmount);\n        // Fee tier to apply for this safe(applied to the redeemer)\n        uint256 feeTier = min(\n            feePaidPercentage + REDEMPTION_BASE_FEE * PRECISION,\n            REDEMPTION_LIQUIDATION_FEE * PRECISION\n        );\n        /*\n        If the fee paid is less than REDEMPTION_BASE_FEE, the redemption fee is (feePaid + REDEMPTION_BASE_FEE)\n         */\n        if (feePaidPercentage <= REDEMPTION_BASE_FEE * PRECISION) {\n            if (amountToRedeem >= collateralValue) {\n                // redeem the whole collateral, while refunding stablecoins back to the owner of the safe\n                _amountToRedeem = safe.borrowedAmount;\n                _amountToRefund = collateralValue - _amountToRedeem;\n                _collateralToRedeem = safe.collateralAmount;\n                // OWNER FEE = REDEMPTION BASE FEE for the\n                // toPay = collateralValue * REDEMPTION_BASE_FEE / BASIS_POINTS_DIVISOR\n                // toPay - feePaid\n                uint256 ownerToPay = (collateralValue * REDEMPTION_BASE_FEE) /\n                    BASIS_POINTS_DIVISOR;\n                if (ownerToPay > safe.feePaid) {\n                    _ownerFee = ownerToPay - safe.feePaid;\n                }\n            } else {\n                if (amountToRedeem >= safe.borrowedAmount) {\n                    _amountToRefund = amountToRedeem - safe.borrowedAmount;\n                    _amountToRedeem = safe.borrowedAmount;\n                    _collateralToRedeem =\n                        ((_amountToRedeem + _amountToRefund) * PRECISION) /\n                        collateralPrice;\n                    _ownerFee =\n                        ((_amountToRedeem + _amountToRefund) *\n                            REDEMPTION_BASE_FEE) /\n                        BASIS_POINTS_DIVISOR;\n                    if (_ownerFee > safe.feePaid) {\n                        _ownerFee = _ownerFee - safe.feePaid;\n                    }\n                } else {\n                    _amountToRedeem = amountToRedeem;\n                    _collateralToRedeem =\n                        (amountToRedeem * PRECISION) /\n                        collateralPrice;\n                    _amountToRefund = 0;\n                    _ownerFee = 0;\n                }\n                // No seller fee here\n            }\n        } else {\n            borrowMode = true;\n            if (amountToRedeem >= safe.borrowedAmount) {\n                _amountToRedeem = safe.borrowedAmount;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n            } else {\n                _amountToRedeem = amountToRedeem;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                //amountToRedeem =\n            }\n        }\n        _redeemerFee = ((_collateralToRedeem * feeTier) /\n            BASIS_POINTS_DIVISOR /\n            PRECISION);\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction redeemSafe(\n        uint256 _safeId,\n        bool borrowMode,\n        uint256 amountToRedeem,\n        uint256 amountToRefund,\n        uint256 collateralToRedeem,\n        uint256 collateralToReturn,\n        Safe memory safe,\n        uint256 nearestSpotInLiquidationQueue,\n        SBStructs.Redemption memory redemption\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        //uint256 amountInCollateral = amountToRedeem /\n        safe.collateralAmount -= collateralToRedeem;\n        safe.borrowedAmount -= amountToRedeem;\n        redemption.collateralAmount += collateralToReturn;\n        redemption.redeemedAmount += amountToRedeem + amountToRefund;\n        redemption.refundedAmount += amountToRefund;\n        safes[_safeId] = safe;\n        // If the safe is empty(borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode)\n        // Borrow mode: If fee paid > REDEMPTION_BASE_FEE\n        // Exchange mode; If fee paid <= REDEMPTION_BASE_FEE\n        if (\n            (safe.borrowedAmount == 0 && borrowMode) ||\n            (!borrowMode &&\n                closeToZero(safe.collateralAmount) &&\n                safe.borrowedAmount == 0)\n        ) {\n            _removeSafeFromBothQueues(_safeId);\n        } else {\n            uint256 newRatio = (safe.borrowedAmount * PRECISION) /\n                safe.collateralAmount;\n            IDoublyLinkedList.Node\n                memory liquidationNode = safesOrderedForLiquidation.upsert(\n                    _safeId,\n                    newRatio,\n                    nearestSpotInLiquidationQueue\n                );\n            emit LiquidationQueueUpdated(\n                _safeId,\n                newRatio,\n                liquidationNode.next\n            );\n        }\n        emit Redeemed(\n            redemption.redemptionId,\n            _safeId,\n            amountToRedeem,\n            collateralToRedeem,\n            amountToRefund,\n            redemption.requestedAmount - redemption.redeemedAmount\n        );\n        return (safe, redemption);\n    }\nfunction closeToZero(uint256 value) internal pure returns (bool) {\n        return value < 1e10;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _redeemToUser(SBStructs.Redemption memory redemption) internal {\n        uint256 collateralRefund = 0;\n        if (redemption.ownerFee > 0) {\n            if (stabilityPoolCanReceiveRewards) {\n                require(\n                    stabilityPool.addReward(redemption.ownerFee),\n                    \"Add reward failed\"\n                );\n                emit OwnerRedemptionFeeDistributed(\n                    redemption.redemptionId,\n                    redemption.ownerFee\n                );\n            } else {\n                require(\n                    sbdToken.transfer(msg.sender, redemption.ownerFee),\n                    \"Owner fee refund failed\"\n                );\n            }\n        }\n        if (redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards) {\n            require(\n                stabilityPool.addCollateralReward{\n                    value: redemption.redeemerFee\n                }(redemption.redeemerFee),\n                \"Add collateral reward failed\"\n            );\n        } else {\n            collateralRefund = redemption.redeemerFee;\n        }\n        (bool success, ) = msg.sender.call{\n            value: redemption.collateralAmount + collateralRefund\n        }(\"\");\n        require(success, \"Transfer failed\");\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction transfer(address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}