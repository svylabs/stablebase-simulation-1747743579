{
  "action": {
    "name": "Redeem",
    "summary": "Redeems debt.",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "pre_execution_parameter_generation_rules": [
      "The 'amount' parameter (uint256) represents the quantity of SBD tokens the user wishes to redeem. It must be greater than zero.",
      "The user must have sufficient SBD tokens in their balance to cover the 'amount'.",
      "The user must have previously approved the StableBaseCDP contract to spend at least the 'amount' of SBD tokens on their behalf (via sbdToken.approve(StableBaseCDP_address, amount)).",
      "The 'nearestSpotInLiquidationQueue' parameter (uint256) is an optional hint for optimizing the re-insertion of a partially redeemed safe into the liquidation queue. It should be the ID of a safe (node) that is expected to be close to the new collateralization ratio of the safe being updated. If no such hint is available or accurate, it can be set to 0, and the function will still operate correctly, albeit potentially less efficiently for large queues. For optimal performance, consider querying the current liquidation queue to find a suitable nearest spot if a specific safe is known to be affected."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Token Transfers & Burns",
        "state_update_descriptions": [
          "The user's SBD token balance will decrease by the 'amount' specified for redemption.",
          "The StableBaseCDP contract's SBD token balance will temporarily increase by the 'amount' from the user, then decrease by the net amount burned after refunds.",
          "The total supply of SBD tokens will decrease by the net amount of SBD burned (redemption.redeemedAmount - redemption.refundedAmount).",
          "If safe owners are refunded SBD tokens, their respective SBD token balances will increase.",
          "If the 'stabilityPoolCanReceiveRewards' flag is false and an owner fee is due, the caller's SBD token balance will increase by the owner fee."
        ]
      },
      {
        "category": "Collateral (ETH) Transfers",
        "state_update_descriptions": [
          "The caller's ETH balance will increase by the sum of 'redemption.collateralAmount' (collateral corresponding to redeemed debt) and any 'collateralRefund' from the redeemer fee (if StabilityPool cannot receive collateral rewards).",
          "If the 'stabilityPoolCanReceiveRewards' flag is true and a redeemer fee is due, the StabilityPool contract's ETH balance will increase by the redeemer fee."
        ]
      },
      {
        "category": "StableBaseCDP Contract State",
        "state_update_descriptions": [
          "The 'totalCollateral' in the StableBaseCDP contract will decrease by the total collateral redeemed ('redemption.collateralAmount' + 'redemption.redeemerFee').",
          "The 'totalDebt' in the StableBaseCDP contract will decrease by the net amount of SBD redeemed ('redemption.redeemedAmount' - 'redemption.refundedAmount').",
          "If 'totalDebt' falls below 'BOOTSTRAP_MODE_DEBT_THRESHOLD' and the protocol is currently in 'BOOTSTRAP' mode, the 'PROTOCOL_MODE' will transition to 'NORMAL'."
        ]
      },
      {
        "category": "Individual Safe State & Queues",
        "state_update_descriptions": [
          "For each affected safe, its 'collateralAmount' will decrease by the 'collateralToRedeem' for that safe.",
          "For each affected safe, its 'borrowedAmount' will decrease by the 'amountToRedeem' for that safe.",
          "If a safe is fully redeemed (its 'borrowedAmount' becomes 0 in borrow mode or both 'collateralAmount' and 'borrowedAmount' become 0 in exchange mode), it will be removed from both 'safesOrderedForLiquidation' and 'safesOrderedForRedemption'.",
          "If a safe is partially redeemed, its position in the 'safesOrderedForLiquidation' doubly linked list will be updated based on its new collateralization ratio.",
          "The 'feePaid' for a safe may be reset to 0 if an owner fee is paid.",
          "The 'totalBorrowedAmount' for a safe may be reset to 1 (not 0) if an owner fee is paid.",
          "Liquidation snapshots ('collateralPerCollateralSnapshot' and 'debtPerCollateralSnapshot') for affected safes will be updated based on cumulative global snapshots."
        ]
      },
      {
        "category": "StabilityPool Contract State (if applicable)",
        "state_update_descriptions": [
          "If 'stabilityPoolCanReceiveRewards' is true and an owner fee is due, the 'totalRewardPerToken' and 'rewardLoss' in the StabilityPool may increase due to SBD reward.",
          "If 'stabilityPoolCanReceiveRewards' is true and a redeemer fee is due, the 'totalCollateralPerToken' and 'collateralLoss' in the StabilityPool may increase due to collateral reward.",
          "The 'lastSBRRewardDistributedTime', 'sbrRewardDistributionEndTime', 'sbrRewardDistributionStatus', 'totalSbrRewardPerToken', and 'sbrRewardLoss' in the StabilityPool may be updated as SBR rewards are processed."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Token Balances and Supply",
        "rule_descriptions": [
          "Verify that the user's SBD token balance has decreased by the 'amount' provided in the input.",
          "Verify that the StableBaseCDP contract's SBD token balance has decreased by the net amount of SBD burned (redemption.redeemedAmount - redemption.refundedAmount).",
          "Verify that the total supply of SBD tokens (DFIDToken.totalSupply()) has decreased by the net amount burned.",
          "Verify that the user's ETH balance has increased by the 'redemption.collateralAmount' plus any 'collateralRefund' (redeemer fee if StabilityPool cannot receive rewards).",
          "If 'stabilityPoolCanReceiveRewards' is true and an owner fee was paid, verify that the StabilityPool's SBD balance has increased by the 'ownerFee'.",
          "If 'stabilityPoolCanReceiveRewards' is true and a redeemer fee was paid, verify that the StabilityPool's ETH balance has increased by the 'redeemerFee'."
        ]
      },
      {
        "category": "StableBaseCDP Global State",
        "rule_descriptions": [
          "Verify that 'StableBaseCDP.totalCollateral' has decreased by the total collateral redeemed ('redemption.collateralAmount' + 'redemption.redeemerFee').",
          "Verify that 'StableBaseCDP.totalDebt' has decreased by the net amount of SBD redeemed ('redemption.redeemedAmount' - 'redemption.refundedAmount').",
          "If applicable, verify that 'StableBaseCDP.PROTOCOL_MODE' has transitioned from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' crossed the threshold."
        ]
      },
      {
        "category": "Individual Safe State and Queue Integrity",
        "rule_descriptions": [
          "For each safe targeted for redemption, verify that its 'collateralAmount' and 'borrowedAmount' within the 'safes' mapping have been correctly reduced.",
          "For each safe processed by the `redeem` function, verify that its `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` is equal to the final `StableBaseCDP.cumulativeCollateralPerUnitCollateral` and its `liquidationSnapshots[safeId].debtPerCollateralSnapshot` is equal to the final `StableBaseCDP.cumulativeDebtPerUnitCollateral` for that transaction.",
          "For any safe that was fully redeemed, verify that it has been removed from both 'safesOrderedForLiquidation' and 'safesOrderedForRedemption' linked lists.",
          "For any safe that was partially redeemed, verify that its position in 'safesOrderedForLiquidation' has been updated according to its new collateralization ratio.",
          "Verify that 'safe.feePaid' is reset to 0 for affected safes if an owner fee was applicable and paid.",
          "Verify that 'safe.totalBorrowedAmount' is reset to 1 for affected safes if an owner fee was applicable and paid."
        ]
      },
      {
        "category": "Event Emission Verification",
        "rule_descriptions": [
          "Verify the emission of a 'RedeemedBatch' event with the correct 'redemptionId', 'amount' (matching the input), 'redeemedCollateral', 'price', and updated 'totalCollateral' and 'totalDebt'.",
          "Verify the emission of 'Transfer' events from the SBD token contract for the 'transferFrom' call (from user to StableBaseCDP) and any refunds to safe owners or the caller.",
          "Verify the emission of a 'Burn' event from the SBD token contract for the net amount burned by the StableBaseCDP contract.",
          "Verify the emission of a 'Redeemed' event for each individual safe that was processed during redemption, checking 'redemptionId', 'safeId', 'amountToRedeem', 'collateralToRedeem', 'amountToRefund', and 'remaningToRedeem'.",
          "If applicable, verify the emission of 'OwnerRefunded' and 'OwnerFeePaid' events.",
          "If applicable, verify the emission of a 'RedeemerFeePaid' event.",
          "If 'stabilityPoolCanReceiveRewards' is true and an owner fee was distributed, verify the emission of 'OwnerRedemptionFeeDistributed'.",
          "If 'stabilityPoolCanReceiveRewards' is true and a redeemer fee was distributed as collateral, verify the emission of 'CollateralRewardAdded' from the StabilityPool contract.",
          "If safes were removed from queues, verify the emission of 'SafeRemovedFromLiquidationQueue' and 'SafeRemovedFromRedemptionQueue' events for those safes.",
          "If safes' positions in the liquidation queue were updated, verify the emission of 'LiquidationQueueUpdated' events.",
          "Verify the emission of 'SafeUpdated' event for each safe whose `borrowedAmount` and `collateralAmount` were adjusted due to cumulative debt/collateral changes."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total sum of collateral (e.g., ETH) locked in all active Safes within the StableBase protocol.",
            "why_is_is_important": "It is crucial for tracking the protocol's overall collateralization and health. A decrease indicates that collateral has been unlocked and returned as debt is redeemed.",
            "when_is_it_updated": "Decreased in the `redeem` function after processing all relevant safes for redemption, reflecting the collateral returned to the redeemer or sent to the Stability Pool as fees.",
            "how_to_validate_state_update": "Verify that `totalCollateral` is reduced by the sum of `_redemption.collateralAmount` (collateral returned to redeemer) and `_redemption.redeemerFee` (collateral sent to StabilityPool or refunded to redeemer) after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The total amount of collateral held in the protocol is decreased.",
            "conditions": [
              "Always, unless the redemption amount is fully refunded to the owner (which would make `_redemption.collateralAmount + _redemption.redeemerFee` zero or negligible, but the formula ensures it's always positive if any collateral is returned/redeemed)."
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The aggregate amount of StableBase Dollar (SBD) stablecoins that have been borrowed against collateral in all active Safes.",
            "why_is_is_important": "This variable tracks the total supply of SBD in circulation that is backed by collateral. Its reduction signifies a decrease in protocol-wide debt and helps maintain the stablecoin's peg.",
            "when_is_it_updated": "Decreased in the `redeem` function by the amount of SBD successfully redeemed and burned, via the `_updateTotalDebt` function. This happens after the SBD transfer and burning operations.",
            "how_to_validate_state_update": "Verify that `totalDebt` is reduced by `_redemption.redeemedAmount - _redemption.refundedAmount` through the `_updateTotalDebt` internal function.",
            "has_conditional_updates": true,
            "summary_of_update": "The total outstanding debt in the protocol is reduced by the net amount of stablecoins redeemed.",
            "conditions": [
              "The `_updateTotalDebt` function is always called. `totalDebt` is decreased if `_redemption.redeemedAmount` is greater than `_redemption.refundedAmount`."
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current operating mode of the protocol (e.g., `BOOTSTRAP` or `NORMAL`), which can affect various parameters and fee structures.",
            "why_is_is_important": "This dictates the operational parameters of the protocol, ensuring stability and proper functioning at different stages of adoption or debt levels.",
            "when_is_it_updated": "Potentially updated within the `_updateTotalDebt` function (called by `redeem`) if the new `totalDebt` crosses the `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is currently in `BOOTSTRAP` mode.",
            "how_to_validate_state_update": "Check if `PROTOCOL_MODE` transitions from `BOOTSTRAP` to `NORMAL` if the updated `totalDebt` surpasses the `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol was previously in `BOOTSTRAP` mode.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol's operational mode might switch from `BOOTSTRAP` to `NORMAL` if the `totalDebt` surpasses a predefined threshold.",
            "conditions": [
              "Only if `totalDebt` (after the current update) exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD` AND the `PROTOCOL_MODE` is currently `BOOTSTRAP`."
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "A mapping from `safeId` (an NFT ID) to a `Safe` struct, which stores the `collateralAmount` (amount of ETH deposited), `borrowedAmount` (amount of SBD borrowed), `weight`, `totalBorrowedAmount`, and `feePaid` for each individual Safe.",
            "why_is_is_important": "This mapping represents the core collateralized debt positions in the system. Accurate updates are vital to reflect the current state of each CDP, its collateralization ratio, and the amount of debt associated with it.",
            "when_is_it_updated": "Updated for each Safe involved in the redemption process, first in `_updateSafe` to account for accrued debt and collateral, and then in `redeemSafe` to reflect the actual reduction from redemption.",
            "how_to_validate_state_update": "After redemption, verify that the `collateralAmount` and `borrowedAmount` for the redeemed Safe are decreased by the respective amounts. If an `ownerFee` was paid, `feePaid` should reset to 0 and `totalBorrowedAmount` to 1. Additionally, check for updates from `_updateSafe` based on cumulative snapshots.",
            "has_conditional_updates": false,
            "summary_of_update": "The `collateralAmount`, `borrowedAmount`, `feePaid`, and `totalBorrowedAmount` for each `Safe` being redeemed are adjusted to reflect the redemption. This includes reducing borrowed debt and collateral, potentially resetting `feePaid`, and adjusting `totalBorrowedAmount`.",
            "conditions": [
              "Always, for each Safe processed during redemption. The `collateralAmount` and `borrowedAmount` are always updated based on redemption amounts in `redeemSafe`. `feePaid` and `totalBorrowedAmount` are conditionally reset to 0 and 1 respectively in `_redeemNode` if `ownerFee > 0`.",
              "Additionally, `collateralAmount`, `borrowedAmount`, `liquidationSnapshot.collateralPerCollateralSnapshot`, and `liquidationSnapshot.debtPerCollateralSnapshot` are updated in `_updateSafe` based on cumulative changes."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "A mapping from `safeId` to a `LiquidationSnapshot` struct, storing historical cumulative values of `collateralPerCollateralSnapshot` and `debtPerCollateralSnapshot` for each Safe. These snapshots are used to calculate accrued debt and collateral increases for a Safe.",
            "why_is_is_important": "These snapshots are crucial for calculating the accurate current borrowed amount and collateral amount of a Safe by accounting for protocol-wide debt and collateral accruals. Updating them ensures that the Safe's state is always current before redemption calculations.",
            "when_is_it_updated": "Updated in the `_updateSafe` function, which is called for each Safe involved in the redemption process, to record the current cumulative values of `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` for that Safe.",
            "how_to_validate_state_update": "Verify that `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` for the specific `safeId` are updated to the current `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral` values respectively, within the `_updateSafe` function.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshots of cumulative debt and collateral per unit of collateral are updated for the specific Safe being processed to reflect the latest global state, ensuring accurate debt calculation.",
            "conditions": [
              "Only if `liquidationSnapshot.collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral` (i.e., if there have been protocol-wide collateral or debt increases since the last snapshot)."
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The balance of SBD tokens held by each address.",
            "why_is_is_important": "Tracks token ownership and movement. Essential for ensuring that SBD tokens are correctly moved to and from the protocol during the redemption process.",
            "when_is_it_updated": "Updated during the `sbdToken.transferFrom` call at the beginning of `redeem`, during conditional `sbdToken.transfer` calls for owner refunds in `_redeemNode` and `_redeemToUser`, and during `sbdToken.transferFrom` call for adding reward to StabilityPool in `_redeemToUser`.",
            "how_to_validate_state_update": "Check the balance of `msg.sender`, the StableBaseCDP contract, the safe owner, and the StabilityPool contract before and after the transaction to confirm the correct transfer of SBD tokens.",
            "has_conditional_updates": true,
            "summary_of_update": "SBD tokens are transferred from the redeemer to the StableBaseCDP contract. Depending on the redemption outcome, SBD may also be transferred from the StableBaseCDP contract to the Safe owner (as a refund) or to the Stability Pool (as an owner fee).",
            "conditions": [
              "Decreased from `msg.sender` (redeemer) by `amount` and increased for `address(this)` (StableBaseCDP contract) by `amount` at the start of `redeem`.",
              "Potentially decreased for `address(this)` and increased for `ownerOf(_safeId)` if `amountToRefund > 0` and `amountToRefund > ownerFee` and `sbdToken.transfer` is called.",
              "Potentially decreased for `address(this)` and increased for `StabilityPool` if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true, and `stabilityPool.addReward` is called."
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of SBD tokens in existence.",
            "why_is_is_important": "This variable tracks the total supply of the stablecoin. Burning redeemed tokens ensures that the stablecoin supply adjusts dynamically to demand and maintains its peg by reducing the amount of debt. Important for the economic stability of the protocol.",
            "when_is_it_updated": "Decreased in the `burn` function (called by `redeem`) if `_redemption.redeemedAmount` is greater than `_redemption.refundedAmount`, indicating that stablecoins have been successfully redeemed and removed from circulation.",
            "how_to_validate_state_update": "Verify that `totalSupply` is decreased by `_redemption.redeemedAmount - _redemption.refundedAmount` after the SBD burn operation.",
            "has_conditional_updates": true,
            "summary_of_update": "The total circulating supply of SBD tokens is decreased by the amount of SBD burned.",
            "conditions": [
              "Only if `_redemption.redeemedAmount` is greater than `_redemption.refundedAmount`."
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD tokens that have ever been burned by the contract.",
            "why_is_is_important": "Provides a historical record of SBD tokens that have been permanently removed from circulation. This is a key metric for understanding the supply dynamics and health of the stablecoin.",
            "when_is_it_updated": "Increased in the `burn` function (called by `redeem`) if `_redemption.redeemedAmount` is greater than `_redemption.refundedAmount`, signifying successful redemption and removal of SBD from circulation.",
            "how_to_validate_state_update": "Verify that `totalBurned` is increased by `_redemption.redeemedAmount - _redemption.refundedAmount` after the SBD burn operation.",
            "has_conditional_updates": true,
            "summary_of_update": "The cumulative amount of SBD tokens that have been burned is increased.",
            "conditions": [
              "Only if `_redemption.redeemedAmount` is greater than `_redemption.refundedAmount`."
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "A mapping from `id` (Safe ID) to a `Node` struct (`value`, `prev`, `next`), representing the elements and their pointers within the doubly linked list. Used for both `safesOrderedForLiquidation` and `safesOrderedForRedemption`.",
            "why_is_is_important": "These lists maintain the order of Safes for efficient liquidation and redemption processes. Maintaining their integrity and correct ordering (based on collateralization ratio for liquidation and weight for redemption) is critical for the protocol's health and functionality.",
            "when_is_it_updated": "Modified in `redeemSafe`. If a Safe is closed (fully redeemed), its node is removed from both `safesOrderedForLiquidation` and `safesOrderedForRedemption` via `_removeSafeFromBothQueues`. If a Safe remains open, its node in `safesOrderedForLiquidation` is updated (value changed and re-inserted) via `upsert`.",
            "how_to_validate_state_update": "If a Safe is fully redeemed and removed, verify that its `nodes[id]` entry is deleted (zeroed out) and that `head` and `tail` are correctly adjusted. If a Safe is partially redeemed and remains active, verify that its `nodes[id]` value and links are correctly updated and the node is re-positioned in the liquidation queue by `upsert`.",
            "has_conditional_updates": true,
            "summary_of_update": "Nodes representing Safes are either removed from both the liquidation and redemption ordered lists or updated (re-positioned) in the liquidation list.",
            "conditions": [
              "Always for each Safe being redeemed. If the Safe's `borrowedAmount` becomes 0 in `borrowMode` or if `collateralAmount` and `borrowedAmount` are 0 in `exchangeMode` (via `_removeSafeFromBothQueues`), its node is removed from both `safesOrderedForLiquidation` and `safesOrderedForRedemption`. Otherwise, if the Safe remains active, its node in `safesOrderedForLiquidation` is updated via `upsert`."
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the ordered doubly linked list. Used for both `safesOrderedForLiquidation` and `safesOrderedForRedemption`.",
            "why_is_is_important": "Crucial for maintaining the integrity and navigability of the doubly linked list, as it provides the entry point for traversing the list. Incorrect `head` pointers can break the list's functionality.",
            "when_is_it_updated": "Potentially updated in `_remove` (called by `_removeSafeFromBothQueues`) if the removed node was the head, or in `_insert` (called by `upsert`) if a new node becomes the new head.",
            "how_to_validate_state_update": "If a safe at the head of either list is removed, verify that `head` points to the next correct node. If a new safe is inserted and becomes the head, verify `head` points to this new safe.",
            "has_conditional_updates": true,
            "summary_of_update": "The pointer to the first node in the list might change if the current head node is removed or if a new node is inserted at the beginning.",
            "conditions": [
              "Only if a node that was the head of the list is removed, or if a new node is inserted and becomes the new head (e.g., has the lowest value for liquidation queue or highest for redemption queue depending on sorting logic)."
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the ordered doubly linked list. Used for both `safesOrderedForLiquidation` and `safesOrderedForRedemption`.",
            "why_is_is_important": "Crucial for maintaining the integrity and navigability of the doubly linked list, as it provides an entry point for traversing the list in reverse or finding the last element. Incorrect `tail` pointers can break the list's functionality.",
            "when_is_it_updated": "Potentially updated in `_remove` (called by `_removeSafeFromBothQueues`) if the removed node was the tail, or in `_insert` (called by `upsert`) if a new node becomes the new tail.",
            "how_to_validate_state_update": "If a safe at the tail of either list is removed, verify that `tail` points to the previous correct node. If a new safe is inserted and becomes the tail, verify `tail` points to this new safe.",
            "has_conditional_updates": true,
            "summary_of_update": "The pointer to the last node in the list might change if the current tail node is removed or if a new node is inserted at the end.",
            "conditions": [
              "Only if a node that was the tail of the list is removed, or if a new node is inserted and becomes the new tail (e.g., has the highest value for liquidation queue or lowest for redemption queue depending on sorting logic)."
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "A cumulative sum that tracks the total reward (in DFIDToken) accrued per unit of staked token in the Stability Pool. This is used to calculate individual staker rewards.",
            "why_is_is_important": "This is a key accounting variable for distributing rewards proportionally to Stability Pool stakers. Its accuracy ensures that stakers receive their fair share of owner fees generated by redemptions.",
            "when_is_it_updated": "Increased in the `addReward` function (called by `_redeemToUser` in StableBaseCDP) when owner fees are distributed to the Stability Pool.",
            "how_to_validate_state_update": "If conditions are met, verify that `totalRewardPerToken` increases by the calculated `_rewardPerToken` in `addReward`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total accumulated reward per token for Stability Pool stakers is increased to reflect the owner fees distributed.",
            "conditions": [
              "Only if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true.",
              "Only if `totalStakedRaw > 0`."
            ]
          },
          {
            "state_variable_name": "rewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks a small amount of reward tokens that remain undistributed due to precision issues when calculating rewards per token.",
            "why_is_is_important": "Ensures that no small amounts of reward tokens are lost due to integer division, allowing them to be carried over and potentially distributed in future reward additions.",
            "when_is_it_updated": "Updated in the `addReward` function (called by `_redeemToUser` in StableBaseCDP) after calculating and updating `totalRewardPerToken`.",
            "how_to_validate_state_update": "If conditions are met, verify that `rewardLoss` is updated based on the formula `_totalAmount - ((_rewardPerToken * _totalStakedRaw * precision) / stakeScalingFactor) / precision` in `addReward`.",
            "has_conditional_updates": true,
            "summary_of_update": "Any fractional remainder of the reward that cannot be perfectly distributed among stakers is updated.",
            "conditions": [
              "Only if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true.",
              "Only if `totalStakedRaw > 0`."
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp when SBR rewards were last distributed to the Stability Pool.",
            "why_is_is_important": "This timestamp is used to calculate the time elapsed for which SBR rewards need to be accrued and distributed to the Stability Pool stakers.",
            "when_is_it_updated": "Updated in the `_addSBRRewards` function (called by `addReward`) when SBR rewards are processed and distributed to the Stability Pool, or when the distribution starts for the first time.",
            "how_to_validate_state_update": "If `_addSBRRewards` is triggered, verify `lastSBRRewardDistributedTime` is updated to the current `block.timestamp`.",
            "has_conditional_updates": true,
            "summary_of_update": "The timestamp of the last SBR reward distribution is updated to the current block timestamp.",
            "conditions": [
              "Only if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true, and `sbrRewardDistributionStatus` is `STARTED` or `NOT_STARTED`.",
              "If `sbrRewardDistributionStatus` is `STARTED`, it's updated to `block.timestamp`.",
              "If `sbrRewardDistributionStatus` is `NOT_STARTED`, it's updated to `block.timestamp`."
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp marking the end of the SBR reward distribution period.",
            "why_is_is_important": "Defines the duration for which SBR rewards will be distributed to the Stability Pool, providing a clear timeframe for reward accrual.",
            "when_is_it_updated": "Updated in the `_addSBRRewards` function (called by `addReward`) only when `sbrRewardDistributionStatus` transitions from `NOT_STARTED` to `STARTED`.",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` is `NOT_STARTED` and `_addSBRRewards` is called, verify `sbrRewardDistributionEndTime` is set to `block.timestamp + 365 days`.",
            "has_conditional_updates": true,
            "summary_of_update": "The end time for SBR reward distribution is set when the distribution starts for the first time.",
            "conditions": [
              "Only if `sbrRewardDistributionStatus` is `NOT_STARTED` at the time `_addSBRRewards` is called (which requires `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` to be true)."
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum StabilityPool.SBRRewardDistribution",
            "what_does_it_track": "The current phase of SBR reward distribution: `NOT_STARTED`, `STARTED`, or `ENDED`.",
            "why_is_is_important": "Controls the flow of SBR reward distribution, ensuring that rewards are only distributed during the active period and that the system properly transitions once the distribution ends.",
            "when_is_it_updated": "Updated in the `_addSBRRewards` function (called by `addReward`). It changes from `NOT_STARTED` to `STARTED` upon the first reward addition, and from `STARTED` to `ENDED` if the distribution end time is reached.",
            "how_to_validate_state_update": "Check the status transition from `NOT_STARTED` to `STARTED` when SBR rewards are first added, and from `STARTED` to `ENDED` if the distribution period has passed.",
            "has_conditional_updates": true,
            "summary_of_update": "The status of SBR reward distribution is updated, either starting it or marking it as ended.",
            "conditions": [
              "Only if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true.",
              "If `sbrRewardDistributionStatus` is `NOT_STARTED`, it's updated to `STARTED`.",
              "If `sbrRewardDistributionStatus` is `STARTED` and `block.timestamp > sbrRewardDistributionEndTime`, it's updated to `ENDED`."
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks a small amount of SBR reward tokens that remain undistributed due to precision issues when calculating SBR rewards per token.",
            "why_is_is_important": "Similar to `rewardLoss`, this ensures that no small amounts of SBR reward tokens are lost due to integer division, allowing them to be carried over and potentially distributed in future reward additions.",
            "when_is_it_updated": "Updated in the `_addSBRRewards` function (called by `addReward`) after calculating and updating `totalSbrRewardPerToken`.",
            "how_to_validate_state_update": "If conditions are met, verify that `sbrRewardLoss` is updated based on the formula `_sbrReward - ((_totalSbrRewardPerToken * totalStakedRaw * precision) / stakeScalingFactor) / precision` in `_addSBRRewards`.",
            "has_conditional_updates": true,
            "summary_of_update": "Any fractional remainder of SBR reward that cannot be perfectly distributed among stakers is updated.",
            "conditions": [
              "Only if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true, and `sbrRewardDistributionStatus` is `STARTED`.",
              "Only if `totalStakedRaw > 0`."
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "A cumulative sum that tracks the total SBR reward accrued per unit of staked token in the Stability Pool.",
            "why_is_is_important": "This is a key accounting variable for distributing SBR rewards proportionally to Stability Pool stakers. Its accuracy ensures that stakers receive their fair share of SBR rewards.",
            "when_is_it_updated": "Increased in the `_addSBRRewards` function (called by `addReward`) when SBR rewards are processed and distributed to the Stability Pool.",
            "how_to_validate_state_update": "If conditions are met, verify that `totalSbrRewardPerToken` increases by the calculated `_totalSbrRewardPerToken` in `_addSBRRewards`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total accumulated SBR reward per token for Stability Pool stakers is increased.",
            "conditions": [
              "Only if `redemption.ownerFee > 0` and `stabilityPoolCanReceiveRewards` is true, and `sbrRewardDistributionStatus` is `STARTED`.",
              "Only if `totalStakedRaw > 0`."
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "A cumulative sum that tracks the total collateral (ETH) accrued per unit of staked token in the Stability Pool. This is used to calculate individual staker collateral rewards.",
            "why_is_is_important": "This is a key accounting variable for distributing collateral rewards proportionally to Stability Pool stakers. Its accuracy ensures that stakers receive their fair share of collateral fees generated by redemptions.",
            "when_is_it_updated": "Increased in the `addCollateralReward` function (called by `_redeemToUser` in StableBaseCDP) when redeemer fees are distributed to the Stability Pool.",
            "how_to_validate_state_update": "If conditions are met, verify that `totalCollateralPerToken` increases by the calculated `_collateralPerToken` in `addCollateralReward`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total accumulated collateral reward (ETH) per token for Stability Pool stakers is increased to reflect the redeemer fees distributed.",
            "conditions": [
              "Only if `redemption.redeemerFee > 0` and `stabilityPoolCanReceiveRewards` is true.",
              "Only if `totalStakedRaw > 0`."
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks a small amount of collateral (ETH) that remains undistributed due to precision issues when calculating collateral rewards per token.",
            "why_is_is_important": "Ensures that no small amounts of collateral are lost due to integer division, allowing them to be carried over and potentially distributed in future reward additions.",
            "when_is_it_updated": "Updated in the `addCollateralReward` function (called by `_redeemToUser` in StableBaseCDP) after calculating and updating `totalCollateralPerToken`.",
            "how_to_validate_state_update": "If conditions are met, verify that `collateralLoss` is updated based on the formula `_totalAmount - ((_collateralPerToken * _totalStakedRaw * precision) / stakeScalingFactor) / precision` in `addCollateralReward`.",
            "has_conditional_updates": true,
            "summary_of_update": "Any fractional remainder of the collateral reward that cannot be perfectly distributed among stakers is updated.",
            "conditions": [
              "Only if `redemption.redeemerFee > 0` and `stabilityPoolCanReceiveRewards` is true.",
              "Only if `totalStakedRaw > 0`."
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function redeem(\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external onlyInNormalMode {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), amount),\n            \"Unable to transfer SBD\"\n        );\n        uint256 price = priceOracle.fetchPrice();\n        uint256 redemptionId = uint256(\n            keccak256(\n                abi.encode(\n                    msg.sender,\n                    amount,\n                    block.number,\n                    safesOrderedForRedemption.getHead()\n                )\n            )\n        );\n\n        SBStructs.Redemption memory _redemption = SBStructs.Redemption({\n            redemptionId: redemptionId,\n            requestedAmount: amount,\n            price: price,\n            redeemedAmount: 0,\n            refundedAmount: 0,\n            processedSpots: 0,\n            collateralAmount: 0,\n            ownerFee: 0,\n            redeemerFee: 0\n        });\n\n        _redemption = _redeemSafes(_redemption, nearestSpotInLiquidationQueue);\n        _redeemToUser(_redemption);\n        totalCollateral -= (_redemption.collateralAmount +\n            _redemption.redeemerFee);\n        require(_redemption.redeemedAmount == amount, \"Redemption failed\");\n        //totalDebt -= _redemption.redeemedAmount;\n        _updateTotalDebt(\n            totalDebt,\n            _redemption.redeemedAmount - _redemption.refundedAmount,\n            false\n        );\n        if (_redemption.redeemedAmount > _redemption.refundedAmount) {\n            require(\n                sbdToken.burn(\n                    address(this),\n                    _redemption.redeemedAmount - _redemption.refundedAmount\n                ),\n                \"Burn failed\"\n            );\n        }\n\n        emit RedeemedBatch(\n            redemptionId,\n            amount,\n            _redemption.collateralAmount,\n            price,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _redeemSafes(\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (SBStructs.Redemption memory) {\n        uint256 processedSpots = redemption.processedSpots;\n        // Target within 1% = 100 points, 100% = 10000 points\n        while (redemption.redeemedAmount < redemption.requestedAmount) {\n            //uint256 spotForUpdate = 0;\n            uint256 head = safesOrderedForRedemption.getHead();\n            (, redemption) = _redeemNode(\n                head,\n                redemption,\n                nearestSpotInLiquidationQueue\n            );\n            processedSpots++;\n        }\n        redemption.processedSpots = processedSpots;\n        return redemption;\n    }\nfunction _redeemNode(\n        uint256 _safeId,\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        // bytes32 _safeId = bytes32(_safeId);\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        uint256 amountToRedeem = redemption.requestedAmount -\n            redemption.redeemedAmount;\n        uint256 collateralToRedeem = (amountToRedeem * PRECISION) /\n            redemption.price;\n        // Amount of collateral to return back to the redeemer\n        uint256 collateralToReturn = collateralToRedeem;\n        // Amount of stablecoins to refund the safe owner\n        uint256 amountToRefund = 0;\n        // Total fee(in percentage terms) paid by the safe owner\n        // Total collateral value of the safe\n        uint256 ownerFee = 0;\n        uint256 redeemerFee = 0;\n        bool borrowMode;\n        (\n            borrowMode,\n            collateralToRedeem,\n            amountToRedeem,\n            amountToRefund,\n            ownerFee,\n            redeemerFee\n        ) = calculateRedemptionAmountsAndFee(\n            safe,\n            amountToRedeem,\n            redemption.price\n        );\n        if (amountToRefund > 0) {\n            if (amountToRefund > ownerFee) {\n                require(\n                    sbdToken.transfer(\n                        ownerOf(_safeId),\n                        amountToRefund - ownerFee\n                    ),\n                    \"Mint failed for owner fee\"\n                );\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    amountToRefund - ownerFee,\n                    ownerFee\n                );\n            } else {\n                // Nothing to pay owner\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    0,\n                    ownerFee\n                );\n            }\n            if (ownerFee > 0) {\n                redemption.ownerFee += ownerFee;\n                safe.feePaid = 0; // Reset the fee paid by the safe owner\n                safe.totalBorrowedAmount = 1; // Not resetting this to 0 to avoid errors\n                emit OwnerFeePaid(redemption.redemptionId, _safeId, ownerFee);\n            }\n        }\n        // Total amount of collateral to return to the redeemer\n        collateralToReturn = collateralToRedeem - redeemerFee;\n        if (redeemerFee > 0) {\n            redemption.redeemerFee += redeemerFee;\n            emit RedeemerFeePaid(\n                redemption.redemptionId,\n                _safeId,\n                collateralToRedeem,\n                collateralToReturn,\n                redeemerFee\n            );\n        }\n        // update target shielding rate\n        return\n            redeemSafe(\n                _safeId,\n                borrowMode,\n                amountToRedeem,\n                amountToRefund,\n                collateralToRedeem,\n                collateralToReturn,\n                safe,\n                nearestSpotInLiquidationQueue,\n                redemption\n            );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction calculateRedemptionAmountsAndFee(\n        Safe memory safe,\n        uint256 amountToRedeem,\n        uint256 collateralPrice\n    )\n        public\n        view\n        returns (\n            bool borrowMode,\n            uint256 _collateralToRedeem,\n            uint256 _amountToRedeem,\n            uint256 _amountToRefund,\n            uint256 _ownerFee,\n            uint256 _redeemerFee\n        )\n    {\n        uint256 collateralValue = (safe.collateralAmount * collateralPrice) /\n            PRECISION;\n        require(\n            collateralValue >=\n                ((safe.borrowedAmount * liquidationRatio) /\n                    BASIS_POINTS_DIVISOR),\n            \"Safe can't be redeemed\"\n        );\n\n        uint256 feePaidPercentage = ((safe.feePaid *\n            BASIS_POINTS_DIVISOR *\n            PRECISION) / safe.totalBorrowedAmount);\n        // Fee tier to apply for this safe(applied to the redeemer)\n        uint256 feeTier = min(\n            feePaidPercentage + REDEMPTION_BASE_FEE * PRECISION,\n            REDEMPTION_LIQUIDATION_FEE * PRECISION\n        );\n        /*\n        If the fee paid is less than REDEMPTION_BASE_FEE, the redemption fee is (feePaid + REDEMPTION_BASE_FEE)\n         */\n        if (feePaidPercentage <= REDEMPTION_BASE_FEE * PRECISION) {\n            if (amountToRedeem >= collateralValue) {\n                // redeem the whole collateral, while refunding stablecoins back to the owner of the safe\n                _amountToRedeem = safe.borrowedAmount;\n                _amountToRefund = collateralValue - _amountToRedeem;\n                _collateralToRedeem = safe.collateralAmount;\n                // OWNER FEE = REDEMPTION BASE FEE for the\n                // toPay = collateralValue * REDEMPTION_BASE_FEE / BASIS_POINTS_DIVISOR\n                // toPay - feePaid\n                uint256 ownerToPay = (collateralValue * REDEMPTION_BASE_FEE) /\n                    BASIS_POINTS_DIVISOR;\n                if (ownerToPay > safe.feePaid) {\n                    _ownerFee = ownerToPay - safe.feePaid;\n                }\n            } else {\n                if (amountToRedeem >= safe.borrowedAmount) {\n                    _amountToRefund = amountToRedeem - safe.borrowedAmount;\n                    _amountToRedeem = safe.borrowedAmount;\n                    _collateralToRedeem =\n                        ((_amountToRedeem + _amountToRefund) * PRECISION) /\n                        collateralPrice;\n                    _ownerFee =\n                        ((_amountToRedeem + _amountToRefund) *\n                            REDEMPTION_BASE_FEE) /\n                        BASIS_POINTS_DIVISOR;\n                    if (_ownerFee > safe.feePaid) {\n                        _ownerFee = _ownerFee - safe.feePaid;\n                    }\n                } else {\n                    _amountToRedeem = amountToRedeem;\n                    _collateralToRedeem =\n                        (amountToRedeem * PRECISION) /\n                        collateralPrice;\n                    _amountToRefund = 0;\n                    _ownerFee = 0;\n                }\n                // No seller fee here\n            }\n        } else {\n            borrowMode = true;\n            if (amountToRedeem >= safe.borrowedAmount) {\n                _amountToRedeem = safe.borrowedAmount;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n            } else {\n                _amountToRedeem = amountToRedeem;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                //amountToRedeem =\n            }\n        }\n        _redeemerFee = ((_collateralToRedeem * feeTier) /\n            BASIS_POINTS_DIVISOR /\n            PRECISION);\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction redeemSafe(\n        uint256 _safeId,\n        bool borrowMode,\n        uint256 amountToRedeem,\n        uint256 amountToRefund,\n        uint256 collateralToRedeem,\n        uint256 collateralToReturn,\n        Safe memory safe,\n        uint256 nearestSpotInLiquidationQueue,\n        SBStructs.Redemption memory redemption\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        //uint256 amountInCollateral = amountToRedeem /\n        safe.collateralAmount -= collateralToRedeem;\n        safe.borrowedAmount -= amountToRedeem;\n        redemption.collateralAmount += collateralToReturn;\n        redemption.redeemedAmount += amountToRedeem + amountToRefund;\n        redemption.refundedAmount += amountToRefund;\n        safes[_safeId] = safe;\n        // If the safe is empty(borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode)\n        // Borrow mode: If fee paid > REDEMPTION_BASE_FEE\n        // Exchange mode; If fee paid <= REDEMPTION_BASE_FEE\n        if (\n            (safe.borrowedAmount == 0 && borrowMode) ||\n            (!borrowMode &&\n                closeToZero(safe.collateralAmount) &&\n                safe.borrowedAmount == 0)\n        ) {\n            _removeSafeFromBothQueues(_safeId);\n        } else {\n            uint256 newRatio = (safe.borrowedAmount * PRECISION) /\n                safe.collateralAmount;\n            IDoublyLinkedList.Node\n                memory liquidationNode = safesOrderedForLiquidation.upsert(\n                    _safeId,\n                    newRatio,\n                    nearestSpotInLiquidationQueue\n                );\n            emit LiquidationQueueUpdated(\n                _safeId,\n                newRatio,\n                liquidationNode.next\n            );\n        }\n        emit Redeemed(\n            redemption.redemptionId,\n            _safeId,\n            amountToRedeem,\n            collateralToRedeem,\n            amountToRefund,\n            redemption.requestedAmount - redemption.redeemedAmount\n        );\n        return (safe, redemption);\n    }\nfunction closeToZero(uint256 value) internal pure returns (bool) {\n        return value < 1e10;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _redeemToUser(SBStructs.Redemption memory redemption) internal {\n        uint256 collateralRefund = 0;\n        if (redemption.ownerFee > 0) {\n            if (stabilityPoolCanReceiveRewards) {\n                require(\n                    stabilityPool.addReward(redemption.ownerFee),\n                    \"Add reward failed\"\n                );\n                emit OwnerRedemptionFeeDistributed(\n                    redemption.redemptionId,\n                    redemption.ownerFee\n                );\n            } else {\n                require(\n                    sbdToken.transfer(msg.sender, redemption.ownerFee),\n                    \"Owner fee refund failed\"\n                );\n            }\n        }\n        if (redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards) {\n            require(\n                stabilityPool.addCollateralReward{\n                    value: redemption.redeemerFee\n                }(redemption.redeemerFee),\n                \"Add collateral reward failed\"\n            );\n        } else {\n            collateralRefund = redemption.redeemerFee;\n        }\n        (bool success, ) = msg.sender.call{\n            value: redemption.collateralAmount + collateralRefund\n        }(\"\");\n        require(success, \"Transfer failed\");\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction transfer(address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}