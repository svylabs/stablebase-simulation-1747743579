{
  "action": {
    "name": "Redeem",
    "summary": "Redeems debt.",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "pre_execution_parameter_generation_rules": [
      "The `amount` parameter (representing the SBD amount to redeem) must be greater than 0.",
      "The `amount` parameter should be less than or equal to the user's SBD balance (`sbdToken.balanceOf(msg.sender)`).",
      "The `nearestSpotInLiquidationQueue` parameter should be a valid `safeId` that exists in the liquidation queue (`safesOrderedForLiquidation.getNode(nearestSpotInLiquidationQueue).value != 0`). If unsure, pass 0, and the contract logic will select a reasonable default.",
      "The `msg.sender` must have sufficient SBD tokens to cover the redemption amount. Approval for the StableBaseCDP contract to `transferFrom` the sender\\'s account should exist, which means `sbdToken.allowance(msg.sender, address(this))` should be greater than or equal to the `amount`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "SBD Token Transfers",
        "state_update_descriptions": [
          "SBD tokens are transferred from the message sender to the StableBaseCDP contract using `sbdToken.transferFrom(msg.sender, address(this), amount)`.",
          "SBD tokens are burned from the StableBaseCDP contract if the redeemed amount is greater than the refunded amount using `sbdToken.burn(address(this), _redemption.redeemedAmount - _redemption.refundedAmount)`."
        ]
      },
      {
        "category": "Collateral and Debt Updates",
        "state_update_descriptions": [
          "Total collateral (`totalCollateral`) is decreased by the collateral amount plus the redeemer fee: `totalCollateral -= (_redemption.collateralAmount + _redemption.redeemerFee);`.",
          "Total debt (`totalDebt`) is updated (decreased) by the redeemed amount minus the refunded amount using the `_updateTotalDebt` function.",
          "Safe's collateral amount (`safe.collateralAmount`) is decreased by `collateralToRedeem`.",
          "Safe's borrowed amount (`safe.borrowedAmount`) is decreased by `amountToRedeem`."
        ]
      },
      {
        "category": "Redemption Tracking",
        "state_update_descriptions": [
          "The redemption struct's `collateralAmount` is increased by `collateralToReturn`.",
          "The redemption struct's `redeemedAmount` is increased by the `amountToRedeem` plus `amountToRefund`.",
          "The redemption struct's `refundedAmount` is increased by `amountToRefund`.",
          "redemption.ownerFee is updated.",
          "redemption.redeemerFee is updated."
        ]
      },
      {
        "category": "Safe Queue Management",
        "state_update_descriptions": [
          "If a safe's `borrowedAmount` becomes 0 in BORROW mode or its `collateralAmount` is close to zero (less than 1e10) and `borrowedAmount` is 0 in EXCHANGE mode, the safe is removed from both the liquidation and redemption queues via `_removeSafeFromBothQueues(safeId)`.",
          "Otherwise, the safe's liquidation ratio is updated as `newRatio = (safe.borrowedAmount * PRECISION) / safe.collateralAmount`, and the safe is re-inserted or updated in the liquidation queue via `safesOrderedForLiquidation.upsert(safeId, newRatio, nearestSpotInLiquidationQueue)`."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Owner fees are distributed to the stability pool (if `stabilityPoolCanReceiveRewards` is true using `stabilityPool.addReward(redemption.ownerFee)`) or refunded to the message sender (using `sbdToken.transfer(msg.sender, redemption.ownerFee)`).",
          "Redeemer fees are distributed to the stability pool as collateral (if `stabilityPoolCanReceiveRewards` is true using `stabilityPool.addCollateralReward{value: redemption.redeemerFee}(redemption.redeemerFee)`) or refunded to the message sender as collateral."
        ]
      },
      {
        "category": "Liquidation Snapshot Updates",
        "state_update_descriptions": [
          "If `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral` the safe's `borrowedAmount`, `collateralAmount` are updated based on cumulative increases since the last snapshot. Also updates `liquidationSnapshot.debtPerCollateralSnapshot` and  `liquidationSnapshot.collateralPerCollateralSnapshot`"
        ]
      },
      {
        "category": "Protocol Mode Update",
        "state_update_descriptions": [
          "The `PROTOCOL_MODE` may be updated from `BOOTSTRAP` to `NORMAL` if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`. This is handled by `_updateTotalDebt` function."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "SBD Token Balance",
        "rule_descriptions": [
          "The contract's SBD token balance (`sbdToken.balanceOf(address(this))`) should decrease by the redeemed amount (minus any refunds if applicable) after the burn. Specifically, the decrease should equal `_redemption.redeemedAmount - _redemption.refundedAmount`.",
          "The user's SBD token balance (`sbdToken.balanceOf(msg.sender)`) should decrease by the amount being redeemed, verifiable via pre and post-transaction balance comparison."
        ]
      },
      {
        "category": "Collateral and Debt Consistency",
        "rule_descriptions": [
          "`totalCollateral` should be decreased by the amount of collateral redeemed + the redeemerFee. This can be validated via pre and post-transaction `totalCollateral` comparison.",
          "`totalDebt` should be decreased by the amount of debt redeemed - `refundedAmount`.  This can be validated via pre and post-transaction `totalDebt` comparison.",
          "The safe's `collateralAmount` should be reduced by `collateralToRedeem`. If `closeToZero(safe.collateralAmount)` returns true, `safe.collateralAmount` should be less than 1e10.",
          "The safe's `borrowedAmount` should be reduced by `amountToRedeem`. If the safe is closed, `safe.borrowedAmount` should be 0."
        ]
      },
      {
        "category": "Queue Integrity",
        "rule_descriptions": [
          "If a safe is removed from the liquidation and redemption queues (using `_removeSafeFromBothQueues`), `safesOrderedForLiquidation.getNode(safeId).value` and `safesOrderedForRedemption.getNode(safeId).value` should both return 0.",
          "If a safe's liquidation ratio is updated, its position in the liquidation queue should reflect the new ratio. This means after redemption, `safesOrderedForLiquidation.getNode(safeId).value` equals `(safe.borrowedAmount * PRECISION) / safe.collateralAmount`",
          "If the safe's borrowed amount and collateral amount are both zero then the safe should no longer exist (`safes[safeId].borrowedAmount == 0 && safes[safeId].collateralAmount == 0`)."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `RedeemedBatch` event should be emitted with the correct parameters (`redemptionId`, `amount`, `redeemedCollateral`, `price`, `totalCollateral`, `totalDebt`).",
          "A `Redeemed` event should be emitted for each safe that is redeemed with the correct parameters (`redemptionId`, `safeId`, `amount`, `collateral`, `refundedToOwner`, `remainingToRedeem`).",
          "`OwnerFeePaid` and `RedeemerFeePaid` events should be emitted if applicable.",
          "`SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` events should be emitted if the safe is removed."
        ]
      },
      {
        "category": "Safe State",
        "rule_descriptions": [
          "If the safe is closed (either borrowedAmount is 0 and borrowMode is true, or !borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0), the `safes` mapping should no longer contain an entry for the `safeId`, or the values are reset to zero: `safes[safeId].collateralAmount == 0 && safes[safeId].borrowedAmount == 0 && safes[safeId].weight == 0 && safes[safeId].totalBorrowedAmount == 0 && safes[safeId].feePaid == 0`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Redeem",
    "contract_name": "StableBaseCDP",
    "function_name": "redeem",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral held by the protocol.",
            "why_is_is_important": "Reflects the current collateralization of the system, crucial for stability and solvency checks.",
            "when_is_it_updated": "When debt is redeemed, and collateral is returned to the redeemer.",
            "how_to_validate_state_update": "Check the totalCollateral variable by subtracting the sum of _redemption.collateralAmount and _redemption.redeemerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateral is decreased by the collateral amount returned to the redeemer and the redeemer fee.",
            "conditions": [
              "amount > 0",
              "sbdToken.transferFrom successful",
              "in normal mode"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt outstanding in the system.",
            "why_is_is_important": "Reflects the overall liabilities of the protocol, essential for maintaining solvency.",
            "when_is_it_updated": "When debt is redeemed by users.",
            "how_to_validate_state_update": "Verify _updateTotalDebt function is called with the correct parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "totalDebt is decreased by the difference between redeemed amount and refunded amount.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount",
              "sbdToken.burn successful"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "Tracks the state of each safe, including collateral and debt.",
            "why_is_is_important": "Individual safe data is crucial for calculating liquidation risk and user positions.",
            "when_is_it_updated": "When debt is redeemed, reducing the debt and collateral associated with the safe.",
            "how_to_validate_state_update": "Check the safes mapping with safeId.",
            "has_conditional_updates": false,
            "summary_of_update": "The safe's collateralAmount and borrowedAmount are decreased.",
            "conditions": [
              "Always"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Maintains an ordered list of safes based on liquidation risk.",
            "why_is_is_important": "Facilitates efficient liquidation of risky safes.",
            "when_is_it_updated": "When a safe is closed or its risk profile changes significantly, and it's empty.",
            "how_to_validate_state_update": "Check if _removeSafeFromBothQueues function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe is removed from the liquidation queue if it is empty.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Maintains an ordered list of safes available for redemption.",
            "why_is_is_important": "Facilitates efficient redemption of safes.",
            "when_is_it_updated": "When a safe is closed or its suitability for redemption changes, and it's empty.",
            "how_to_validate_state_update": "Check if _removeSafeFromBothQueues function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe is removed from the redemption queue if it is empty.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Maintains an ordered list of safes based on liquidation risk.",
            "why_is_is_important": "Facilitates efficient liquidation of risky safes.",
            "when_is_it_updated": "When a safe's risk profile changes due to borrowing or collateral adjustments.",
            "how_to_validate_state_update": "Verify that the upsert function of safesOrderedForLiquidation is called with the correct newRatio.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe's position in the liquidation queue is updated if its collateralization ratio changes.",
            "conditions": [
              "safe.borrowedAmount != 0 && borrowMode || !borrowMode && !closeToZero(safe.collateralAmount) && safe.borrowedAmount != 0"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping(uint256 => LiquidationSnapshot)",
            "what_does_it_track": "Snapshots of debt and collateral ratios at specific points in time for individual safes.",
            "why_is_is_important": "Ensures accurate accounting of debt and collateral, preventing manipulation and protecting against interest-related exploits.",
            "when_is_it_updated": "Before performing operations like borrowing or adding/removing collateral to account for accrued interest.",
            "how_to_validate_state_update": "Check that liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Liquidation snapshot is updated, tracking collateral and debt per unit collateral.",
            "conditions": [
              "cumulativeCollateralPerUnitCollateral != liquidationSnapshots[_safeId].collateralPerCollateralSnapshot"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The operational mode of the protocol.",
            "why_is_is_important": "Controls protocol behavior based on overall risk levels, enabling features like increased liquidation penalties during bootstrap mode.",
            "when_is_it_updated": "When the total debt crosses a predefined threshold during operation.",
            "how_to_validate_state_update": "Check the value of PROTOCOL_MODE, it should be SBStructs.Mode.NORMAL after the execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Protocol mode is updated from BOOTSTRAP to NORMAL if debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "Reflects the token distribution across users and the contract's holdings.",
            "when_is_it_updated": "When SBD tokens are burned during redemption.",
            "how_to_validate_state_update": "Check the balanceOf(address(this)) and totalSupply() decrease by (_redemption.redeemedAmount - _redemption.refundedAmount).",
            "has_conditional_updates": true,
            "summary_of_update": "The contract's balance of SBD tokens is reduced.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total circulating supply of the SBD token.",
            "why_is_is_important": "Maintains the overall scarcity of the token and is crucial for price stability.",
            "when_is_it_updated": "When SBD tokens are burned during redemption.",
            "how_to_validate_state_update": "Check the value of totalSupply(), it should decrease by (_redemption.redeemedAmount - _redemption.refundedAmount).",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of SBD tokens is reduced.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD tokens that have been burned.",
            "why_is_is_important": "Records historical burn data.",
            "when_is_it_updated": "When SBD tokens are burned during redemption.",
            "how_to_validate_state_update": "Check the value of totalBurned, it should increase by (_redemption.redeemedAmount - _redemption.refundedAmount).",
            "has_conditional_updates": true,
            "summary_of_update": "The total burned amount of SBD tokens is increased.",
            "conditions": [
              "_redemption.redeemedAmount > _redemption.refundedAmount"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first element in the linked list.",
            "why_is_is_important": "Facilitates traversal of the list.",
            "when_is_it_updated": "When the element being removed is the head.",
            "how_to_validate_state_update": "Check the values of head, tail and nodes[safeId], it should be zero.",
            "has_conditional_updates": true,
            "summary_of_update": "The head is updated if the safe being removed is the head of the linked list.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last element in the linked list.",
            "why_is_is_important": "Facilitates traversal of the list.",
            "when_is_it_updated": "When the element being removed is the tail.",
            "how_to_validate_state_update": "Check the values of head, tail and nodes[safeId], it should be zero.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail is updated if the safe being removed is the tail of the linked list.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Each node in the linked list.",
            "why_is_is_important": "Represents an individual safe in the list, crucial for maintaining order.",
            "when_is_it_updated": "When an element is removed from the linked list.",
            "how_to_validate_state_update": "Check the values of head, tail and nodes[safeId], it should be zero.",
            "has_conditional_updates": true,
            "summary_of_update": "The node corresponding to the safe being removed is deleted from the linked list.",
            "conditions": [
              "(safe.borrowedAmount == 0 && borrowMode) || (!borrowMode && closeToZero(safe.collateralAmount) && safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Each node in the linked list.",
            "why_is_is_important": "Represents an individual safe in the list, crucial for maintaining order.",
            "when_is_it_updated": "When an element is added to or updated in the linked list.",
            "how_to_validate_state_update": "Check the values of nodes[safeId], it should be updated with new value and its position should also be updated.",
            "has_conditional_updates": true,
            "summary_of_update": "A node is upserted with the new ratio.",
            "conditions": [
              "safe.borrowedAmount != 0 && borrowMode || !borrowMode && !closeToZero(safe.collateralAmount) && safe.borrowedAmount != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakingToken",
            "type": "IERC20",
            "what_does_it_track": "Represents the staking token contract.",
            "why_is_is_important": "Tracks balance of the token in the pool.",
            "when_is_it_updated": "When adding rewards.",
            "how_to_validate_state_update": "Verify that stabilityPool.addReward is called with redemption.ownerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "stakingToken.transferFrom is called to transfer tokens from msg.sender to address(this).",
            "conditions": [
              "redemption.ownerFee > 0 && stabilityPoolCanReceiveRewards"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral per token.",
            "why_is_is_important": "Tracks the amount of collateral distributed",
            "when_is_it_updated": "When collateral rewards are added.",
            "how_to_validate_state_update": "Verify that stabilityPool.addCollateralReward is called with redemption.redeemerFee.",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateralPerToken is updated when collateral rewards are added.",
            "conditions": [
              "redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function redeem(\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external onlyInNormalMode {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), amount),\n            \"Unable to transfer SBD\"\n        );\n        uint256 price = priceOracle.fetchPrice();\n        uint256 redemptionId = uint256(\n            keccak256(\n                abi.encode(\n                    msg.sender,\n                    amount,\n                    block.number,\n                    safesOrderedForRedemption.getHead()\n                )\n            )\n        );\n\n        SBStructs.Redemption memory _redemption = SBStructs.Redemption({\n            redemptionId: redemptionId,\n            requestedAmount: amount,\n            price: price,\n            redeemedAmount: 0,\n            refundedAmount: 0,\n            processedSpots: 0,\n            collateralAmount: 0,\n            ownerFee: 0,\n            redeemerFee: 0\n        });\n\n        _redemption = _redeemSafes(_redemption, nearestSpotInLiquidationQueue);\n        _redeemToUser(_redemption);\n        totalCollateral -= (_redemption.collateralAmount +\n            _redemption.redeemerFee);\n        require(_redemption.redeemedAmount == amount, \"Redemption failed\");\n        //totalDebt -= _redemption.redeemedAmount;\n        _updateTotalDebt(\n            totalDebt,\n            _redemption.redeemedAmount - _redemption.refundedAmount,\n            false\n        );\n        if (_redemption.redeemedAmount > _redemption.refundedAmount) {\n            require(\n                sbdToken.burn(\n                    address(this),\n                    _redemption.redeemedAmount - _redemption.refundedAmount\n                ),\n                \"Burn failed\"\n            );\n        }\n\n        emit RedeemedBatch(\n            redemptionId,\n            amount,\n            _redemption.collateralAmount,\n            price,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _redeemSafes(\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (SBStructs.Redemption memory) {\n        uint256 processedSpots = redemption.processedSpots;\n        // Target within 1% = 100 points, 100% = 10000 points\n        while (redemption.redeemedAmount < redemption.requestedAmount) {\n            //uint256 spotForUpdate = 0;\n            uint256 head = safesOrderedForRedemption.getHead();\n            (, redemption) = _redeemNode(\n                head,\n                redemption,\n                nearestSpotInLiquidationQueue\n            );\n            processedSpots++;\n        }\n        redemption.processedSpots = processedSpots;\n        return redemption;\n    }\nfunction _redeemNode(\n        uint256 _safeId,\n        SBStructs.Redemption memory redemption,\n        uint256 nearestSpotInLiquidationQueue\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        // bytes32 _safeId = bytes32(_safeId);\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        uint256 amountToRedeem = redemption.requestedAmount -\n            redemption.redeemedAmount;\n        uint256 collateralToRedeem = (amountToRedeem * PRECISION) /\n            redemption.price;\n        // Amount of collateral to return back to the redeemer\n        uint256 collateralToReturn = collateralToRedeem;\n        // Amount of stablecoins to refund the safe owner\n        uint256 amountToRefund = 0;\n        // Total fee(in percentage terms) paid by the safe owner\n        // Total collateral value of the safe\n        uint256 ownerFee = 0;\n        uint256 redeemerFee = 0;\n        bool borrowMode;\n        (\n            borrowMode,\n            collateralToRedeem,\n            amountToRedeem,\n            amountToRefund,\n            ownerFee,\n            redeemerFee\n        ) = calculateRedemptionAmountsAndFee(\n            safe,\n            amountToRedeem,\n            redemption.price\n        );\n        if (amountToRefund > 0) {\n            if (amountToRefund > ownerFee) {\n                require(\n                    sbdToken.transfer(\n                        ownerOf(_safeId),\n                        amountToRefund - ownerFee\n                    ),\n                    \"Mint failed for owner fee\"\n                );\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    amountToRefund - ownerFee,\n                    ownerFee\n                );\n            } else {\n                // Nothing to pay owner\n                emit OwnerRefunded(\n                    redemption.redemptionId,\n                    _safeId,\n                    0,\n                    ownerFee\n                );\n            }\n            if (ownerFee > 0) {\n                redemption.ownerFee += ownerFee;\n                safe.feePaid = 0; // Reset the fee paid by the safe owner\n                safe.totalBorrowedAmount = 1; // Not resetting this to 0 to avoid errors\n                emit OwnerFeePaid(redemption.redemptionId, _safeId, ownerFee);\n            }\n        }\n        // Total amount of collateral to return to the redeemer\n        collateralToReturn = collateralToRedeem - redeemerFee;\n        if (redeemerFee > 0) {\n            redemption.redeemerFee += redeemerFee;\n            emit RedeemerFeePaid(\n                redemption.redemptionId,\n                _safeId,\n                collateralToRedeem,\n                collateralToReturn,\n                redeemerFee\n            );\n        }\n        // update target shielding rate\n        return\n            redeemSafe(\n                _safeId,\n                borrowMode,\n                amountToRedeem,\n                amountToRefund,\n                collateralToRedeem,\n                collateralToReturn,\n                safe,\n                nearestSpotInLiquidationQueue,\n                redemption\n            );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction calculateRedemptionAmountsAndFee(\n        Safe memory safe,\n        uint256 amountToRedeem,\n        uint256 collateralPrice\n    )\n        public\n        view\n        returns (\n            bool borrowMode,\n            uint256 _collateralToRedeem,\n            uint256 _amountToRedeem,\n            uint256 _amountToRefund,\n            uint256 _ownerFee,\n            uint256 _redeemerFee\n        )\n    {\n        uint256 collateralValue = (safe.collateralAmount * collateralPrice) /\n            PRECISION;\n        require(\n            collateralValue >=\n                ((safe.borrowedAmount * liquidationRatio) /\n                    BASIS_POINTS_DIVISOR),\n            \"Safe can't be redeemed\"\n        );\n\n        uint256 feePaidPercentage = ((safe.feePaid *\n            BASIS_POINTS_DIVISOR *\n            PRECISION) / safe.totalBorrowedAmount);\n        // Fee tier to apply for this safe(applied to the redeemer)\n        uint256 feeTier = min(\n            feePaidPercentage + REDEMPTION_BASE_FEE * PRECISION,\n            REDEMPTION_LIQUIDATION_FEE * PRECISION\n        );\n        /*\n        If the fee paid is less than REDEMPTION_BASE_FEE, the redemption fee is (feePaid + REDEMPTION_BASE_FEE)\n         */\n        if (feePaidPercentage <= REDEMPTION_BASE_FEE * PRECISION) {\n            if (amountToRedeem >= collateralValue) {\n                // redeem the whole collateral, while refunding stablecoins back to the owner of the safe\n                _amountToRedeem = safe.borrowedAmount;\n                _amountToRefund = collateralValue - _amountToRedeem;\n                _collateralToRedeem = safe.collateralAmount;\n                // OWNER FEE = REDEMPTION BASE FEE for the\n                // toPay = collateralValue * REDEMPTION_BASE_FEE / BASIS_POINTS_DIVISOR\n                // toPay - feePaid\n                uint256 ownerToPay = (collateralValue * REDEMPTION_BASE_FEE) /\n                    BASIS_POINTS_DIVISOR;\n                if (ownerToPay > safe.feePaid) {\n                    _ownerFee = ownerToPay - safe.feePaid;\n                }\n            } else {\n                if (amountToRedeem >= safe.borrowedAmount) {\n                    _amountToRefund = amountToRedeem - safe.borrowedAmount;\n                    _amountToRedeem = safe.borrowedAmount;\n                    _collateralToRedeem =\n                        ((_amountToRedeem + _amountToRefund) * PRECISION) /\n                        collateralPrice;\n                    _ownerFee =\n                        ((_amountToRedeem + _amountToRefund) *\n                            REDEMPTION_BASE_FEE) /\n                        BASIS_POINTS_DIVISOR;\n                    if (_ownerFee > safe.feePaid) {\n                        _ownerFee = _ownerFee - safe.feePaid;\n                    }\n                } else {\n                    _amountToRedeem = amountToRedeem;\n                    _collateralToRedeem =\n                        (amountToRedeem * PRECISION) /\n                        collateralPrice;\n                    _amountToRefund = 0;\n                    _ownerFee = 0;\n                }\n                // No seller fee here\n            }\n        } else {\n            borrowMode = true;\n            if (amountToRedeem >= safe.borrowedAmount) {\n                _amountToRedeem = safe.borrowedAmount;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n            } else {\n                _amountToRedeem = amountToRedeem;\n                _amountToRefund = 0;\n                _ownerFee = 0;\n                _collateralToRedeem =\n                    (_amountToRedeem * PRECISION) /\n                    collateralPrice;\n                //amountToRedeem =\n            }\n        }\n        _redeemerFee = ((_collateralToRedeem * feeTier) /\n            BASIS_POINTS_DIVISOR /\n            PRECISION);\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\nfunction redeemSafe(\n        uint256 _safeId,\n        bool borrowMode,\n        uint256 amountToRedeem,\n        uint256 amountToRefund,\n        uint256 collateralToRedeem,\n        uint256 collateralToReturn,\n        Safe memory safe,\n        uint256 nearestSpotInLiquidationQueue,\n        SBStructs.Redemption memory redemption\n    ) internal returns (Safe memory, SBStructs.Redemption memory) {\n        //uint256 amountInCollateral = amountToRedeem /\n        safe.collateralAmount -= collateralToRedeem;\n        safe.borrowedAmount -= amountToRedeem;\n        redemption.collateralAmount += collateralToReturn;\n        redemption.redeemedAmount += amountToRedeem + amountToRefund;\n        redemption.refundedAmount += amountToRefund;\n        safes[_safeId] = safe;\n        // If the safe is empty(borrowedAmount == 0 in BORROW mode or when the collateral has been fully redeemed in EXCHANGE mode)\n        // Borrow mode: If fee paid > REDEMPTION_BASE_FEE\n        // Exchange mode; If fee paid <= REDEMPTION_BASE_FEE\n        if (\n            (safe.borrowedAmount == 0 && borrowMode) ||\n            (!borrowMode &&\n                closeToZero(safe.collateralAmount) &&\n                safe.borrowedAmount == 0)\n        ) {\n            _removeSafeFromBothQueues(_safeId);\n        } else {\n            uint256 newRatio = (safe.borrowedAmount * PRECISION) /\n                safe.collateralAmount;\n            IDoublyLinkedList.Node\n                memory liquidationNode = safesOrderedForLiquidation.upsert(\n                    _safeId,\n                    newRatio,\n                    nearestSpotInLiquidationQueue\n                );\n            emit LiquidationQueueUpdated(\n                _safeId,\n                newRatio,\n                liquidationNode.next\n            );\n        }\n        emit Redeemed(\n            redemption.redemptionId,\n            _safeId,\n            amountToRedeem,\n            collateralToRedeem,\n            amountToRefund,\n            redemption.requestedAmount - redemption.redeemedAmount\n        );\n        return (safe, redemption);\n    }\nfunction closeToZero(uint256 value) internal pure returns (bool) {\n        return value < 1e10;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _redeemToUser(SBStructs.Redemption memory redemption) internal {\n        uint256 collateralRefund = 0;\n        if (redemption.ownerFee > 0) {\n            if (stabilityPoolCanReceiveRewards) {\n                require(\n                    stabilityPool.addReward(redemption.ownerFee),\n                    \"Add reward failed\"\n                );\n                emit OwnerRedemptionFeeDistributed(\n                    redemption.redemptionId,\n                    redemption.ownerFee\n                );\n            } else {\n                require(\n                    sbdToken.transfer(msg.sender, redemption.ownerFee),\n                    \"Owner fee refund failed\"\n                );\n            }\n        }\n        if (redemption.redeemerFee > 0 && stabilityPoolCanReceiveRewards) {\n            require(\n                stabilityPool.addCollateralReward{\n                    value: redemption.redeemerFee\n                }(redemption.redeemerFee),\n                \"Add collateral reward failed\"\n            );\n        } else {\n            collateralRefund = redemption.redeemerFee;\n        }\n        (bool success, ) = msg.sender.call{\n            value: redemption.collateralAmount + collateralRefund\n        }(\"\");\n        require(success, \"Transfer failed\");\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction transfer(address to, uint256 value) external returns (bool);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}