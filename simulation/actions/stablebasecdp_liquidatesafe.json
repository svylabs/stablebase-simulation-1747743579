{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "The safeId must correspond to an existing Safe (safes[safeId].collateralAmount > 0).",
      "The borrowedAmount of the Safe must be greater than 0 (safes[safeId].borrowedAmount > 0).",
      "The collateralValue (collateralAmount * collateralPrice / PRECISION) must be less than ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR), where collateralPrice is obtained from priceOracle.fetchPrice().",
      "If the stabilityPool.isLiquidationPossible(borrowedAmount) is false and the safeId is the last Safe in the liquidation queue, the transaction should revert with message Cannot liquidate the last Safe",
      "The caller must have enough gas to execute the liquidation and pay for potential external calls.",
      "If the stabilityPool.isLiquidationPossible(borrowedAmount) is true and totalStakedRaw is zero, the transaction should not revert with message Invalid liquidation amount",
      "If stabilityPoolCanReceiveRewards is false and  sbrStakingPoolCanReceiveRewards is false the msg.sender.call should succeed."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Data",
        "state_update_descriptions": [
          "The collateralAmount of the Safe with ID _safeId is decremented by collateralAmount.",
          "The borrowedAmount of the Safe with ID _safeId is decremented by borrowedAmount.",
          "The Safe with ID _safeId is removed from both the liquidation and redemption queues.",
          "The Safe with ID _safeId is removed from the safes mapping.",
          "The NFT associated with the Safe ID is burned, effectively closing the Safe."
        ]
      },
      {
        "category": "System Debt and Collateral",
        "state_update_descriptions": [
          "totalCollateral is decreased by collateralAmount.",
          "totalDebt is decreased by borrowedAmount.",
          "cumulativeCollateralPerUnitCollateral may be updated if the stability pool cannot absorb the liquidation.",
          "cumulativeDebtPerUnitCollateral may be updated if the stability pool cannot absorb the liquidation.",
          "collateralLoss may be updated if the stability pool cannot absorb the liquidation.",
          "debtLoss may be updated if the stability pool cannot absorb the liquidation.",
          "The PROTOCOL_MODE may be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "External Contract Interactions",
        "state_update_descriptions": [
          "The stabilityPool contract's performLiquidation function is called, transferring collateral to the pool and reducing its stakeScalingFactor.This occurs if possible is true, the msg.value must be equal to collateralAmount - liquidationFee.",
          "sbdToken.burn is called to burn the borrowedAmount from the stability pool, this is only executed when liquidation happens through stability pool.",
          "If sbrStakingPoolCanReceiveRewards and there are enough liquidation fees, dfireTokenStaking.addCollateralReward is called to send liquidation fee to SBR stakers, and msg.value is liquidationFee - refund.",
          "If dfireTokenStaking.addCollateralReward fails and stabilityPoolCanReceiveRewards and there are enough liquidation fees, stabilityPool.addCollateralReward is called, and msg.value is liquidationFee - refund.",
          "If the liquidation fee could not be distributed, the user is refunded the remaining liquidation fee.",
          "msg.sender receives a refund of gas compensation up to the amount of the liquidationFee."
        ]
      },
      {
        "category": "Liquidation Fee Distribution",
        "state_update_descriptions": [
          "Liquidation Fee paid to the receiver (DFIREStaking or StabilityPool).",
          "Gas compensation is paid to the msg.sender.",
          "If there is remaining liquidation fee after gas compensation it is paid to DFIREStaking or StabilityPool.",
          "gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION)*(block.basefee + (block.basefee * 10) / 100);",
          "refund = min(gasCompensation, liquidationFee);",
          "If possible to send the reward it's sent to sbrStakers, otherwise to stabilityPool, otherwise refund = liquidationFee."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "Safe is removed from Liquidation Queue."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Safe is removed from Redemption Queue."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Data",
        "rule_descriptions": [
          "safes[_safeId] should no longer exist (i.e., be deleted).",
          "The NFT associated with safeId should be burned, verify by calling ownerOf(safeId) which should return address(0).",
          "The safeId should be removed from the liquidation queue (safesOrderedForLiquidation.get(_safeId) should return default values).",
          "The safeId should be removed from the redemption queue (safesOrderedForRedemption.get(_safeId) should return default values)."
        ]
      },
      {
        "category": "System Debt and Collateral",
        "rule_descriptions": [
          "totalCollateral should be decreased by the initial collateralAmount of the liquidated safe.",
          "totalDebt should be decreased by the initial borrowedAmount of the liquidated safe.",
          "If the stability pool was used, the totalStakedRaw in the StabilityPool contract should decrease by borrowedAmount.",
          "If the secondary mechanism was used (stability pool not available), the cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral should be updated accordingly.",
          "Verify the updated collateralLoss and debtLoss after debt and collateral distribution.",
          "If totalDebt is now less than or equal to BOOTSTRAP_MODE_DEBT_THRESHOLD, PROTOCOL_MODE should remain NORMAL."
        ]
      },
      {
        "category": "External Contract Interactions",
        "rule_descriptions": [
          "If liquidation occurs through the StabilityPool, verify that the StabilityPool's totalStakedRaw is reduced by the borrowedAmount.",
          "If the sbrStakingPoolCanReceiveRewards is true, verify that the dfireTokenStaking contract's collateral reward balance is increased by the distributed liquidation fee (if any).",
          "If the stabilityPoolCanReceiveRewards is true and sbrStakingPoolCanReceiveRewards is false, verify that the stabilityPool contract's collateral reward balance is increased by the distributed liquidation fee (if any).",
          "Verify that the msg.sender (liquidator) received the correct gas compensation refund."
        ]
      },
      {
        "category": "Price Oracle",
        "rule_descriptions": [
          "The priceOracle.fetchPrice() value should not have changed as a result of this function call."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A LiquidatedUsingStabilityPool or LiquidatedUsingSecondaryMechanism event should be emitted with the correct parameters (safeId, borrowedAmount, collateralAmount, totalCollateral, totalDebt).",
          "A SafeRemovedFromLiquidationQueue event should be emitted with the correct safeId.",
          "A SafeRemovedFromRedemptionQueue event should be emitted with the correct safeId.",
          "A RemovedSafe event should be emitted with the correct parameters (safeId, safe).",
          "A Transfer event should be emitted showing the burning of the NFT associated with the safeId.",
          "A LiquidationFeePaid event should be emitted to either dfireTokenStaking or stabilityPool if applicable.",
          "A LiquidationGasCompensationPaid event should be emitted to the msg.sender if applicable.",
          "A SafeUpdated event should be emitted if liquidationSnapshot need update."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt the Safe has.",
            "why_is_is_important": "Reflects the current debt of the Safe, critical for calculating liquidation thresholds.",
            "when_is_it_updated": "It's updated when the Safe is liquidated and the cumulative debt per collateral changes.",
            "how_to_validate_state_update": "Check if the borrowedAmount of the specified safeId is updated in the safes mapping.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount of the Safe is updated by calling the internal function _updateSafe, which adjusts the borrowed amount based on cumulativeDebtPerUnitCollateral and liquidationSnapshots.",
            "conditions": [
              "Collateral value < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "borrowedAmount > 0",
              "collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral the Safe holds.",
            "why_is_is_important": "Reflects the current collateral of the Safe, which is essential for determining the liquidation status.",
            "when_is_it_updated": "It's updated when the Safe is liquidated and the cumulative collateral per collateral changes.",
            "how_to_validate_state_update": "Check if the collateralAmount of the specified safeId is updated in the safes mapping.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount of the Safe is updated by calling the internal function _updateSafe, which adjusts the collateral amount based on cumulativeCollateralPerUnitCollateral and liquidationSnapshots.",
            "conditions": [
              "Collateral value < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "borrowedAmount > 0",
              "collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Keeps track of the total collateral in the system.",
            "why_is_is_important": "Used to calculate the overall collateralization ratio of the system.",
            "when_is_it_updated": "When a Safe is liquidated.",
            "how_to_validate_state_update": "Check if the totalCollateral is decreased by the collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total collateral by the liquidated collateral amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Used to calculate the overall debt ratio of the system.",
            "when_is_it_updated": "When a Safe is liquidated.",
            "how_to_validate_state_update": "Check if totalDebt is decreased by borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total debt by the liquidated borrowed amount using the internal function _updateTotalDebt.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "Safe",
            "what_does_it_track": "Stores the details of each Safe.",
            "why_is_is_important": "Removes the Safe from the active list, preventing further interactions.",
            "when_is_it_updated": "When a Safe is liquidated.",
            "how_to_validate_state_update": "Verify the safe is removed from the mapping safes.",
            "has_conditional_updates": true,
            "summary_of_update": "The Safe object is deleted from the safes mapping.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "dfireTokenStaking.collateralReward",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral rewards in the staking pool.",
            "why_is_is_important": "Incentivizes stakers by providing them with liquidation fees.",
            "when_is_it_updated": "When a Safe is liquidated and there are staking rewards to be paid.",
            "how_to_validate_state_update": "Check the collateral reward in dfireTokenStaking contract",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the liquidation fee to the dfireTokenStaking contract as a collateral reward.",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards is true",
              "stabilityPoolCanReceiveRewards is false"
            ]
          },
          {
            "state_variable_name": "stabilityPool.collateralReward",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral rewards in the stability pool.",
            "why_is_is_important": "Incentivizes stability providers by providing them with liquidation fees.",
            "when_is_it_updated": "When a Safe is liquidated and there are staking rewards to be paid.",
            "how_to_validate_state_update": "Check the collateral reward in stabilityPool contract",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the liquidation fee to the stabilityPool contract as a collateral reward.",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards is false",
              "stabilityPoolCanReceiveRewards is true"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the current mode of the protocol.",
            "why_is_is_important": "Controls the operational state of the protocol, impacting various functionalities.",
            "when_is_it_updated": "When the total debt surpasses a predefined threshold in bootstrap mode.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE is NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per unit of collateral.",
            "why_is_is_important": "Used to distribute debt and collateral fairly among borrowers in secondary liquidation mechanism.",
            "when_is_it_updated": "When a Safe is liquidated, and the stability pool cannot perform the liquidation.",
            "how_to_validate_state_update": "Verify if cumulativeCollateralPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the cumulative collateral per unit collateral based on the debt and collateral distributed to existing borrowers when stability pool liquidation is not possible.",
            "conditions": [
              "possible is false"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit of collateral.",
            "why_is_is_important": "Used to distribute debt and collateral fairly among borrowers in secondary liquidation mechanism.",
            "when_is_it_updated": "When a Safe is liquidated, and the stability pool cannot perform the liquidation.",
            "how_to_validate_state_update": "Verify if cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the cumulative debt per unit collateral based on the debt and collateral distributed to existing borrowers when stability pool liquidation is not possible.",
            "conditions": [
              "possible is false"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral loss during distribution.",
            "why_is_is_important": "Tracks small amount of collateral loss due to integer division.",
            "when_is_it_updated": "When a Safe is liquidated, and the stability pool cannot perform the liquidation.",
            "how_to_validate_state_update": "Verify if collateralLoss is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the remaining collateral loss after debt and collateral distribution.",
            "conditions": [
              "possible is false"
            ]
          },
          {
            "state_variable_name": "debtLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt loss during distribution.",
            "why_is_is_important": "Tracks small amount of debt loss due to integer division.",
            "when_is_it_updated": "When a Safe is liquidated, and the stability pool cannot perform the liquidation.",
            "how_to_validate_state_update": "Verify if debtLoss is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the remaining debt loss after debt and collateral distribution.",
            "conditions": [
              "possible is false"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[safeId]",
            "type": "Node",
            "what_does_it_track": "Manages the order of Safes for liquidation.",
            "why_is_is_important": "Maintains the correct order of Safes for liquidation and redemption processes.",
            "when_is_it_updated": "When a Safe is liquidated.",
            "how_to_validate_state_update": "Check if the safeId is removed from the linked list by checking the node values in the `nodes` mapping.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the Safe's ID from the linked list, updating the previous and next nodes.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the head of the list.",
            "why_is_is_important": "Need to keep track of where head is in the doubly linked list.",
            "when_is_it_updated": "When current safe id is the head.",
            "how_to_validate_state_update": "Check the head after removing safeId",
            "has_conditional_updates": true,
            "summary_of_update": "Update head to next safe id in line if current safe id is the head.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the tail of the list.",
            "why_is_is_important": "Need to keep track of where tail is in the doubly linked list.",
            "when_is_it_updated": "When current safe id is the tail.",
            "how_to_validate_state_update": "Check the tail after removing safeId",
            "has_conditional_updates": true,
            "summary_of_update": "Update tail to prev safe id in line if current safe id is the tail.",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the scaling factor of the stakes in the pool.",
            "why_is_is_important": "Used to calculate the rewards and collateral for each staker in the pool.",
            "when_is_it_updated": "When the liquidation is performed using stability pool.",
            "how_to_validate_state_update": "Check the stakeScalingFactor after liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the stake scaling factor based on the amount liquidated from the stability pool.",
            "conditions": [
              "possible is true"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral available per token staked.",
            "why_is_is_important": "Used to distribute the collateral to the stakers.",
            "when_is_it_updated": "When the liquidation is performed using stability pool.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken after liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral per token based on the liquidated collateral.",
            "conditions": [
              "possible is true"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total staked amount in the stability pool.",
            "why_is_is_important": "Used to calculate the scaling factor and the collateral per token.",
            "when_is_it_updated": "When the liquidation is performed using stability pool.",
            "how_to_validate_state_update": "Check the totalStakedRaw after liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked amount in the pool by the liquidated amount.",
            "conditions": [
              "possible is true"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Tracks whether the reward sender is active or not.",
            "why_is_is_important": "Deactivates the reward sender when there is no more stake in the pool.",
            "when_is_it_updated": "When the liquidation is performed using stability pool and the total staked amount becomes 0.",
            "how_to_validate_state_update": "Check the rewardSenderActive after liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "If the total staked amount is 0 and reward sender is active, deactivates the reward sender.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive is true",
              "possible is true"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the number of times the stake scaling factor has been reset.",
            "why_is_is_important": "Prevents the scaling factor from becoming too small and causing precision issues.",
            "when_is_it_updated": "When the liquidation is performed using stability pool and the cumulative product scaling factor is below the minimum scaling factor.",
            "how_to_validate_state_update": "Check the stakeResetCount after liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Resets the stake scaling factor and other related variables if the scaling factor falls below a minimum threshold. Increments stakeResetCount.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor",
              "possible is true"
            ]
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the scaling factor of the stakes in the pool.",
            "why_is_is_important": "Prevents the scaling factor from becoming too small and causing precision issues.",
            "when_is_it_updated": "When the liquidation is performed using stability pool and the cumulative product scaling factor is below the minimum scaling factor.",
            "how_to_validate_state_update": "Check stakeScalingFactor after liquidation",
            "has_conditional_updates": true,
            "summary_of_update": "Reset stakeScalingFactor to precision when cumulativeProductScalingFactor is less than minimumScalingFactor.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor",
              "possible is true"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral available per token staked.",
            "why_is_is_important": "Used to distribute the collateral to the stakers.",
            "when_is_it_updated": "When the liquidation is performed using stability pool and the cumulative product scaling factor is below the minimum scaling factor.",
            "how_to_validate_state_update": "Check totalCollateralPerToken after liquidation",
            "has_conditional_updates": true,
            "summary_of_update": "Reset totalCollateralPerToken to 0 when cumulativeProductScalingFactor is less than minimumScalingFactor.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor",
              "possible is true"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral loss for dust.",
            "why_is_is_important": "Tracks collateral loss.",
            "when_is_it_updated": "When the liquidation is performed using stability pool.",
            "how_to_validate_state_update": "Check stakeScalingFactor after liquidation",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateral loss for dust.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[address(stabilityPool)]",
            "type": "uint256",
            "what_does_it_track": "Tracks the token balance of the stability pool.",
            "why_is_is_important": "Ensures the stability pool's token balance reflects the amount liquidated.",
            "when_is_it_updated": "When the liquidation is performed using the stability pool.",
            "how_to_validate_state_update": "Check the balance of stability pool",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the borrowed amount from the stability pool, reducing the token balance of the stability pool.",
            "conditions": [
              "possible is true"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount burned.",
            "why_is_is_important": "Need to keep track of total amount burned.",
            "when_is_it_updated": "When tokens are burned.",
            "how_to_validate_state_update": "Check the totalBurned variable.",
            "has_conditional_updates": false,
            "summary_of_update": "Increment totalBurned.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total token supply.",
            "why_is_is_important": "Reduce the overall circulating supply of token.",
            "when_is_it_updated": "When the liquidation is performed using the stability pool.",
            "how_to_validate_state_update": "Check the totalSupply after burning the tokens.",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of the token is reduced when the borrowed amount is burned from the stability pool",
            "conditions": [
              "possible is true"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral rewards per token staked.",
            "why_is_is_important": "Distributes liquidation fees as rewards to the stakers.",
            "when_is_it_updated": "When the SBR staking pool can receive rewards and a liquidation fee is paid.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken after adding the reward.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral per token in the staking pool when the SBR staking pool can receive rewards.",
            "conditions": [
              "sbrStakingPoolCanReceiveRewards is true",
              "liquidationFee > refund"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}