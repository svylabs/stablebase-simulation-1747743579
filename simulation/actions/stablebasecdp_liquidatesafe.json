{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "safeId must correspond to existing Safe.",
      "Safe must have collateralAmount > 0.",
      "Safe must have borrowedAmount > 0.",
      "Collateral value must be < (borrowedAmount * liquidationRatio / BASIS_POINTS_DIVISOR).",
      "If secondary mechanism, safeId != safesOrderedForLiquidation.getHead()."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the safe's borrowed amount based on cumulativeDebtPerUnitCollateral and liquidation snapshots.",
          "Updates the safe's collateral amount based on cumulativeCollateralPerUnitCollateral and liquidation snapshots.",
          "Removes the Safe from the `safes` mapping.",
          "Burns the Safe's token ID."
        ]
      },
      {
        "category": "Global Debt and Collateral Updates",
        "state_update_descriptions": [
          "Decreases `totalCollateral`.",
          "Decreases `totalDebt`.",
          "Updates `cumulativeCollateralPerUnitCollateral` (if secondary liquidation).",
          "Updates `cumulativeDebtPerUnitCollateral` (if secondary liquidation)."
        ]
      },
      {
        "category": "Queue Management",
        "state_update_descriptions": [
          "Removes the Safe from the `safesOrderedForLiquidation` queue.",
          "Removes the Safe from the `safesOrderedForRedemption` queue."
        ]
      },
      {
        "category": "Stability Pool Interaction",
        "state_update_descriptions": [
          "Potentially calls `stabilityPool.performLiquidation`.",
          "Potentially burns SBD tokens from Stability Pool."
        ]
      },
      {
        "category": "Fee Distribution and Compensation",
        "state_update_descriptions": [
          "Distributes the liquidation fee to SBR stakers or Stability Pool.",
          "Potentially refunds liquidation fee.",
          "Refunds gas compensation."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "`safes[safeId]` should no longer exist.",
          "`ownerOf(safeId)` should return the zero address.",
          "Safe should not be present in either liquidation or redemption queues."
        ]
      },
      {
        "category": "Global Debt and Collateral",
        "rule_descriptions": [
          "`totalCollateral` should be decreased.",
          "`totalDebt` should be decreased."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The liquidated `safeId` should no longer be in `safesOrderedForLiquidation`.",
          "The liquidated `safeId` should no longer be in `safesOrderedForRedemption`."
        ]
      },
      {
        "category": "Stability Pool",
        "rule_descriptions": [
          "If liquidation via Stability Pool, `totalStakedRaw` should decrease.",
          "If liquidation via Stability Pool, `stakeScalingFactor` should decrease."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "`LiquidatedUsingStabilityPool` or `LiquidatedUsingSecondaryMechanism` event emitted.",
          "`SafeRemovedFromLiquidationQueue` event emitted.",
          "`SafeRemovedFromRedemptionQueue` event emitted.",
          "`RemovedSafe` event emitted.",
          "`LiquidationFeePaid` event emitted (if applicable).",
          "`LiquidationGasCompensationPaid` event emitted."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "decrement",
            "what_does_it_track": "Tracks the total amount of collateral held by the protocol.",
            "why_is_is_important": "Important for calculating the overall collateralization ratio of the protocol.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool can perform the liquidation.",
            "how_to_validate_state_update": "Check the emitted LiquidatedUsingStabilityPool event for the correct borrowedAmount, collateralAmount, totalCollateral, and totalDebt values after the function executes successfully.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalCollateral by the liquidated safe's collateral amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount) == true"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "decrement",
            "what_does_it_track": "Tracks the total amount of debt outstanding in the protocol.",
            "why_is_is_important": "Important for calculating the overall collateralization ratio of the protocol and assessing the protocol's solvency.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool can perform the liquidation.",
            "how_to_validate_state_update": "Check the emitted LiquidatedUsingStabilityPool event for the correct borrowedAmount, collateralAmount, totalCollateral, and totalDebt values after the function executes successfully.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalDebt by the liquidated safe's borrowed amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount) == true"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "decrement",
            "what_does_it_track": "Tracks the total amount of collateral held by the protocol.",
            "why_is_is_important": "Important for calculating the overall collateralization ratio of the protocol.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool cannot perform the liquidation and _safeId != safesOrderedForLiquidation.getHead()",
            "how_to_validate_state_update": "Check the emitted LiquidatedUsingSecondaryMechanism event for the correct borrowedAmount, collateralAmount, totalCollateral, and totalDebt values after the function executes successfully.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalCollateral by the liquidated safe's collateral amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "_safeId != safesOrderedForLiquidation.getHead()",
              "stabilityPool.isLiquidationPossible(borrowedAmount) == false"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "decrement",
            "what_does_it_track": "Tracks the total amount of debt outstanding in the protocol.",
            "why_is_is_important": "Important for calculating the overall collateralization ratio of the protocol and assessing the protocol's solvency.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool cannot perform the liquidation and _safeId != safesOrderedForLiquidation.getHead()",
            "how_to_validate_state_update": "Check the emitted LiquidatedUsingSecondaryMechanism event for the correct borrowedAmount, collateralAmount, totalCollateral, and totalDebt values after the function executes successfully.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalDebt by the liquidated safe's borrowed amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "_safeId != safesOrderedForLiquidation.getHead()",
              "stabilityPool.isLiquidationPossible(borrowedAmount) == false"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "update",
            "what_does_it_track": "Tracks the current operational mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Indicates whether the protocol is operating under bootstrap conditions or normal conditions.  Reverse transitions from NORMAL to BOOTSTRAP are not allowed",
            "when_is_it_updated": "When totalDebt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD while in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check PROTOCOL_MODE after the execution. It should be NORMAL if totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD before. Reverse transitions from NORMAL to BOOTSTRAP are not allowed",
            "has_conditional_updates": true,
            "summary_of_update": "Changes PROTOCOL_MODE from BOOTSTRAP to NORMAL. Reverse transitions are not allowed",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "increment",
            "what_does_it_track": "Tracks the cumulative collateral per unit of collateral.",
            "why_is_is_important": "Used to calculate liquidation snapshots",
            "when_is_it_updated": "When distributing debt and collateral.",
            "how_to_validate_state_update": "Check the value of cumulativeCollateralPerUnitCollateral after the distributeDebtAndCollateral function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by collPerUnitColl",
            "conditions": [
              "cumulativeCollateralPerUnitCollateral is updated"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "increment",
            "what_does_it_track": "Tracks the cumulative debt per unit of collateral.",
            "why_is_is_important": "Used to calculate liquidation snapshots",
            "when_is_it_updated": "When distributing debt and collateral.",
            "how_to_validate_state_update": "Check the value of cumulativeDebtPerUnitCollateral after the distributeDebtAndCollateral function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by debtPerUnitColl",
            "conditions": [
              "cumulativeDebtPerUnitCollateral is updated"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "update",
            "what_does_it_track": "Tracks the state of individual safes.",
            "why_is_is_important": "Vital for managing individual user positions and ensuring proper collateralization. totalBorrowedAmount of safe is updated",
            "when_is_it_updated": "When collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
            "how_to_validate_state_update": "Check the emitted SafeUpdated event for the correct collateralAmount, debtAmount, collateralIncrease, debtIncrease, totalCollateral and totalDebt values after the function executes successfully.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateralAmount and borrowedAmount of a safe may increase. totalBorrowedAmount of safe is updated.",
            "conditions": [
              "a safe is updated via _updateSafe"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "update",
            "what_does_it_track": "Stores snapshots of debt and collateral per collateral for each safe.",
            "why_is_is_important": "Used to track debt and collateral accrual for each safe.",
            "when_is_it_updated": "When the liquidation snapshot for a safe is outdated.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping after execution. The debtPerCollateralSnapshot and collateralPerCollateralSnapshot values should be updated to cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral respectively.",
            "has_conditional_updates": true,
            "summary_of_update": "debtPerCollateralSnapshot and collateralPerCollateralSnapshot are updated to cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral respectively.",
            "conditions": [
              "collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "remove",
            "what_does_it_track": "Maintains an ordered list of safes for liquidation.",
            "why_is_is_important": "Ensures proper ordering of liquidations.",
            "when_is_it_updated": "Always, after a safe is liquidated.",
            "how_to_validate_state_update": "Check that safesOrderedForLiquidation.remove and safesOrderedForRedemption.remove are called with the correct safeId.",
            "has_conditional_updates": false,
            "summary_of_update": "The safe is removed from the liquidation queue.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "remove",
            "what_does_it_track": "Maintains an ordered list of safes for redemption.",
            "why_is_is_important": "Ensures proper ordering of redemptions.",
            "when_is_it_updated": "Always, after a safe is liquidated.",
            "how_to_validate_state_update": "Check that safesOrderedForLiquidation.remove and safesOrderedForRedemption.remove are called with the correct safeId.",
            "has_conditional_updates": false,
            "summary_of_update": "The safe is removed from the redemption queue.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "delete",
            "what_does_it_track": "Stores the details of each safe.",
            "why_is_is_important": "Holds the collateral and debt information for each user's safe.",
            "when_is_it_updated": "Always, after a safe is liquidated.",
            "how_to_validate_state_update": "Check that safes[_safeId] is deleted after the function executes.",
            "has_conditional_updates": false,
            "summary_of_update": "The safe mapping is deleted. The NFT associated with the safe is burned.",
            "conditions": [
              "true"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "update",
            "what_does_it_track": "Tracks the first node in the linked list.",
            "why_is_is_important": "Maintains the correct start of the list.",
            "when_is_it_updated": "When the node being removed is the head.",
            "how_to_validate_state_update": "Check that the head is updated to node.next.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated if the node being removed is the head.",
            "conditions": [
              "nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "update",
            "what_does_it_track": "Tracks the last node in the linked list.",
            "why_is_is_important": "Maintains the correct end of the list.",
            "when_is_it_updated": "When the node being removed is the tail.",
            "how_to_validate_state_update": "Check that the tail is updated to node.prev.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated if the node being removed is the tail.",
            "conditions": [
              "node.next == 0"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "delete",
            "what_does_it_track": "Stores the nodes in the linked list.",
            "why_is_is_important": "Stores the data and pointers for each node in the list.",
            "when_is_it_updated": "Always, when a node is removed.",
            "how_to_validate_state_update": "Check that nodes[id] is deleted after the function executes.",
            "has_conditional_updates": true,
            "summary_of_update": "The node is deleted.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "decrement",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "Tracks the total supply of SBD tokens and individual account balances.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool performs the liquidation.",
            "how_to_validate_state_update": "Check the balance of the stability pool address after the function executes.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns SBD tokens from the stability pool.",
            "conditions": [
              "stabilityPool.performLiquidation returns true"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "decrement",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "Tracks the total supply of SBD tokens.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool performs the liquidation.",
            "how_to_validate_state_update": "Check the total supply of SBD tokens after the function executes. It should decrease by the amount burned.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total supply of SBD tokens.",
            "conditions": [
              "stabilityPool.performLiquidation returns true"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "increment",
            "what_does_it_track": "Tracks the total amount of SBD tokens burned.",
            "why_is_is_important": "Tracks the total amount of SBD tokens burned.",
            "when_is_it_updated": "When a safe is liquidated and the stability pool performs the liquidation.",
            "how_to_validate_state_update": "Check the totalBurned value after the function executes.  It should increase by the amount burned.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total amount of SBD tokens burned.",
            "conditions": [
              "stabilityPool.performLiquidation returns true"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "update",
            "what_does_it_track": "Tracks the scaling factor for stakes in the Stability Pool.",
            "why_is_is_important": "Used to calculate user rewards and collateral.",
            "when_is_it_updated": "When a liquidation is performed.",
            "how_to_validate_state_update": "Check the stakeScalingFactor after execution; it should be updated based on the formula ((totalStakedRaw - amount) * precision) / totalStakedRaw.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the stake scaling factor.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "increment",
            "what_does_it_track": "Tracks the total collateral available per token in the Stability Pool.",
            "why_is_is_important": "Used to calculate user rewards and collateral.",
            "when_is_it_updated": "When a liquidation is performed.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken after execution; it should be updated by adding _totalCollateralPerToken",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total collateral per token.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "update",
            "what_does_it_track": "Tracks the collateral loss in the Stability Pool.",
            "why_is_is_important": "Used to track discrepancies in collateral amounts.",
            "when_is_it_updated": "When a liquidation is performed.",
            "how_to_validate_state_update": "Check the collateralLoss after execution; it should be updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateral loss.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "decrement",
            "what_does_it_track": "Tracks the total staked amount in the Stability Pool.",
            "why_is_is_important": "Represents the total amount of tokens staked in the pool.",
            "when_is_it_updated": "When a liquidation is performed.",
            "how_to_validate_state_update": "Check the totalStakedRaw after execution; it should be decremented by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decrements the total staked raw amount.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "update",
            "what_does_it_track": "Tracks whether the reward sender is active.",
            "why_is_is_important": "Controls whether the Stability Pool can receive rewards.",
            "when_is_it_updated": "When totalStakedRaw reaches 0 and rewardSenderActive is true.",
            "how_to_validate_state_update": "Check that the setCanStabilityPoolReceiveRewards function is called on the stableBaseCDP.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially updates rewardSenderActive to false via stableBaseCDP.setCanStabilityPoolReceiveRewards(false).",
            "conditions": [
              "totalStakedRaw == 0 && rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "update",
            "what_does_it_track": "Stores snapshots of scaling factors and rewards.",
            "why_is_is_important": "Maintains historical snapshots for stake resets.",
            "when_is_it_updated": "When cumulativeProductScalingFactor is less than minimumScalingFactor.",
            "how_to_validate_state_update": "Check that the stakeResetSnapshots mapping is updated, totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken are set to 0 and stakeScalingFactor is set to precision.",
            "has_conditional_updates": true,
            "summary_of_update": "Resets totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken to 0 and stakeScalingFactor to precision. Stores snapshot.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "increment",
            "what_does_it_track": "Tracks the total collateral per token.",
            "why_is_is_important": "Used for calculating collateral rewards.",
            "when_is_it_updated": "When collateral reward is added.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken after execution; it should be updated by adding (_amount * PRECISION) / _totalStake.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases totalCollateralPerToken.",
            "conditions": [
              "totalStake > 0",
              "sbrStakingPoolCanReceiveRewards && liquidationFee > refund"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}