{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` parameter should be a valid, existing safeId.",
      "The safeId should be selected such that the collateralValue is less than ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR). This can be checked off-chain using the `safes` mapping and the `fetchPrice` function of the priceOracle.",
      "Ensure that `PROTOCOL_MODE` is not BOOTSTRAP mode, or if it is, handle the potential differences in liquidation behavior. Liquidations might be disallowed or behave differently in BOOTSTRAP mode."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe",
        "state_update_descriptions": [
          "The safe's collateralAmount and borrowedAmount are updated based on cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral, respectively.",
          "The safe is removed from the `safes` mapping using `delete safes[_safeId]`.",
          "The safe is burned using `_burn(_safeId)`, which removes the safe's ownership (ERC721 token). This involves transferring ownership to the zero address."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "totalDebt is decreased by the borrowedAmount of the liquidated safe."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "totalCollateral is decreased by the collateralAmount of the liquidated safe."
        ]
      },
      {
        "category": "Liquidation Queues",
        "state_update_descriptions": [
          "The safeId is removed from both the liquidation and redemption queues."
        ]
      },
      {
        "category": "Stability Pool",
        "state_update_descriptions": [
          "If the Stability Pool is used, its state variables related to total staked amount, scaling factor and collateral per token are updated.",
          "The SBD token is burned from the Stability Pool's balance."
        ]
      },
      {
        "category": "Distribution Mechanism",
        "state_update_descriptions": [
          "If the Stability Pool cannot be used, the debt and collateral are distributed to other borrowers.",
          "cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral are updated.",
          "collateralLoss and debtLoss are updated."
        ]
      },
      {
        "category": "Fees and Gas Compensation",
        "state_update_descriptions": [
          "Liquidation fees are distributed to SBR stakers or Stability Pool if possible. Otherwise, liquidation fee is refunded to the user",
          "Gas compensation is paid to the user liquidating the safe. The `msg.sender` receives a refund."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId] should no longer exist. Use `safes[safeId].collateralAmount` or similar to check for existence."
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "rule_descriptions": [
          "totalCollateral should decrease by the liquidated collateral amount.",
          "totalDebt should decrease by the liquidated borrowed amount."
        ]
      },
      {
        "category": "Liquidation Queues",
        "rule_descriptions": [
          "The safeId should be removed from both the liquidation and redemption queues. Check that `safesOrderedForLiquidation.getNode(safeId)` and `safesOrderedForRedemption.getNode(safeId)` return a node with value, prev, and next all equal to 0."
        ]
      },
      {
        "category": "Stability Pool Interaction",
        "rule_descriptions": [
          "If liquidation is possible via the Stability Pool (`stabilityPool.isLiquidationPossible(borrowedAmount)` returns true):",
          "  - The Stability Pool's `totalStakedRaw` should decrease by the `borrowedAmount`.",
          "  - The Stability Pool's `stakeScalingFactor` should be updated accordingly.",
          "If liquidation is NOT possible via the Stability Pool:",
          "  - `cumulativeCollateralPerUnitCollateral` should be updated.",
          "  - `cumulativeDebtPerUnitCollateral` should be updated.",
          "  - `collateralLoss` and `debtLoss` variables should also be updated."
        ]
      },
      {
        "category": "Token Burning",
        "rule_descriptions": [
          "The SBD token's total supply should be decreased by the borrowedAmount if liquidated through stability pool.",
          "Check the `totalBurned` state variable of SBD token contract."
        ]
      },
      {
        "category": "DFIRE Staking Pool or Stability Pool Rewards",
        "rule_descriptions": [
          "Check that DFIRE staking pool or Stability Pool receives liquidation fees if `sbrStakingPoolCanReceiveRewards` or `stabilityPoolCanReceiveRewards` is true respectively.",
          "The rewards should be added to the corresponding pool."
        ]
      },
      {
        "category": "Protocol Mode",
        "rule_descriptions": [
          "If `PROTOCOL_MODE` was NORMAL before liquidation, it should remain NORMAL. If it was BOOTSTRAP, verify that it transitions to NORMAL if `totalDebt` drops below `BOOTSTRAP_MODE_DEBT_THRESHOLD`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "The collateral and borrowed amounts for each safe.",
            "why_is_is_important": "Stores the data of each Safe, including collateral amount, borrowed amount, and other important parameters. It's used to track the state of each Safe.",
            "when_is_it_updated": "It's updated at the beginning of the _liquidate function in the _updateSafe function to account for accrued debt and collateral, based on cumulative debt and collateral per unit collateral, and it is deleted when the Safe is liquidated, removing the safe data.",
            "how_to_validate_state_update": "Check the `RemovedSafe` event emitted after the safe is deleted, also check the safe data at `safes[_safeId]` is set to default value.",
            "has_conditional_updates": true,
            "summary_of_update": "When a Safe is liquidated, the data associated with the `_safeId` in the `safes` mapping is deleted using the `delete` keyword. Before deletion, the `safe` variable is created to hold the safe's data which is used in the `RemovedSafe` event.",
            "conditions": [
              "The `liquidationSnapshot.collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "variable",
            "what_does_it_track": "The total collateral amount in the system.",
            "why_is_is_important": "Tracks the total amount of collateral in the system. Used to calculate collateralization ratios and system health.",
            "when_is_it_updated": "It is decreased by `collateralAmount` when a Safe is liquidated.",
            "how_to_validate_state_update": "Check that the `totalCollateral` is reduced by the `collateralAmount` of the liquidated Safe. Validate this by querying the `totalCollateral` before and after the `liquidateSafe` call.",
            "has_conditional_updates": false,
            "summary_of_update": "The `totalCollateral` is decreased by the `collateralAmount` of the liquidated Safe. This reflects the removal of that collateral from the system's total.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "variable",
            "what_does_it_track": "The total debt amount in the system.",
            "why_is_is_important": "Tracks the total debt in the system. Used to calculate collateralization ratios and assess system risk.",
            "when_is_it_updated": "It is decreased by `borrowedAmount` when a Safe is liquidated.",
            "how_to_validate_state_update": "Check that the `totalDebt` is reduced by the `borrowedAmount` of the liquidated Safe. Query the `totalDebt` before and after the `liquidateSafe` call to confirm.",
            "has_conditional_updates": false,
            "summary_of_update": "The `totalDebt` is decreased by the `borrowedAmount` of the liquidated Safe, reflecting the removal of that debt from the system's total.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "variable",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "Determines whether the protocol operates in Bootstrap or Normal mode, affecting certain functionalities.",
            "when_is_it_updated": "If `totalDebt` is greater than `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is in `BOOTSTRAP` mode, the `PROTOCOL_MODE` is set to `NORMAL`.",
            "how_to_validate_state_update": "Check the `PROTOCOL_MODE` before and after the `liquidateSafe` call, ensuring it transitions as expected when the debt threshold is crossed.",
            "has_conditional_updates": true,
            "summary_of_update": "If the total debt crosses the threshold during the liquidation (after debt reduction), the protocol mode may change from `BOOTSTRAP` to `NORMAL`.",
            "conditions": [
              "`debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "variable",
            "what_does_it_track": "Keeps track of any collateral amount left over from distribution calculation.",
            "why_is_is_important": "Represents unallocated collateral during distribution of debt and collateral upon liquidation, ensuring balance.",
            "when_is_it_updated": "Updated by the `distributeDebtAndCollateral` function, which is called when stability pool liquidation is not possible.",
            "how_to_validate_state_update": "Check the value of `collateralLoss` before and after the `liquidateSafe` call when liquidation uses secondary mechanism.",
            "has_conditional_updates": false,
            "summary_of_update": "Calculated as remainder from distribution, then assigned. Updated in `distributeDebtAndCollateral` function when `stabilityPool.isLiquidationPossible` is false.",
            "conditions": []
          },
          {
            "state_variable_name": "debtLoss",
            "type": "variable",
            "what_does_it_track": "Keeps track of any debt amount left over from distribution calculation.",
            "why_is_is_important": "Represents unallocated debt during distribution of debt and collateral upon liquidation, ensuring balance.",
            "when_is_it_updated": "Updated by the `distributeDebtAndCollateral` function, which is called when stability pool liquidation is not possible.",
            "how_to_validate_state_update": "Check the value of `debtLoss` before and after the `liquidateSafe` call when liquidation uses secondary mechanism.",
            "has_conditional_updates": false,
            "summary_of_update": "Calculated as remainder from distribution, then assigned. Updated in `distributeDebtAndCollateral` function when `stabilityPool.isLiquidationPossible` is false.",
            "conditions": []
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "variable",
            "what_does_it_track": "Total amount of collateral distributed per unit of collateral.",
            "why_is_is_important": "Accumulates distributed collateral across all safes, used in calculating individual safe's collateral.",
            "when_is_it_updated": "Updated by the `distributeDebtAndCollateral` function, which is called when stability pool liquidation is not possible.",
            "how_to_validate_state_update": "Check the value of `cumulativeCollateralPerUnitCollateral` before and after the `liquidateSafe` call when liquidation uses secondary mechanism.",
            "has_conditional_updates": false,
            "summary_of_update": "Accumulates collateral per unit, assigned after distribution in `distributeDebtAndCollateral` function when `stabilityPool.isLiquidationPossible` is false.",
            "conditions": []
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "variable",
            "what_does_it_track": "Total amount of debt distributed per unit of collateral.",
            "why_is_is_important": "Accumulates distributed debt across all safes, used in calculating individual safe's debt.",
            "when_is_it_updated": "Updated by the `distributeDebtAndCollateral` function, which is called when stability pool liquidation is not possible.",
            "how_to_validate_state_update": "Check the value of `cumulativeDebtPerUnitCollateral` before and after the `liquidateSafe` call when liquidation uses secondary mechanism.",
            "has_conditional_updates": false,
            "summary_of_update": "Accumulates debt per unit, assigned after distribution in `distributeDebtAndCollateral` function when `stabilityPool.isLiquidationPossible` is false.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Liquidation snapshot of each safe",
            "why_is_is_important": "Stores liquidation snapshot of each safe, the snapshot is used to calculate the inactive debt and collateral.",
            "when_is_it_updated": "Updated by the `_updateSafe` function at the begining of the `_liquidate` function.",
            "how_to_validate_state_update": "Check the value of `liquidationSnapshots[_safeId]` before and after the `_updateSafe` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "Update `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` when the safe is liquidated.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Keeps track of node connections and values in the linked list.",
            "why_is_is_important": "Maintains the linked list structure for liquidation queue.",
            "when_is_it_updated": "When `_removeSafeFromBothQueues` is called. The `remove` function is called on both `safesOrderedForLiquidation` and `safesOrderedForRedemption`.",
            "how_to_validate_state_update": "Check `nodes[safeId]` before and after the `_remove` function is called, ensuring that node data has been cleared.",
            "has_conditional_updates": false,
            "summary_of_update": "The node corresponding to `safeId` is deleted from the `nodes` mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "variable",
            "what_does_it_track": "Keeps track of the first element in the linked list.",
            "why_is_is_important": "Represents the head of the linked list, allowing for traversal.",
            "when_is_it_updated": "Updated when `node.prev == 0` inside the `_remove` function, which is called in the `remove` function.",
            "how_to_validate_state_update": "Check that the `head` is modified if the node removed is the original `head`.",
            "has_conditional_updates": true,
            "summary_of_update": "If the node being removed is the head, the `head` is updated to the next node in the list. Updated when `stabilityPool.isLiquidationPossible` is false.",
            "conditions": [
              "if (node.prev == 0)"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "variable",
            "what_does_it_track": "Keeps track of the last element in the linked list.",
            "why_is_is_important": "Represents the tail of the linked list, allowing for easy addition to the end.",
            "when_is_it_updated": "Updated when `node.next == 0` inside the `_remove` function, which is called in the `remove` function.",
            "how_to_validate_state_update": "Check that the `tail` is modified if the node removed is the original `tail`.",
            "has_conditional_updates": true,
            "summary_of_update": "If the node being removed is the tail, the `tail` is updated to the previous node in the list. Updated when `stabilityPool.isLiquidationPossible` is false.",
            "conditions": [
              "if (node.next == 0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalStakedRaw",
            "type": "variable",
            "what_does_it_track": "The raw total amount of staked tokens in the stability pool.",
            "why_is_is_important": "Tracks the total staked amount in the stability pool and is crucial for calculating liquidation possibilities and scaling factors.",
            "when_is_it_updated": "totalStakedRaw is decreased by the `amount` being liquidated in the `performLiquidation` function.",
            "how_to_validate_state_update": "Check the `totalStakedRaw` before and after liquidation. Ensure the difference matches the liquidation `amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalStakedRaw` is decreased by the `amount` liquidated, reflecting the removal of those tokens from the pool. This occurs inside the `performLiquidation` function, provided `isLiquidationPossible` is true.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "variable",
            "what_does_it_track": "Keeps track of any collateral amount left over from reward distribution calculation.",
            "why_is_is_important": "Loss of collateral due to rounding errors. Used in calculating reward distribution.",
            "when_is_it_updated": "Set in `performLiquidation` and `addCollateralReward`.",
            "how_to_validate_state_update": "Monitor the value before and after a liquidation. The change should be related to the collateral being processed.",
            "has_conditional_updates": false,
            "summary_of_update": "Collateral loss from calculation, then assigned, updated in `performLiquidation`.",
            "conditions": []
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "variable",
            "what_does_it_track": "The cumulative product scaling factor for adjusting user stakes.",
            "why_is_is_important": "Adjusts individual stake values based on totalStakedRaw change, ensuring fair distribution of rewards and collateral.",
            "when_is_it_updated": "The stakeScalingFactor is updated based on the reduction in totalStakedRaw due to the liquidated `amount`, inside the `performLiquidation` function.",
            "how_to_validate_state_update": "Check the `stakeScalingFactor` before and after the liquidation. The new value should reflect the proportional decrease based on the liquidated amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The `stakeScalingFactor` is decreased in proportion to the liquidation amount, adjusting all stakes accordingly. Updated inside `performLiquidation`.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "variable",
            "what_does_it_track": "Keeps track of collateral distributed per token.",
            "why_is_is_important": "Distributes collateral across stakers.",
            "when_is_it_updated": "Updated in `performLiquidation` function after liquidation occurs.",
            "how_to_validate_state_update": "Monitor the value before and after a liquidation. The change should be related to the collateral being processed.",
            "has_conditional_updates": false,
            "summary_of_update": "Calculates and assigns collateral per token in `performLiquidation` function.",
            "conditions": []
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "mapping",
            "what_does_it_track": "Snapshots of the stake state for reset purposes.",
            "why_is_is_important": "Stores snapshots of the scaling factor and reward information when the scaling factor falls below a minimum threshold, allowing for stake resets.",
            "when_is_it_updated": "Updated when `cumulativeProductScalingFactor < minimumScalingFactor` inside the `performLiquidation` function. A snapshot of `scalingFactor`, `totalRewardPerToken`, and `totalCollateralPerToken` is saved.",
            "how_to_validate_state_update": "Check that a new entry is created in `stakeResetSnapshots` when the scaling factor falls below the minimum threshold. Verify the snapshot data matches the current stake state.",
            "has_conditional_updates": true,
            "summary_of_update": "A new snapshot of the stake state is recorded in `stakeResetSnapshots` when the scaling factor falls too low, allowing for later resets. Updated in `performLiquidation` function.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "variable",
            "what_does_it_track": "Keeps track of how many times the stake state has been reset.",
            "why_is_is_important": "Increments when a stake reset occurs, indicating how many resets have happened.",
            "when_is_it_updated": "Incremented inside the `performLiquidation` function, only when `cumulativeProductScalingFactor < minimumScalingFactor`.",
            "how_to_validate_state_update": "Check that the stakeResetCount increments when stake reset occurs.",
            "has_conditional_updates": true,
            "summary_of_update": "The stakeResetCount is incremented whenever the stake is reset due to the scaling factor falling below the threshold. Updated in `performLiquidation` function.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalBurned",
            "type": "variable",
            "what_does_it_track": "The cumulative amount of tokens burned.",
            "why_is_is_important": "Tracks the total amount of tokens burned, useful for supply monitoring.",
            "when_is_it_updated": "Incremented by the `amount` burned in the `burn` function, which is called in `_removeSafe`.",
            "how_to_validate_state_update": "Check that the `totalBurned` amount increases by the amount burned.",
            "has_conditional_updates": false,
            "summary_of_update": "The `totalBurned` amount is increased when tokens are burned from the StabilityPool. `_removeSafe` function calls `burn`.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The token balance of each account.",
            "why_is_is_important": "Stores the balance of each account, critical for token transfers and accounting.",
            "when_is_it_updated": "Decreased by the `amount` burned in the `_update` function, when `to == address(0)`. Called in the `_burn` function.",
            "how_to_validate_state_update": "Check that the account's balance decreases by the burn amount. Query balance before and after burn to validate.",
            "has_conditional_updates": false,
            "summary_of_update": "When tokens are burned from an account, its balance in the `_balances` mapping decreases. `_update` function, when `to == address(0)`.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "variable",
            "what_does_it_track": "The total token supply.",
            "why_is_is_important": "Represents the total number of tokens in existence.",
            "when_is_it_updated": "Decreased by the `value` burned in the `_update` function, when `to == address(0)`. Called in the `_burn` function.",
            "how_to_validate_state_update": "Verify `_totalSupply` decreases by the burn amount. Get supply before and after to validate.",
            "has_conditional_updates": false,
            "summary_of_update": "The `_totalSupply` decreases by the `value` burned. `_update` function is called with `to == address(0)`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "variable",
            "what_does_it_track": "Total distributed collateral per token for DFIRE stakers.",
            "why_is_is_important": "Collateral distributed among DFIRE stakers. Influences amount stakers can claim.",
            "when_is_it_updated": "Increase to `totalCollateralPerToken` when `addCollateralReward` is called in `_distributeLiquidationFeeAndGasCompensation` when the `sbrStakingPoolCanReceiveRewards` is true.",
            "how_to_validate_state_update": "Compare the value of `totalCollateralPerToken` before and after. Also check if `CollateralRewardAdded` event is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "If `sbrStakingPoolCanReceiveRewards` is true then collateral rewards are sent to DFIRE stakers. This increase `totalCollateralPerToken` .",
            "conditions": [
              "`_totalStake != 0`"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}