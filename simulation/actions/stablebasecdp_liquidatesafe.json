{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "Provide a valid safeId of an existing Safe.",
      "Ensure that the collateralValue of safe is less than ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR).",
      "Ensure borrowedAmount of safe is greater than 0.",
      "Ensure collateralAmount of safe is greater than 0.",
      "Caller of `liquidateSafe` does not have to be authorized.",
      "If liquidation via stability pool is not possible, ensure safeId is not equal to safesOrderedForLiquidation.getHead()"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Data",
        "state_update_descriptions": [
          "Updates the borrowed and collateral amounts of the safe if there are inactive debts and collaterals.",
          "Removes the Safe from both the liquidation and redemption queues.",
          "Deletes the Safe data, effectively closing the safe."
        ]
      },
      {
        "category": "Total Debt and Collateral",
        "state_update_descriptions": [
          "Decreases the total collateral by the liquidated safe's collateral amount.",
          "Decreases the total debt by the liquidated safe's borrowed amount.",
          "Distributes debt and collateral to existing borrowers if liquidation via the stability pool is not possible.",
          "Updates cumulative collateral and debt per unit collateral if secondary liquidation mechanism is used."
        ]
      },
      {
        "category": "Token Transfers and Burning",
        "state_update_descriptions": [
          "Burns the SBD tokens from stability pool if the safe is liquidated using stability pool.",
          "Burns the safe's NFT."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes the liquidation fee (collateral) to the SBR staking pool or the stability pool, prioritizing the SBR staking pool if it can receive rewards.",
          "Refunds gas compensation to the liquidator."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "Transitions the protocol from BOOTSTRAP mode to NORMAL mode if the total debt exceeds a threshold."
        ]
      },
      {
        "category": "Liquidation Snapshots",
        "state_update_descriptions": [
          "Update liquidation snapshots debtPerCollateralSnapshot and collateralPerCollateralSnapshot"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Existence",
        "rule_descriptions": [
          "The Safe with the given safeId should no longer exist (safes[safeId] should be empty)."
        ]
      },
      {
        "category": "Total Debt and Collateral",
        "rule_descriptions": [
          "Verify that totalCollateral has decreased by the correct amount.",
          "Verify that totalDebt has decreased by the correct amount."
        ]
      },
      {
        "category": "Queue Removal",
        "rule_descriptions": [
          "The Safe should no longer be present in the liquidation queue.",
          "The Safe should no longer be present in the redemption queue."
        ]
      },
      {
        "category": "Stability Pool Interaction (if applicable)",
        "rule_descriptions": [
          "If liquidation used the stability pool, verify that the stability pool's totalStakedRaw has decreased by the borrowedAmount of liquidated safe.",
          "If liquidation used the stability pool, verify that the stability pool's stakeScalingFactor and totalCollateralPerToken are updated accordingly.",
          "If liquidation used the stability pool, verify the sbdToken balance of stability pool is reduced by borrowedAmount."
        ]
      },
      {
        "category": "SBR Staking Pool interaction (if applicable)",
        "rule_descriptions": [
          "If liquidation fee is paid to SBR staking pool, then collateral reward is increased on DFIREStaking contract"
        ]
      },
      {
        "category": "ERC721 Ownership",
        "rule_descriptions": [
          "The liquidated safe's NFT should no longer be owned by anyone (ownerOf(safeId) should return address(0))."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks all the safes and their corresponding details like collateral amount, borrowed amount, etc.",
            "why_is_is_important": "It holds critical information about each safe, necessary for calculating liquidation rewards and overall system solvency.",
            "when_is_it_updated": "Updated when a safe is liquidated and removed from the system.",
            "how_to_validate_state_update": "Check if `safes[_safeId].borrowedAmount` is decreased by `borrowedAmount` and `safes[_safeId].collateralAmount` is decreased by `collateralAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `safes` mapping is updated by removing the entry associated with `_safeId`. The borrowedAmount and collateralAmount are used in calculating liquidation rewards. Further `safes[_safeId]` is deleted which removes all the details of the safe.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "It is a key metric for assessing the overall health and solvency of the protocol.",
            "when_is_it_updated": "Updated when a safe is liquidated.",
            "how_to_validate_state_update": "Check if `totalCollateral` is decreased by `collateralAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "`totalCollateral` is decreased by the `collateralAmount` of the liquidated safe.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the system.",
            "why_is_is_important": "It is a key metric for assessing the overall health and solvency of the protocol.",
            "when_is_it_updated": "Updated when a safe is liquidated.",
            "how_to_validate_state_update": "Check if `totalDebt` is decreased by `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "`totalDebt` is decreased by the `borrowedAmount` of the liquidated safe.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "sbdToken",
            "type": "contract",
            "what_does_it_track": "The SBD token contract.",
            "why_is_is_important": "Burning SBD reduces the total supply.",
            "when_is_it_updated": "Updated during liquidation when the stability pool is used.",
            "how_to_validate_state_update": "Verify that `sbdToken.burn` is called with `address(stabilityPool)` and `borrowedAmount` as arguments.",
            "has_conditional_updates": true,
            "summary_of_update": "The `sbdToken` is burned from the `stabilityPool` address, reducing the total supply of SBD tokens.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral, cumulativeDebtPerUnitCollateral, collateralLoss, debtLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks cumulative collateral and debt per unit collateral, as well as any residual loss due to distribution imprecision.",
            "why_is_is_important": "These variables are key for tracking and distributing debt and collateral in the system.",
            "when_is_it_updated": "Updated during liquidation when the secondary mechanism is used.",
            "how_to_validate_state_update": "Check the change in `cumulativeCollateralPerUnitCollateral` and `cumulativeDebtPerUnitCollateral`.  Also check if `collateralLoss` and `debtLoss` are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "The debt and collateral are distributed to existing borrowers, updating `cumulativeCollateralPerUnitCollateral`, `cumulativeDebtPerUnitCollateral`, `collateralLoss`, and `debtLoss`.",
            "conditions": [
              "_safeId != _last",
              "!stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation, safesOrderedForRedemption",
            "type": "contract",
            "what_does_it_track": "Doubly linked lists that maintain the order of safes for liquidation and redemption.",
            "why_is_is_important": "Maintaining accurate queues is essential for proper liquidation and redemption processes.",
            "when_is_it_updated": "Updated during liquidation to remove the liquidated safe from these queues.",
            "how_to_validate_state_update": "Check if `safesOrderedForLiquidation.remove(safeId)` and `safesOrderedForRedemption.remove(safeId)` are called with `safeId` as argument.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe is removed from both liquidation and redemption queues.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operating mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Controls certain aspects of protocol behavior.",
            "when_is_it_updated": "Updated during liquidation if the debt threshold is crossed.",
            "how_to_validate_state_update": "Check if `PROTOCOL_MODE` is updated from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL`.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode is changed from BOOTSTRAP to NORMAL if the total debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount, safes[_safeId].totalBorrowedAmount, liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "mapping",
            "what_does_it_track": "Tracks the debt and collateral snapshots for each safe, used to calculate interest accrual.",
            "why_is_is_important": "Ensures accurate debt calculation.",
            "when_is_it_updated": "Updated during liquidation when the safe's snapshot is outdated.",
            "how_to_validate_state_update": "Verify the debt increase calculation and update of  `safes[_safeId].borrowedAmount`, `safes[_safeId].totalBorrowedAmount`, `liquidationSnapshots[_safeId].debtPerCollateralSnapshot`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount if the snapshot is outdated, increasing `borrowedAmount` and `totalBorrowedAmount` and updating the `debtPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount, liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "mapping",
            "what_does_it_track": "Tracks the debt and collateral snapshots for each safe, used to calculate interest accrual.",
            "why_is_is_important": "Ensures accurate collateral calculation.",
            "when_is_it_updated": "Updated during liquidation when the safe's snapshot is outdated.",
            "how_to_validate_state_update": "Verify the collateral increase calculation and update of `safes[_safeId].collateralAmount`, `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount if the snapshot is outdated, increasing `collateralAmount` and updating the `collateralPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Stores the nodes of the doubly linked list, representing the order of safes.",
            "why_is_is_important": "Maintaining the order of safes is crucial for liquidation and redemption processes.",
            "when_is_it_updated": "Updated when a safe is liquidated and needs to be removed from the liquidation or redemption queue.",
            "how_to_validate_state_update": "Check if `nodes[id]` is deleted after calling `_remove(safeId)`. Also verify that `head` and `tail` are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a node from the doubly linked list, updating the `nodes` mapping and potentially updating `head` and `tail` if the removed node was at the beginning or end of the list.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the linked list.",
            "why_is_is_important": "Head is used to access the queue.",
            "when_is_it_updated": "When the first node in the list is removed.",
            "how_to_validate_state_update": "Check if `head` is updated to `node.next`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the linked list if the node being removed is the current head.",
            "conditions": [
              "node.prev == 0",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the linked list.",
            "why_is_is_important": "Tail is used to access the queue.",
            "when_is_it_updated": "When the last node in the list is removed.",
            "how_to_validate_state_update": "Check if `tail` is updated to `node.prev`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the linked list if the node being removed is the current tail.",
            "conditions": [
              "node.next == 0",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "A scaling factor used to calculate rewards and collateral distribution for stakers in the Stability Pool.",
            "why_is_is_important": "It ensures fair distribution of rewards and collateral among stakers.",
            "when_is_it_updated": "Updated during liquidation to adjust rewards and collateral distribution.",
            "how_to_validate_state_update": "Check if `stakeScalingFactor` is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "The `stakeScalingFactor` is updated based on the liquidated amount.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken, collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral per token in the stability pool.",
            "why_is_is_important": "Used to calculate rewards for stakers in the stability pool.",
            "when_is_it_updated": "Updated when collateral rewards are added.",
            "how_to_validate_state_update": "Verify the update to `totalCollateralPerToken` using the formula and check the update of `collateralLoss`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalCollateralPerToken` is updated and `collateralLoss` is updated.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total amount of staked tokens in the Stability Pool.",
            "why_is_is_important": "Reflects the current amount of staked tokens.",
            "when_is_it_updated": "Updated during liquidation.",
            "how_to_validate_state_update": "Check if `totalStakedRaw` is decreased by the `amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "`totalStakedRaw` is decreased by the liquidated `amount`.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "A boolean indicating whether the reward sender is active.",
            "why_is_is_important": "Controls whether the stability pool can receive rewards.",
            "when_is_it_updated": "Updated during liquidation when the total staked raw amount becomes zero.",
            "how_to_validate_state_update": "Verify that `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)` is called.",
            "has_conditional_updates": true,
            "summary_of_update": "If `totalStakedRaw` becomes 0, the reward sender is deactivated.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive",
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots, totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount",
            "type": "mapping",
            "what_does_it_track": "Stake reset snapshots, total collateral per token, total reward per token, total SBR reward per token, stake scaling factor, and stake reset count.",
            "why_is_is_important": "Handles extreme cases where the scaling factor becomes too small, resetting rewards and collateral distribution.",
            "when_is_it_updated": "Updated during liquidation if the scaling factor falls below the minimum threshold.",
            "how_to_validate_state_update": "Check the update to `stakeResetSnapshots[stakeResetCount]` and the resetting of `totalCollateralPerToken`, `totalRewardPerToken`, `totalSbrRewardPerToken`, `stakeScalingFactor`.",
            "has_conditional_updates": true,
            "summary_of_update": "If `cumulativeProductScalingFactor` falls below `minimumScalingFactor`, a stake reset snapshot is created, and several variables are reset.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor",
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "The total collateral per token in the DFIRE staking pool.",
            "why_is_is_important": "Used to calculate rewards for stakers in the DFIRE staking pool.",
            "when_is_it_updated": "Updated when a collateral reward is added.",
            "how_to_validate_state_update": "Check if `totalCollateralPerToken` is updated using the provided formula.",
            "has_conditional_updates": true,
            "summary_of_update": "`totalCollateralPerToken` is updated when a collateral reward is added.",
            "conditions": [
              "sbrStakingPoolCanReceiveRewards",
              "liquidationFee > refund"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Balances of the token holders.",
            "why_is_is_important": "Important for the tokenomics.",
            "when_is_it_updated": "During the burn operation.",
            "how_to_validate_state_update": "Check that  `_burn(address(stabilityPool), borrowedAmount)` is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the specified amount of tokens from the stability pool.",
            "conditions": [
              "possible",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Track the total burned amount of token.",
            "why_is_is_important": "Important for the tokenomics and provide an overview of the contract's token burn history.",
            "when_is_it_updated": "After burning operation is successful.",
            "how_to_validate_state_update": "Check that `totalBurned` is increased by `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the `totalBurned` by `borrowedAmount`.",
            "conditions": [
              "possible",
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}