{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "The safeId must correspond to an existing Safe (CDP), i.e., safes[safeId].collateralAmount > 0.",
      "The collateralAmount of the Safe must be greater than 0 (safes[safeId].collateralAmount > 0).",
      "The borrowedAmount of the Safe must be greater than 0 (safes[safeId].borrowedAmount > 0).",
      "The collateralValue (collateralAmount * collateralPrice / PRECISION) must be less than (borrowedAmount * liquidationRatio / BASIS_POINTS_DIVISOR), ensuring the Safe is undercollateralized.",
      "If liquidation via secondary mechanism is required, the safeId should not be the last Safe in the liquidation queue. Verify _safeId != safesOrderedForLiquidation.getHead().",
      "Verify that liquidation is possible, i.e., collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR).",
      "Check that stabilityPool.isLiquidationPossible(borrowedAmount) returns true or false based on whether totalStakedRaw > borrowedAmount. If it is false, ensure that safeId != safesOrderedForLiquidation.getHead() is true."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Update borrowed and collateral amount of the safe using liquidationSnapshots if cumulativeDebtPerUnitCollateral or cumulativeCollateralPerUnitCollateral have changed since last update.",
          "Remove the Safe from the safes mapping.",
          "Burn the NFT representing the Safe by transferring ownership to the zero address."
        ]
      },
      {
        "category": "Global Debt and Collateral",
        "state_update_descriptions": [
          "Decrease totalCollateral by the liquidated collateralAmount.",
          "Decrease totalDebt by the liquidated borrowedAmount.",
          "Update cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral based on distributed debt and collateral to the remaining safes if liquidated using the secondary mechanism.",
          "Update collateralLoss and debtLoss due to precision loss."
        ]
      },
      {
        "category": "Liquidation Queues",
        "state_update_descriptions": [
          "Remove the Safe from both the liquidation and redemption queues (safesOrderedForLiquidation and safesOrderedForRedemption)."
        ]
      },
      {
        "category": "Stability Pool Interaction (If Possible)",
        "state_update_descriptions": [
          "If liquidation is possible using the Stability Pool: Transfer collateral (collateralAmount - liquidationFee) from the StableBaseCDP contract to the Stability Pool.",
          "If liquidation is possible using the Stability Pool: Burn borrowedAmount from the Stability Pool's balance of sbdToken."
        ]
      },
      {
        "category": "Fee Distribution and Gas Compensation",
        "state_update_descriptions": [
          "Attempt to distribute liquidation fee (liquidationFee - refund) to SBR stakers via dfireTokenStaking.addCollateralReward or Stability Pool via stabilityPool.addCollateralReward, if possible.",
          "If neither dfireTokenStaking nor StabilityPool can receive rewards, the liquidation fee is refunded to the liquidator.",
          "Refund gas compensation to the user (msg.sender) if applicable, calculated based on gas used and liquidationFee. The refund amount is min(gasCompensation, liquidationFee)."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "Transition from BOOTSTRAP to NORMAL mode if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and protocol is currently in BOOTSTRAP mode."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Removal",
        "rule_descriptions": [
          "safes[safeId] should no longer exist (or its values should be reset to zero).",
          "The NFT representing the Safe should no longer be owned by any address other than zero, verified by ownerOf(safeId) == address(0)."
        ]
      },
      {
        "category": "Global Debt and Collateral Consistency",
        "rule_descriptions": [
          "totalCollateral should be decreased by the liquidated collateralAmount.",
          "totalDebt should be decreased by the liquidated borrowedAmount."
        ]
      },
      {
        "category": "Liquidation Queue Removal",
        "rule_descriptions": [
          "safesOrderedForLiquidation should no longer contain safeId.",
          "safesOrderedForRedemption should no longer contain safeId."
        ]
      },
      {
        "category": "Stability Pool State (If Applicable)",
        "rule_descriptions": [
          "If liquidation used Stability Pool: Stability Pool's SBD token balance should decrease by borrowedAmount.",
          "If liquidation used Stability Pool: Stability Pool's totalStakedRaw should decrease by borrowedAmount.",
          "If liquidation used Stability Pool: Verify totalCollateralPerToken is updated correctly according to the formula in performLiquidation."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "If dfireTokenStaking.addCollateralReward or stabilityPool.addCollateralReward was successful, their collateral token balance should increase by the transferred amount (liquidationFee - refund)."
        ]
      },
      {
        "category": "StableBaseCDP collateral token balance",
        "rule_descriptions": [
          "StableBaseCDP collateral token balance should decrease by amount sent to stability pool + amount distributed as reward + amount refunded to liquidator"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The debt of a specific safe.",
            "why_is_is_important": "Keeps track of the debt owed by the safe.",
            "when_is_it_updated": "When a safe's liquidation snapshot is outdated and the safe is being liquidated.",
            "how_to_validate_state_update": "Compare the borrowedAmount of the safe before and after the transaction. It should increase by the debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the borrowed amount of the safe if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total debt ever borrowed by a specific safe.",
            "why_is_is_important": "Keeps track of the total debt ever borrowed by the safe.",
            "when_is_it_updated": "When a safe's liquidation snapshot is outdated and the safe is being liquidated.",
            "how_to_validate_state_update": "Compare the totalBorrowedAmount of the safe before and after the transaction. It should increase by the debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total borrowed amount of the safe if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The collateral deposited in a specific safe.",
            "why_is_is_important": "Keeps track of the collateral backing the debt in the safe.",
            "when_is_it_updated": "When a safe's liquidation snapshot is outdated and the safe is being liquidated.",
            "how_to_validate_state_update": "Compare the collateralAmount of the safe before and after the transaction. It should increase by the collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of the safe if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the system.",
            "why_is_is_important": "Tracks the total amount of collateral in the system.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingStabilityPool and compare the totalCollateral value before and after the liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total collateral by the collateralAmount when liquidated using the stability pool.",
            "conditions": [
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "Tracks the total amount of debt in the system.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingStabilityPool and compare the totalDebt value before and after the liquidation. It should decrease by borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total debt by the borrowedAmount when liquidated using the stability pool.",
            "conditions": [
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the system.",
            "why_is_is_important": "Tracks the total amount of collateral in the system.",
            "when_is_it_updated": "When a safe is liquidated using the secondary mechanism.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingSecondaryMechanism and compare the totalCollateral value before and after the liquidation. It should decrease by collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total collateral by the collateralAmount when liquidated using the secondary mechanism.",
            "conditions": [
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "Tracks the total amount of debt in the system.",
            "when_is_it_updated": "When a safe is liquidated using the secondary mechanism.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingSecondaryMechanism and compare the totalDebt value before and after the liquidation. It should decrease by borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total debt by the borrowedAmount when liquidated using the secondary mechanism.",
            "conditions": [
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per unit collateral.",
            "why_is_is_important": "Used to calculate collateral increases in other safes.",
            "when_is_it_updated": "When a safe is liquidated using the secondary mechanism and debt/collateral is distributed.",
            "how_to_validate_state_update": "Check the cumulativeCollateralPerUnitCollateral before and after the distribution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the cumulative collateral per unit collateral when distributing debt and collateral to existing borrowers.",
            "conditions": [
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral.",
            "why_is_is_important": "Used to calculate debt increases in other safes.",
            "when_is_it_updated": "When a safe is liquidated using the secondary mechanism and debt/collateral is distributed.",
            "how_to_validate_state_update": "Check the cumulativeDebtPerUnitCollateral before and after the distribution.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the cumulative debt per unit collateral when distributing debt and collateral to existing borrowers.",
            "conditions": [
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Controls certain protocol behaviors.",
            "when_is_it_updated": "When the total debt exceeds the bootstrap mode threshold.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE before and after the liquidation. If the conditions are met, it should change from BOOTSTRAP to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "mapping",
            "what_does_it_track": "Stores the information about each safe.",
            "why_is_is_important": "Maintains a registry of all safes.",
            "when_is_it_updated": "When a safe is liquidated.",
            "how_to_validate_state_update": "Check the safes mapping before and after the liquidation. The safe with _safeId should be deleted.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the safe from the safes mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "collateral loss",
            "why_is_is_important": "collateral accounting",
            "when_is_it_updated": "distributeDebtAndCollateral",
            "how_to_validate_state_update": "Check collateralLoss value before and after distributeDebtAndCollateral",
            "has_conditional_updates": false,
            "summary_of_update": "Keeps track of any excess collateral",
            "conditions": []
          },
          {
            "state_variable_name": "debtLoss",
            "type": "uint256",
            "what_does_it_track": "debt loss",
            "why_is_is_important": "debt accounting",
            "when_is_it_updated": "distributeDebtAndCollateral",
            "how_to_validate_state_update": "Check debtLoss value before and after distributeDebtAndCollateral",
            "has_conditional_updates": false,
            "summary_of_update": "Keeps track of any excess debt",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The nodes in the doubly linked list.",
            "why_is_is_important": "Maintains the order of safes for liquidation.",
            "when_is_it_updated": "When a safe is liquidated.",
            "how_to_validate_state_update": "Check that the safeId is removed from safesOrderedForLiquidation.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the safe's ID from the liquidation queue.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total staked amount in the stability pool.",
            "why_is_is_important": "Tracks the total amount of staked tokens in the stability pool.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the emitted event LiquidationPerformed and compare the totalStakedRaw before and after the liquidation.  It should decrease by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total staked raw amount in the stability pool.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Scaling factor for stake in stability pool.",
            "why_is_is_important": "Adjusts rewards based on pool size changes.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the stakeScalingFactor before and after the liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the stake scaling factor after liquidation.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total collateral per token in stability pool",
            "why_is_is_important": "Calculates the rewards claimable",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken before and after the liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral per token after liquidation.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "if reward sender is active",
            "why_is_is_important": "deactivates the reward sender",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check rewardSenderActive before and after the liquidation.",
            "has_conditional_updates": true,
            "summary_of_update": "Deactivates reward sender if total staked raw is zero.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "struct",
            "what_does_it_track": "Keeps track of the StakeResetSnapshot.",
            "why_is_is_important": "Keeps track of the snapshots",
            "when_is_it_updated": "scaling factor is less than min",
            "how_to_validate_state_update": "Compare StakeResetSnapshot before and after the scalingfactor reset",
            "has_conditional_updates": true,
            "summary_of_update": "stores snapshot of the different parameters.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "collateral loss",
            "why_is_is_important": "collateral accounting",
            "when_is_it_updated": "performLiquidation",
            "how_to_validate_state_update": "Check collateralLoss value before and after performLiquidation",
            "has_conditional_updates": false,
            "summary_of_update": "Keeps track of any excess collateral",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[address(stabilityPool)]",
            "type": "uint256",
            "what_does_it_track": "The balance of SBD tokens held by the StabilityPool.",
            "why_is_is_important": "Reduces the supply of SBD tokens held by the StabilityPool.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the balanceOf StabilityPool before and after the transaction. It should decrease by the borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the borrowed amount from the StabilityPool.",
            "conditions": [
              "possible"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of SBD tokens.",
            "why_is_is_important": "Maintains an accurate record of the total supply of SBD tokens.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool and the SBD tokens are burned.",
            "how_to_validate_state_update": "Check the totalSupply before and after the transaction. It should decrease by the borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total supply of SBD tokens.",
            "conditions": [
              "possible"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD tokens that have been burned.",
            "why_is_is_important": "Tracks the total amount of burned SBD tokens.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the totalBurned before and after the transaction. It should increase by borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total amount of SBD tokens burned.",
            "conditions": [
              "possible"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral rewards per token in DFIREStaking.",
            "why_is_is_important": "Used to distribute rewards to stakers.",
            "when_is_it_updated": "When liquidationFee is paid to DFIREStaking.",
            "how_to_validate_state_update": "Check the totalCollateralPerToken of DFIREStaking after a successful call to addCollateralReward. It should increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases totalCollateralPerToken in DFIREStaking if liquidation fee is paid to it.",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards",
              "dfireTokenStaking.addCollateralReward{value: liquidationFee - refund}(liquidationFee - refund)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}