{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "The safeId parameter must correspond to an existing, valid safe.",
      "The safe associated with safeId must have collateralAmount > 0 and borrowedAmount > 0.",
      "The safe's collateral value must be less than (borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR, indicating it is undercollateralized and eligible for liquidation.",
      "If stabilityPool.isLiquidationPossible(borrowedAmount) returns false, ensure safeId is not the last safe in the liquidation queue. This prevents issues with secondary liquidation.",
      "The caller should have sufficient gas to execute the transaction."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Update (Pre-Liquidation)",
        "state_update_descriptions": [
          "Updates liquidation snapshots for the safe being liquidated to reflect the current cumulative debt and collateral per unit collateral.",
          "Increases the safe's borrowed amount based on the cumulative debt.",
          "Increases the safe's collateral amount based on the cumulative collateral.",
          "Updates the contract's totalCollateral.",
          "Updates the contract's totalDebt."
        ]
      },
      {
        "category": "Liquidation Calculations & Global State Updates",
        "state_update_descriptions": [
          "Fetches the collateral price from the price oracle.",
          "Calculates the collateral value based on collateral amount and price.",
          "Calculates the liquidation fee using the collateral amount and REDEMPTION_LIQUIDATION_FEE.",
          "Decreases totalCollateral by the liquidated collateral amount.",
          "Decreases totalDebt by the liquidated borrowed amount."
        ]
      },
      {
        "category": "Finalization & Fee Distribution",
        "state_update_descriptions": [
          "If liquidation is successful using stability pool, burn the borrowed amount from the Stability Pool via sbdToken.burn(address(stabilityPool), borrowedAmount).",
          "Removes the safe from safesOrderedForLiquidation and safesOrderedForRedemption.",
          "Removes the safe from the safes mapping, effectively deleting it.",
          "Burns the NFT token associated with the safe via _burn(_safeId).",
          "Distributes liquidation fees to SBR stakers or the Stability Pool.",
          "Compensates the transaction sender for gas used during liquidation."
        ]
      },
      {
        "category": "Secondary Liquidation Mechanism",
        "state_update_descriptions": [
          "Updates cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral to distribute collateral and debt to existing borrowers.",
          "Updates collateralLoss and debtLoss variables to track any residual collateral or debt."
        ]
      },
      {
        "category": "Stability Pool",
        "state_update_descriptions": [
          "Updates stakeScalingFactor in StabilityPool to reflect the liquidation.",
          "Updates totalCollateralPerToken in StabilityPool to account for changes in collateral distribution.",
          "Potentially resets the scaling factor in StabilityPool if it falls below a minimum threshold, triggering a StakeResetSnapshot."
        ]
      },
      {
        "category": "DFIRE Staking Pool",
        "state_update_descriptions": [
          "If liquidation fee is sent to the DFIRE staking pool, increase totalCollateralPerToken in DFIREStaking."
        ]
      },
      {
        "category": "Token Burning",
        "state_update_descriptions": [
          "Burns the SBD tokens from the StabilityPool address representing the liquidated debt by calling burn function in DFIDToken contract."
        ]
      },
      {
        "category": "OrderedDoublyLinkedList updates",
        "state_update_descriptions": [
          "Remove node from `safesOrderedForLiquidation` linked list.",
          "Remove node from `safesOrderedForRedemption` linked list."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId] must no longer exist (or must be zeroed), confirming the safe's removal.",
          "ownerOf(safeId) must return the zero address, indicating the safe's NFT has been burned.",
          "The safe must be removed from both the liquidation and redemption queues (safesOrderedForLiquidation and safesOrderedForRedemption)."
        ]
      },
      {
        "category": "Global State",
        "rule_descriptions": [
          "totalCollateral must be decreased by the liquidated collateral amount.",
          "totalDebt must be decreased by the liquidated borrowed amount."
        ]
      },
      {
        "category": "Doubly Linked List",
        "rule_descriptions": [
          "The safe must not be present in safesOrderedForLiquidation and safesOrderedForRedemption. Check getHead and iterate if necessary."
        ]
      },
      {
        "category": "Stability Pool",
        "rule_descriptions": [
          "If liquidation used the stability pool, totalStakedRaw in the StabilityPool must decrease by the borrowed amount.",
          "stakeScalingFactor and totalCollateralPerToken in the StabilityPool must be updated correctly based on the liquidation event. Consider using getUser to check.",
          "Check related events to validate `stakeScalingFactor` and `totalCollateralPerToken` updates."
        ]
      },
      {
        "category": "DFIREStaking",
        "rule_descriptions": [
          "If the liquidation fee is sent to DFIREStaking, totalCollateralPerToken in DFIREStaking must be updated accordingly. Check emitted event parameters."
        ]
      },
      {
        "category": "DFIDToken",
        "rule_descriptions": [
          "If the liquidation used the Stability Pool, the SBD token balance of the stability pool (sbdToken.balanceOf(stabilityPool)) must be decreased by the liquidated amount."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "Verify that a LiquidatedUsingStabilityPool or LiquidatedUsingSecondaryMechanism event is emitted with the correct parameters (safeId, borrowedAmount, collateralAmount, totalCollateral, totalDebt).",
          "Verify that a SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue event are emitted for the given safeId.",
          "Verify that a RemovedSafe event is emitted with the correct safe details."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Stores all the safe information based on safeId.",
            "why_is_is_important": "It holds the information of a safe, which includes collateral amount, borrowed amount, weight, total borrowed amount and fee paid.",
            "when_is_it_updated": "Always, within the `_removeSafe` function called by `_liquidate` which is called by `liquidateSafe`.",
            "how_to_validate_state_update": "Check if the safe with given safeId exists after `liquidateSafe` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "The safe is deleted from the `safes` mapping when `_removeSafe` is executed inside `liquidateSafe`.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "contract",
            "what_does_it_track": "Contract for managing the order of safes for liquidation.",
            "why_is_is_important": "Manages the order in which safes are liquidated.",
            "when_is_it_updated": "When `_removeSafeFromBothQueues` is called, which executes `safesOrderedForLiquidation.remove(safeId)`, the safe ID will be removed.",
            "how_to_validate_state_update": "Check if the safeId is present in `safesOrderedForLiquidation` after `liquidateSafe` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe ID is removed from the liquidation queue when the safe is liquidated, by calling the `remove` function.",
            "conditions": [
              "safeId exists in the queue"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "contract",
            "what_does_it_track": "Contract for managing the order of safes for redemption.",
            "why_is_is_important": "Manages the order in which safes are redeemed.",
            "when_is_it_updated": "When `_removeSafeFromBothQueues` is called, which executes `safesOrderedForRedemption.remove(safeId)`, the safe ID will be removed.",
            "how_to_validate_state_update": "Check if the safeId is present in `safesOrderedForRedemption` after `liquidateSafe` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe ID is removed from the redemption queue when the safe is liquidated, by calling the `remove` function.",
            "conditions": [
              "safeId exists in the queue"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total collateral in the protocol.",
            "why_is_is_important": "Tracks the total collateral in the protocol, used to calculate global collateralization ratio.",
            "when_is_it_updated": "It is decreased by the collateral amount when a safe is liquidated. `totalCollateral -= collateralAmount;` inside `_liquidate` function.",
            "how_to_validate_state_update": "Check if `totalCollateral` is decreased by `collateralAmount` after `liquidateSafe` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "Total collateral is decreased when a safe is liquidated.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt in the protocol.",
            "why_is_is_important": "Tracks the total outstanding debt in the protocol, used for calculating protocol solvency.",
            "when_is_it_updated": "It's decremented by borrowedAmount. It is updated inside the `_updateTotalDebt` function, which is called in `_liquidate` with the `add` parameter set to `false`.",
            "how_to_validate_state_update": "Check if totalDebt is decreased by borrowedAmount after liquidateSafe function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "Total debt is decreased when a safe is liquidated.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Governs certain protocol behaviors based on its mode.",
            "when_is_it_updated": "If the debt exceeds the threshold and the protocol is in BOOTSTRAP mode, it transitions to NORMAL mode.  This happens inside `_updateTotalDebt` function.",
            "how_to_validate_state_update": "Check if the protocol mode changes from BOOTSTRAP to NORMAL when the debt exceeds the threshold.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode may change from BOOTSTRAP to NORMAL if debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Cumulative collateral per unit collateral.",
            "why_is_is_important": "Used for calculating collateral increases during updates.",
            "when_is_it_updated": "cumulativeCollateralPerUnitCollateral is increased by collateralToDistribute * PRECISION / totalCollateralAfterLiquidation inside the `distributeDebtAndCollateral` function.",
            "how_to_validate_state_update": "Check that cumulativeCollateralPerUnitCollateral is increased appropriately when distributing debt and collateral.",
            "has_conditional_updates": false,
            "summary_of_update": "The cumulative collateral per unit collateral is updated when distributing debt and collateral.",
            "conditions": []
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Cumulative debt per unit collateral.",
            "why_is_is_important": "Used for calculating debt increases during updates.",
            "when_is_it_updated": "cumulativeDebtPerUnitCollateral is increased by debtToDistribute * PRECISION / totalCollateralAfterLiquidation inside the `distributeDebtAndCollateral` function.",
            "how_to_validate_state_update": "Check that cumulativeDebtPerUnitCollateral is increased appropriately when distributing debt and collateral.",
            "has_conditional_updates": false,
            "summary_of_update": "The cumulative debt per unit collateral is updated when distributing debt and collateral.",
            "conditions": []
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Collateral loss.",
            "why_is_is_important": "Tracks the amount of collateral lost during the distribution process.",
            "when_is_it_updated": "collateralLoss is updated inside the `distributeDebtAndCollateral` function.",
            "how_to_validate_state_update": "Verify collateralLoss is updated when distributing debt and collateral.",
            "has_conditional_updates": false,
            "summary_of_update": "Collateral loss is updated when distributing debt and collateral.",
            "conditions": []
          },
          {
            "state_variable_name": "debtLoss",
            "type": "uint256",
            "what_does_it_track": "Debt loss.",
            "why_is_is_important": "Tracks the amount of debt lost during the distribution process.",
            "when_is_it_updated": "debtLoss is updated inside the `distributeDebtAndCollateral` function.",
            "how_to_validate_state_update": "Verify debtLoss is updated when distributing debt and collateral.",
            "has_conditional_updates": false,
            "summary_of_update": "Debt loss is updated when distributing debt and collateral.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Mapping of liquidation snapshots.",
            "why_is_is_important": "Stores the snapshots to calculate collateral and debt changes of each safe.",
            "when_is_it_updated": "It is updated with `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` inside `_updateSafe` function if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check if liquidationSnapshots is updated with `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `liquidationSnapshots` is updated inside `_updateSafe` function with `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "priceOracle",
            "type": "contract",
            "what_does_it_track": "Reads the collateral price from the PriceOracle contract",
            "why_is_is_important": "The price is used to calculate the collateral value",
            "when_is_it_updated": "The price is fetched inside the `_liquidate` function to check if collateral value is lower than borrowed amount * liquidation ratio",
            "how_to_validate_state_update": "Verify that the price is fetched correctly by comparing it with the expected value in MockPriceOracle",
            "has_conditional_updates": false,
            "summary_of_update": "The collateral price is read to determine if liquidation is possible",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "It identifies the first element in the list",
            "when_is_it_updated": "If the node being removed is the head (node.prev == 0), the head is updated to the next node (head = node.next).",
            "how_to_validate_state_update": "Check if the head node is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "The head is updated if the removed node is the current head.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "It identifies the last element in the list",
            "when_is_it_updated": "If the node being removed is the tail (node.next == 0), the tail is updated to the previous node (tail = node.prev).",
            "how_to_validate_state_update": "Check if the tail node is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail is updated if the removed node is the current tail.",
            "conditions": [
              "node.next == 0"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Mapping of nodes in the doubly linked list.",
            "why_is_is_important": "It holds the information of each node in the list",
            "when_is_it_updated": "The node with the given ID is deleted from the `nodes` mapping using `delete nodes[id]`.",
            "how_to_validate_state_update": "Check if a particular node in the list is updated or deleted.",
            "has_conditional_updates": false,
            "summary_of_update": "The node is deleted from the `nodes` mapping.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Total staked amount in the stability pool.",
            "why_is_is_important": "Used to calculate rewards and liquidation possibilities.",
            "when_is_it_updated": "It is decremented by amount when `performLiquidation` function is called: `totalStakedRaw -= amount;`",
            "how_to_validate_state_update": "Check if totalStakedRaw is decreased by amount after `performLiquidation` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "The total staked raw amount is decremented by the amount liquidated.",
            "conditions": []
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Stake scaling factor in stability pool.",
            "why_is_is_important": "Used to calculate reward distribution.",
            "when_is_it_updated": "It is updated in `performLiquidation` function by `stakeScalingFactor = cumulativeProductScalingFactor;`, after a liquidation happened and reached that code.",
            "how_to_validate_state_update": "Check the value of stakeScalingFactor after the `performLiquidation` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "The stake scaling factor is updated during liquidation.",
            "conditions": [
              "A liquidation happens"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Total collateral per token in stability pool.",
            "why_is_is_important": "Tracks collateral distribution across staked tokens.",
            "when_is_it_updated": "It is updated in `performLiquidation` by `totalCollateralPerToken += _totalCollateralPerToken;` or in `addCollateralReward` by `totalCollateralPerToken += _collateralPerToken;`.",
            "how_to_validate_state_update": "Check the value of totalCollateralPerToken after the `performLiquidation` or `addCollateralReward` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "The total collateral per token is updated after liquidation or when a collateral reward is added.",
            "conditions": []
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Collateral loss in stability pool.",
            "why_is_is_important": "Tracks any collateral loss.",
            "when_is_it_updated": "It is updated in `performLiquidation` or `addCollateralReward` functions.",
            "how_to_validate_state_update": "Check the value of collateralLoss after the `performLiquidation` or `addCollateralReward` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "The collateral loss is updated after liquidation.",
            "conditions": []
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Whether the reward sender is active.",
            "why_is_is_important": "Indicates whether the reward sender is currently active.",
            "when_is_it_updated": "If totalStakedRaw is 0, the rewardSenderActive is set to `false`. This happens inside `performLiquidation` function.",
            "how_to_validate_state_update": "Check if the rewardSenderActive is set to `false` when totalStakedRaw is zero.",
            "has_conditional_updates": true,
            "summary_of_update": "The reward sender activity is turned off when there is no more staked balance.",
            "conditions": [
              "totalStakedRaw == 0 && rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "mapping",
            "what_does_it_track": "Stake reset snapshots.",
            "why_is_is_important": "Used to reset stake data under certain conditions.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor, a StakeResetSnapshot is created and stored in `stakeResetSnapshots`. This occurs in `performLiquidation`.",
            "how_to_validate_state_update": "Check the value of stakeResetSnapshots after conditions are met inside performLiquidation",
            "has_conditional_updates": true,
            "summary_of_update": "The stake reset snapshot is created during liquidation if `cumulativeProductScalingFactor < minimumScalingFactor`.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Stake reset count.",
            "why_is_is_important": "Tracks the number of stake resets.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor, stakeResetCount is incremented in `performLiquidation`.",
            "how_to_validate_state_update": "Check the value of stakeResetCount when `cumulativeProductScalingFactor < minimumScalingFactor`.",
            "has_conditional_updates": true,
            "summary_of_update": "Stake reset count is incremented when cumulativeProductScalingFactor is less than the minimum.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Total burned tokens.",
            "why_is_is_important": "It tracks the total number of tokens that are burned.",
            "when_is_it_updated": "It is increased by amount when `burn` function is called: `totalBurned += amount;`",
            "how_to_validate_state_update": "Check the value of totalBurned after the `burn` function is called.",
            "has_conditional_updates": false,
            "summary_of_update": "The total burned tokens is incremented when tokens are burned.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "uint256",
            "what_does_it_track": "Balance of an account.",
            "why_is_is_important": "It tracks the token balance of a specific account.",
            "when_is_it_updated": "It is updated when `_update` function, which is invoked by `_burn` function, is called: `_balances[from] = fromBalance - value;`",
            "how_to_validate_state_update": "Check the balance of an account after tokens are burned using `_burn`.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of the account being burned from is reduced.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Total supply of the token.",
            "why_is_is_important": "Tracks the total supply of the token.",
            "when_is_it_updated": "It's reduced by `value` in `_update` function: `_totalSupply -= value;`",
            "how_to_validate_state_update": "Check the total supply of the token after tokens are burned.",
            "has_conditional_updates": false,
            "summary_of_update": "The total supply of tokens is reduced by burn amount.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Total collateral per token in DFIREStaking contract.",
            "why_is_is_important": "It is used to track collateral per token in DFIREStaking contract.",
            "when_is_it_updated": "It is updated by (_amount * PRECISION) / _totalStake when `addCollateralReward` function is called, given `_totalStake` is not zero.",
            "how_to_validate_state_update": "Check the value of totalCollateralPerToken after the `addCollateralReward` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Total collateral per token is updated with the collateral reward amount.",
            "conditions": [
              "_totalStake != 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}