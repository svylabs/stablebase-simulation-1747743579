{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "The 'safeId' (uint256) must correspond to an existing CDP (Safe) in the StableBaseCDP contract.",
      "The Safe identified by 'safeId' must have a 'collateralAmount' greater than zero.",
      "The Safe identified by 'safeId' must have a 'borrowedAmount' greater than zero.",
      "The Safe identified by 'safeId' must be undercollateralized, meaning its 'collateralValue' (collateralAmount * current collateral price) must be less than its 'borrowedAmount' multiplied by the 'liquidationRatio'. This is typically checked by comparing `collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)`.",
      "If the liquidation cannot be fully absorbed by the Stability Pool (i.e., 'stabilityPool.isLiquidationPossible(borrowedAmount)' is false), the 'safeId' cannot be the last Safe in the 'safesOrderedForLiquidation' queue (i.e., 'safeId' must not be equal to 'safesOrderedForLiquidation.getHead()')."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "CDP Core State Updates",
        "state_update_descriptions": [
          "The 'collateralAmount' of the liquidated safe (safes[safeId]) is updated to reflect any accrued collateral.",
          "The 'borrowedAmount' of the liquidated safe (safes[safeId]) is updated to reflect any accrued debt.",
          "The 'collateralPerCollateralSnapshot' in 'liquidationSnapshots[safeId]' is updated to the current 'cumulativeCollateralPerUnitCollateral'.",
          "The 'debtPerCollateralSnapshot' in 'liquidationSnapshots[safeId]' is updated to the current 'cumulativeDebtPerUnitCollateral'.",
          "The 'totalCollateral' is decreased by the 'collateralAmount' of the liquidated safe and potentially by any 'collateralIncrease' calculated during 'Safe' update.",
          "The 'totalDebt' is decreased by the 'borrowedAmount' of the liquidated safe and potentially increased by any 'debtIncrease' calculated during 'Safe' update.",
          "The 'PROTOCOL_MODE' may switch from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD'.",
          "The 'safes[safeId]' entry in the mapping is deleted, effectively removing the CDP.",
          "The ownership of the Safe NFT (represented by 'safeId') is transferred from its owner to the zero address (burned).",
          "The `_balances` mapping for the previous owner of the NFT is decreased by 1.",
          "The `_owners` mapping for the NFT (`safeId`) is set to the zero address."
        ]
      },
      {
        "category": "Liquidation/Redemption Queue Updates",
        "state_update_descriptions": [
          "The 'safeId' is removed from the 'safesOrderedForLiquidation' doubly linked list.",
          "The 'head' or 'tail' of 'safesOrderedForLiquidation' may be updated if the removed node was at an end.",
          "The 'nodes' mapping within 'safesOrderedForLiquidation' is updated to reflect the removal of the node corresponding to 'safeId'.",
          "The 'safeId' is removed from the 'safesOrderedForRedemption' doubly linked list.",
          "The 'head' or 'tail' of 'safesOrderedForRedemption' may be updated if the removed node was at an end.",
          "The 'nodes' mapping within 'safesOrderedForRedemption' is updated to reflect the removal of the node corresponding to 'safeId'."
        ]
      },
      {
        "category": "Stability Pool (if used for liquidation)",
        "state_update_descriptions": [
          "The 'totalStakedRaw' in the Stability Pool decreases by the 'borrowedAmount' of the liquidated safe.",
          "The 'stakeScalingFactor' in the Stability Pool is updated based on the reduction in 'totalStakedRaw'.",
          "The 'totalCollateralPerToken' in the Stability Pool increases due to the received collateral.",
          "The 'collateralLoss' in the Stability Pool is updated.",
          "If 'totalStakedRaw' becomes zero and 'rewardSenderActive' is true, 'stabilityPoolCanReceiveRewards' in 'StableBaseCDP' is set to 'false'.",
          "If the 'cumulativeProductScalingFactor' falls below 'minimumScalingFactor', the Stability Pool's scaling factors are reset, and a new 'StakeResetSnapshot' is recorded, incrementing 'stakeResetCount'."
        ]
      },
      {
        "category": "DFID Token (SBD Token) State Updates (if Stability Pool used)",
        "state_update_descriptions": [
          "The balance of the Stability Pool (`_balances[address(stabilityPool)]`) for the SBD token decreases by the 'borrowedAmount' of the liquidated safe.",
          "The total supply (`totalSupply`) of the SBD token decreases by the 'borrowedAmount'.",
          "The 'totalBurned' count for the SBD token increases by the 'borrowedAmount'."
        ]
      },
      {
        "category": "Secondary Liquidation Mechanism State Updates (if Stability Pool not used)",
        "state_update_descriptions": [
          "The 'cumulativeCollateralPerUnitCollateral' is increased to distribute the liquidated collateral.",
          "The 'cumulativeDebtPerUnitCollateral' is increased to distribute the liquidated debt.",
          "The 'collateralLoss' is updated to track any remainder collateral.",
          "The 'debtLoss' is updated to track any remainder debt."
        ]
      },
      {
        "category": "Fee Distribution and Gas Compensation",
        "state_update_descriptions": [
          "If 'sbrStakingPoolCanReceiveRewards' is true and a portion of the liquidation fee remains after gas compensation, 'totalCollateralPerToken' in 'dfireTokenStaking' is increased.",
          "Alternatively, if 'dfireTokenStaking' fails and 'stabilityPoolCanReceiveRewards' is true, 'totalCollateralPerToken' and 'collateralLoss' in 'stabilityPool' are updated with the remaining fee.",
          "Ether is transferred to the 'msg.sender' (liquidator) as gas compensation and any remaining refund from the liquidation fee."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "StableBaseCDP Contract State Validation",
        "rule_descriptions": [
          "Verify that 'safes[safeId]' now returns a zero-value Safe struct (or equivalent indicating deletion).",
          "Confirm that 'ownerOf(safeId)' for the NFT now returns the zero address, indicating the NFT has been burned.",
          "Check that 'totalCollateral' has decreased by the initial 'collateralAmount' of the liquidated safe (after accounting for 'Safe' update changes).",
          "Check that 'totalDebt' has decreased by the initial 'borrowedAmount' of the liquidated safe (after accounting for 'Safe' update changes).",
          "If 'totalDebt' crossed the 'BOOTSTRAP_MODE_DEBT_THRESHOLD' during execution, verify that 'PROTOCOL_MODE' is now 'NORMAL'.",
          "If the liquidation occurred via the secondary mechanism, verify that 'cumulativeCollateralPerUnitCollateral' and 'cumulativeDebtPerUnitCollateral' have increased.",
          "Verify that the liquidator's balance has increased by the 'refund' amount as gas compensation."
        ]
      },
      {
        "category": "OrderedDoublyLinkedList Contract State Validation",
        "rule_descriptions": [
          "Verify that the 'safeId' node no longer exists in 'safesOrderedForLiquidation' (e.g., 'safesOrderedForLiquidation.get(safeId)' returns a zero-value node).",
          "Verify that the 'safeId' node no longer exists in 'safesOrderedForRedemption' (e.g., 'safesOrderedForRedemption.get(safeId)' returns a zero-value node).",
          "Check the 'head' and 'tail' pointers and the 'next'/'prev' pointers of adjacent nodes in both lists to ensure the node removal was correctly handled."
        ]
      },
      {
        "category": "StabilityPool Contract State Validation",
        "rule_descriptions": [
          "If the liquidation was handled by the Stability Pool, verify that 'stabilityPool.totalStakedRaw' has decreased by the 'borrowedAmount'.",
          "If the liquidation was handled by the Stability Pool, verify that 'stabilityPool.stakeScalingFactor' has been updated as expected.",
          "If the liquidation was handled by the Stability Pool, verify that 'stabilityPool.totalCollateralPerToken' has increased.",
          "If 'totalStakedRaw' in Stability Pool became zero, verify that 'StableBaseCDP.stabilityPoolCanReceiveRewards' is 'false'."
        ]
      },
      {
        "category": "DFIDToken (SBD Token) Contract State Validation",
        "rule_descriptions": [
          "If the liquidation was handled by the Stability Pool, verify that 'sbdToken.balanceOf(address(stabilityPool))' has decreased by the 'borrowedAmount'.",
          "If the liquidation was handled by the Stability Pool, verify that 'sbdToken.totalSupply' has decreased by the 'borrowedAmount'.",
          "If the liquidation was handled by the Stability Pool, verify that 'sbdToken.totalBurned' has increased by the 'borrowedAmount'."
        ]
      },
      {
        "category": "DFIREStaking Contract State Validation",
        "rule_descriptions": [
          "If 'dfireTokenStaking' received a liquidation fee, verify that 'dfireTokenStaking.totalCollateralPerToken' has increased."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "Verify the emission of a 'SafeUpdated' event from 'StableBaseCDP'.",
          "Verify the emission of either 'LiquidatedUsingStabilityPool' or 'LiquidatedUsingSecondaryMechanism' event from 'StableBaseCDP', depending on the execution path.",
          "Verify the emission of 'SafeRemovedFromLiquidationQueue' and 'SafeRemovedFromRedemptionQueue' events from 'StableBaseCDP'.",
          "Verify the emission of a 'RemovedSafe' event from 'StableBaseCDP'.",
          "Verify the emission of a 'Transfer' (ERC721 burn) event from 'StableBaseCDP' with the 'to' address as zero.",
          "Verify the emission of a 'LiquidationGasCompensationPaid' event from 'StableBaseCDP'.",
          "Verify the conditional emission of a 'LiquidationFeePaid' event from 'StableBaseCDP'.",
          "If Stability Pool liquidation occurred, verify the emission of a 'LiquidationPerformed' event from 'StabilityPool' and potentially 'ScalingFactorReset'.",
          "If SBD tokens were burned, verify the emission of a 'Burn' event from 'sbdToken'.",
          "If DFIRE staking pool received a fee, verify the emission of a 'CollateralRewardAdded' event from 'dfireTokenStaking'.",
          "If Stability Pool received a fee (as a fallback), verify the emission of a 'CollateralRewardAdded' event from 'StabilityPool'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral held in the protocol.",
            "why_is_is_important": "Crucial for tracking the overall collateralization of the system and maintaining protocol solvency.",
            "when_is_it_updated": "At the beginning of the `_liquidate` function.",
            "how_to_validate_state_update": "The `totalCollateral` variable should be decremented by the `collateralAmount` of the liquidated safe.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreased by the collateral amount of the liquidated safe.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral held in the protocol.",
            "why_is_is_important": "Crucial for tracking the overall collateralization of the system and maintaining protocol solvency.",
            "when_is_it_updated": "During the `_updateSafe` call, if the safe's collateral snapshot is outdated.",
            "how_to_validate_state_update": "If the condition is met, `totalCollateral` should be incremented by the `collateralIncrease` calculated within `_updateSafe`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased if the safe's collateral snapshot in `liquidationSnapshots` is outdated, reflecting accrued collateral.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the protocol.",
            "why_is_is_important": "Essential for assessing the total liabilities of the protocol and for determining the protocol's operating mode.",
            "when_is_it_updated": "At the beginning of the `_liquidate` function.",
            "how_to_validate_state_update": "The `totalDebt` variable should be decremented by the `borrowedAmount` of the liquidated safe.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreased by the borrowed amount of the liquidated safe.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the protocol.",
            "why_is_is_important": "Essential for assessing the total liabilities of the protocol and for determining the protocol's operating mode.",
            "when_is_it_updated": "During the `_updateSafe` call, if the safe's debt snapshot is outdated.",
            "how_to_validate_state_update": "If the condition is met, `totalDebt` should be incremented by the `debtIncrease` calculated within `_updateSafe`. Additionally, its update might trigger a `PROTOCOL_MODE` change.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased if the safe's debt snapshot in `liquidationSnapshots` is outdated, reflecting accrued debt.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current operating mode of the protocol (e.g., BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Determines certain operational parameters and behaviors of the protocol.",
            "when_is_it_updated": "When `_updateTotalDebt` is called, if the updated `totalDebt` crosses the `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is currently in `BOOTSTRAP` mode.",
            "how_to_validate_state_update": "If `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD` while in `BOOTSTRAP` mode, `PROTOCOL_MODE` should switch to `NORMAL`.",
            "has_conditional_updates": true,
            "summary_of_update": "Can transition from BOOTSTRAP to NORMAL mode.",
            "conditions": [
              "The `totalDebt` is greater than `BOOTSTRAP_MODE_DEBT_THRESHOLD`",
              "The current `PROTOCOL_MODE` is `BOOTSTRAP`"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "Maps `safeId` to its associated Safe struct, containing collateral, borrowed amount, weight, etc.",
            "why_is_is_important": "Stores the core data for each collateralized debt position (Safe).",
            "when_is_it_updated": "Unconditionally at the end of the `_liquidate` function.",
            "how_to_validate_state_update": "The `safe` struct mapping at `safeId` should be entirely removed.",
            "has_conditional_updates": false,
            "summary_of_update": "The entire Safe struct corresponding to `safeId` is removed from storage.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping(uint256 => LiquidationSnapshot)",
            "what_does_it_track": "Snapshots of cumulative debt and collateral per unit of collateral for each safe, used to calculate debt and collateral increases due to system-wide changes.",
            "why_is_is_important": "Ensures accurate accounting of a safe's debt and collateral amounts by incorporating system-wide accruals.",
            "when_is_it_updated": "During the `_updateSafe` call, if the safe's collateral snapshot is outdated.",
            "how_to_validate_state_update": "If the condition is met, `liquidationSnapshots[safeId].debtPerCollateralSnapshot` is updated to the current `cumulativeDebtPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `debtPerCollateralSnapshot` for the liquidated safe is updated.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping(uint256 => LiquidationSnapshot)",
            "what_does_it_track": "Snapshots of cumulative debt and collateral per unit of collateral for each safe, used to calculate debt and collateral increases due to system-wide changes.",
            "why_is_is_important": "Ensures accurate accounting of a safe's debt and collateral amounts by incorporating system-wide accruals.",
            "when_is_it_updated": "During the `_updateSafe` call, if the safe's collateral snapshot is outdated.",
            "how_to_validate_state_update": "If the condition is met, `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` is updated to the current `cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `collateralPerCollateralSnapshot` for the liquidated safe is updated.",
            "conditions": [
              "`liquidationSnapshot.collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Small remainder of collateral that cannot be perfectly distributed to existing borrowers during a secondary mechanism liquidation.",
            "why_is_is_important": "Ensures that all collateral is accounted for, even if small fractions remain after distribution.",
            "when_is_it_updated": "When `distributeDebtAndCollateral` is called (i.e., if liquidation is handled by the secondary mechanism).",
            "how_to_validate_state_update": "If the secondary mechanism is used, `collateralLoss` is updated based on the distributed collateral and `totalCollateralAfterLiquidation`.",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates any leftover collateral from distribution that couldn't be perfectly distributed.",
            "conditions": [
              "The liquidation is performed using the secondary mechanism (`possible` is false, i.e., `stabilityPool.isLiquidationPossible` returns false)"
            ]
          },
          {
            "state_variable_name": "debtLoss",
            "type": "uint256",
            "what_does_it_track": "Small remainder of debt that cannot be perfectly distributed to existing borrowers during a secondary mechanism liquidation.",
            "why_is_is_important": "Ensures that all debt is accounted for, even if small fractions remain after distribution.",
            "when_is_it_updated": "When `distributeDebtAndCollateral` is called (i.e., if liquidation is handled by the secondary mechanism).",
            "how_to_validate_state_update": "If the secondary mechanism is used, `debtLoss` is updated based on the distributed debt and `totalCollateralAfterLiquidation`.",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates any leftover debt from distribution that couldn't be perfectly distributed.",
            "conditions": [
              "The liquidation is performed using the secondary mechanism (`possible` is false, i.e., `stabilityPool.isLiquidationPossible` returns false)"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "A cumulative sum of collateral added to existing safes per unit of their collateral.",
            "why_is_is_important": "Used to calculate how much collateral (from liquidation) should be added to each existing safe proportionally.",
            "when_is_it_updated": "When `distributeDebtAndCollateral` is called (i.e., if liquidation is handled by the secondary mechanism).",
            "how_to_validate_state_update": "If the secondary mechanism is used, `cumulativeCollateralPerUnitCollateral` is increased based on the distributed collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases to reflect the proportional share of collateral distributed per unit of existing collateral.",
            "conditions": [
              "The liquidation is performed using the secondary mechanism (`possible` is false, i.e., `stabilityPool.isLiquidationPossible` returns false)"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "A cumulative sum of debt added to existing safes per unit of their collateral.",
            "why_is_is_important": "Used to calculate how much debt (from liquidation) should be added to each existing safe proportionally.",
            "when_is_it_updated": "When `distributeDebtAndCollateral` is called (i.e., if liquidation is handled by the secondary mechanism).",
            "how_to_validate_state_update": "If the secondary mechanism is used, `cumulativeDebtPerUnitCollateral` is increased based on the distributed debt.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases to reflect the proportional share of debt distributed per unit of existing collateral.",
            "conditions": [
              "The liquidation is performed using the secondary mechanism (`possible` is false, i.e., `stabilityPool.isLiquidationPossible` returns false)"
            ]
          },
          {
            "state_variable_name": "stabilityPoolCanReceiveRewards",
            "type": "boolean",
            "what_does_it_track": "Indicates whether the Stability Pool is eligible to receive rewards.",
            "why_is_is_important": "Controls the flow of rewards to the Stability Pool.",
            "when_is_it_updated": "When the `StabilityPool` contract calls `setCanStabilityPoolReceiveRewards(false)` on `StableBaseCDP` during its `performLiquidation` function.",
            "how_to_validate_state_update": "If the conditions are met, `stabilityPoolCanReceiveRewards` should be set to `false`.",
            "has_conditional_updates": true,
            "summary_of_update": "Can be set to `false` if the Stability Pool's total staked amount becomes zero after a liquidation performed through it, and the reward sender is active.",
            "conditions": [
              "The `totalStakedRaw` in `StabilityPool` is 0",
              "The `rewardSenderActive` in `StabilityPool` is `true`",
              "The liquidation is performed using the stability pool (`possible` is `true`)"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "ERC721 internal mapping tracking the number of NFTs held by each address.",
            "why_is_is_important": "Maintains the ERC721 ownership records.",
            "when_is_it_updated": "During the `_burn` process of the Safe NFT.",
            "how_to_validate_state_update": "The balance of the previous owner of the liquidated safe (NFT) should decrease by 1.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of the previous owner of the liquidated Safe (NFT) is decreased by 1.",
            "conditions": []
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping(uint256 => address)",
            "what_does_it_track": "ERC721 internal mapping tracking the owner of each `tokenId`.",
            "why_is_is_important": "Maintains the ERC721 ownership records.",
            "when_is_it_updated": "During the `_burn` process of the Safe NFT.",
            "how_to_validate_state_update": "The ownership of the `safeId` NFT should be transferred to the zero address, effectively burning it.",
            "has_conditional_updates": false,
            "summary_of_update": "The owner of the liquidated Safe (NFT) is set to the zero address.",
            "conditions": []
          },
          {
            "state_variable_name": "_tokenApprovals",
            "type": "mapping(uint256 => address)",
            "what_does_it_track": "ERC721 internal mapping tracking the approved address for each `tokenId`.",
            "why_is_is_important": "Ensures that no address has approval over a burned NFT.",
            "when_is_it_updated": "During the `_burn` process of the Safe NFT.",
            "how_to_validate_state_update": "The approval for the `safeId` NFT should be cleared (set to zero address).",
            "has_conditional_updates": false,
            "summary_of_update": "Any existing approval for the liquidated Safe (NFT) is cleared.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the ordered linked list.",
            "why_is_is_important": "Maintains the integrity and order of the liquidation and redemption queues.",
            "when_is_it_updated": "When `remove(safeId)` is called on `safesOrderedForLiquidation` or `safesOrderedForRedemption`, if the removed `safeId` was the current head.",
            "how_to_validate_state_update": "If the removed node is the head, `head` should be updated to the `next` node of the removed node.",
            "has_conditional_updates": true,
            "summary_of_update": "The head of the linked list is updated if the liquidated safe was the head.",
            "conditions": [
              "The removed node (`safeId`) is the head of the list.",
              "The removal of the safe from the queue is attempted (unconditionally called in `_liquidate`)"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the ordered linked list.",
            "why_is_is_important": "Maintains the integrity and order of the liquidation and redemption queues.",
            "when_is_it_updated": "When `remove(safeId)` is called on `safesOrderedForLiquidation` or `safesOrderedForRedemption`, if the removed `safeId` was the current tail.",
            "how_to_validate_state_update": "If the removed node is the tail, `tail` should be updated to the `prev` node of the removed node.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail of the linked list is updated if the liquidated safe was the tail.",
            "conditions": [
              "The removed node (`safeId`) is the tail of the list.",
              "The removal of the safe from the queue is attempted (unconditionally called in `_liquidate`)"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Maps `safeId` to its Node struct, containing its value, previous, and next node IDs.",
            "why_is_is_important": "Represents the structure of the doubly linked list, which orders safes for liquidation and redemption.",
            "when_is_it_updated": "When `remove(safeId)` is called on `safesOrderedForLiquidation` and `safesOrderedForRedemption`.",
            "how_to_validate_state_update": "The `nodes[safeId]` entry should be deleted, and the `next` and `prev` pointers of its adjacent nodes should be updated to bypass the removed node.",
            "has_conditional_updates": false,
            "summary_of_update": "The node corresponding to the liquidated safe is removed, and adjacent nodes' pointers are updated.",
            "conditions": [
              "The removal of the safe from the queue is attempted (unconditionally called in `_liquidate`)"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Internal OpenZeppelin ERC20 mapping tracking token balances.",
            "why_is_is_important": "Reduces the supply of DFID tokens held by the Stability Pool, reflecting the burned debt.",
            "when_is_it_updated": "When `sbdToken.burn` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If the condition is met, the balance of `address(stabilityPool)` should be decremented by the `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The DFID balance of the Stability Pool is decreased by the `borrowedAmount` of the liquidated safe.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of DFID tokens in existence.",
            "why_is_is_important": "Reflects the total supply of the stablecoin, essential for maintaining its peg and market stability.",
            "when_is_it_updated": "When `sbdToken.burn` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If the condition is met, `totalSupply` should be decremented by the `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of DFID tokens is decreased.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The cumulative amount of DFID tokens that have been burned.",
            "why_is_is_important": "Provides an audit trail for token destruction and can influence tokenomics.",
            "when_is_it_updated": "When `sbdToken.burn` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If the condition is met, `totalBurned` should be incremented by the `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total amount of DFID tokens ever burned is increased.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "A factor used to calculate the effective stake of users, decreasing proportionally when debt is liquidated from the pool.",
            "why_is_is_important": "Adjusts stakers' effective returns based on protocol activity, especially liquidations.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If `performLiquidation` is called, `stakeScalingFactor` is updated by multiplying it with a factor derived from the `borrowedAmount` and `totalStakedRaw`. If the new factor falls below `minimumScalingFactor`, it's reset to `precision`.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduced proportionally to the liquidated debt amount, or reset to a base value if a minimum threshold is breached.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative collateral earned per unit of stake in the Stability Pool.",
            "why_is_is_important": "Determines the collateral rewards that stakers in the Stability Pool can claim.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If `performLiquidation` is called, `totalCollateralPerToken` is increased based on the `_collateral`, `previousScalingFactor`, and `totalStakedRaw`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by the collateral received during liquidation.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative collateral earned per unit of stake in the Stability Pool.",
            "why_is_is_important": "Determines the collateral rewards that stakers in the Stability Pool can claim.",
            "when_is_it_updated": "When `addCollateralReward` is successfully called by `StableBaseCDP` (as part of fee distribution).",
            "how_to_validate_state_update": "If `addCollateralReward` is called and `_totalStakedRaw > 0`, `totalCollateralPerToken` is increased based on `amount`, `stakeScalingFactor`, and `_totalStakedRaw`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by collateral rewards distributed from `StableBaseCDP`.",
            "conditions": [
              "`sbrStakingPoolCanReceiveRewards` is `false`",
              "`stabilityPoolCanReceiveRewards` is `true`",
              "The `totalStakedRaw` in `StabilityPool` is greater than 0"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative collateral earned per unit of stake in the Stability Pool.",
            "why_is_is_important": "Determines the collateral rewards that stakers in the Stability Pool can claim; resets ensure correct accounting after a scaling factor reset.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP` and `cumulativeProductScalingFactor` falls below `minimumScalingFactor`.",
            "how_to_validate_state_update": "If the conditions are met, `totalCollateralPerToken` is reset to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset to zero if the `stakeScalingFactor` falls too low during liquidation.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)",
              "`cumulativeProductScalingFactor` is less than `minimumScalingFactor`"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Leftover collateral that could not be perfectly distributed among Stability Pool stakers during a liquidation or reward addition.",
            "why_is_is_important": "Ensures all collateral is accounted for within the pool.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If `performLiquidation` is called, `collateralLoss` is updated based on the `collateral` received and calculations involving `_totalCollateralPerToken` and `totalStakedRaw`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated based on any collateral remaining after distribution during liquidation.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Leftover collateral that could not be perfectly distributed among Stability Pool stakers during a liquidation or reward addition.",
            "why_is_is_important": "Ensures all collateral is accounted for within the pool.",
            "when_is_it_updated": "When `addCollateralReward` is successfully called by `StableBaseCDP` (as part of fee distribution).",
            "how_to_validate_state_update": "If `addCollateralReward` is called and `_totalStakedRaw > 0`, `collateralLoss` is updated based on the `amount` and calculations involving `_collateralPerToken` and `_totalStakedRaw`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated based on any collateral remaining after distributing collateral rewards from `StableBaseCDP`.",
            "conditions": [
              "`sbrStakingPoolCanReceiveRewards` is `false`",
              "`stabilityPoolCanReceiveRewards` is `true`",
              "The `totalStakedRaw` in `StabilityPool` is greater than 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total amount of DFID tokens currently staked in the Stability Pool.",
            "why_is_is_important": "Represents the total capacity of the Stability Pool to absorb liquidated debt.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP`.",
            "how_to_validate_state_update": "If `performLiquidation` is called, `totalStakedRaw` is decremented by the `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreased by the `borrowedAmount` of the liquidated safe.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "mapping(uint256 => StakeResetSnapshot)",
            "what_does_it_track": "Records historical states of the Stability Pool, specifically when a scaling factor reset occurs.",
            "why_is_is_important": "Preserves historical data for reward calculations across scaling factor resets.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP` and `cumulativeProductScalingFactor` falls below `minimumScalingFactor`.",
            "how_to_validate_state_update": "If the conditions are met, a new snapshot of the pool's state is stored in `stakeResetSnapshots` at the index `stakeResetCount`.",
            "has_conditional_updates": true,
            "summary_of_update": "A new snapshot of the Stability Pool's state (scaling factors and cumulative rewards per token) is recorded.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)",
              "`cumulativeProductScalingFactor` is less than `minimumScalingFactor`"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative rewards (DFIRE tokens) earned per unit of stake in the Stability Pool.",
            "why_is_is_important": "Part of the reward calculation mechanism for Stability Pool stakers; resets ensure correct accounting after a scaling factor reset.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP` and `cumulativeProductScalingFactor` falls below `minimumScalingFactor`.",
            "how_to_validate_state_update": "If the conditions are met, `totalRewardPerToken` is reset to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset to zero.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)",
              "`cumulativeProductScalingFactor` is less than `minimumScalingFactor`"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Cumulative SBR rewards earned per unit of stake in the Stability Pool.",
            "why_is_is_important": "Part of the reward calculation mechanism for Stability Pool stakers; resets ensure correct accounting after a scaling factor reset.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP` and `cumulativeProductScalingFactor` falls below `minimumScalingFactor`.",
            "how_to_validate_state_update": "If the conditions are met, `totalSbrRewardPerToken` is reset to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset to zero.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)",
              "`cumulativeProductScalingFactor` is less than `minimumScalingFactor`"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "The number of times the Stability Pool's scaling factor has been reset.",
            "why_is_is_important": "Acts as an index for `stakeResetSnapshots`, crucial for managing the reward distribution logic.",
            "when_is_it_updated": "When `performLiquidation` is called by `StableBaseCDP` and `cumulativeProductScalingFactor` falls below `minimumScalingFactor`.",
            "how_to_validate_state_update": "If the conditions are met, `stakeResetCount` is incremented by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by one.",
            "conditions": [
              "`stabilityPool.isLiquidationPossible(borrowedAmount)` returns `true` (i.e., liquidation is performed via Stability Pool)",
              "`cumulativeProductScalingFactor` is less than `minimumScalingFactor`"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative collateral reward per unit of staked DFIRE tokens.",
            "why_is_is_important": "Determines the share of collateral rewards that DFIRE stakers can claim.",
            "when_is_it_updated": "When `addCollateralReward` is called by `StableBaseCDP` (as part of fee distribution).",
            "how_to_validate_state_update": "If the conditions are met, `totalCollateralPerToken` is increased based on the `_amount` and `_totalStake`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased to reflect the collateral reward distributed to stakers.",
            "conditions": [
              "`sbrStakingPoolCanReceiveRewards` is true",
              "`totalStake` in `DFIREStaking` is greater than 0",
              "A liquidation fee is allocated to the DFIRE staking pool (`liquidationFee > refund`)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "dfidToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "dfireToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "dfireStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "mockPriceOracle",
              "contract_name": "MockPriceOracle"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}