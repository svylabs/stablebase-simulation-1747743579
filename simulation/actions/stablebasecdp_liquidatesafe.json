{
  "action": {
    "name": "Liquidate Safe",
    "summary": "Liquidates a specific CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "pre_execution_parameter_generation_rules": [
      "Select a `safeId` corresponding to an existing Safe where collateralValue < (borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR, indicating it is undercollateralized.",
      "Ensure that `collateralAmount` and `borrowedAmount` are greater than 0 for the selected `safeId`.",
      "If the stabilityPool has enough staked tokens, ensure that `stabilityPool.isLiquidationPossible(borrowedAmount)` returns true. Otherwise, ensure that `safeId` is not the last safe in the liquidation queue and the `safesOrderedForLiquidation` list is not empty."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Secondary Liquidation Mechanism",
        "state_update_descriptions": [
          "The collateral and debt of the liquidated safe are distributed to the existing borrowers.",
          "cumulativeCollateralPerUnitCollateral is increased by (collateralToDistribute * PRECISION) / totalCollateralAfterLiquidation.",
          "cumulativeDebtPerUnitCollateral is increased by (debtToDistribute * PRECISION) / totalCollateralAfterLiquidation.",
          "collateralLoss is updated to collateralToDistribute - (collPerUnitColl * totalCollateralAfterLiquidation) / PRECISION.",
          "debtLoss is updated to debtToDistribute - (debtPerUnitColl * totalCollateralAfterLiquidation) / PRECISION.",
          "The liquidated safe is removed from both liquidation and redemption queues managed by OrderedDoublyLinkedList.",
          "The safe is removed from the safes mapping, meaning the safe entry is deleted or marked as non-existent."
        ]
      },
      {
        "category": "Liquidation using Stability Pool",
        "state_update_descriptions": [
          "Collateral and debt amounts are transferred to the stability pool.",
          "SBD tokens are burned from the stability pool.",
          "The liquidated safe is removed from both liquidation and redemption queues managed by OrderedDoublyLinkedList.",
          "The safe is removed from the safes mapping, meaning the safe entry is deleted or marked as non-existent."
        ]
      },
      {
        "category": "Safe Update",
        "state_update_descriptions": [
          "The `borrowedAmount` of the Safe with ID `_safeId` is potentially updated based on cumulative debt calculations.",
          "The `collateralAmount` of the Safe with ID `_safeId` is potentially updated based on cumulative collateral calculations.",
          "totalCollateral is potentially updated based on `collateralIncrease`",
          "totalDebt is potentially updated based on `debtIncrease`"
        ]
      },
      {
        "category": "Total Debt Update",
        "state_update_descriptions": [
          "If `debt` is greater than `BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE` is `BOOTSTRAP`, `PROTOCOL_MODE` is set to `NORMAL`.",
          "`totalDebt` is updated by adding or subtracting `delta` based on the `add` boolean."
        ]
      },
      {
        "category": "Fee and Gas Compensation Distribution",
        "state_update_descriptions": [
          "Liquidation fee is distributed to either `dfireTokenStaking` or `stabilityPool` based on whether they can receive rewards.",
          "Gas compensation is paid to `msg.sender`."
        ]
      },
      {
        "category": "NFT Burn",
        "state_update_descriptions": [
          "The NFT representing the safe is burned, removing ownership."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "General Checks",
        "rule_descriptions": [
          "The Safe with ID `safeId` should no longer exist in the `safes` mapping.",
          "The Safe with ID `safeId` should be removed from the `safesOrderedForLiquidation` queue.",
          "The Safe with ID `safeId` should be removed from the `safesOrderedForRedemption` queue.",
          "totalCollateral should be decreased by collateralAmount of the liquidated safe.",
          "totalDebt should be decreased by borrowedAmount of the liquidated safe.",
          "safesOrderedForLiquidation.getHead() should return a different safeId, or 0 if the list is now empty.",
          "safesOrderedForRedemption.getHead() should return a different safeId, or 0 if the list is now empty."
        ]
      },
      {
        "category": "Stability Pool Liquidation",
        "rule_descriptions": [
          "If liquidation happened through the Stability Pool, the Stability Pool's `totalStakedRaw` should decrease by `borrowedAmount` of the liquidated safe.",
          "If liquidation happened through the Stability Pool, the SBD token balance of the Stability Pool should decrease by `borrowedAmount`.",
          "The collateralLoss of the StabilityPool should be updated.",
          "If a ScalingFactorReset event is emitted, verify stakeScalingFactor and cumulativeProductScalingFactor were reset accordingly"
        ]
      },
      {
        "category": "Secondary Mechanism Liquidation",
        "rule_descriptions": [
          "If liquidation happened through the secondary mechanism, `cumulativeCollateralPerUnitCollateral` should increase.",
          "If liquidation happened through the secondary mechanism, `cumulativeDebtPerUnitCollateral` should increase.",
          "If liquidation happened through the secondary mechanism, `collateralLoss` and `debtLoss` should be updated."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "The contract should attempt to distribute liquidation fee to `dfireTokenStaking` and `stabilityPool`, if possible.",
          "If the fee distribution to `dfireTokenStaking` and `stabilityPool` fails, the refund amount should equal the liquidation fee.",
          "Verify the message sender received the appropriate gas compensation if applicable."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidateSafe",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Collateral amount of a specific safe.",
            "why_is_is_important": "Ensures the safe's collateral amount is up-to-date before liquidation.",
            "when_is_it_updated": "Before liquidation, if the collateral or debt has changed due to cumulative interest or collateral changes.",
            "how_to_validate_state_update": "Check if the collateralAmount of the safe with ID safeId is updated to reflect the collateral after update.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateral amount of the safe, increasing it.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Borrowed amount of a specific safe.",
            "why_is_is_important": "Ensures the safe's borrowed amount is up-to-date before liquidation.",
            "when_is_it_updated": "Before liquidation, if the collateral or debt has changed due to cumulative interest or collateral changes.",
            "how_to_validate_state_update": "Check if the borrowedAmount of the safe with ID safeId is updated to reflect the debt after update.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the borrowed amount of the safe, increasing it.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Debt per collateral snapshot for a specific safe.",
            "why_is_is_important": "Used to accurately calculate debt increases due to cumulative interest.",
            "when_is_it_updated": "Before liquidation, if the collateral or debt has changed due to cumulative interest or collateral changes.",
            "how_to_validate_state_update": "Check if the debtPerCollateralSnapshot of the liquidationSnapshot with ID safeId is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates debt snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Collateral per collateral snapshot for a specific safe.",
            "why_is_is_important": "Used to accurately calculate deposited collateral increases due to cumulative interest.",
            "when_is_it_updated": "Before liquidation, if the collateral or debt has changed due to cumulative interest or collateral changes.",
            "how_to_validate_state_update": "Check if the collateralPerCollateralSnapshot of the liquidationSnapshot with ID safeId is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Total borrowed amount for a specific safe.",
            "why_is_is_important": "Tracks the total amount ever borrowed by a safe.",
            "when_is_it_updated": "Before liquidation, if the collateral or debt has changed due to cumulative interest or collateral changes.",
            "how_to_validate_state_update": "Check if the totalBorrowedAmount of the safe with ID safeId is updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total borrowed amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total collateral in the system.",
            "why_is_is_important": "Reflects total collateral in the system.",
            "when_is_it_updated": "Always, the total collateral is reduced by the amount from the liquidated safe.",
            "how_to_validate_state_update": "Check if the totalCollateral is decreased by the collateralAmount",
            "has_conditional_updates": false,
            "summary_of_update": "Decrease the total collateral",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Total debt in the system.",
            "why_is_is_important": "Reflects total debt in the system.",
            "when_is_it_updated": "Always, the total debt is reduced by the amount from the liquidated safe.",
            "how_to_validate_state_update": "Check if the totalDebt is decreased by the borrowedAmount of liquidated safe.",
            "has_conditional_updates": false,
            "summary_of_update": "Decrease the total debt",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Protocol operating mode (Bootstrap or Normal).",
            "why_is_is_important": "Transitions the protocol from bootstrap to normal mode.",
            "when_is_it_updated": "If totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD while in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE is set to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Update Protocol Mode from Bootstrap to Normal",
            "conditions": [
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Cumulative collateral per unit collateral.",
            "why_is_is_important": "Distributes debt and collateral to existing borrowers when direct liquidation is not possible.",
            "when_is_it_updated": "If stabilityPool.isLiquidationPossible returns false and _safeId is not the last safe.",
            "how_to_validate_state_update": "Check if cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Update cumulative collateral per unit collateral",
            "conditions": [
              "possible is false",
              "_safeId != _last"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Cumulative debt per unit collateral.",
            "why_is_is_important": "Distributes debt and collateral to existing borrowers when direct liquidation is not possible.",
            "when_is_it_updated": "If stabilityPool.isLiquidationPossible returns false and _safeId is not the last safe.",
            "how_to_validate_state_update": "Check if cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Update cumulative debt per unit collateral",
            "conditions": [
              "possible is false",
              "_safeId != _last"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Collateral loss.",
            "why_is_is_important": "Tracks any remaining collateral after distribution.",
            "when_is_it_updated": "If stabilityPool.isLiquidationPossible returns false and _safeId is not the last safe.",
            "how_to_validate_state_update": "Check if collateralLoss is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Update the collateral loss",
            "conditions": [
              "possible is false",
              "_safeId != _last"
            ]
          },
          {
            "state_variable_name": "debtLoss",
            "type": "uint256",
            "what_does_it_track": "Debt loss.",
            "why_is_is_important": "Tracks any remaining debt after distribution.",
            "when_is_it_updated": "If stabilityPool.isLiquidationPossible returns false and _safeId is not the last safe.",
            "how_to_validate_state_update": "Check if debtLoss is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Update the debt loss",
            "conditions": [
              "possible is false",
              "_safeId != _last"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "Doubly Linked List",
            "what_does_it_track": "Queue of safes ordered for liquidation",
            "why_is_is_important": "Maintains the correct ordering of safes for liquidation.",
            "when_is_it_updated": "Always, after liquidation",
            "how_to_validate_state_update": "Check if safesOrderedForLiquidation.remove(safeId) is called and its effect",
            "has_conditional_updates": false,
            "summary_of_update": "Remove safeId from liquidation queue",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "Doubly Linked List",
            "what_does_it_track": "Queue of safes ordered for redemption",
            "why_is_is_important": "Maintains the correct ordering of safes for redemption.",
            "when_is_it_updated": "Always, after liquidation",
            "how_to_validate_state_update": "Check if safesOrderedForRedemption.remove(safeId) is called and its effect",
            "has_conditional_updates": false,
            "summary_of_update": "Remove safeId from redemption queue",
            "conditions": []
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "Safe",
            "what_does_it_track": "Mapping of safeId to Safe struct",
            "why_is_is_important": "Removes the safe from the active safes.",
            "when_is_it_updated": "Always, after liquidation",
            "how_to_validate_state_update": "Check if safe is deleted from mapping safes",
            "has_conditional_updates": false,
            "summary_of_update": "Remove safe from mapping",
            "conditions": []
          },
          {
            "state_variable_name": "sbdToken",
            "type": "uint256",
            "what_does_it_track": "burning of sbdToken",
            "why_is_is_important": "burn the amount from stability pool",
            "when_is_it_updated": "if possible",
            "how_to_validate_state_update": "Check sbdToken.burn() is called.",
            "has_conditional_updates": true,
            "summary_of_update": "burn the amount from stability pool",
            "conditions": [
              "possible"
            ]
          },
          {
            "state_variable_name": "dfireTokenStaking",
            "type": "uint256",
            "what_does_it_track": "Liquidation fee distribution.",
            "why_is_is_important": "Transfers the liquidation fee to the DFIRE staking pool as a reward.",
            "when_is_it_updated": "If liquidationFee > refund and sbrStakingPoolCanReceiveRewards is true.",
            "how_to_validate_state_update": "Check if dfireTokenStaking.addCollateralReward() is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Pay liquidation fee to DFIRE staking pool",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards"
            ]
          },
          {
            "state_variable_name": "stabilityPool",
            "type": "uint256",
            "what_does_it_track": "Liquidation fee distribution.",
            "why_is_is_important": "Transfers the liquidation fee to the stability pool as a reward if the DFIRE staking pool cannot receive it.",
            "when_is_it_updated": "If liquidationFee > refund, sbrStakingPoolCanReceiveRewards is false, and stabilityPoolCanReceiveRewards is true.",
            "how_to_validate_state_update": "Check if stabilityPool.addCollateralReward() is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Pay liquidation fee to stability pool",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards is false",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "scaling factor for stakers",
            "why_is_is_important": "cumulative product scaling factor for rewards calculation",
            "when_is_it_updated": "if possible",
            "how_to_validate_state_update": "Check stakeScalingFactor",
            "has_conditional_updates": true,
            "summary_of_update": "Update stake scaling factor",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Accumulated collateral amount per token",
            "why_is_is_important": "accumulated collateral amount per token",
            "when_is_it_updated": "if possible",
            "how_to_validate_state_update": "Check totalCollateralPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "Update total collateral per token",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "collateral loss",
            "why_is_is_important": "collateral loss due to rounding errors",
            "when_is_it_updated": "if possible",
            "how_to_validate_state_update": "Check collateralLoss",
            "has_conditional_updates": true,
            "summary_of_update": "Update collateral loss",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "total staked amount",
            "why_is_is_important": "Total staked amount",
            "when_is_it_updated": "if possible",
            "how_to_validate_state_update": "Check totalStakedRaw",
            "has_conditional_updates": true,
            "summary_of_update": "Update total staked raw",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Reward sender activity status.",
            "why_is_is_important": "Deactivates the reward sender when totalStakedRaw is zero.",
            "when_is_it_updated": "If totalStakedRaw is 0, rewardSenderActive and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check if IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false) is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Deactivate reward sender",
            "conditions": [
              "totalStakedRaw == 0",
              "amount <= totalStakedRaw",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots[stakeResetCount]",
            "type": "StakeResetSnapshot",
            "what_does_it_track": "Snapshot of scaling factor and related parameters.",
            "why_is_is_important": "Resets the scaling factor if it falls below the minimum threshold.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check the values of stakeResetSnapshots[stakeResetCount], totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset scaling factor",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Snapshot of scaling factor and related parameters.",
            "why_is_is_important": "Resets the scaling factor if it falls below the minimum threshold.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check the values of stakeResetSnapshots[stakeResetCount], totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset scaling factor",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Snapshot of scaling factor and related parameters.",
            "why_is_is_important": "Resets the scaling factor if it falls below the minimum threshold.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check the values of stakeResetSnapshots[stakeResetCount], totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset scaling factor",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Snapshot of scaling factor and related parameters.",
            "why_is_is_important": "Resets the scaling factor if it falls below the minimum threshold.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check the values of stakeResetSnapshots[stakeResetCount], totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset scaling factor",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Snapshot of scaling factor and related parameters.",
            "why_is_is_important": "Resets the scaling factor if it falls below the minimum threshold.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check the values of stakeResetSnapshots[stakeResetCount], totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset scaling factor",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Snapshot of scaling factor and related parameters.",
            "why_is_is_important": "Resets the scaling factor if it falls below the minimum threshold.",
            "when_is_it_updated": "If cumulativeProductScalingFactor is less than minimumScalingFactor and amount <= totalStakedRaw.",
            "how_to_validate_state_update": "Check the values of stakeResetSnapshots[stakeResetCount], totalCollateralPerToken, totalRewardPerToken, totalSbrRewardPerToken, stakeScalingFactor, stakeResetCount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reset scaling factor",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "Node",
            "what_does_it_track": "Mapping of nodeId to Node struct",
            "why_is_is_important": "Maintains the correct ordering of safes.",
            "when_is_it_updated": "Always, after liquidation",
            "how_to_validate_state_update": "Check if node is deleted from mapping nodes",
            "has_conditional_updates": false,
            "summary_of_update": "Remove node from mapping",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Total collateral per token.",
            "why_is_is_important": "Collateral rewards distributed to stakers.",
            "when_is_it_updated": "When liquidationFee > refund and sbrStakingPoolCanReceiveRewards is true.",
            "how_to_validate_state_update": "Verify the totalCollateralPerToken is updated in DFIREStaking.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds collateral rewards to DFIREStaking.",
            "conditions": [
              "sbrStakingPoolCanReceiveRewards",
              "liquidationFee > refund"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidateSafe(uint256 safeId) external {\n        uint256 gasStart = gasleft();\n        _liquidate(safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}