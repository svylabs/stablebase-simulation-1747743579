{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "Generate a `_safeId` greater than 0 that does not already exist in the `safes` mapping. Check `safes[_safeId].collateralAmount == 0` and `_ownerOf(_safeId) == address(0)` to ensure uniqueness.",
      "Generate an `_amount` greater than 0, representing the amount of collateral to deposit.",
      "Set `msg.value` equal to `_amount` to simulate sending the collateral with the transaction.",
      "The contract must have been initialized with the necessary dependencies (e.g., PriceOracle, SBDToken, etc.) and be in a valid state for opening a Safe.  Specifically ensure that `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral` are initialized."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Creation",
        "state_update_descriptions": [
          "A new Safe is created and stored in the `safes` mapping, indexed by `_safeId`.",
          "The `collateralAmount` of the safe is set to `_amount`.",
          "The `borrowedAmount` of the safe is initialized to 0.",
          "The `weight` of the safe is initialized to 0.",
          "The `totalBorrowedAmount` is initialized to 0",
          "The `feePaid` is initialized to 0"
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "A liquidation snapshot is created and stored in the `liquidationSnapshots` mapping, indexed by `_safeId`.",
          "The `debtPerCollateralSnapshot` is set to `cumulativeDebtPerUnitCollateral` at the time of opening the Safe.",
          "The `collateralPerCollateralSnapshot` is set to `cumulativeCollateralPerUnitCollateral` at the time of opening the Safe."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "The `totalCollateral` is increased by `_amount`."
        ]
      },
      {
        "category": "NFT Minting",
        "state_update_descriptions": [
          "An NFT representing the Safe is minted and assigned to the `msg.sender` with the `_safeId` as the token ID.",
          "The owner of the NFT with ID `_safeId` is set to `msg.sender` in the `_owners` mapping.",
          "The balance of the `msg.sender` is incremented by 1 in the `_balances` mapping"
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "An `OpenSafe` event is emitted, containing the `_safeId`, `msg.sender`, `_amount`, `totalCollateral`, and `totalDebt`."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Existence",
        "rule_descriptions": [
          "The Safe with ID `_safeId` exists in the `safes` mapping, and its `collateralAmount` is equal to `_amount`.",
          "The NFT representing the Safe with ID `_safeId` is owned by `msg.sender` (checked via `ownerOf(_safeId) == msg.sender`)."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "The `totalCollateral` is increased by `_amount` compared to its initial value."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "The `liquidationSnapshots[_safeId]` should store correct snapshot of `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "An `OpenSafe` event is emitted with the correct parameters: `safeId` equals `_safeId`, `owner` equals `msg.sender`, `amount` equals `_amount`, `totalCollateral` equals the updated total collateral, and `totalDebt` remains unchanged."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "safeId",
        "type": "random_id",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for each Safe created in the system."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks all the opened safes, their collateral, and debt",
            "why_is_is_important": "Stores the state of each safe, which is crucial for tracking collateral, debt, and calculating liquidation risk.",
            "when_is_it_updated": "When a new safe is opened using the openSafe function.",
            "how_to_validate_state_update": "Check the mapping safes[_safeId] to ensure the collateralAmount, borrowedAmount, weight, totalBorrowedAmount and feePaid are initialized correctly.  Also verify the liquidationSnapshots[_safeId] is initialized correctly, totalCollateral is increased by _amount and a Transfer event is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes a new Safe struct in the safes mapping with the provided _safeId. The Safe struct stores the collateralAmount, borrowedAmount, weight, totalBorrowedAmount and feePaid.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks liquidation snapshots for each safe.",
            "why_is_is_important": "Used for calculating liquidation thresholds and determining when a safe is at risk of liquidation.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping to ensure it is initialized correctly",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes a LiquidationSnapshot struct in the liquidationSnapshots mapping with the provided _safeId. This snapshot tracks cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral at the time of opening.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral locked in the system.",
            "why_is_is_important": "Used for calculating global collateralization ratios and system health.",
            "when_is_it_updated": "When a new safe is opened or collateral is added to an existing safe.",
            "how_to_validate_state_update": "Verify that the totalCollateral state variable has increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalCollateral by the amount of collateral provided (_amount).",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721",
        "state_updated": [
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of the NFT representing the Safe",
            "why_is_is_important": "It enables tracking the ownership of the safe by assigning an NFT to the owner",
            "when_is_it_updated": "When a new Safe is created via openSafe function",
            "how_to_validate_state_update": "Check if the _owners array has been updated and the msg.sender owns the _safeId token",
            "has_conditional_updates": true,
            "summary_of_update": "Mint a new NFT representing the safe with tokenId _safeId to the msg.sender using the _safeMint function.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the NFT balances of the Safe",
            "why_is_is_important": "It enables tracking the ownership of the safe by assigning an NFT to the owner",
            "when_is_it_updated": "When a new Safe is created via openSafe function",
            "how_to_validate_state_update": "Verify that the _balances mapping has been updated and the balance of the msg.sender has increased",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the balance of the msg.sender who will become the owner of the Safe NFT",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}