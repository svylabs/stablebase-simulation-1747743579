{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "Generate a unique _safeId greater than 0, ensuring that safes[_safeId].collateralAmount == 0 and _ownerOf(_safeId) == address(0). If these conditions are not met, the transaction will revert with the message \"Safe already exists\" or \"Invalid Safe ID\".",
      "Generate a _amount greater than 0, representing the collateral amount to be deposited. If _amount is not greater than 0, the transaction will revert with the message \"Amount must be greater than 0\".",
      "Ensure that msg.value is equal to _amount to satisfy the collateral requirement. If msg.value is not equal to _amount, the transaction will revert with the message \"Insufficient collateral\"."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Creation",
        "state_update_descriptions": [
          "A new Safe is created with the specified collateral amount, zero borrowed amount, weight, total borrowed amount, and fee paid.",
          "The safe is associated with the provided safeId.",
          "The safeId is assigned to the msg.sender, representing the owner of the Safe NFT.",
          "A snapshot of the liquidation parameters is created for the safe."
        ]
      },
      {
        "category": "System-wide State Updates",
        "state_update_descriptions": [
          "The total collateral in the system is increased by the amount of collateral deposited in the new Safe.",
          "The total debt in the system remains unchanged."
        ]
      },
      {
        "category": "NFT Minting",
        "state_update_descriptions": [
          "An ERC721 NFT representing the Safe is minted and transferred to the msg.sender. This is reflected by the Transfer event emitted during the _safeMint function."
        ]
      },
      {
        "category": "Event Emission",
        "state_update_descriptions": [
          "The OpenSafe event is emitted, indicating a new safe has been opened."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Existence and Data",
        "rule_descriptions": [
          "safes[_safeId].collateralAmount should be equal to _amount",
          "safes[_safeId].borrowedAmount should be equal to 0",
          "safes[_safeId].weight should be equal to 0",
          "safes[_safeId].totalBorrowedAmount should be equal to 0",
          "safes[_safeId].feePaid should be equal to 0",
          "_ownerOf(_safeId) should be equal to msg.sender",
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot should be equal to cumulativeCollateralPerUnitCollateral"
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "rule_descriptions": [
          "totalCollateral should be increased by _amount",
          "totalDebt should remain unchanged."
        ]
      },
      {
        "category": "NFT Ownership",
        "rule_descriptions": [
          "The owner of the safeId should be the msg.sender"
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "The OpenSafe event should be emitted with safeId equal to _safeId, owner equal to msg.sender, amount equal to _amount, totalCollateral equal to the updated totalCollateral, and totalDebt equal to the current totalDebt."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "_safeId",
        "type": "structured_id_internal",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for the Safe. It's internally managed to ensure uniqueness."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in the safe.",
            "why_is_is_important": "Stores the collateral amount for a specific safe.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check that safes[_safeId].collateralAmount is equal to _amount after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The collateralAmount of the safe with ID _safeId is set to _amount.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount borrowed against the collateral in the safe.",
            "why_is_is_important": "Stores the borrowed amount for a specific safe.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check that safes[_safeId].borrowedAmount is equal to 0 after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The borrowedAmount of the safe with ID _safeId is initialized to 0.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The weight associated with the safe, used for prioritization in liquidation or redemption queues.",
            "why_is_is_important": "Stores the weight for a specific safe.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check that safes[_safeId].weight is equal to 0 after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The weight of the safe with ID _safeId is initialized to 0.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount that has ever been borrowed by the safe.",
            "why_is_is_important": "Stores the total borrowed amount for a specific safe.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check that safes[_safeId].totalBorrowedAmount is equal to 0 after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalBorrowedAmount of the safe with ID _safeId is initialized to 0.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "The cumulative fee paid by the safe owner.",
            "why_is_is_important": "Stores the accumulated fee paid for a specific safe.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check that safes[_safeId].feePaid is equal to 0 after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The feePaid of the safe with ID _safeId is initialized to 0.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId]",
            "type": "LiquidationSnapshot",
            "what_does_it_track": "The debt and collateral ratios at the time the safe was opened.",
            "why_is_is_important": "Stores the liquidation snapshot for a safe. This is important for tracking the collateral and debt ratios at the time of opening the safe.",
            "when_is_it_updated": "When a new safe is opened.",
            "how_to_validate_state_update": "Check that liquidationSnapshots[_safeId].debtPerCollateralSnapshot is equal to cumulativeDebtPerUnitCollateral and liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is equal to cumulativeCollateralPerUnitCollateral after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "A liquidation snapshot is created and stored for the safe with ID _safeId.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral deposited in all safes.",
            "why_is_is_important": "Tracks the total amount of collateral in the system.",
            "when_is_it_updated": "When a new safe is opened and collateral is added.",
            "how_to_validate_state_update": "Check that totalCollateral is increased by _amount after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalCollateral is increased by the amount of collateral deposited in the new safe.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721",
        "state_updated": [
          {
            "state_variable_name": "_owners[_safeId]",
            "type": "address",
            "what_does_it_track": "The current owner of a given Safe (NFT).",
            "why_is_is_important": "Maps token IDs to their owners. Essential for tracking ownership of the Safe (NFT).",
            "when_is_it_updated": "When a new Safe is minted, transferring ownership to the caller.",
            "how_to_validate_state_update": "Verify that _owners[_safeId] is equal to msg.sender after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Ownership of the Safe (NFT) with ID _safeId is assigned to the transaction sender (msg.sender).",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "to != address(0)"
            ]
          },
          {
            "state_variable_name": "_balances[to]",
            "type": "uint256",
            "what_does_it_track": "The balance of ERC721 tokens owned by each address.",
            "why_is_is_important": "Tracks the number of tokens owned by each address.  Used to enforce ERC721 ownership rules.",
            "when_is_it_updated": "When a new Safe is minted, incrementing the balance of the recipient.",
            "how_to_validate_state_update": "Confirm that _balances[msg.sender] has increased by 1 after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The token balance of the recipient (msg.sender) is incremented by 1, representing the new Safe (NFT) ownership.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "to != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}