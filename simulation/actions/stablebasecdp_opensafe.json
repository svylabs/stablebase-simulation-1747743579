{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "The '_safeId' parameter must be a unique 'uint256' value greater than 0 that does not currently have an owner (i.e., 'ownerOf(_safeId)' returns 'address(0)') and for which no safe currently exists (i.e., 'safes[_safeId].collateralAmount == 0').",
      "The '_amount' parameter must be a 'uint256' value greater than 0, representing the amount of collateral to deposit. This amount must also be sent as 'msg.value' with the transaction."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral Management",
        "state_update_descriptions": [
          "The 'totalCollateral' state variable in the 'StableBaseCDP' contract is increased by the '_amount' provided."
        ]
      },
      {
        "category": "Safe State Initialization",
        "state_update_descriptions": [
          "A new 'Safe' struct for '_safeId' is created in the 'safes' mapping with: 'collateralAmount' set to '_amount', 'borrowedAmount' set to '0', 'weight' set to '0', 'totalBorrowedAmount' set to '0', and 'feePaid' set to '0'.",
          "A new 'LiquidationSnapshot' struct for '_safeId' is created in the 'liquidationSnapshots' mapping with: 'debtPerCollateralSnapshot' set to the current 'cumulativeDebtPerUnitCollateral', and 'collateralPerCollateralSnapshot' set to the current 'cumulativeCollateralPerUnitCollateral'."
        ]
      },
      {
        "category": "NFT Ownership Transfer",
        "state_update_descriptions": [
          "The '_safeId' token (representing the Safe) is minted and its ownership is transferred to 'msg.sender'.",
          "The '_owners[_safeId]' mapping is updated to 'msg.sender'.",
          "The '_balances[msg.sender]' mapping (representing the ERC721 balance of 'msg.sender') is incremented by 1."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State Validation",
        "rule_descriptions": [
          "The 'safes[_safeId].collateralAmount' must be equal to the '_amount' provided in the transaction.",
          "The 'safes[_safeId].borrowedAmount' must be '0'.",
          "The 'safes[_safeId].weight' must be '0'.",
          "The 'safes[_safeId].totalBorrowedAmount' must be '0'.",
          "The 'safes[_safeId].feePaid' must be '0'."
        ]
      },
      {
        "category": "Liquidation Snapshot Validation",
        "rule_descriptions": [
          "The 'liquidationSnapshots[_safeId].debtPerCollateralSnapshot' must be equal to the 'cumulativeDebtPerUnitCollateral' at the time of transaction execution.",
          "The 'liquidationSnapshots[_safeId].collateralPerCollateralSnapshot' must be equal to the 'cumulativeCollateralPerUnitCollateral' at the time of transaction execution."
        ]
      },
      {
        "category": "Total Collateral Validation",
        "rule_descriptions": [
          "The 'totalCollateral' state variable must have increased by the '_amount' provided."
        ]
      },
      {
        "category": "NFT Ownership Validation",
        "rule_descriptions": [
          "The 'ownerOf(_safeId)' function must return 'msg.sender'.",
          "The 'balanceOf(msg.sender)' function must return a value incremented by '1'."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "An 'OpenSafe' event must be emitted with: 'safeId' equal to '_safeId', 'owner' equal to 'msg.sender', 'amount' equal to '_amount', 'totalCollateral' equal to the new 'totalCollateral' value, and 'totalDebt' equal to the current 'totalDebt' value.",
          "A 'Transfer' event must be emitted with: 'from' equal to 'address(0)', 'to' equal to 'msg.sender', and 'tokenId' equal to '_safeId'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "safeId",
        "type": "structured_id_external",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "A unique identifier for the newly created CDP (Safe). This ID is also the token ID for the ERC721 NFT that represents ownership of the Safe."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping (uint256 => struct StableBaseCDP.LiquidationSnapshot)",
            "what_does_it_track": "This mapping stores snapshots of the global cumulative debt per unit collateral and cumulative collateral per unit collateral at the time each Safe is opened.",
            "why_is_is_important": "It provides a historical reference point for a Safe's effective debt and collateral, which is essential for accurate liquidation calculations as global cumulative values change over time due to system-wide operations like liquidations and redemptions.",
            "when_is_it_updated": "It is updated when a new Safe is successfully opened via the `openSafe` function.",
            "how_to_validate_state_update": "Verify that `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` is set to the value of `cumulativeDebtPerUnitCollateral` and `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot` is set to the value of `cumulativeCollateralPerUnitCollateral` at the time of the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "A new entry for the given `_safeId` is created in the `liquidationSnapshots` mapping, storing the current global cumulative debt and collateral per unit collateral. This snapshot is crucial for calculating the actual debt and collateral of the Safe for liquidation purposes.",
            "conditions": []
          },
          {
            "state_variable_name": "safes",
            "type": "mapping (uint256 => struct IStableBase.Safe)",
            "what_does_it_track": "This mapping stores the detailed state of each individual Safe (CDP), including its collateral amount, borrowed amount, weight in the liquidation/redemption queues, total borrowed amount over time, and fees paid.",
            "why_is_is_important": "It is the primary data structure for managing all open CDPs in the system, reflecting their current financial status and position.",
            "when_is_it_updated": "It is updated when a new Safe is successfully opened via the `openSafe` function, or when an existing Safe's parameters are modified (e.g., adding/removing collateral, borrowing/repaying debt).",
            "how_to_validate_state_update": "Verify that `safes[_safeId].collateralAmount` is set to `_amount`, `safes[_safeId].borrowedAmount` is 0, `safes[_safeId].weight` is 0, `safes[_safeId].totalBorrowedAmount` is 0, and `safes[_safeId].feePaid` is 0.",
            "has_conditional_updates": false,
            "summary_of_update": "A new `Safe` struct is created and assigned to the `_safeId` in the `safes` mapping. It is initialized with the deposited `_amount` as collateral and all other fields (borrowedAmount, weight, totalBorrowedAmount, feePaid) set to zero, signifying a newly opened Safe with no debt yet.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The aggregate sum of all collateral locked across all active Safes in the system.",
            "why_is_is_important": "It provides a global view of the total collateral backing the stablecoin in the system. This value is critical for understanding the system's solvency and overall collateralization ratio.",
            "when_is_it_updated": "It is updated whenever collateral enters or leaves the system, such as when a Safe is opened, collateral is added to an existing Safe, or collateral is removed through withdrawal, liquidation, or redemption.",
            "how_to_validate_state_update": "Verify that the `totalCollateral` variable has increased by the `_amount` provided in the function call.",
            "has_conditional_updates": false,
            "summary_of_update": "The `totalCollateral` is increased by the `_amount` of collateral deposited to open the new Safe. This reflects the new collateral added to the system.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping (address => uint256)",
            "what_does_it_track": "The number of Safe NFTs owned by a particular address.",
            "why_is_is_important": "It maintains the ERC721 compliant balance of Safe NFTs for each owner, indicating how many Safes an address controls.",
            "when_is_it_updated": "It is updated when an NFT is transferred or minted/burned. In the `openSafe` function, it's called through `_safeMint` -> `_mint` -> `_update`.",
            "how_to_validate_state_update": "During minting, this update path is skipped because `from` is `address(0)`. Therefore, `_balances[address(0)]` is not decremented.",
            "has_conditional_updates": true,
            "summary_of_update": "This internal mapping, used for ERC721 balance tracking, would typically decrement the balance of the `from` address. However, during the minting process within `openSafe`, the `from` address is `address(0)`, so this specific conditional block is skipped, and no balance is decremented.",
            "conditions": [
              "The `from` address in the `_update` function (which is `address(0)` for minting) is not `address(0)`."
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping (address => uint256)",
            "what_does_it_track": "The number of Safe NFTs owned by a particular address.",
            "why_is_is_important": "It maintains the ERC721 compliant balance of Safe NFTs for each owner, indicating how many Safes an address controls.",
            "when_is_it_updated": "It is updated when an NFT is transferred or minted/burned. In the `openSafe` function, it's called through `_safeMint` -> `_mint` -> `_update`.",
            "how_to_validate_state_update": "Verify that `_balances[msg.sender]` has increased by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "The Safe owner's (`msg.sender`) balance of Safe NFTs is incremented by one, reflecting the minting of a new Safe NFT.",
            "conditions": [
              "The `to` address in the `_update` function (which is `msg.sender` for minting) is not `address(0)`."
            ]
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping (uint256 => address)",
            "what_does_it_track": "The owner address for a given Safe NFT ID.",
            "why_is_is_important": "It defines the direct ownership of each Safe NFT, which represents control over the corresponding CDP.",
            "when_is_it_updated": "It is updated when a new Safe NFT is minted or when an existing Safe NFT is transferred.",
            "how_to_validate_state_update": "Verify that `_owners[_safeId]` is set to `msg.sender`.",
            "has_conditional_updates": false,
            "summary_of_update": "The `_owners` mapping is updated to associate the newly minted `_safeId` (NFT tokenId) with the `msg.sender`, establishing them as the owner of the Safe NFT.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}