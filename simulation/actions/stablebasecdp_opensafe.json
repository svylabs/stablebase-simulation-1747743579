{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "Generate a unique safeId greater than 0 that does not already exist in the safes mapping.",
      "Generate an amount greater than 0 to be used as collateral.",
      "Ensure that msg.value (ETH sent with the transaction) is equal to the amount of collateral specified."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Creation",
        "state_update_descriptions": [
          "A new Safe is created with the specified collateral amount and a unique Safe ID.",
          "The Safe's initial borrowed amount is set to 0.",
          "The Safe's initial weight is set to 0.",
          "The Safe's total borrowed amount is set to 0.",
          "The Safe's initial fee paid is set to 0."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "A new LiquidationSnapshot is created for the Safe, capturing the current debt and collateral ratios.",
          "debtPerCollateralSnapshot is set to cumulativeDebtPerUnitCollateral.",
          "collateralPerCollateralSnapshot is set to cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Collateral Management",
        "state_update_descriptions": [
          "The totalCollateral is increased by the amount of collateral deposited for the new Safe."
        ]
      },
      {
        "category": "NFT Management",
        "state_update_descriptions": [
          "An NFT representing the Safe is minted and assigned to the message sender (msg.sender).",
          "The NFT's tokenId corresponds to the Safe ID."
        ]
      },
      {
        "category": "Ownership Tracking",
        "state_update_descriptions": [
          "The `_owners` mapping is updated, associating the safeId with the msg.sender, establishing ownership.",
          "The _balances mapping for the msg.sender is incremented by 1, indicating ownership of the new Safe (NFT)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Properties",
        "rule_descriptions": [
          "safes[safeId].collateralAmount must equal the amount of collateral provided as input.",
          "safes[safeId].borrowedAmount must equal 0.",
          "safes[safeId].weight must equal 0.",
          "safes[safeId].totalBorrowedAmount must equal 0.",
          "safes[safeId].feePaid must equal 0."
        ]
      },
      {
        "category": "Collateral Totals",
        "rule_descriptions": [
          "totalCollateral must equal the previous totalCollateral plus the amount of collateral provided as input."
        ]
      },
      {
        "category": "NFT Verification",
        "rule_descriptions": [
          "ownerOf(safeId) must equal msg.sender, confirming ownership of the Safe's NFT.",
          "_balances[msg.sender] must be incremented by 1."
        ]
      },
      {
        "category": "Snapshot Integrity",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot must equal cumulativeDebtPerUnitCollateral.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot must equal cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Event Verification",
        "rule_descriptions": [
          "An OpenSafe event must be emitted with the safeId, msg.sender, amount, totalCollateral, and totalDebt as arguments.",
          "A Transfer event must be emitted with address(0) as from, msg.sender as to, and safeId as tokenId."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "safeId",
        "type": "random_id",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique ID for the Safe, also used as ERC721 token ID."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Stores information about each safe, including collateral amount, borrowed amount, weight, total borrowed amount, and fee paid.",
            "why_is_is_important": "Tracks the state of each safe, which is essential for managing collateralization ratios and liquidations.",
            "when_is_it_updated": "When a new safe is opened with `openSafe` function, if the safe with the given safeId does not exist.",
            "how_to_validate_state_update": "Check if the `safes` mapping at `_safeId` contains the correct `collateralAmount`, `borrowedAmount`, `weight`, `totalBorrowedAmount`, and `feePaid` values.",
            "has_conditional_updates": true,
            "summary_of_update": "The `safes` mapping is updated with a new `Safe` struct at the key `_safeId`. The struct's fields are initialized with `_amount` as `collateralAmount`, 0 for `borrowedAmount`, `weight`, `totalBorrowedAmount` and `feePaid`",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "Insufficient collateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Stores liquidation snapshots for each safe. The liquidation snapshots contains cumulative debt and collateral per unit collateral.",
            "why_is_is_important": "The liquidation snapshots are important for proper calculation of liquidation threshold.",
            "when_is_it_updated": "When a new safe is opened with `openSafe` function, if the safe with the given safeId does not exist.",
            "how_to_validate_state_update": "Check if the `liquidationSnapshots` mapping at `_safeId` contains the `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` values.",
            "has_conditional_updates": true,
            "summary_of_update": "The `liquidationSnapshots` mapping is updated with a new `LiquidationSnapshot` struct at the key `_safeId`. The snapshot's fields are initialized with current `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "Insufficient collateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Important for calculating global collateralization ratios and system health.",
            "when_is_it_updated": "When a new safe is opened, the total collateral increases by the collateral amount.",
            "how_to_validate_state_update": "Check the value of `totalCollateral` after the function execution by reading the `totalCollateral` state variable using a view call.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalCollateral` variable is increased by `_amount`.",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "Insufficient collateral"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721",
        "state_updated": [
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of each Safe (ERC721 token).",
            "why_is_is_important": "Essential for tracking ownership of Safes and ensuring proper authorization for actions on the Safe.",
            "when_is_it_updated": "When a new Safe is opened, the ownership of the Safe (NFT) is assigned to the caller.",
            "how_to_validate_state_update": "Call the `ownerOf(_safeId)` function after the execution to confirm the owner of the token.",
            "has_conditional_updates": true,
            "summary_of_update": "The `_owners` mapping (inherited from ERC721) is updated, associating `msg.sender` with the `_safeId` token, meaning the safeId is minted to the user.",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "Insufficient collateral",
              "to != address(0)",
              "previousOwner == address(0)"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the number of tokens (Safes) owned by each address.",
            "why_is_is_important": "Keeps track of the number of safes each user has opened.",
            "when_is_it_updated": "When a new Safe is opened, the balance of the owner increases by 1.",
            "how_to_validate_state_update": "Call the `balanceOf(msg.sender)` function after the execution to confirm the balance of the owner.",
            "has_conditional_updates": true,
            "summary_of_update": "The `_balances` mapping is updated, incrementing the balance of `msg.sender` by one. This means that the owner owns one more Safe.",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "Insufficient collateral",
              "to != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}