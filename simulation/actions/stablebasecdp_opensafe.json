{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "_safeId: Generate a unique integer greater than 0 that has not been used before.",
      "_amount: Generate a positive integer representing the amount of collateral to deposit.",
      "msg.value: Must be equal to _amount. Ensure sufficient funds are available in the user's account to cover this amount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Creation",
        "state_update_descriptions": [
          "A new Safe is created with the provided _safeId.",
          "The collateralAmount of the Safe is set to _amount.",
          "The borrowedAmount of the Safe is initialized to 0.",
          "The weight of the Safe is initialized to 0.",
          "The totalBorrowedAmount of the Safe is initialized to 0.",
          "The feePaid of the Safe is initialized to 0.",
          "A LiquidationSnapshot is created for the Safe, storing the current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral. This snapshot is stored in the liquidationSnapshots mapping using _safeId as the key.",
          "The Safe's information is stored in the safes mapping using _safeId as the key."
        ]
      },
      {
        "category": "Collateral Update",
        "state_update_descriptions": [
          "totalCollateral is increased by _amount."
        ]
      },
      {
        "category": "NFT Minting and Transfer",
        "state_update_descriptions": [
          "An NFT representing the Safe is minted to the msg.sender with the tokenId being _safeId.",
          "The owner of the NFT with tokenId _safeId is set to msg.sender in the _owners mapping.",
          "The balance of the msg.sender (owner) is incremented by 1.",
          "A Transfer event is emitted, indicating the transfer of the NFT from address(0) to msg.sender with tokenId _safeId."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "An OpenSafe event is emitted, logging the _safeId, msg.sender, _amount, totalCollateral, and totalDebt."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Existence",
        "rule_descriptions": [
          "safes[_safeId].collateralAmount should be equal to _amount.",
          "safes[_safeId].borrowedAmount should be equal to 0.",
          "safes[_safeId].weight should be equal to 0.",
          "safes[_safeId].totalBorrowedAmount should be equal to 0.",
          "safes[_safeId].feePaid should be equal to 0."
        ]
      },
      {
        "category": "NFT Ownership",
        "rule_descriptions": [
          "_ownerOf(_safeId) should be equal to msg.sender.",
          "balanceOf(msg.sender) should be incremented by 1 compared to before the function call."
        ]
      },
      {
        "category": "Collateral Value",
        "rule_descriptions": [
          "totalCollateral should be increased by _amount compared to before the function call."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral before the function call.",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot should be equal to cumulativeCollateralPerUnitCollateral before the function call."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "Safe ID",
        "type": "random_id",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for each Safe (CDP)."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the details of each Safe, including collateral amount, borrowed amount, weight, total borrowed amount, and fee paid.",
            "why_is_is_important": "It stores the state of each Safe, which is crucial for tracking collateral, debt, and other important parameters for liquidations, redemptions, and overall system health.",
            "when_is_it_updated": "When a new Safe is opened using the 'openSafe' function, and the conditions mentioned above are met.",
            "how_to_validate_state_update": "Check the 'safes' mapping for the given '_safeId'. Verify that 'collateralAmount' is equal to '_amount', 'borrowedAmount' is 0, 'weight' is 0, 'totalBorrowedAmount' is 0, and 'feePaid' is 0.",
            "has_conditional_updates": true,
            "summary_of_update": "A new Safe is created and its details are stored in the 'safes' mapping using '_safeId' as the key.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "It tracks cumulative debt per unit collateral and cumulative collateral per unit collateral at the time of opening Safe for later liquidations.",
            "why_is_is_important": "It is important for liquidation process to know debt and collateral snapshots at the time of opening safe.",
            "when_is_it_updated": "When a new Safe is opened using the 'openSafe' function.",
            "how_to_validate_state_update": "Verify that the 'liquidationSnapshots' mapping contains the current cumulative debt per unit collateral and cumulative collateral per unit collateral for the '_safeId'.",
            "has_conditional_updates": false,
            "summary_of_update": "A new LiquidationSnapshot is created and stored in the 'liquidationSnapshots' mapping using '_safeId' as the key. It contains the debtPerCollateralSnapshot and collateralPerCollateralSnapshot",
            "conditions": [
              "None"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral held by the contract.",
            "why_is_is_important": "It is important for calculating the overall collateralization ratio of the system and assessing its health.",
            "when_is_it_updated": "When a new Safe is opened using the 'openSafe' function.",
            "how_to_validate_state_update": "Verify that 'totalCollateral' has increased by '_amount'.",
            "has_conditional_updates": false,
            "summary_of_update": "The 'totalCollateral' variable is increased by the amount of collateral provided for the new Safe.",
            "conditions": [
              "None"
            ]
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of each Safe NFT.",
            "why_is_is_important": "It is crucial for tracking ownership of Safe NFTs, allowing users to manage their positions and interact with the protocol.",
            "when_is_it_updated": "When a new Safe NFT is minted using '_safeMint', which is called by 'openSafe'.",
            "how_to_validate_state_update": "Check _owners mapping. Verify that '_owners[tokenId]' is equal to 'to'",
            "has_conditional_updates": true,
            "summary_of_update": "The '_owners' mapping is updated to associate the 'tokenId' (Safe ID) with the 'to' address (msg.sender). This effectively assigns ownership of the Safe NFT to the user.",
            "conditions": [
              "to != address(0)"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each address, i.e., the number of Safe NFTs owned by each address.",
            "why_is_is_important": "It is important for tracking number of tokens held by each address",
            "when_is_it_updated": "When a new Safe NFT is minted using '_safeMint', which is called by 'openSafe'.",
            "how_to_validate_state_update": "Check _balances mapping. Verify that '_balances[to]' increased by 1",
            "has_conditional_updates": true,
            "summary_of_update": "The '_balances' mapping which tracks the number of tokens held by each address is incremented by 1 for the recipient 'to'.",
            "conditions": [
              "to != address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}