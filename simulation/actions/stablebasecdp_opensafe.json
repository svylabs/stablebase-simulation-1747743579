{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "_safeId: Generate a unique uint256 greater than 0 that does not already exist in the _owners mapping. Check _owners[_safeId] == address(0) should be true.",
      "_amount: Generate a uint256 greater than 0. This will be the amount of collateral deposited. msg.value should be equal to _amount.",
      "msg.value: Set msg.value equal to _amount to satisfy the collateral deposit requirement.",
      "msg.sender:  Set to the address of the user who is opening the Safe. This should be an externally owned account."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Creation",
        "state_update_descriptions": [
          "A new Safe is created with the provided _safeId.",
          "The collateralAmount of the Safe is set to _amount.",
          "The borrowedAmount of the Safe is initialized to 0.",
          "The weight of the Safe is initialized to 0.",
          "The totalBorrowedAmount of the Safe is initialized to 0.",
          "The feePaid of the Safe is initialized to 0.",
          "A LiquidationSnapshot is created for the Safe, capturing the current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral.",
          "The Safe is mapped to the provided _safeId in the safes mapping."
        ]
      },
      {
        "category": "Collateral Update",
        "state_update_descriptions": [
          "The totalCollateral is increased by _amount."
        ]
      },
      {
        "category": "NFT Minting",
        "state_update_descriptions": [
          "An NFT representing the Safe is minted and transferred to the msg.sender. The tokenId of the NFT is _safeId.",
          "The ownership of the NFT with tokenId _safeId is assigned to msg.sender. _owners[_safeId] = msg.sender",
          "The balance of the owner (msg.sender) is increased by 1. _balances[msg.sender] += 1;"
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "An OpenSafe event is emitted, containing the _safeId, msg.sender, _amount, totalCollateral, and totalDebt."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Existence and Properties",
        "rule_descriptions": [
          "safes[_safeId].collateralAmount == _amount",
          "safes[_safeId].borrowedAmount == 0",
          "safes[_safeId].weight == 0",
          "safes[_safeId].totalBorrowedAmount == 0",
          "safes[_safeId].feePaid == 0"
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "totalCollateral (after execution) == totalCollateral (before execution) + _amount"
        ]
      },
      {
        "category": "NFT Ownership",
        "rule_descriptions": [
          "_ownerOf(_safeId) == msg.sender",
          "balanceOf(msg.sender) (after execution) == balanceOf(msg.sender) (before execution) + 1"
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot == cumulativeDebtPerUnitCollateral (at the time of execution)",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot == cumulativeCollateralPerUnitCollateral (at the time of execution)"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "_safeId",
        "type": "random_id",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for the created safe."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the details (collateralAmount, borrowedAmount, weight, totalBorrowedAmount, feePaid) of each safe by its ID.",
            "why_is_is_important": "It stores the core information about each safe, which is essential for all other operations.",
            "when_is_it_updated": "When a new safe is opened using the openSafe function, a new entry is added to this mapping.",
            "how_to_validate_state_update": "Check if the safe with the given _safeId exists and verify its parameters (collateralAmount, borrowedAmount, weight, totalBorrowedAmount, feePaid) match the provided _amount and initialized values.",
            "has_conditional_updates": true,
            "summary_of_update": "A new safe is created and its details are stored in the `safes` mapping using the provided _safeId.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral locked in all safes.",
            "why_is_is_important": "This variable is used to calculate the collateralization ratio and to determine the overall health of the protocol.",
            "when_is_it_updated": "When a new safe is opened or when collateral is added to an existing safe.",
            "how_to_validate_state_update": "Verify that the totalCollateral is increased by the amount of collateral provided when opening the safe.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral is increased by the amount deposited in the new safe.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "It tracks cumulative debt and collateral per unit collateral at the time of safe opening.",
            "why_is_is_important": "This information is critical for liquidation calculations, ensuring fairness and accuracy.",
            "when_is_it_updated": "It is updated when a new safe is opened.",
            "how_to_validate_state_update": "Check if the `liquidationSnapshots` mapping with the key `_safeId` holds the current values of `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`. ",
            "has_conditional_updates": true,
            "summary_of_update": "Stores a snapshot of cumulative debt and collateral per unit collateral at the time of safe opening.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "ERC721",
        "state_updated": [
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "Tracks the owner of each safe (tokenId).",
            "why_is_is_important": "This ensures that only the owner can control the safe, part of minting a ERC721 token",
            "when_is_it_updated": "When a new safe is minted via _safeMint.",
            "how_to_validate_state_update": "Verify that the _owners mapping is updated with the msg.sender as the owner of the _safeId.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the _owners mapping to record the owner of the newly created safe.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the number of safes owned by each address.",
            "why_is_is_important": "Used to track ownership and count of safes owned by an address, following ERC721 standards.",
            "when_is_it_updated": "When a new safe is minted.",
            "how_to_validate_state_update": "Verify that the _balances mapping is updated, increasing the balance of the msg.sender by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the _balances mapping to reflect the new safe ownership.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}