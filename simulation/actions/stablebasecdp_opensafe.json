{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "_safeId: Generate a unique uint256 greater than 0 that hasn't been used before and isn't currently associated with an existing Safe.",
      "_amount: Generate a uint256 greater than 0 representing the amount of collateral to deposit. Ensure that the msg.value sent with the transaction equals this amount.",
      "msg.value: Set the msg.value to be equal to the _amount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Creation",
        "state_update_descriptions": [
          "A new Safe is created with the provided safeId.",
          "The collateralAmount of the new Safe is set to the provided amount.",
          "The borrowedAmount of the new Safe is initialized to 0.",
          "The weight of the new Safe is initialized to 0.",
          "The totalBorrowedAmount of the new Safe is initialized to 0.",
          "The feePaid of the new Safe is initialized to 0"
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "A new LiquidationSnapshot is created for the safeId.",
          "The debtPerCollateralSnapshot of the new LiquidationSnapshot is set to the current cumulativeDebtPerUnitCollateral.",
          "The collateralPerCollateralSnapshot of the new LiquidationSnapshot is set to the current cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "The totalCollateral is increased by the provided amount."
        ]
      },
      {
        "category": "NFT Minting",
        "state_update_descriptions": [
          "An ERC721 NFT representing the Safe is minted and assigned to the message sender with safeId as token ID."
        ]
      },
      {
        "category": "Owner Mapping",
        "state_update_descriptions": [
          "The _owners mapping is updated to associate the safeId with the message sender, indicating ownership of the Safe."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Existence",
        "rule_descriptions": [
          "safes[safeId].collateralAmount == _amount: The collateral amount of the Safe should be equal to the provided amount.",
          "safes[safeId].borrowedAmount == 0: The borrowed amount of the Safe should be equal to 0.",
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot == cumulativeDebtPerUnitCollateral: The debtPerCollateralSnapshot should match cumulativeDebtPerUnitCollateral",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot == cumulativeCollateralPerUnitCollateral: The collateralPerCollateralSnapshot should match cumulativeCollateralPerUnitCollateral"
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "totalCollateral (after) == totalCollateral (before) + _amount: The total collateral should have increased by the provided amount."
        ]
      },
      {
        "category": "NFT Ownership",
        "rule_descriptions": [
          "ownerOf(safeId) == msg.sender: The owner of the Safe's NFT should be the message sender."
        ]
      },
      {
        "category": "Balances",
        "rule_descriptions": [
          "_balances[msg.sender] > 0: The balance of the msg.sender should be greater than 0"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "safeId",
        "type": "random_id",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for each Safe (CDP)."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the Safe data, including collateral amount, borrowed amount, and other related information, for each safeId.",
            "why_is_is_important": "It stores the core data for each Safe, which is essential for tracking collateral, debt, and other important metrics for the CDP. This data is crucial for liquidations, redemptions, and other core functionalities of the protocol.",
            "when_is_it_updated": "It is updated when a new Safe is created using the openSafe function.",
            "how_to_validate_state_update": "Check that safes[_safeId].collateralAmount equals _amount, safes[_safeId].borrowedAmount equals 0, safes[_safeId].weight equals 0, safes[_safeId].totalBorrowedAmount equals 0, safes[_safeId].feePaid equals 0.",
            "has_conditional_updates": true,
            "summary_of_update": "A new Safe is created with the provided _safeId, setting the collateralAmount to _amount, borrowedAmount to 0, and other fields to 0. The new safe is stored in the safes mapping with key _safeId.",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "msg.value == _amount"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks the snapshot of debt and collateral ratios at the time the safe was created.",
            "why_is_is_important": "It stores a snapshot of the cumulative debt and collateral ratios, which is essential for accurately liquidating safes.",
            "when_is_it_updated": "It is updated when a new Safe is created using the openSafe function.",
            "how_to_validate_state_update": "Check that liquidationSnapshots[_safeId].debtPerCollateralSnapshot equals cumulativeDebtPerUnitCollateral and liquidationSnapshots[_safeId].collateralPerCollateralSnapshot equals cumulativeCollateralPerUnitCollateral",
            "has_conditional_updates": true,
            "summary_of_update": "A LiquidationSnapshot is created with cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral stored, and saved to the liquidationSnapshots mapping with key _safeId",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "msg.value == _amount"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral in the system.",
            "why_is_is_important": "It is used to track the overall health of the system, and is used in calculating the collateralization ratio.",
            "when_is_it_updated": "It is updated when a new Safe is created using the openSafe function.",
            "how_to_validate_state_update": "Check that totalCollateral is increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The totalCollateral is increased by the amount of collateral provided by the user (_amount).",
            "conditions": [
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "Amount must be greater than 0",
              "msg.value == _amount"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Keeps track of the number of tokens held by each address",
            "why_is_is_important": "Used to query the number of tokens held by an address (balanceOf)",
            "when_is_it_updated": "when a token is minted to an address",
            "how_to_validate_state_update": "Check if _balances[to] is incremented by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Increments the balance of the recipient address to, keeping track of the number of tokens held by each address",
            "conditions": [
              "to == address(0)"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Keeps track of the number of tokens held by each address",
            "why_is_is_important": "Used to query the number of tokens held by an address (balanceOf)",
            "when_is_it_updated": "when a token is transferred from an address",
            "how_to_validate_state_update": "Check if _balances[from] is decremented by 1",
            "has_conditional_updates": true,
            "summary_of_update": "Decrements the balance of the sender address, as the token is being transferred",
            "conditions": [
              "from != address(0)"
            ]
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "tracks the owner of each token id",
            "why_is_is_important": "Used to query the owner of a token (ownerOf)",
            "when_is_it_updated": "when a token is minted or transferred",
            "how_to_validate_state_update": "Check that _owners[tokenId] equals to",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the _owners mapping to reflect the new owner of the token",
            "conditions": [
              "to != address(0)"
            ]
          },
          {
            "state_variable_name": "_tokenApprovals",
            "type": "mapping",
            "what_does_it_track": "Keeps track of the address approved to spend a token",
            "why_is_is_important": "Used to query the address approved to spend a token (getApproved)",
            "when_is_it_updated": "when a token is approved to be spent by another address, or when a token is transferred",
            "how_to_validate_state_update": "check that _tokenApprovals[tokenId] is reset to address(0)",
            "has_conditional_updates": true,
            "summary_of_update": "Resets the approval for the token, if the token is being transferred from an address. There is no need to re-authorize or emit the Approval event in this case",
            "conditions": [
              "from != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}