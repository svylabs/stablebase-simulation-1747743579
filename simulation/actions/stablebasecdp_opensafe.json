{
  "action": {
    "name": "Open Safe",
    "summary": "Opens a new CDP (Safe).",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "pre_execution_parameter_generation_rules": [
      "Generate `_safeId`: A unique integer greater than 0. It's used as an identifier for the new Safe (CDP). Ensure that no existing Safe uses this ID by checking that `safes[_safeId].collateralAmount == 0` and `_ownerOf(_safeId) == address(0)` returns true.",
      "Generate `_amount`: A positive integer representing the amount of collateral to deposit. This value must be greater than 0. The user must send this amount of ETH with the transaction (msg.value == _amount)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Data",
        "state_update_descriptions": [
          "A new `Safe` struct is created and stored in the `safes` mapping at the key `_safeId`. The `collateralAmount` is set to `_amount`, `borrowedAmount` is set to 0, `weight` is set to 0, `totalBorrowedAmount` is set to 0 and `feePaid` is set to 0.",
          "A `LiquidationSnapshot` struct is created and stored in the `liquidationSnapshots` mapping at the key `_safeId`. The `debtPerCollateralSnapshot` is set to `cumulativeDebtPerUnitCollateral` and the `collateralPerCollateralSnapshot` is set to `cumulativeCollateralPerUnitCollateral`."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "The `totalCollateral` variable is increased by `_amount`."
        ]
      },
      {
        "category": "NFT Minting",
        "state_update_descriptions": [
          "The `_safeMint` function is called, minting an ERC721 NFT representing the Safe to the transaction sender (`msg.sender`). The NFT's token ID is `_safeId`."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "An `OpenSafe` event is emitted, with `safeId` set to `_safeId`, `owner` set to `msg.sender`, `amount` set to `_amount`, `totalCollateral` set to the updated `totalCollateral`, and `totalDebt` set to the current `totalDebt`."
        ]
      },
      {
        "category": "ERC721 State Updates",
        "state_update_descriptions": [
          "The `_owners[_safeId]` mapping is updated to store the address of `msg.sender` as the owner of the NFT with token ID `_safeId`.",
          "The `_balances[msg.sender]` mapping, tracking the number of NFTs owned by the sender, is incremented by 1."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral Deposit Validation",
        "rule_descriptions": [
          "Verify that `msg.value == _amount` to ensure the correct amount of ETH was sent with the transaction."
        ]
      },
      {
        "category": "Safe Data Validation",
        "rule_descriptions": [
          "Verify that `safes[_safeId].collateralAmount` is equal to `_amount`.",
          "Verify that `safes[_safeId].borrowedAmount` is equal to 0.",
          "Verify that `safes[_safeId].weight` is equal to 0.",
          "Verify that `safes[_safeId].totalBorrowedAmount` is equal to 0.",
          "Verify that `safes[_safeId].feePaid` is equal to 0.",
          "Verify that `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` is equal to the contract's current `cumulativeDebtPerUnitCollateral` value.",
          "Verify that `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot` is equal to the contract's current `cumulativeCollateralPerUnitCollateral` value."
        ]
      },
      {
        "category": "Total Collateral Validation",
        "rule_descriptions": [
          "Verify that `totalCollateral` has increased by `_amount` compared to its value before the transaction."
        ]
      },
      {
        "category": "NFT Ownership Validation",
        "rule_descriptions": [
          "Verify that `ownerOf(_safeId)` returns `msg.sender`.",
          "Verify that `balanceOf(msg.sender)` has increased by 1 compared to its value before the transaction."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "Check that an `OpenSafe` event was emitted with the correct parameters: `safeId` equal to `_safeId`, `owner` equal to `msg.sender`, `amount` equal to `_amount`, `totalCollateral` equal to the updated `totalCollateral`, and `totalDebt` equal to the current `totalDebt`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Open Safe",
    "contract_name": "StableBaseCDP",
    "function_name": "openSafe",
    "does_register_new_identifier": true,
    "new_identifiers": [
      {
        "name": "_safeId",
        "type": "structured_id_internal",
        "has_max_identifier_limit_per_address": false,
        "max_identifier_limit_per_address": 0,
        "description": "Unique identifier for the Safe (CDP)."
      }
    ],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId]",
            "type": "mapping",
            "what_does_it_track": "The collateral amount, borrowed amount, weight, total borrowed amount, and fee paid for a specific Safe.",
            "why_is_is_important": "This stores the essential details of each Safe, enabling the tracking of collateral, debt, and other relevant parameters.",
            "when_is_it_updated": "When a new Safe is opened and the collateral amount is greater than 0, the msg.value equals amount, the safeId is valid, and the safe does not already exist.",
            "how_to_validate_state_update": "Check that safes[_safeId].collateralAmount equals _amount, safes[_safeId].borrowedAmount equals 0, safes[_safeId].weight equals 0, safes[_safeId].totalBorrowedAmount equals 0, and safes[_safeId].feePaid equals 0.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes a new Safe's data with the provided collateral amount and default values for other parameters.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "liquidationSnapshots[_safeId]",
            "type": "mapping",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral and cumulative collateral per unit collateral at the time the Safe is opened.",
            "why_is_is_important": "Used for liquidation calculations.",
            "when_is_it_updated": "When a new Safe is opened and the collateral amount is greater than 0, the msg.value equals amount, the safeId is valid, and the safe does not already exist.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[_safeId].debtPerCollateralSnapshot equals cumulativeDebtPerUnitCollateral and liquidationSnapshots[_safeId].collateralPerCollateralSnapshot equals cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Stores a snapshot of debt and collateral ratios at the time of opening a Safe.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Keeps track of the total collateral in the protocol, essential for calculating global collateralization ratios and assessing system health.",
            "when_is_it_updated": "When a new Safe is opened and the collateral amount is greater than 0, the msg.value equals amount, the safeId is valid, and the safe does not already exist.",
            "how_to_validate_state_update": "Check that totalCollateral has increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total collateral in the system by the amount deposited in the new Safe.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_owners[tokenId]",
            "type": "mapping",
            "what_does_it_track": "The owner of a specific tokenId, representing a Safe.",
            "why_is_is_important": "Maintains the ownership of each Safe, enabling access control and proper accounting of collateral and debt.",
            "when_is_it_updated": "When a new Safe (CDP) is opened, the collateral amount is greater than 0, the msg.value equals amount, the safeId is valid, and the safe does not already exist, and the token is minted.",
            "how_to_validate_state_update": "Verify that _owners[tokenId] is updated to `to` and that the Transfer event is emitted with the correct parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the owner of the Safe NFT to the message sender.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "to != address(0)",
              "previousOwner == address(0)"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_balances[to]",
            "type": "mapping",
            "what_does_it_track": "The balance of ERC721 tokens owned by an address.",
            "why_is_is_important": "Keeps track of the number of Safes owned by each address.",
            "when_is_it_updated": "When a new Safe (CDP) is opened, the collateral amount is greater than 0, the msg.value equals amount, the safeId is valid, and the safe does not already exist, and the token is minted.",
            "how_to_validate_state_update": "Verify that _balances[to] is incremented by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the token balance of the Safe owner.",
            "conditions": [
              "_amount > 0",
              "msg.value == _amount",
              "_safeId > 0",
              "safes[_safeId].collateralAmount == 0",
              "_ownerOf(_safeId) == address(0)",
              "to != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function openSafe(uint256 _safeId, uint256 _amount) external payable {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(msg.value == _amount, \"Insufficient collateral\");\n        require(_safeId > 0, \"Invalid Safe ID\"); // To avoid race conditions somewhere in the code\n        require(safes[_safeId].collateralAmount == 0, \"Safe already exists\");\n        require(_ownerOf(_safeId) == address(0), \"Safe already exists\");\n\n        Safe memory safe = Safe({\n            collateralAmount: _amount,\n            borrowedAmount: 0,\n            weight: 0,\n            totalBorrowedAmount: 0,\n            feePaid: 0\n        });\n        LiquidationSnapshot memory liquidationSnapshot = LiquidationSnapshot({\n            debtPerCollateralSnapshot: cumulativeDebtPerUnitCollateral,\n            collateralPerCollateralSnapshot: cumulativeCollateralPerUnitCollateral\n        });\n        liquidationSnapshots[_safeId] = liquidationSnapshot;\n        safes[_safeId] = safe;\n        totalCollateral += _amount;\n\n        _safeMint(msg.sender, _safeId); // mint the NFT Safe to the owner\n        emit OpenSafe(_safeId, msg.sender, _amount, totalCollateral, totalDebt);\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\nfunction _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        ERC721Utils.checkOnERC721Received(_msgSender(), address(0), to, tokenId, data);\n    }\nfunction _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}