"{\"action\":{\"name\":\"borrow\",\"summary\":\"Borrow from the protocol\",\"contract_name\":\"StableBaseCDP\",\"function_name\":\"borrow\",\"probability\":1.0},\"action_detail\":{\"action_name\":\"borrow\",\"contract_name\":\"StableBaseCDP\",\"function_name\":\"borrow\",\"pre_execution_parameter_generation_rules\":[\"safeId: User must have an existing safeId. This can be obtained by calling a view function or from events emitted during safe creation.\",\"amount: The amount of SBD tokens the user wishes to borrow. This value must be greater than or equal to MINIMUM_DEBT and should be less than or equal to maxBorrowAmount which can be calculated as ((safe.collateralAmount * price * BASIS_POINTS_DIVISOR) / liquidationRatio) / PRECISION - safe.borrowedAmount.\",\"shieldingRate: The shielding rate (in basis points) the user is willing to pay for the borrow. This affects the position of the safe in the redemption queue.  Should be a non-negative integer.\",\"nearestSpotInLiquidationQueue: The ID of a safe in the liquidation queue to place the new safe near. If the user wants to insert at the head, set this to 0.\",\"nearestSpotInRedemptionQueue: The ID of a safe in the redemption queue to place the new safe near. If the user wants to insert at the head, set this to 0.\"],\"on_execution_state_updates_made\":[{\"category\":\"Safe Data\",\"state_update_descriptions\":[\"safes[safeId].borrowedAmount is increased by amount.\",\"safes[safeId].totalBorrowedAmount is increased by amount.\",\"safes[safeId].feePaid is increased by the shielding fee.\",\"safes[safeId].weight is updated based on the shielding rate and existing borrowings.\"]},{\"category\":\"Doubly Linked Lists\",\"state_update_descriptions\":[\"The safe's position in safesOrderedForRedemption is updated or inserted based on its new weight.\",\"The safe's position in safesOrderedForLiquidation is updated or inserted based on its new ratio (borrowedAmount per unit collateral).\"]},{\"category\":\"Token Minting and Burning\",\"state_update_descriptions\":[\"SBD tokens are minted to the msg.sender (borrower) for the amount borrowed minus shielding fees + any refunds.\",\"Fees are distributed to SBR stakers and the stability pool. SBD tokens might be minted to the contract address.\",\"SBD tokens might be burned from the contract address as refunds.\"]},{\"category\":\"Total Debt\",\"state_update_descriptions\":[\"totalDebt is increased by amount.\"]},{\"category\":\"Cumulative snapshots update\",\"state_update_descriptions\":[\"liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated.\",\"liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated.\",\"totalCollateral may be increased.\",\"totalDebt may be increased.\"]}],\"post_execution_contract_state_validation_rules\":[{\"category\":\"Safe and Token Balances\",\"rule_descriptions\":[\"safes[safeId].borrowedAmount should be equal to the initial borrowedAmount + amount.\",\"safes[safeId].totalBorrowedAmount should be equal to the initial totalBorrowedAmount + amount.\",\"safes[safeId].feePaid should reflect the shielding fee paid.\",\"The user's SBD token balance should increase by the amount borrowed minus shielding fees + any refunds.\",\"Verify safesOrderedForRedemption is correctly updated according to safe.weight.\",\"Verify safesOrderedForLiquidation is correctly updated according to ratio (borrowedAmount * PRECISION) / safe.collateralAmount.\"]},{\"category\":\"System-wide Debt and Collateral\",\"rule_descriptions\":[\"totalDebt should be increased by the amount borrowed.\",\"totalCollateral should remain consistent with the deposited collateral amount.\"]},{\"category\":\"Events\",\"rule_descriptions\":[\"Verify that the Borrowed event is emitted with the correct parameters: safeId, amount, weight, totalCollateral, totalDebt, prev nodes of linked lists.\"]},{\"category\":\"Cumulative snapshots consistency\",\"rule_descriptions\":[\"Validate that total debt is updated if cumulative snapshots are updated.\",\"Validate that total collateral is updated if cumulative snapshots are updated.\"]}]},\"action_execution\":{\"action_name\":\"borrow\",\"contract_name\":\"StableBaseCDP\",\"function_name\":\"borrow\",\"does_register_new_identifier\":false,\"new_identifiers\":[],\"all_state_updates\":[{\"contract_name\":\"StableBaseCDP\",\"state_updated\":[{\"state_variable_name\":\"_safe.borrowedAmount\",\"type\":\"uint256\",\"summary_of_update\":\"Updates the `borrowedAmount` and `totalBorrowedAmount` of a safe based on cumulative debt per unit collateral and liquidation snapshot data. It increases `_safe.borrowedAmount` and `_safe.totalBorrowedAmount` by `debtIncrease`. Also updates `totalCollateral`, `totalDebt` and emits `SafeUpdated` event.\",\"has_conditional_updates\":true,\"conditions\":[\"liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral\"]},{\"state_variable_name\":\"_safe.collateralAmount\",\"type\":\"uint256\",\"summary_of_update\":\"Updates the collateral amount. `_safe.collateralAmount` is increased by `collateralIncrease` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.\",\"has_conditional_updates\":true,\"conditions\":[\"liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral\"]},{\"state_variable_name\":\"liquidationSnapshot.debtPerCollateralSnapshot\",\"type\":\"uint256\",\"summary_of_update\":\"Updates liquidation snapshot data. `liquidationSnapshot.debtPerCollateralSnapshot` is set to `cumulativeDebtPerUnitCollateral` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.\",\"has_conditional_updates\":true,\"conditions\":[\"liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral\"]},{\"state_variable_name\":\"liquidationSnapshot.collateralPerCollateralSnapshot\",\"type\":\"uint256\",\"summary_of_update\":\"Updates liquidation snapshot data. `liquidationSnapshot.collateralPerCollateralSnapshot` is set to `cumulativeCollateralPerUnitCollateral` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.\",\"has_conditional_updates\":true,\"conditions\":[\"liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral\"]},{\"state_variable_name\":\"totalCollateral\",\"type\":\"uint256\",\"summary_of_update\":\"Updates total collateral. `totalCollateral` is increased by `collateralIncrease` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.\",\"has_conditional_updates\":true,\"conditions\":[\"liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral\"]},{\"state_variable_name\":\"totalDebt\",\"type\":\"uint256\",\"summary_of_update\":\"Updates total debt using the internal function `_updateTotalDebt`. Updates the `totalDebt` based on current debt, delta, and whether to add or subtract. It updates `PROTOCOL_MODE` if `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`.\",\"has_conditional_updates\":true,\"conditions\":[\"liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral\"]},{\"state_variable_name\":\"safe.weight\",\"type\":\"uint256\",\"summary_of_update\":\"Updates the safe's `weight` based on shielding rate and existing borrowings. If `safe.borrowedAmount == 0` and `_minFeeWeightNode == 0`, sets `safe.weight = shieldingRate`. If `safe.borrowedAmount == 0` and `_minFeeWeightNode != 0`, sets `safe.weight = _minFeeWeight + shieldingRate`. If `safe.borrowedAmount != 0`, updates `safe.weight` based on a weighted average of the existing weight and the shielding rate.\",\"has_conditional_updates\":true,\"conditions\":[\"safe.borrowedAmount == 0\",\"_minFeeWeightNode == 0\",\"safe.borrowedAmount == 0\",\"_minFeeWeightNode != 0\",\"safe.borrowedAmount != 0\"]},{\"state_variable_name\":\"safe.borrowedAmount\",\"type\":\"uint256\",\"summary_of_update\":\"Increases the safe's `borrowedAmount` by the borrowed `amount`.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"safe.totalBorrowedAmount\",\"type\":\"uint256\",\"summary_of_update\":\"Increases the safe's `totalBorrowedAmount` by the borrowed `amount`.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"safe.feePaid\",\"type\":\"uint256\",\"summary_of_update\":\"Increases the safe's `feePaid` by the shielding fee `_shieldingFee`.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"feePaid\",\"type\":\"uint256\",\"summary_of_update\":\"Calls the `distributeFees` function, which mints SBD tokens to the contract, transfers fees to the `dfireTokenStaking` and `stabilityPool` contracts, and potentially burns refunded fees. Updates `sbrStakersFee`, `stabilityPoolFee` and `canRefund`.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"sbdToken\",\"type\":\"uint256\",\"summary_of_update\":\"Mints SBD tokens to the borrower using `sbdToken.mint`, increasing the borrower's balance.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"totalDebt\",\"type\":\"uint256\",\"summary_of_update\":\"Updates the total debt using the internal function `_updateTotalDebt`.Updates the `totalDebt` based on current debt, delta, and whether to add or subtract. It updates `PROTOCOL_MODE` if `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`.\",\"has_conditional_updates\":false,\"conditions\":[]}]},{\"contract_name\":\"IDoublyLinkedList\",\"state_updated\":[{\"state_variable_name\":\"safesOrderedForRedemption\",\"type\":\"IDoublyLinkedList.Node\",\"summary_of_update\":\"Upserts the safe into the redemption queue using `safesOrderedForRedemption.upsert` with the safe's ID, weight, and nearest spot, which can modify the state of the external IDoublyLinkedList contract.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"safesOrderedForLiquidation\",\"type\":\"IDoublyLinkedList.Node\",\"summary_of_update\":\"Upserts the safe into the liquidation queue using `safesOrderedForLiquidation.upsert` with the safe's ID, borrow ratio, and nearest spot, which can modify the state of the external IDoublyLinkedList contract.\",\"has_conditional_updates\":false,\"conditions\":[]}]},{\"contract_name\":\"DFIREStaking\",\"state_updated\":[{\"state_variable_name\":\"rewardToken\",\"type\":\"uint256\",\"summary_of_update\":\"Transfers reward tokens from the `msg.sender` to the contract, increasing the contract's balance. This function does not distribute rewards.\",\"has_conditional_updates\":true,\"conditions\":[\"_totalStake == 0\"]},{\"state_variable_name\":\"totalRewardPerToken\",\"type\":\"uint256\",\"summary_of_update\":\"Updates the total reward per token in the staking contract. `totalRewardPerToken` increases if `_totalStake != 0`. This function does not distribute rewards.\",\"has_conditional_updates\":true,\"conditions\":[\"_totalStake == 0\"]}]},{\"contract_name\":\"StabilityPool\",\"state_updated\":[{\"state_variable_name\":\"stakingToken\",\"type\":\"uint256\",\"summary_of_update\":\"Transfers staking tokens from the `msg.sender` to the contract, increasing the contract's balance. Updates `totalRewardPerToken`, `rewardLoss`,  `totalSbrRewardPerToken`,`lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime`, and `sbrRewardDistributionStatus` if rewards are distributed.\",\"has_conditional_updates\":true,\"conditions\":[]},{\"state_variable_name\":\"totalRewardPerToken\",\"type\":\"uint256\",\"summary_of_update\":\"Updates reward-related variables. This function does not distribute rewards. If `_totalStakedRaw != 0`, `totalRewardPerToken` is updated. Updates `rewardLoss`, `totalRewardPerToken`, `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime`, `sbrRewardDistributionStatus` and `totalSbrRewardPerToken`.\",\"has_conditional_updates\":true,\"conditions\":[\"_totalStakedRaw == 0\"]}]},{\"contract_name\":\"DFIDToken\",\"state_updated\":[{\"state_variable_name\":\"_balances\",\"type\":\"mapping(address => uint256)\",\"summary_of_update\":\"Updates `_balances` when minting and burning tokens. Calls `_update` internal function.\",\"has_conditional_updates\":false,\"conditions\":[]},{\"state_variable_name\":\"_totalSupply\",\"type\":\"uint256\",\"summary_of_update\":\"Updates `_totalSupply` when minting and burning tokens. Calls `_update` internal function.\",\"has_conditional_updates\":false,\"conditions\":[]}]}]}}"