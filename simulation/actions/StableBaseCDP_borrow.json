{
  "action": {
    "name": "borrow",
    "summary": "Borrow from the protocol",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "probability": 1.0
  },
  "action_detail": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "safeId: Needs to be a valid, existing safeId in the safes mapping.",
      "amount: The amount of SBD tokens the user wants to borrow. Should be greater than MINIMUM_DEBT when added to the existing debt. The resulting debt (safe.borrowedAmount + amount) must be less than or equal to the maximum borrowable amount calculated based on collateral and liquidationRatio.",
      "shieldingRate: A percentage (in basis points) representing the fee the user is willing to pay for shielding. Must be less than or equal to BASIS_POINTS_DIVISOR.",
      "nearestSpotInLiquidationQueue: A valid safeId representing the nearest spot in the liquidation queue. Can be 0.",
      "nearestSpotInRedemptionQueue: A valid safeId representing the nearest spot in the redemption queue. Can be 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId].borrowedAmount increases by amount.",
          "safes[safeId].totalBorrowedAmount increases by amount.",
          "safes[safeId].weight is updated based on shieldingRate and existing minimum fee weight. The weight update depends on whether it is the first time borrowing (safe.borrowedAmount == 0) or not, and on the existence and value of the minimum fee weight node.",
          "safes[safeId].feePaid increases by shieldingFee."
        ]
      },
      {
        "category": "Doubly Linked List State",
        "state_update_descriptions": [
          "safesOrderedForRedemption is updated with the new safeId and weight via upsert.",
          "safesOrderedForLiquidation is updated with the new safeId and ratio via upsert."
        ]
      },
      {
        "category": "Token State",
        "state_update_descriptions": [
          "SBD tokens are minted to the borrower (msg.sender) by _amountToBorrow.",
          "Contract might mint and burn SBD tokens to distribute fees"
        ]
      },
      {
        "category": "Total Debt State",
        "state_update_descriptions": [
          "totalDebt increases by amount via the _updateTotalDebt function."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "DFIREStaking contract may receive rewards based on SBR_FEE_REWARD.",
          "StabilityPool contract may receive rewards.",
          "The contract might burn canRefund amount of SBD token.",
          "The contract might mint fee amount of SBD token.",
          "The contract's SBD balance should reflect the fees distributed and refunded. Call sbdToken.balanceOf(address(this)) to check the balance."
        ]
      },
      {
        "category": "Liquidation Snapshots",
        "state_update_descriptions": [
          "liquidationSnapshots[_safeId] is updated with current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral. This happens inside _updateSafe() function which is called at the begining."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "totalCollateral may increase if there is a collateralIncrease in _updateSafe() function"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be increased by amount after borrow.",
          "safes[safeId].totalBorrowedAmount should be increased by amount after borrow.",
          "safes[safeId].feePaid should be increased by the shielding fee calculated from amount and shieldingRate.",
          "The ownerOf(safeId) should remain the same after the borrow operation."
        ]
      },
      {
        "category": "Doubly Linked List State",
        "rule_descriptions": [
          "The safesOrderedForRedemption should contain the safeId with the updated weight.",
          "The safesOrderedForLiquidation should contain the safeId with the updated ratio.",
          "Check the prev and next node are updated correctly in the doubly linked lists."
        ]
      },
      {
        "category": "Token State",
        "rule_descriptions": [
          "The balance of msg.sender in sbdToken should be increased by the borrowed amount after fee deduction and potential refund."
        ]
      },
      {
        "category": "Total Debt State",
        "rule_descriptions": [
          "totalDebt should be increased by amount after borrow."
        ]
      },
      {
        "category": "Invariants",
        "rule_descriptions": [
          "totalCollateral should be greater than or equal to totalDebt at all times.",
          "The contract's SBD balance should reflect the fees distributed and refunded. Call sbdToken.balanceOf(address(this)) to check."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "summary_of_update": "Updates the borrowed amount and total borrowed amount of the safe if the liquidation snapshot is outdated.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.totalBorrowedAmount",
            "type": "uint256",
            "summary_of_update": "Updates the totalBorrowedAmount within the safe.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.debtPerCollateralSnapshot",
            "type": "uint256",
            "summary_of_update": "Updates the cumulativeDebtPerUnitCollateral in the liquidationSnapshot struct",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "summary_of_update": "Increases collateral amount if the cumulativeCollateralPerUnitCollateral has changed.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.collateralPerCollateralSnapshot",
            "type": "uint256",
            "summary_of_update": "Update collateralPerCollateralSnapshot to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "summary_of_update": "Increase totalCollateral if there is collateral increase.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "summary_of_update": "Update totalDebt, potentially changing the protocol mode.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "summary_of_update": "Updates the weight of the safe if it is the first time borrowing, determining the new fee weight based on existing minimum fee weight or setting it to the shielding rate.",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "summary_of_update": "Updates the safe's weight by adding the shielding rate to the minimum fee weight of redemption queue",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode != 0"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "summary_of_update": "Update safe's weight by shield rate",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount != 0",
              "shieldingRate > 0"
            ]
          },
          {
            "state_variable_name": "safe.borrowedAmount",
            "type": "uint256",
            "summary_of_update": "Increase borrowed amount for the safe",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safe.totalBorrowedAmount",
            "type": "uint256",
            "summary_of_update": "Increase total borrowed amount for the safe.",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safe.feePaid",
            "type": "uint256",
            "summary_of_update": "Increase the fee paid by the safe",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "summary_of_update": "Updates the linked list safesOrderedForRedemption",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "summary_of_update": "Update the linked list safesOrderedForLiquidation.",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "sbdToken",
            "type": "IMintableToken",
            "summary_of_update": "Distributes fees and potentially refunds some amount, updating external contracts and burning tokens if necessary.",
            "has_conditional_updates": true,
            "conditions": [
              "_shieldingFee > 0"
            ]
          },
          {
            "state_variable_name": "dfireTokenStaking",
            "type": "IDFIREStaking",
            "summary_of_update": "Updates the DFIRE staking contract by adding reward",
            "has_conditional_updates": true,
            "conditions": [
              "_shieldingFee > 0"
            ]
          },
          {
            "state_variable_name": "stabilityPool",
            "type": "IStabilityPool",
            "summary_of_update": "Update the stability pool rewards",
            "has_conditional_updates": true,
            "conditions": [
              "_shieldingFee > 0"
            ]
          },
          {
            "state_variable_name": "sbdToken",
            "type": "IMintableToken",
            "summary_of_update": "Mints SBD tokens to the borrower",
            "has_conditional_updates": false,
            "conditions": [
              "sbdToken.mint(msg.sender, _amountToBorrow) is successful"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "summary_of_update": "Updates the total debt.",
            "has_conditional_updates": false,
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "uint256",
            "summary_of_update": "Updates the head of the list",
            "has_conditional_updates": true,
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "summary_of_update": "Updates the tail of the linked list",
            "has_conditional_updates": true,
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].next",
            "type": "uint256",
            "summary_of_update": "Updates the next node of the linked list",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].prev",
            "type": "uint256",
            "summary_of_update": "Updates the previous node of the linked list",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "summary_of_update": "Updates the head of the list",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].next",
            "type": "uint256",
            "summary_of_update": "Updates next node",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value < node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "summary_of_update": "Updates tail node",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value < node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].prev",
            "type": "uint256",
            "summary_of_update": "Updates the previous node of the nearest spot",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value < node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].next",
            "type": "uint256",
            "summary_of_update": "Updates the next node of the nearest spot.",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "summary_of_update": "Updates the tail of the linked list",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].prev",
            "type": "uint256",
            "summary_of_update": "Updates the previous node",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].next",
            "type": "uint256",
            "summary_of_update": "Updates the next node",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].prev",
            "type": "uint256",
            "summary_of_update": "Updates the previous node",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "summary_of_update": "Updates the head of the linked list",
            "has_conditional_updates": true,
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "nodes[_nearestSpot].next",
            "type": "uint256",
            "summary_of_update": "Update the next node",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "nodes[node.next].prev",
            "type": "uint256",
            "summary_of_update": "Update the prev node",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "Node",
            "summary_of_update": "Updates the node in the list",
            "has_conditional_updates": false,
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "sbdToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[to]",
            "type": "uint256",
            "summary_of_update": "Mints new tokens, increasing the total supply and updating the balance of the recipient.",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "summary_of_update": "Increases the total supply of the token.",
            "has_conditional_updates": false,
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "summary_of_update": "Updates totalRewardPerToken if the total stake is greater than zero.",
            "has_conditional_updates": true,
            "conditions": [
              "_totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "summary_of_update": "Update totalRewardPerToken in the stability pool when the total staked is greater than zero.",
            "has_conditional_updates": true,
            "conditions": [
              "_totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "rewardLoss",
            "type": "uint256",
            "summary_of_update": "Update rewardLoss in the stability pool when total staked is greater than zero.",
            "has_conditional_updates": true,
            "conditions": [
              "_totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "summary_of_update": "Update SBR rewards if sbrRewardDistributionStatus is not ended.",
            "has_conditional_updates": true,
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "summary_of_update": "Update sbrRewardLoss if sbrRewardDistributionStatus is not ended and totalStakedRaw > 0.",
            "has_conditional_updates": true,
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "summary_of_update": "Updates the lastSBRRewardDistributedTime if sbrRewardDistributionStatus is started",
            "has_conditional_updates": true,
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "summary_of_update": "Updates the lastSBRRewardDistributedTime if sbrRewardDistributionStatus is not ended",
            "has_conditional_updates": true,
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "summary_of_update": "Updates the sbrRewardDistributionEndTime and sbrRewardDistributionStatus.",
            "has_conditional_updates": true,
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "summary_of_update": "Updates the sbrRewardDistributionEndTime and sbrRewardDistributionStatus.",
            "has_conditional_updates": true,
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          }
        ]
      }
    ]
  }
}