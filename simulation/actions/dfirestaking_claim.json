{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their accumulated rewards.",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [],
    "on_execution_state_updates_made": [
      {
        "category": "DFIREStaking Contract State Updates",
        "state_update_descriptions": [
          "The 'rewardSnapshot' for the caller's stake in the DFIREStaking contract is updated to the current 'totalRewardPerToken'.",
          "The 'collateralSnapshot' for the caller's stake in the DFIREStaking contract is updated to the current 'totalCollateralPerToken'."
        ]
      },
      {
        "category": "Token Balances Updates",
        "state_update_descriptions": [
          "The calculated 'reward' amount of DFIDToken is transferred from the DFIREStaking contract to the caller's address. This decreases the DFIDToken balance of the DFIREStaking contract and increases the DFIDToken balance of the caller.",
          "The calculated 'collateralReward' amount of native currency (ETH) is transferred from the DFIREStaking contract to the caller's address. This decreases the ETH balance of the DFIREStaking contract and increases the ETH balance of the caller."
        ]
      },
      {
        "category": "Event Emissions",
        "state_update_descriptions": [
          "A 'Claimed' event is emitted, indicating the user who claimed, the amount of rewardToken claimed, and the amount of collateral reward (ETH) claimed."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "DFIREStaking Contract State Validation",
        "rule_descriptions": [
          "The 'rewardSnapshot' for the caller's stake in the DFIREStaking contract must be equal to the 'totalRewardPerToken' at the time of execution.",
          "The 'collateralSnapshot' for the caller's stake in the DFIREStaking contract must be equal to the 'totalCollateralPerToken' at the time of execution."
        ]
      },
      {
        "category": "Token Balance Validation",
        "rule_descriptions": [
          "The DFIDToken balance of the caller's address must have increased by the exact 'reward' amount calculated ((((DFIREStaking.totalRewardPerToken - DFIREStaking.stakes[msg.sender].rewardSnapshot_BEFORE_EXECUTION) * DFIREStaking.stakes[msg.sender].stake_BEFORE_EXECUTION) / DFIREStaking.PRECISION)).",
          "The DFIDToken balance of the DFIREStaking contract must have decreased by the exact 'reward' amount calculated ((((DFIREStaking.totalRewardPerToken - DFIREStaking.stakes[msg.sender].rewardSnapshot_BEFORE_EXECUTION) * DFIREStaking.stakes[msg.sender].stake_BEFORE_EXECUTION) / DFIREStaking.PRECISION))."
        ]
      },
      {
        "category": "Native Currency Balance Validation",
        "rule_descriptions": [
          "The native currency (ETH) balance of the caller's address must have increased by the exact 'collateralReward' amount calculated ((((DFIREStaking.totalCollateralPerToken - DFIREStaking.stakes[msg.sender].collateralSnapshot_BEFORE_EXECUTION) * DFIREStaking.stakes[msg.sender].stake_BEFORE_EXECUTION) / DFIREStaking.PRECISION)), accounting for gas costs.",
          "The native currency (ETH) balance of the DFIREStaking contract must have decreased by the exact 'collateralReward' amount calculated ((((DFIREStaking.totalCollateralPerToken - DFIREStaking.stakes[msg.sender].collateralSnapshot_BEFORE_EXECUTION) * DFIREStaking.stakes[msg.sender].stake_BEFORE_EXECUTION) / DFIREStaking.PRECISION))."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "A 'Claimed' event must be emitted with the following arguments:",
          "- 'user': should be the address of the transaction sender (msg.sender).",
          "- 'rewardAmount': should be the exact 'reward' amount calculated ((((DFIREStaking.totalRewardPerToken - DFIREStaking.stakes[msg.sender].rewardSnapshot_BEFORE_EXECUTION) * DFIREStaking.stakes[msg.sender].stake_BEFORE_EXECUTION) / DFIREStaking.PRECISION)).",
          "- 'collateralReward': should be the exact 'collateralReward' amount calculated ((((DFIREStaking.totalCollateralPerToken - DFIREStaking.stakes[msg.sender].collateralSnapshot_BEFORE_EXECUTION) * DFIREStaking.stakes[msg.sender].stake_BEFORE_EXECUTION) / DFIREStaking.PRECISION))."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping(address => struct IDFIREStaking.Stake)",
            "what_does_it_track": "The 'rewardSnapshot' component of the 'Stake' struct for each user, which records the value of 'totalRewardPerToken' at the last interaction (stake, unstake, or claim). This is used to calculate pending DFI rewards.",
            "why_is_is_important": "It is crucial for preventing users from claiming the same rewards multiple times and for accurately calculating the new rewards accumulated since the last interaction.",
            "when_is_it_updated": "Whenever a user calls the 'claim' function.",
            "how_to_validate_state_update": "The 'rewardSnapshot' for the 'msg.sender' in the 'stakes' mapping should be updated to the current value of 'totalRewardPerToken'.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's 'rewardSnapshot' is updated to reflect the `totalRewardPerToken` at the time of claiming, ensuring that future reward calculations are based on the correct starting point.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes",
            "type": "mapping(address => struct IDFIREStaking.Stake)",
            "what_does_it_track": "The 'collateralSnapshot' component of the 'Stake' struct for each user, which records the value of 'totalCollateralPerToken' at the last interaction (stake, unstake, or claim). This is used to calculate pending collateral rewards (native token).",
            "why_is_is_important": "It is crucial for preventing users from claiming the same collateral rewards multiple times and for accurately calculating the new collateral rewards accumulated since the last interaction.",
            "when_is_it_updated": "Whenever a user calls the 'claim' function.",
            "how_to_validate_state_update": "The 'collateralSnapshot' for the 'msg.sender' in the 'stakes' mapping should be updated to the current value of 'totalCollateralPerToken'.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's 'collateralSnapshot' is updated to reflect the `totalCollateralPerToken` at the time of claiming, ensuring that future collateral reward calculations are based on the correct starting point.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The balance of DFID (reward) tokens held by each address.",
            "why_is_is_important": "This ensures that users receive their accumulated DFID token rewards and that the token supply distribution is correctly reflected after a claim.",
            "when_is_it_updated": "Conditionally, if the calculated reward for the user is greater than zero.",
            "how_to_validate_state_update": "The balance of 'DFIREStaking' contract for DFIDToken should decrease by 'reward' amount, and the 'msg.sender''s balance for DFIDToken should increase by 'reward' amount.",
            "has_conditional_updates": true,
            "summary_of_update": "If the calculated 'reward' for the user is greater than zero, the corresponding amount of DFID tokens is transferred from the DFIREStaking contract's balance to the user's balance.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "Native Token (e.g., ETH/BNB)",
        "state_updated": [
          {
            "state_variable_name": "Native Token Balance",
            "type": "uint256",
            "what_does_it_track": "The native token (collateral) balance of each address on the blockchain.",
            "why_is_is_important": "This ensures that users receive their accumulated native token collateral rewards and that the balance of the contract and user reflects the transfer.",
            "when_is_it_updated": "Conditionally, if the calculated collateral reward for the user is greater than zero.",
            "how_to_validate_state_update": "The native token balance of the 'DFIREStaking' contract should decrease by 'collateralReward' amount, and the 'msg.sender''s native token balance should increase by 'collateralReward' amount.",
            "has_conditional_updates": true,
            "summary_of_update": "If the calculated 'collateralReward' for the user is greater than zero, the corresponding amount of native tokens (e.g., ETH/BNB) is transferred from the DFIREStaking contract's balance to the user's address.",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function claim() external {\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}