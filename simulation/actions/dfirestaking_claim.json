{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their accumulated rewards.",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "The user must have an existing stake in the DFIREStaking contract (stakes[msg.sender].stake > 0).",
      "The contract must have a positive totalRewardPerToken and/or totalCollateralPerToken to allow for rewards to be claimed.",
      "The DFIREStaking contract must have a sufficient rewardToken balance to cover the claimable rewards.",
      "The user's rewardSnapshot and collateralSnapshot should be less than or equal to totalRewardPerToken and totalCollateralPerToken respectively to prevent negative reward calculations."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Reward Snapshot Update",
        "state_update_descriptions": [
          "The user's reward snapshot is updated to the current total reward per token.",
          "The user's collateral snapshot is updated to the current total collateral per token."
        ]
      },
      {
        "category": "Reward Token Transfer",
        "state_update_descriptions": [
          "The reward token is transferred from the contract to the user.",
          "The amount transferred is calculated as ((totalRewardPerToken - user.rewardSnapshot) * user.stake) / PRECISION."
        ]
      },
      {
        "category": "Collateral Reward Transfer",
        "state_update_descriptions": [
          "Collateral reward (ETH) is transferred from the contract to the user.",
          "The amount transferred is calculated as ((totalCollateralPerToken - user.collateralSnapshot) * user.stake) / PRECISION."
        ]
      },
      {
        "category": "Event Emission",
        "state_update_descriptions": [
          "A Claimed event is emitted, including the user's address, reward amount, and collateral reward amount."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Reward Snapshot",
        "rule_descriptions": [
          "stakes[msg.sender].rewardSnapshot should be equal to the contract's totalRewardPerToken after the claim.",
          "stakes[msg.sender].collateralSnapshot should be equal to the contract's totalCollateralPerToken after the claim."
        ]
      },
      {
        "category": "Reward Token Balance",
        "rule_descriptions": [
          "The user's rewardToken balance should increase by the reward amount calculated before claim execution. The calculated reward amount must be non-negative.",
          "If collateralReward > 0, then msg.sender's ETH balance should increase by the collateralReward amount. The calculated collateralReward amount must be non-negative."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the reward snapshot per user.",
            "why_is_is_important": "Used to calculate the reward that the user is entitled to when claim function is called next time. ",
            "when_is_it_updated": "Always updated when the claim function is called.",
            "how_to_validate_state_update": "Verify that the user.rewardSnapshot is updated to totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "The rewardSnapshot for the user is updated to the current totalRewardPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral snapshot per user.",
            "why_is_is_important": "Used to calculate the collateral reward that the user is entitled to when claim function is called next time.",
            "when_is_it_updated": "Always updated when the claim function is called.",
            "how_to_validate_state_update": "Verify that the user.collateralSnapshot is updated to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "The collateralSnapshot for the user is updated to the current totalCollateralPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "rewardToken.balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of reward tokens owned by the user.",
            "why_is_is_important": "Reflects the user's current reward balance after claiming rewards, and necessary for subsequent transfers involving the reward token. The balance is from rewardToken contract which is an ERC20 contract",
            "when_is_it_updated": "When the reward is greater than 0, after calculating the reward amount.",
            "how_to_validate_state_update": "Check if the balance of the msg.sender in the rewardToken contract has increased by the amount of reward.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of the msg.sender in the rewardToken contract is increased by the amount of reward.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "msg.sender.balance",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral reward the user has in the native token.",
            "why_is_is_important": "Reflects the user's current native token balance after claiming collateral rewards. This is native token balance of the user (eg ETH, AVAX, etc.)",
            "when_is_it_updated": "When the collateralReward is greater than 0, after calculating the collateral reward amount.",
            "how_to_validate_state_update": "Check if the balance of the msg.sender has increased by the collateralReward.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of the msg.sender is increased by the collateralReward amount.",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "Tracks the balance of reward tokens for the msg.sender in the DFIDToken contract.",
            "why_is_is_important": "Reflects the updated balance of reward tokens for the user after claiming.",
            "when_is_it_updated": "When reward > 0 and the transfer is successful.",
            "how_to_validate_state_update": "Verify that the reward tokens are transferred from the contract to the msg.sender.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of msg.sender is increased by reward.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "balanceOf(DFIREStaking)",
            "type": "uint256",
            "what_does_it_track": "Tracks the balance of reward tokens for the DFIREStaking contract.",
            "why_is_is_important": "Reflects the updated balance of reward tokens in the staking contract after transfer.",
            "when_is_it_updated": "When reward > 0 and the transfer is successful.",
            "how_to_validate_state_update": "Verify that the reward tokens are transferred from the contract to the msg.sender.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of DFIREStaking contract is decreased by reward.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function claim() external {\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}