{
  "action": {
    "name": "Claim",
    "summary": "Allows a user to claim their accumulated rewards.",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Claim",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "pre_execution_parameter_generation_rules": [
      "User must have staked tokens",
      "totalRewardPerToken and/or totalCollateralPerToken must be positive",
      "Contract must have sufficient rewardToken balance",
      "Contract must have sufficient ETH balance"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Rewards and Snapshots",
        "state_update_descriptions": [
          "Update user's rewardSnapshot to totalRewardPerToken",
          "Update user's collateralSnapshot to totalCollateralPerToken",
          "Transfer reward tokens from contract to user",
          "Transfer collateral reward (ETH) from contract to user"
        ]
      },
      {
        "category": "Contract-level Accounting",
        "state_update_descriptions": [
          "Potentially update totalRewardPerToken (if rewards are added concurrently)",
          "Potentially update totalCollateralPerToken (if collateral rewards are added concurrently)",
          "Decrease contract's rewardToken balance",
          "Decrease contract's ETH balance"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User State Validation",
        "rule_descriptions": [
          "user.rewardSnapshot == totalRewardPerToken",
          "user.collateralSnapshot == totalCollateralPerToken",
          "User's rewardToken balance increased by rewardAmount (considering slippage/fees)",
          "User's ETH balance increased by collateralReward (considering slippage/fees)"
        ]
      },
      {
        "category": "Contract State Validation",
        "rule_descriptions": [
          "totalRewardPerToken remains same (unless concurrent reward additions)",
          "totalCollateralPerToken remains same (unless concurrent collateral reward additions)",
          "Contract's rewardToken balance decreased by rewardAmount (considering slippage/fees)",
          "Contract's ETH balance decreased by collateralReward (considering slippage/fees)"
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "Claimed event emitted with correct user, rewardAmount, collateralReward",
          "If rewardAmount > 0, Transfer event emitted from DFIREStaking to user on rewardToken"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Claim",
    "contract_name": "DFIREStaking",
    "function_name": "claim",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender]",
            "type": "struct",
            "what_does_it_track": "Tracks the staking information for each user, including their stake, reward snapshot, and collateral snapshot.",
            "why_is_is_important": "It is important for tracking the user's reward accrual and preventing double claiming. It also facilitates the correct distribution of rewards to the users. The collateral rewards are sent as ETH to the user's address using a call function with value attached. ",
            "when_is_it_updated": "This state is updated when a user claims their rewards.",
            "how_to_validate_state_update": "Check the user's stake structure to see if rewardSnapshot and collateralSnapshot are updated to totalRewardPerToken and totalCollateralPerToken respectively. Verify the user's balance for rewardToken and collateral (ETH) has increased by reward and collateralReward amounts, respectively.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the rewardSnapshot and collateralSnapshot values within the user's stake structure. `reward` is calculated as `((totalRewardPerToken - user.rewardSnapshot) * user.stake) / PRECISION`. `collateralReward` is calculated as `((totalCollateralPerToken - user.collateralSnapshot) * user.stake) / PRECISION`. If rewards are greater than 0 the rewardToken is transferred to the msg.sender and if collateralRewards are greater than 0 collateralReward (in ETH) is transferred to the msg.sender using `msg.sender.call{value: collateralReward}(\"\")`.",
            "conditions": []
          },
          {
            "state_variable_name": "rewardToken.balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "Tracks the balance of reward tokens for the user.",
            "why_is_is_important": "This ensures the user receives the correct amount of reward tokens.",
            "when_is_it_updated": "This is updated when the user claims their reward and if the calculated reward is greater than 0.",
            "how_to_validate_state_update": "Check the user's balance of rewardToken has increased by 'reward' amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The rewardToken balance of the msg.sender increases by the amount of 'reward'.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "msg.sender (ETH balance)",
            "type": "uint256",
            "what_does_it_track": "Tracks the ETH balance of the msg.sender.",
            "why_is_is_important": "This ensures the user receives the correct amount of collateral reward in ETH.",
            "when_is_it_updated": "This is updated when the user claims their collateral reward and if the calculated collateral reward is greater than 0.",
            "how_to_validate_state_update": "Check the user's ETH balance increases by the `collateralReward` amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The ETH balance of the msg.sender increases by the amount of 'collateralReward', transferred via `msg.sender.call{value: collateralReward}(\"\")`.",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function claim() external {\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}