{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "The 'safeId' must correspond to an existing CDP owned by the transaction sender.",
      "The CDP identified by 'safeId' must have an outstanding 'borrowedAmount' greater than 0.",
      "The 'amount' must be a positive integer representing the SBD tokens to repay.",
      "The transaction sender must have a SBD token balance (queried via 'sbdToken.balanceOf(msg.sender)') greater than or equal to the specified 'amount'.",
      "The 'amount' must be less than or equal to the current 'borrowedAmount' of the CDP (queried from 'safes[safeId].borrowedAmount').",
      "After repayment, the remaining 'borrowedAmount' of the CDP must either be 0 or greater than or equal to the 'MINIMUM_DEBT' value (which can be queried from the 'StableBaseCDP' contract).",
      "The 'nearestSpotInLiquidationQueue' can be 0. If a non-zero value is provided, it should be a 'safeId' that exists within the 'safesOrderedForLiquidation' linked list and is numerically 'close' to the expected new collateralization ratio of the CDP to optimize gas usage for list operations."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "CDP State Updates",
        "state_update_descriptions": [
          "The 'borrowedAmount' of the specified CDP ('safes[safeId].borrowedAmount') is first increased to account for any accrued debt since the last update, and then decreased by the 'amount' repaid.",
          "The 'collateralAmount' of the specified CDP ('safes[safeId].collateralAmount') is increased to account for any accrued collateral since the last update.",
          "The 'totalBorrowedAmount' of the specified CDP ('safes[safeId].totalBorrowedAmount') is increased by any accrued debt.",
          "The 'collateralPerCollateralSnapshot' in 'liquidationSnapshots[safeId]' is updated to the current 'cumulativeCollateralPerUnitCollateral'.",
          "The 'debtPerCollateralSnapshot' in 'liquidationSnapshots[safeId]' is updated to the current 'cumulativeDebtPerUnitCollateral'."
        ]
      },
      {
        "category": "Global Protocol State Updates",
        "state_update_descriptions": [
          "The 'totalCollateral' is increased by any accrued collateral for the specific CDP.",
          "The 'totalDebt' is increased by any accrued debt for the specific CDP, and then decreased by the 'amount' repaid.",
          "The 'PROTOCOL_MODE' may change from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD' during the debt increase step."
        ]
      },
      {
        "category": "Token Balance Updates",
        "state_update_descriptions": [
          "The SBD token balance of the transaction sender (msg.sender) is decreased by the 'amount'.",
          "The total supply of SBD tokens ('sbdToken.totalSupply') is decreased by the 'amount'.",
          "The 'totalBurned' counter in the 'DFIDToken' contract is increased by the 'amount'."
        ]
      },
      {
        "category": "Liquidation Queue Updates",
        "state_update_descriptions": [
          "If the CDP's new collateralization ratio is not zero after repayment, the CDP's position in the 'safesOrderedForLiquidation' linked list is updated or re-inserted (via 'upsert') to reflect its new ratio, potentially modifying 'nodes', 'head', or 'tail' of the list.",
          "If the CDP's new collateralization ratio is zero (debt fully repaid), the CDP is removed from the 'safesOrderedForLiquidation' linked list, updating 'nodes', 'head', or 'tail'."
        ]
      },
      {
        "category": "Redemption Queue Updates",
        "state_update_descriptions": [
          "If the CDP's new collateralization ratio is zero (debt fully repaid), the CDP is removed from the 'safesOrderedForRedemption' linked list, updating 'nodes', 'head', or 'tail'."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "CDP State Validation",
        "rule_descriptions": [
          "The 'borrowedAmount' of the 'safeId' in 'safes' must be equal to its original 'borrowedAmount' (after accounting for any accrual via '_updateSafe') minus the 'amount' repaid.",
          "The 'collateralAmount' of the 'safeId' in 'safes' must reflect any accrued collateral (via '_updateSafe').",
          "The 'liquidationSnapshots[safeId].collateralPerCollateralSnapshot' must be equal to the 'cumulativeCollateralPerUnitCollateral' of the 'StableBaseCDP' contract after the transaction.",
          "The 'liquidationSnapshots[safeId].debtPerCollateralSnapshot' must be equal to the 'cumulativeDebtPerCollateral' of the 'StableBaseCDP' contract after the transaction.",
          "If the 'borrowedAmount' of the CDP becomes 0, the CDP must no longer exist in the 'safesOrderedForLiquidation' and 'safesOrderedForRedemption' linked lists.",
          "If the 'borrowedAmount' of the CDP is still greater than 0, its position within the 'safesOrderedForLiquidation' linked list must accurately reflect its new collateralization ratio."
        ]
      },
      {
        "category": "Global Protocol State Validation",
        "rule_descriptions": [
          "The 'totalCollateral' in 'StableBaseCDP' must be updated by any accrued collateral for the specific CDP.",
          "The 'totalDebt' in 'StableBaseCDP' must be updated by any accrued debt for the specific CDP and then decreased by the 'amount' repaid.",
          "The 'PROTOCOL_MODE' must reflect any changes if 'totalDebt' crossed the 'BOOTSTRAP_MODE_DEBT_THRESHOLD'."
        ]
      },
      {
        "category": "Token Balance Validation",
        "rule_descriptions": [
          "The SBD token balance of the transaction sender (msg.sender) must be reduced by the specified 'amount'.",
          "The 'sbdToken.totalSupply' must be reduced by the specified 'amount'.",
          "The 'sbdToken.totalBurned' must be increased by the specified 'amount'."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "A 'Repaid' event must be emitted by the 'StableBaseCDP' contract, containing the correct 'safeId', 'amount', 'newRatio', 'totalCollateral', and 'totalDebt'.",
          "A 'SafeUpdated' event must be emitted by the 'StableBaseCDP' contract, with correct 'safeId', 'collateralAmount', 'debtAmount', 'collateralIncrease', 'debtIncrease', 'totalCollateral', and 'totalDebt' if the CDP's state was updated via '_updateSafe'.",
          "A 'Burn' event must be emitted by the 'sbdToken' (DFIDToken) contract, with 'from' as 'msg.sender' and the correct 'amount'.",
          "If the CDP's borrowed amount becomes zero after repayment, a 'SafeRemovedFromLiquidationQueue' event must be emitted by 'StableBaseCDP' with the 'safeId'.",
          "If the CDP's borrowed amount becomes zero after repayment, a 'SafeRemovedFromRedemptionQueue' event must be emitted by 'StableBaseCDP' with the 'safeId'.",
          "If the CDP's borrowed amount remains greater than zero after repayment, a 'LiquidationQueueUpdated' event must be emitted by 'StableBaseCDP' with the correct 'safeId', 'newRatio', and 'nextNode'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The current amount of SBD (debt) borrowed against a specific CDP.",
            "why_is_is_important": "It reflects the actual amount of debt owed for the CDP, which is crucial for calculating the new collateralization ratio after repayment and determining if the CDP is undercollateralized.",
            "when_is_it_updated": "It is updated at the beginning of the `repay` function, within the `_updateSafe` internal function, if the `cumulativeCollateralPerUnitCollateral` has changed since the last snapshot, implying an accrual of debt.",
            "how_to_validate_state_update": "Verify that the `borrowedAmount` for the specific `safeId` has increased by the calculated `debtIncrease` (based on the difference in `cumulativeDebtPerUnitCollateral` since the last snapshot and the `collateralAmount`).",
            "has_conditional_updates": true,
            "summary_of_update": "The `borrowedAmount` within the specified CDP (`safeId`) is increased to account for accrued interest (debt increase) since the last update.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral'"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD ever borrowed for a specific CDP, including all accrued interest.",
            "why_is_is_important": "This variable tracks the historical debt taken, potentially for accounting or analytics purposes, distinct from the currently owed `borrowedAmount`.",
            "when_is_it_updated": "It is updated at the beginning of the `repay` function, within the `_updateSafe` internal function, if the `cumulativeCollateralPerUnitCollateral` has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify that the `totalBorrowedAmount` for the specific `safeId` has increased by the calculated `debtIncrease`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalBorrowedAmount` within the specified CDP (`safeId`) is increased by the `debtIncrease` accrued since the last snapshot.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral'"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The value of `cumulativeDebtPerUnitCollateral` at the time of the last update for a specific CDP, used to calculate debt accrual.",
            "why_is_is_important": "This snapshot is crucial for accurately calculating the accrued debt on a CDP between user interactions.",
            "when_is_it_updated": "It is updated at the beginning of the `repay` function, within the `_updateSafe` internal function, if the `cumulativeCollateralPerUnitCollateral` has changed, indicating an update to the safe's state.",
            "how_to_validate_state_update": "Verify that `liquidationSnapshots[safeId].debtPerCollateralSnapshot` is updated to the current `cumulativeDebtPerUnitCollateral` value.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the `cumulativeDebtPerUnitCollateral` for the given CDP (`safeId`) is updated to the current value.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral'"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The current amount of collateral deposited in a specific CDP.",
            "why_is_is_important": "It reflects the actual amount of collateral backing the CDP, essential for ratio calculations and liquidation checks.",
            "when_is_it_updated": "It is updated at the beginning of the `repay` function, within the `_updateSafe` internal function, if the `cumulativeCollateralPerUnitCollateral` has changed.",
            "how_to_validate_state_update": "Verify that the `collateralAmount` for the specific `safeId` has increased by the calculated `collateralIncrease` (based on the difference in `cumulativeCollateralPerUnitCollateral` since the last snapshot and the `collateralAmount`).",
            "has_conditional_updates": true,
            "summary_of_update": "The `collateralAmount` within the specified CDP (`safeId`) is increased to account for accrued collateral interest (collateral increase) since the last update.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral'"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The value of `cumulativeCollateralPerUnitCollateral` at the time of the last update for a specific CDP, used to calculate collateral accrual.",
            "why_is_is_important": "This snapshot is crucial for accurately calculating the accrued collateral in a CDP between user interactions.",
            "when_is_it_updated": "It is updated at the beginning of the `repay` function, within the `_updateSafe` internal function, if `cumulativeCollateralPerUnitCollateral` has changed.",
            "how_to_validate_state_update": "Verify that `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` is updated to the current `cumulativeCollateralPerUnitCollateral` value.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the `cumulativeCollateralPerUnitCollateral` for the given CDP (`safeId`) is updated to the current value.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral'"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The aggregated amount of collateral held across all active CDPs in the protocol.",
            "why_is_is_important": "It represents the protocol's total collateral backing the issued SBD, vital for overall system health and solvency.",
            "when_is_it_updated": "It is updated at the beginning of the `repay` function, within the `_updateSafe` internal function, if collateral interest has accrued for the `safeId`.",
            "how_to_validate_state_update": "Verify that `totalCollateral` has increased by the `collateralIncrease` calculated in the `_updateSafe` function.",
            "has_conditional_updates": true,
            "summary_of_update": "The total amount of collateral locked across all CDPs is increased by the `collateralIncrease` calculated for the specific `safeId`.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral'"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD currently minted and outstanding across all CDPs.",
            "why_is_is_important": "It indicates the total SBD supply backed by collateral, crucial for maintaining the SBD peg and system stability.",
            "when_is_it_updated": "It is updated twice: first within `_updateSafe` (if debt accrued) and then directly at the end of the `repay` function to reflect the repayment amount.",
            "how_to_validate_state_update": "The `totalDebt` should reflect the sum/difference of the current `totalDebt` and the provided `delta` (`debtIncrease` for the first call, `amount` for the second call) based on the `add` parameter.",
            "has_conditional_updates": false,
            "summary_of_update": "The total outstanding debt in the system is updated by increasing it (due to accrued interest during `_updateSafe`) and then decreasing it (due to the `amount` repaid).",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral' (first call to _updateTotalDebt)",
              "Always (second call to _updateTotalDebt)"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operating mode of the protocol (e.g., 'BOOTSTRAP' or 'NORMAL'), which might influence fee structures or other parameters.",
            "why_is_is_important": "This mode transition can signify a mature state of the protocol and potentially adjust risk parameters or fee mechanisms.",
            "when_is_it_updated": "It is updated during the first call to `_updateTotalDebt` (triggered by `_updateSafe`) if the total debt crosses a certain threshold and the system is in `BOOTSTRAP` mode.",
            "how_to_validate_state_update": "Verify `PROTOCOL_MODE` changes from `BOOTSTRAP` to `NORMAL` if the debt crosses the threshold and the protocol is in bootstrap mode.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol's operational mode is changed from `BOOTSTRAP` to `NORMAL` if the total debt exceeds a predefined threshold.",
            "conditions": [
              "If 'liquidationSnapshot.collateralPerCollateralSnapshot' is not equal to 'cumulativeCollateralPerUnitCollateral' AND 'totalDebt' (after update) is greater than 'BOOTSTRAP_MODE_DEBT_THRESHOLD' AND 'PROTOCOL_MODE' is 'BOOTSTRAP'"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The current amount of SBD (debt) borrowed against a specific CDP.",
            "why_is_is_important": "This is the primary state change reflecting the debt reduction for the CDP, directly impacting its collateralization ratio.",
            "when_is_it_updated": "After SBD tokens are burned, the `borrowedAmount` of the specific `safeId` is directly reduced by the `amount` repaid.",
            "how_to_validate_state_update": "Verify that `safes[safeId].borrowedAmount` has decreased by the `amount` of SBD repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "The `borrowedAmount` for the given CDP (`safeId`) is reduced by the amount of SBD repaid.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The individual SBD token balance of a specific address.",
            "why_is_is_important": "This reflects the SBD token transfer out of the user's wallet as part of the repayment.",
            "when_is_it_updated": "It is updated when `sbdToken.burn` is called on the `DFIDToken` contract, which occurs as part of the `repay` function.",
            "how_to_validate_state_update": "Verify that `_balances[msg.sender]` has decreased by `amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The SBD balance of the `msg.sender` (the repayer) is decreased by the `amount` repaid, as these tokens are burned.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of SBD tokens in existence.",
            "why_is_is_important": "This maintains the deflationary nature of SBD upon repayment, contributing to its peg stability.",
            "when_is_it_updated": "It is updated when `sbdToken.burn` is called on the `DFIDToken` contract.",
            "how_to_validate_state_update": "Verify that `_totalSupply` has decreased by `amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The total supply of SBD tokens is decreased by the `amount` repaid, as these tokens are burned.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The cumulative sum of all SBD tokens that have been permanently removed from circulation.",
            "why_is_is_important": "This provides a public record of the SBD tokens burned, useful for transparency and auditing.",
            "when_is_it_updated": "It is updated when `sbdToken.burn` is called on the `DFIDToken` contract.",
            "how_to_validate_state_update": "Verify that `totalBurned` has increased by `amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The total cumulative amount of SBD tokens ever burned is increased by the `amount` repaid.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[safeId]",
            "type": "struct",
            "what_does_it_track": "The metadata (value, prev, next pointers) for each node (CDP `safeId`) in the ordered doubly linked list, representing its collateralization ratio and position.",
            "why_is_is_important": "This ensures the liquidation queue accurately reflects the current risk profile of the CDPs, allowing for efficient liquidation of undercollateralized positions.",
            "when_is_it_updated": "If the `_newRatio` (collateralization ratio) is not zero, the `safeId`'s position in `safesOrderedForLiquidation` is `upsert`-ed with the new ratio.",
            "how_to_validate_state_update": "After `upsert`, retrieve `nodes[safeId]`. Its `value` should be `_newRatio`, and its `prev` and `next` pointers should correctly link it within the ordered list based on `_newRatio`.",
            "has_conditional_updates": true,
            "summary_of_update": "The node representing the `safeId` in the `safesOrderedForLiquidation` list is updated with the new collateralization ratio, or inserted if it was not present.",
            "conditions": [
              "If the new collateralization ratio (`_newRatio`) for the safe is not zero AND the safe already exists in the list (i.e., it's an update)",
              "If the new collateralization ratio (`_newRatio`) for the safe is not zero AND the safe does not exist in the list (i.e., it's an insert)"
            ]
          },
          {
            "state_variable_name": "nodes[safeId]",
            "type": "struct",
            "what_does_it_track": "The metadata (value, prev, next pointers) for each node (CDP `safeId`) in the ordered doubly linked list.",
            "why_is_is_important": "Removing the safe ensures it's no longer considered for liquidation or redemption, especially when the debt is fully repaid.",
            "when_is_it_updated": "If the `_newRatio` (collateralization ratio) becomes zero, the `safeId` is removed from both `safesOrderedForLiquidation` and `safesOrderedForRedemption` lists.",
            "how_to_validate_state_update": "After `remove`, querying `nodes[safeId]` should return a default/zero-initialized node, indicating its deletion.",
            "has_conditional_updates": true,
            "summary_of_update": "The node representing the `safeId` is removed from both the `safesOrderedForLiquidation` and `safesOrderedForRedemption` lists.",
            "conditions": [
              "If the new collateralization ratio (`_newRatio`) for the safe is zero AND the safe is removed from the liquidation queue.",
              "If the new collateralization ratio (`_newRatio`) for the safe is zero AND the safe is removed from the redemption queue."
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the ordered doubly linked list.",
            "why_is_is_important": "This pointer provides efficient access to the riskiest/least risky CDP in the respective queues, depending on the ordering logic.",
            "when_is_it_updated": "It is updated when a node is inserted at the beginning of the list, or when the current head node is removed.",
            "how_to_validate_state_update": "After an operation that modifies `head`, verify that the `head` pointer points to the correct `safeId` which should be the new first element in the ordered list.",
            "has_conditional_updates": true,
            "summary_of_update": "The `head` pointer of `safesOrderedForLiquidation` or `safesOrderedForRedemption` might change if the `safeId` being updated/removed was previously the head or if a new `safeId` becomes the new head.",
            "conditions": [
              "If the new collateralization ratio (`_newRatio`) is zero AND the `safeId` was previously the head of the `safesOrderedForLiquidation` list.",
              "If the new collateralization ratio (`_newRatio`) is zero AND the `safeId` was previously the head of the `safesOrderedForRedemption` list.",
              "If the new collateralization ratio (`_newRatio`) is not zero AND the `safeId` is inserted as the new head of the `safesOrderedForLiquidation` list."
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the ordered doubly linked list.",
            "why_is_is_important": "This pointer provides efficient access to the least risky/most risky CDP in the respective queues, depending on the ordering logic.",
            "when_is_it_updated": "It is updated when a node is inserted at the end of the list, or when the current tail node is removed.",
            "how_to_validate_state_update": "After an operation that modifies `tail`, verify that the `tail` pointer points to the correct `safeId` which should be the new last element in the ordered list.",
            "has_conditional_updates": true,
            "summary_of_update": "The `tail` pointer of `safesOrderedForLiquidation` or `safesOrderedForRedemption` might change if the `safeId` being updated/removed was previously the tail or if a new `safeId` becomes the new tail.",
            "conditions": [
              "If the new collateralization ratio (`_newRatio`) is zero AND the `safeId` was previously the tail of the `safesOrderedForLiquidation` list.",
              "If the new collateralization ratio (`_newRatio`) is zero AND the `safeId` was previously the tail of the `safesOrderedForRedemption` list.",
              "If the new collateralization ratio (`_newRatio`) is not zero AND the `safeId` is inserted as the new tail of the `safesOrderedForLiquidation` list."
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}