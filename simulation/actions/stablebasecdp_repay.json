{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId that exists in the safes mapping and is owned by the caller.",
      "amount: A valid amount of SBD tokens that the caller owns and is less than or equal to the borrowedAmount of the safe. The amount must result in a valid repayment, either fully repaying the debt or leaving a debt greater than or equal to MINIMUM_DEBT.",
      "nearestSpotInLiquidationQueue: A valid safeId representing the nearest spot in the liquidation queue, used for reordering the queue after repayment. This can be 0 to indicate the head of the queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "The borrowedAmount of the safe with safeId is decreased by amount.",
          "If borrowedAmount becomes 0, the safe is removed from both liquidation and redemption queues.",
          "If the cumulative collateral per unit collateral or cumulative debt per unit collateral has changed since the last update, the safe's collateralAmount and borrowedAmount are updated to reflect the change. The totalBorrowedAmount is also updated."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "The totalDebt is decreased by the amount repaid."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "If the new collateral ratio is not 0, the safe's position in the liquidation queue is updated based on the new ratio and nearestSpotInLiquidationQueue."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE is updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "SBD Token",
        "state_update_descriptions": [
          "The specified amount of SBD tokens is burned from the user's account."
        ]
      },
      {
        "category": "Liquidation Snapshots",
        "state_update_descriptions": [
          "liquidationSnapshots mapping is updated with the new values of cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral to track debt and collateral changes for each safe."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "totalCollateral may increase if collateralAmount is updated to reflect cumulativeCollateralPerUnitCollateral changes."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be decreased by amount.",
          "If safes[safeId].borrowedAmount is 0, safesOrderedForLiquidation.nodes[safeId] and safesOrderedForRedemption.nodes[safeId] should be empty.",
          "If cumulativeCollateralPerUnitCollateral or cumulativeDebtPerUnitCollateral has changed, safes[safeId].collateralAmount and safes[safeId].borrowedAmount should be updated appropriately."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "totalDebt should be decreased by amount."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "If safes[safeId].borrowedAmount is not 0, safesOrderedForLiquidation should contain the safeId with the updated ratio."
        ]
      },
      {
        "category": "SBD Token",
        "rule_descriptions": [
          "sbdToken.balanceOf(msg.sender) should be decreased by amount. totalBurned should also be updated"
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A Repaid event should be emitted with the correct safeId, amount, newRatio, totalCollateral, and totalDebt.",
          "A LiquidationQueueUpdated event should be emitted if safes[safeId].borrowedAmount is not zero and the ratio has changed, triggering an update to the liquidation queue.",
          "A SafeRemovedFromLiquidationQueue event should be emitted if the safe is removed from the liquidation queue.",
          "A SafeRemovedFromRedemptionQueue event should be emitted if the safe is removed from the redemption queue.",
          "A SafeUpdated event should be emitted if the safe's collateralAmount or borrowedAmount is updated."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The outstanding debt for a specific CDP.",
            "why_is_is_important": "Reflects the current debt of a safe, which is crucial for calculating collateralization ratio and determining liquidation risk.",
            "when_is_it_updated": "When a user repays their debt, reducing their outstanding borrowed amount.",
            "how_to_validate_state_update": "Check if the borrowedAmount of the safe decreases by the repayment amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the borrowed amount of a specific safe (CDP) by the 'amount' repaid.",
            "conditions": [
              "_safe.borrowedAmount > 0",
              "sbdToken.balanceOf(msg.sender) >= amount",
              "amount <= _safe.borrowedAmount",
              "_safe.borrowedAmount - amount == 0 || _safe.borrowedAmount - amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "_safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The outstanding debt for a specific CDP.",
            "why_is_is_important": "It is important to keep the debt value correct.",
            "when_is_it_updated": "When the safe's snapshot is outdated, it will increase debt amount.",
            "how_to_validate_state_update": "Verify that _safe.borrowedAmount increases by the calculated debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The debt of the safe increases to account for protocol-wide debt increases since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "Reference to the doubly linked list contract used for liquidation queue management.",
            "why_is_is_important": "Maintaining an accurate liquidation queue is critical for efficient and fair liquidation of undercollateralized safes.",
            "when_is_it_updated": "After the borrowed amount is updated. It is updated if newRatio is not 0.",
            "how_to_validate_state_update": "Check if the safesOrderedForLiquidation is called and updated.",
            "has_conditional_updates": false,
            "summary_of_update": "The position of the safe in the liquidation queue is updated based on the new collateralization ratio.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "Reference to the doubly linked list contract used for liquidation queue management.",
            "why_is_is_important": "Removing fully repaid safes from the queues ensures that only relevant safes are considered for liquidation and redemption.",
            "when_is_it_updated": "When the borrowed amount becomes zero after repayment.",
            "how_to_validate_state_update": "Check if _removeSafeFromBothQueues function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from both the liquidation and redemption queues if the borrowed amount is fully repaid.",
            "conditions": [
              "_newRatio == 0"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the protocol.",
            "why_is_is_important": "Reflects the overall health of the protocol and is used in various calculations, such as stability fees.",
            "when_is_it_updated": "When a safe repays its debt.",
            "how_to_validate_state_update": "Verify that totalDebt decreases by the repayment amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total outstanding debt in the protocol by the repayment amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Keeps track of the total collateral locked within the protocol",
            "why_is_is_important": "It is important for accounting purposes",
            "when_is_it_updated": "The safe's snapshot is outdated.",
            "how_to_validate_state_update": "Verify that totalCollateral increases by the calculated collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total collateral to account for protocol-wide collateral increases since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Operational mode of the protocol.",
            "why_is_is_important": "Controls certain protocol parameters and behaviors, especially during the initial bootstrapping phase.",
            "when_is_it_updated": "When the total debt exceeds a certain threshold during the repayment process.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE updates to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the protocol from BOOTSTRAP mode to NORMAL mode if the total debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "_safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Keeps track of the collateral of a safe.",
            "why_is_is_important": "It is important to keep the debt value correct.",
            "when_is_it_updated": "When the safe's snapshot is outdated, it will increase debt amount.",
            "how_to_validate_state_update": "Verify that _safe.collateralAmount increases by the calculated collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral of the safe increases to account for protocol-wide collateral increases since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "address",
            "what_does_it_track": "Doubly linked list contract address.",
            "why_is_is_important": "Ensures the redemption queue contains only safes with outstanding debt.",
            "when_is_it_updated": "When a safe's debt is reduced to zero.",
            "how_to_validate_state_update": "Confirm that safesOrderedForRedemption.remove(safeId) is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the redemption queue when its debt is fully repaid.",
            "conditions": [
              "_newRatio == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "The SBD token balance of a specific address.",
            "why_is_is_important": "Reduces the circulating supply of SBD tokens, maintaining the peg.",
            "when_is_it_updated": "When a user repays their debt using SBD tokens.",
            "how_to_validate_state_update": "Check if the SBD tokens are burned from the user's account, reducing their balance.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns (destroys) SBD tokens from the user's balance when they repay their debt.",
            "conditions": [
              "from != address(0)",
              "amount > 0",
              "balanceOf(msg.sender) >= amount"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of SBD tokens.",
            "why_is_is_important": "It is important for keeping track of the SBD token supply.",
            "when_is_it_updated": "When SBD is burned, the total supply decreases.",
            "how_to_validate_state_update": "Verify that _totalSupply is decreased.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total supply of SBD token when it is burned.",
            "conditions": [
              "from != address(0)",
              "amount > 0",
              "balanceOf(msg.sender) >= amount"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD that has been burned.",
            "why_is_is_important": "For accounting purposes.",
            "when_is_it_updated": "When a user repays their debt using SBD tokens.",
            "how_to_validate_state_update": "Verify that totalBurned increases by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increase the totalBurned amount when SBD is burned.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Each node's information in the linked list.",
            "why_is_is_important": "Storing relevant information in each node.",
            "when_is_it_updated": "If the node does not exist in the list",
            "how_to_validate_state_update": "Verify that the _insert function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts a new node into the doubly linked list if it doesn't already exist.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Each node's information in the linked list.",
            "why_is_is_important": "Storing relevant information in each node.",
            "when_is_it_updated": "If the node exists in the list.",
            "how_to_validate_state_update": "Verify that the _update function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates an existing node's value in the doubly linked list.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the list.",
            "why_is_is_important": "Important for list traversal.",
            "when_is_it_updated": "During insertion if the current node is the first node.",
            "how_to_validate_state_update": "Check if head is updated correctly.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the head of the list.",
            "conditions": []
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the list.",
            "why_is_is_important": "Important for list traversal.",
            "when_is_it_updated": "During insertion if the current node is the last node.",
            "how_to_validate_state_update": "Check if tail is updated correctly.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the tail of the list.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "The SBD token balance of a specific address.",
            "why_is_is_important": "Reduces the circulating supply of SBD tokens, maintaining the peg.",
            "when_is_it_updated": "When a user repays their debt using SBD tokens.",
            "how_to_validate_state_update": "Check if the SBD tokens are burned from the user's account, reducing their balance.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns (destroys) SBD tokens from the user's balance when they repay their debt.",
            "conditions": [
              "from != address(0)",
              "amount > 0",
              "balanceOf(msg.sender) >= amount"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}