{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: Provide a valid safeId for an existing CDP that the user owns.",
      "amount: Provide the amount of SBD tokens to repay. This amount must be less than or equal to the borrowedAmount for the given safeId and also should meet the condition that after repaying the debt, borrowedAmount must be 0 or greater than or equal to MINIMUM_DEBT.",
      "nearestSpotInLiquidationQueue: Provide a valid safeId for a CDP that serves as the nearest spot in the liquidation queue. This can be 0 if the user doesn't have a preference."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "State Updates",
        "state_update_descriptions": [
          "safes[safeId].borrowedAmount is decremented by amount.",
          "If cumulativeCollateralPerUnitCollateral or cumulativeDebtPerUnitCollateral has changed since the last update, safe's collateralAmount and borrowedAmount will be updated based on the difference.",
          "sbdToken.burn is called to burn the repaid amount from the msg.sender's balance.",
          "totalDebt is decremented by amount.",
          "safesOrderedForLiquidation is updated with the new ratio if borrowedAmount is not zero. The upsert function is called with safeId, the new ratio, and nearestSpotInLiquidationQueue.",
          "If the new ratio is 0, safesOrderedForLiquidation.remove(safeId) is called.",
          "If the new ratio is 0, safesOrderedForRedemption.remove(safeId) is called.",
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral if the cumulative values have changed.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral if the cumulative values have changed.",
          "PROTOCOL_MODE may be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "The `borrowedAmount` of the specified `safeId` should be decreased by `amount`.",
          "The `borrowedAmount` of the specified `safeId` should be non-negative and greater than or equal to MINIMUM_DEBT, unless it becomes zero.",
          "If the `borrowedAmount` becomes zero, the safe should be removed from both liquidation and redemption queues.",
          "The `weight` of the `safeId` should be updated in the liquidation queue if `borrowedAmount` is not zero, based on the new ratio of `borrowedAmount` to `collateralAmount`."
        ]
      },
      {
        "category": "Token State",
        "rule_descriptions": [
          "The balance of the `msg.sender` in the `sbdToken` contract should decrease by `amount`."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "The `totalDebt` should decrease by `amount`."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "If the new ratio (`borrowedAmount` * PRECISION) / `collateralAmount` is not 0, the liquidation queue should be updated to reflect the new ratio. The `nearestSpotInLiquidationQueue` should be considered when updating the queue.",
          "If the new ratio is 0, the safe should be removed from the liquidation queue."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "If the new ratio is 0, the safe should be removed from the redemption queue."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "Tracks the collateral amount, borrowed amount, weight, total borrowed amount and fee paid for each safe.",
            "why_is_is_important": "Stores the details of each safe, including collateral amount, borrowed amount, and other relevant information.",
            "when_is_it_updated": "Updated when debt is repaid, decreasing borrowedAmount.",
            "how_to_validate_state_update": "Check that the borrowedAmount for the given safeId is decreased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "The borrowedAmount field of the Safe struct corresponding to safeId is decremented by amount. collateralAmount may also be updated in the _updateSafe call, and this updates the totalCollateral variable.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt in the protocol.",
            "why_is_is_important": "Tracks the total debt in the system, which is crucial for assessing the overall risk and stability of the protocol.",
            "when_is_it_updated": "Updated when debt is repaid.",
            "how_to_validate_state_update": "Verify that totalDebt is decreased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "totalDebt is decreased by amount.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the operating mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Reflects whether the protocol is in BOOTSTRAP or NORMAL mode, affecting how certain functions behave.",
            "when_is_it_updated": "Updated only if the total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD and the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check if the PROTOCOL_MODE changes from BOOTSTRAP to NORMAL when totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "has_conditional_updates": true,
            "summary_of_update": "PROTOCOL_MODE is updated from BOOTSTRAP to NORMAL if debt > BOOTSTRAP_MODE_DEBT_THRESHOLD and PROTOCOL_MODE is currently BOOTSTRAP.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral.",
            "why_is_is_important": "It is used to calculate the debt increase when updating a safe.",
            "when_is_it_updated": "Updated when _updateSafe is called if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that the liquidationSnapshot.debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshot.debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per unit collateral.",
            "why_is_is_important": "It is used to calculate the collateral increase when updating a safe.",
            "when_is_it_updated": "Updated when _updateSafe is called if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that the liquidationSnapshot.collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshot.collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system.",
            "why_is_is_important": "Tracks the total collateral in the system, crucial for calculating global collateralization ratio and assessing system health.",
            "when_is_it_updated": "Updated when _updateSafe is called if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Check that totalCollateral is increased by collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateral is increased by collateralIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping(uint256 => LiquidationSnapshot)",
            "what_does_it_track": "Tracks the collateralPerCollateralSnapshot and debtPerCollateralSnapshot for each safe.",
            "why_is_is_important": "Stores snapshots of collateral and debt per collateral for each safe, used to calculate debt and collateral increases.",
            "when_is_it_updated": "Updated when _updateSafe is called if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Check that liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Tracks the token balance of each address.",
            "why_is_is_important": "Tracks the token balance of each address.",
            "when_is_it_updated": "Updated when debt is repaid.",
            "how_to_validate_state_update": "Check that the balance of msg.sender is decreased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "_balances[msg.sender] is decremented by amount.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of the token.",
            "why_is_is_important": "Tracks the total supply of the token.",
            "when_is_it_updated": "Updated when debt is repaid.",
            "how_to_validate_state_update": "Check that _totalSupply is decreased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "_totalSupply is decremented by amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens burned.",
            "why_is_is_important": "Tracks the total amount of tokens burned.",
            "when_is_it_updated": "Updated when debt is repaid.",
            "how_to_validate_state_update": "Check that totalBurned is increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "totalBurned is incremented by amount.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Tracks the value, prev, and next node IDs in the doubly linked list.",
            "why_is_is_important": "Stores nodes for the doubly linked list, used to manage safes in liquidation and redemption queues.",
            "when_is_it_updated": "Updated when the safe's ratio changes and it needs to be re-ordered in the liquidation queue, or when the safe is removed from the queue.",
            "how_to_validate_state_update": "Check that the nodes mapping is updated with the new node's value, prev, and next values.",
            "has_conditional_updates": true,
            "summary_of_update": "Nodes are either inserted, updated, or removed from the doubly linked list. Insertion involves finding the correct position based on value and nearestSpot. Updating involves removing the existing node and re-inserting it with the new value. Removal involves adjusting the prev and next pointers of adjacent nodes.",
            "conditions": [
              "_newRatio != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the ID of the first node in the list.",
            "why_is_is_important": "Points to the first node in the doubly linked list.",
            "when_is_it_updated": "Updated when a new safe is added to the beginning of the liquidation queue, or when the current head is removed.",
            "how_to_validate_state_update": "Verify that the head is updated to the new safeId if the new safeId is the new head of the list.",
            "has_conditional_updates": true,
            "summary_of_update": "The head pointer is updated to the new safe ID if it becomes the new head of the list.",
            "conditions": [
              "New ratio != 0",
              "New safe added to the beginning of the list",
              "Current head is removed"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the ID of the last node in the list.",
            "why_is_is_important": "Points to the last node in the doubly linked list.",
            "when_is_it_updated": "Updated when a new safe is added to the end of the liquidation queue, or when the current tail is removed.",
            "how_to_validate_state_update": "Verify that the tail is updated to the new safeId if the new safeId is the new tail of the list.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail pointer is updated to the new safe ID if it becomes the new tail of the list.",
            "conditions": [
              "New ratio != 0",
              "New safe added to the end of the list",
              "Current tail is removed"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      }
    ]
  }
}