{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: Must be a valid, existing safe ID that belongs to the user (msg.sender).",
      "amount: Must be greater than 0 and less than or equal to the safe's borrowedAmount. Also, after repayment, borrowedAmount must be zero or greater than or equal to MINIMUM_DEBT.",
      "nearestSpotInLiquidationQueue: Provide a valid node id in the liquidation queue to optimize the upsert operation, can be 0 if unknown."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the safe's collateral and borrowed amounts if the cumulative collateral per unit collateral or cumulative debt per unit collateral has changed since the last update (within the `_updateSafe` function).",
          "Decreases the safe's borrowedAmount by the repayment amount.",
          "Updates the safe's position in the liquidation queue based on the new collateral ratio, potentially removing it if the debt is fully repaid.",
          "If the safe's collateral ratio is 0, it's removed from both the liquidation and redemption queues."
        ]
      },
      {
        "category": "Token Burning",
        "state_update_descriptions": [
          "Burns the repaid SBD tokens from the user's balance using the sbdToken.burn function."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Decreases the total debt of the protocol."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "If the safe's collateral ratio changes, the safe's position in the liquidation queue is updated, inserting, updating or removing the safe."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "If the safe's collateral ratio is 0, the safe is removed from the redemption queue."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "The PROTOCOL_MODE is potentially changed from BOOTSTRAP to NORMAL if totalDebt goes above BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "The liquidation snapshot is updated with cumulative collateral and debt per unit collateral."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "The total collateral is increased as the inactive collateral is added to the safe (inside `_updateSafe`)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be decreased by amount.",
          "safes[safeId].borrowedAmount should be greater than or equal to 0.",
          "If safes[safeId].borrowedAmount is 0, the safe should be removed from both liquidation and redemption queues, verify using IDoublyLinkedList.get(safeId).",
          "If safes[safeId].borrowedAmount is not 0, the collateral ratio (borrowedAmount * PRECISION) / collateralAmount should be correctly reflected in the liquidation queue, verify using IDoublyLinkedList.get(safeId).",
          "Verify that collateralAmount and borrowedAmount are updated correctly based on cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral within the _updateSafe function. Check liquidationSnapshots[safeId] to confirm the snapshot update."
        ]
      },
      {
        "category": "Token State",
        "rule_descriptions": [
          "The SBD token balance of the user (msg.sender) should be decreased by the amount repaid, verify using sbdToken.balanceOf(msg.sender).",
          "The total supply of SBD tokens should be decreased by the amount repaid, implicitly verified by the burn function."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "totalDebt should be decreased by amount."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A 'Repaid' event should be emitted with the correct safeId, amount, newRatio, totalCollateral and totalDebt values."
        ]
      },
      {
        "category": "Protocol Mode",
        "rule_descriptions": [
          "If the totalDebt crosses BOOTSTRAP_MODE_DEBT_THRESHOLD, the PROTOCOL_MODE should be updated accordingly."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt a safe has.",
            "why_is_is_important": "Reflects the current debt owed by a safe and is crucial for calculating collateralization ratio and liquidation thresholds.",
            "when_is_it_updated": "Updated when a safe repays debt.",
            "how_to_validate_state_update": "Check if _safe.borrowedAmount is decreased by amount. For example, if _safe.borrowedAmount is 100 and amount is 20, then _safe.borrowedAmount should become 80.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the borrowedAmount of a specific safe by the repayment amount.",
            "conditions": [
              "_safe.borrowedAmount > 0",
              "sbdToken.balanceOf(msg.sender) >= amount",
              "amount <= _safe.borrowedAmount",
              "_safe.borrowedAmount - amount == 0 || _safe.borrowedAmount - amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Ensures that safes are liquidated in the correct order when the protocol is undercollateralized.",
            "when_is_it_updated": "Updated when the collateralization ratio changes due to repayment, deposit, or borrow.",
            "how_to_validate_state_update": "Check if safesOrderedForLiquidation is updated with the new ratio. Examine the linked list structure to confirm the safeId is correctly positioned based on its new ratio. Use getNodes() to inspect all members.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the position of the safe in the liquidation queue if the new collateralization ratio is not zero.",
            "conditions": [
              "_newRatio != 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation and safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes for liquidation and redemption.",
            "why_is_is_important": "Maintains accurate queue status by removing safes when they are no longer relevant.",
            "when_is_it_updated": "Updated when the collateralization ratio changes to zero.",
            "how_to_validate_state_update": "Check that the safe is removed from both liquidation and redemption queues using their respective remove() functions. Verify via the doubly linked list contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from both liquidation and redemption queues if the new collateralization ratio is zero, meaning the debt is fully repaid.",
            "conditions": [
              "_newRatio == 0"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt in the protocol.",
            "why_is_is_important": "Crucial for assessing the overall health and risk of the protocol.",
            "when_is_it_updated": "Updated whenever debt is borrowed, repaid, or liquidated.",
            "how_to_validate_state_update": "Verify that totalDebt is decreased by the repayment amount. For example, if totalDebt is 500 and amount is 20, then totalDebt should become 480.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total debt of the protocol by the repayment amount.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount and safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt and collateral of a specific safe.",
            "why_is_is_important": "Keeps the safe's state synchronized with the global protocol state, accounting for accrued debt and collateral changes.",
            "when_is_it_updated": "Updated when the safe's snapshot values differ from the cumulative values.",
            "how_to_validate_state_update": "Verify that _safe.borrowedAmount and _safe.collateralAmount are updated based on cumulative values. The update applies debtIncrease to borrowedAmount and collateralIncrease to collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's borrowed amount and collateral amount based on cumulative collateral and debt per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "Tracks the operational mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Controls certain protocol behaviors and parameters based on the level of outstanding debt.",
            "when_is_it_updated": "Updated when total debt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE changes to NORMAL by calling mode() and comparing it.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the protocol from BOOTSTRAP mode to NORMAL mode when total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender] and totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balances of addresses and the total amount burned.",
            "why_is_is_important": "Reduces the circulating supply of SBD tokens and ensures that repaid debt is effectively removed from the system.",
            "when_is_it_updated": "Updated when SBD tokens are burned during repayment.",
            "how_to_validate_state_update": "Verify that the balance of msg.sender is decreased by amount by calling balanceOf(msg.sender) before and after the transaction. Also, verify that totalBurned is increased by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the SBD tokens from the repayer's balance.",
            "conditions": [
              "from != address(0)",
              "amount > 0",
              "balanceOf(from) >= amount"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of the SBD tokens.",
            "why_is_is_important": "Reduces the circulating supply of SBD tokens and ensures that repaid debt is effectively removed from the system.",
            "when_is_it_updated": "Updated when SBD tokens are burned during repayment.",
            "how_to_validate_state_update": "Verify that _totalSupply is decreased by amount by calling totalSupply() before and after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total supply of the SBD tokens.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[safeId]",
            "type": "struct IDoublyLinkedList.Node",
            "what_does_it_track": "Tracks the nodes in the doubly linked list, representing the order of safes for liquidation or redemption.",
            "why_is_is_important": "Maintains the correct order of safes for liquidation and redemption, ensuring efficient protocol operations.",
            "when_is_it_updated": "Updated when a safe's collateralization ratio changes or when a safe is added or removed from the list.",
            "how_to_validate_state_update": "Verify that a new node is inserted into the linked list by checking nodes(id) after the transaction. If it's a new node, value, next and prev should be initialized based on insert logic.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts a new node if the safeId doesn't exist in the linked list.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes[safeId]",
            "type": "struct IDoublyLinkedList.Node",
            "what_does_it_track": "Tracks the nodes in the doubly linked list, representing the order of safes for liquidation or redemption.",
            "why_is_is_important": "Maintains the correct order of safes for liquidation and redemption, ensuring efficient protocol operations.",
            "when_is_it_updated": "Updated when a safe's collateralization ratio changes or when a safe is added or removed from the list.",
            "how_to_validate_state_update": "Verify that the existing node is updated in the linked list by calling getNode(id) before and after the transaction and comparing the value, next, and prev fields. These fields should be modified based on the update logic.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates an existing node if the safeId already exists in the linked list.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          },
          {
            "state_variable_name": "head and tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the first and last elements of the linked list.",
            "why_is_is_important": "Provides quick access to the beginning and end of the list, crucial for efficient list traversal.",
            "when_is_it_updated": "Updated when a safe is added or removed from the list, or when the list is reordered.",
            "how_to_validate_state_update": "Check that the head and tail pointers are updated correctly after insertion or update by calling getHead() and getTail() respectively. The values returned should reflect the new first and last elements in the list.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the head and tail pointers of the linked list after inserting or updating a node.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      }
    ]
  }
}