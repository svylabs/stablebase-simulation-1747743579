{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "'safeId': Must be the ID of an existing CDP (Safe) that is owned by the calling address (msg.sender).",
      "'amount': A positive integer representing the amount of SBD to repay. This amount must be less than or equal to the current 'borrowedAmount' of the specified 'safeId'. The calling address must have an SBD token balance greater than or equal to this 'amount'. The 'borrowedAmount' remaining after repayment (i.e., previous_borrowedAmount - amount) must either be zero or greater than or equal to the 'MINIMUM_DEBT' constant.",
      "'nearestSpotInLiquidationQueue': An optional 'safeId' that serves as a hint for efficient placement/repositioning within the 'safesOrderedForLiquidation' doubly linked list. This parameter can be 0 if no specific hint is provided or required, in which case the contract will start searching from the head of the list."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "CDP State Updates",
        "state_update_descriptions": [
          "The 'borrowedAmount' of the specified Safe (CDP) is decreased by the repaid 'amount'.",
          "The 'collateralAmount' of the specified Safe (CDP) may be increased if the '_updateSafe' function is triggered due to accrued collateral.",
          "The 'totalBorrowedAmount' of the specified Safe (CDP) may be increased if the '_updateSafe' function is triggered due to accrued debt."
        ]
      },
      {
        "category": "Global Protocol State Updates",
        "state_update_descriptions": [
          "The overall 'totalDebt' of the protocol is decreased by the 'amount' repaid.",
          "The 'totalCollateral' of the protocol may be increased if the '_updateSafe' function is triggered due to accrued collateral.",
          "The 'PROTOCOL_MODE' may transition from 'BOOTSTRAP' to 'NORMAL' if the 'totalDebt' falls below 'BOOTSTRAP_MODE_DEBT_THRESHOLD'."
        ]
      },
      {
        "category": "Token State Updates",
        "state_update_descriptions": [
          "The SBD token balance of the 'msg.sender' (the caller) is decreased by the 'amount' as tokens are burned.",
          "The total supply of SBD tokens ('sbdToken.totalSupply') is decreased by the 'amount'.",
          "The 'totalBurned' counter in the SBD token contract is increased by the 'amount'."
        ]
      },
      {
        "category": "Queue State Updates",
        "state_update_descriptions": [
          "The specified Safe is repositioned in the 'safesOrderedForLiquidation' doubly linked list based on its new collateralization ratio, or removed if its new borrowed amount becomes zero.",
          "If the Safe's borrowed amount becomes zero after repayment, it is also removed from the 'safesOrderedForRedemption' doubly linked list."
        ]
      },
      {
        "category": "Snapshot State Updates",
        "state_update_descriptions": [
          "The 'collateralPerCollateralSnapshot' and 'debtPerCollateralSnapshot' for the 'safeId' within 'liquidationSnapshots' are updated if the '_updateSafe' function is triggered, reflecting the latest cumulative values."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "State Validation",
        "rule_descriptions": [
          "Verify that the 'borrowedAmount' for the 'safeId' in 'StableBaseCDP.safes' has been updated correctly, reflecting the 'amount' repaid and any adjustments from accrued debt within '_updateSafe'.",
          "Verify that the 'totalDebt' in 'StableBaseCDP' has been decreased by the 'amount' repaid, taking into account any 'debtIncrease' from '_updateSafe'.",
          "Verify that the 'sbdToken.balanceOf(msg.sender)' has decreased by the 'amount' repaid.",
          "Verify that the 'sbdToken.totalSupply' has decreased by the 'amount' repaid.",
          "Verify that the 'sbdToken.totalBurned' has increased by the 'amount' repaid.",
          "If '_updateSafe' was triggered, verify that 'StableBaseCDP.safes[safeId].collateralAmount' and 'StableBaseCDP.safes[safeId].totalBorrowedAmount' reflect the increase from accrued collateral and debt respectively. Also, verify 'StableBaseCDP.totalCollateral' is updated.",
          "If '_updateSafe' was triggered, verify that 'StableBaseCDP.liquidationSnapshots[safeId].collateralPerCollateralSnapshot' is updated to 'cumulativeCollateralPerUnitCollateral' and 'StableBaseCDP.liquidationSnapshots[safeId].debtPerCollateralSnapshot' is updated to 'cumulativeDebtPerCollateral'.",
          "Verify that if the calculated 'newRatio' for the safe is not zero, the 'safeId' is correctly positioned (or re-positioned) within 'StableBaseCDP.safesOrderedForLiquidation' according to its updated ratio.",
          "Verify that if the calculated 'newRatio' for the safe is zero, the 'safeId' has been successfully removed from both 'StableBaseCDP.safesOrderedForLiquidation' and 'StableBaseCDP.safesOrderedForRedemption'.",
          "If the protocol's 'PROTOCOL_MODE' was 'BOOTSTRAP' prior to repayment and the new 'totalDebt' is less than or equal to 'BOOTSTRAP_MODE_DEBT_THRESHOLD', verify that 'StableBaseCDP.PROTOCOL_MODE' has transitioned to 'NORMAL'."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "A 'Repaid' event must be emitted from the 'StableBaseCDP' contract with the correct 'safeId', 'amount', the calculated 'newRatio', and the updated 'totalCollateral' and 'totalDebt'.",
          "A 'Burn' event must be emitted from the 'DFIDToken' contract (sbdToken) with 'msg.sender' as 'from' and the 'amount' repaid.",
          "A 'Transfer' event must be emitted from the 'DFIDToken' contract (sbdToken) with 'msg.sender' as 'from', 'address(0)' as 'to', and the 'amount' repaid.",
          "If the internal '_updateSafe' function was executed, a 'SafeUpdated' event must be emitted from 'StableBaseCDP' with the relevant updated values.",
          "If the 'newRatio' (calculated for the safe after repayment) is not zero, a 'LiquidationQueueUpdated' event must be emitted from 'StableBaseCDP' for the 'safeId'.",
          "If the 'newRatio' is zero, a 'SafeRemovedFromLiquidationQueue' event and a 'SafeRemovedFromRedemptionQueue' event must be emitted from 'StableBaseCDP' for the 'safeId'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The current outstanding SBD debt for a specific CDP (Safe).",
            "why_is_is_important": "It represents the current financial obligation of a user within a CDP.",
            "when_is_it_updated": "Updated when 'repay' is called. First, it might increase due to accrued debt via `_updateSafe`, then it is decreased by the 'amount' being repaid.",
            "how_to_validate_state_update": "Verify the 'borrowedAmount' for the specified 'safeId' decreases by the 'amount' repaid, after any potential increase from accrued debt calculated by '_updateSafe'.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'borrowedAmount' for the specific CDP ('safeId') is decreased by the 'amount' of SBD repaid. It can also be increased by accrued debt if the `_updateSafe` function logic is triggered.",
            "conditions": [
              "Updates from _updateSafe only apply if liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral.",
              "Repayment amount must be less than or equal to current borrowedAmount.",
              "Resulting borrowedAmount must be 0 or greater than or equal to MINIMUM_DEBT."
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBD debt that a specific CDP (Safe) has ever accrued.",
            "why_is_is_important": "It provides a historical record of the total debt associated with a CDP over its lifetime.",
            "when_is_it_updated": "Updated when the `_updateSafe` function is called, which happens at the beginning of `repay`.",
            "how_to_validate_state_update": "Verify the 'totalBorrowedAmount' for the specified 'safeId' increases by the 'debtIncrease' calculated in '_updateSafe'.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'totalBorrowedAmount' for the specific CDP ('safeId') is increased by any accrued debt (`debtIncrease`) calculated during the `_updateSafe` call.",
            "conditions": [
              "Only applies if liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the `cumulativeDebtPerUnitCollateral` at the time a Safe's debt is last updated, used to calculate future debt accrual.",
            "why_is_is_important": "It is crucial for correctly calculating the amount of debt that has accrued on a Safe since its last update.",
            "when_is_it_updated": "Updated when the `_updateSafe` function is called, which happens at the beginning of `repay`.",
            "how_to_validate_state_update": "Verify 'debtPerCollateralSnapshot' for the specified 'safeId' is set to the current 'cumulativeDebtPerUnitCollateral' after the `_updateSafe` call.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'debtPerCollateralSnapshot' for the specific CDP ('safeId') is updated to the current `cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "Only applies if liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral."
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral (e.g., ETH) currently locked in a specific CDP (Safe).",
            "why_is_is_important": "It represents the value securing the debt of a CDP and impacts its collateralization ratio.",
            "when_is_it_updated": "Updated when the `_updateSafe` function is called, which happens at the beginning of `repay`.",
            "how_to_validate_state_update": "Verify the 'collateralAmount' for the specified 'safeId' increases by the 'collateralIncrease' calculated in '_updateSafe'.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'collateralAmount' for the specific CDP ('safeId') is increased by any accrued collateral (`collateralIncrease`) calculated during the `_updateSafe` call.",
            "conditions": [
              "Only applies if liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the `cumulativeCollateralPerUnitCollateral` at the time a Safe's collateral is last updated, used to calculate future collateral accrual.",
            "why_is_is_important": "It is crucial for correctly calculating the amount of collateral that has accrued in a Safe since its last update.",
            "when_is_it_updated": "Updated when the `_updateSafe` function is called, which happens at the beginning of `repay`.",
            "how_to_validate_state_update": "Verify 'collateralPerCollateralSnapshot' for the specified 'safeId' is set to the current 'cumulativeCollateralPerUnitCollateral' after the `_updateSafe` call.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'collateralPerCollateralSnapshot' for the specific CDP ('safeId') is updated to the current `cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "Only applies if liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral."
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held across all active CDPs in the protocol.",
            "why_is_is_important": "It represents the overall collateral backing the system's stablecoin supply.",
            "when_is_it_updated": "Updated when the `_updateSafe` function is called, which happens at the beginning of `repay`.",
            "how_to_validate_state_update": "Verify 'totalCollateral' increases by the 'collateralIncrease' amount determined in the '_updateSafe' call.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'totalCollateral' is increased by any accrued collateral (`collateralIncrease`) calculated during the `_updateSafe` call.",
            "conditions": [
              "Only applies if `_updateSafe` logic is triggered and `collateralIncrease` is positive (i.e., liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral and `collateralIncrease` is > 0)."
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The sum of all outstanding SBD debt across all active CDPs in the protocol.",
            "why_is_is_important": "It represents the total stablecoin supply generated by the protocol.",
            "when_is_it_updated": "Updated via `_updateSafe` at the beginning of `repay` (for potential increase) and then directly by `repay` itself (for decrease).",
            "how_to_validate_state_update": "Verify 'totalDebt' decreases by the 'amount' repaid, after considering any potential increase from accrued debt calculated by '_updateSafe'.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'totalDebt' is decreased by the 'amount' of SBD repaid. It can also be increased by accrued debt (`debtIncrease`) if the `_updateSafe` function logic is triggered before the repayment.",
            "conditions": [
              "Always decreased by the 'amount' being repaid.",
              "Can be increased if `_updateSafe` logic is triggered and `debtIncrease` is positive (i.e., liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral and `debtIncrease` is > 0)."
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The operational mode of the protocol (e.g., BOOTSTRAP, NORMAL).",
            "why_is_is_important": "Determines certain operational parameters and restrictions of the protocol.",
            "when_is_it_updated": "Potentially updated within the `_updateTotalDebt` function, which is called both by `_updateSafe` and directly by `repay`.",
            "how_to_validate_state_update": "Verify 'PROTOCOL_MODE' changes from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' crosses the 'BOOTSTRAP_MODE_DEBT_THRESHOLD' during this transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode can transition from `BOOTSTRAP` to `NORMAL` if the `totalDebt` exceeds a predefined `BOOTSTRAP_MODE_DEBT_THRESHOLD` during the update of `totalDebt`.",
            "conditions": [
              "Only updated if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD` AND `PROTOCOL_MODE` is currently `BOOTSTRAP`."
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[account]",
            "type": "uint256",
            "what_does_it_track": "The SBD token balance held by individual addresses.",
            "why_is_is_important": "Tracks the SBD ownership for each user.",
            "when_is_it_updated": "Updated when `sbdToken.burn(msg.sender, amount)` is called within the `repay` function.",
            "how_to_validate_state_update": "Verify the SBD balance of `msg.sender` decreases by the `amount` repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "The SBD token balance of the `msg.sender` is decreased by the `amount` being repaid.",
            "conditions": [
              "Sender (msg.sender) must have sufficient SBD balance (balanceOf(msg.sender) >= amount)."
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of SBD tokens in existence.",
            "why_is_is_important": "Reflects the overall supply of the stablecoin.",
            "when_is_it_updated": "Updated when `sbdToken.burn(msg.sender, amount)` is called within the `repay` function.",
            "how_to_validate_state_update": "Verify the 'totalSupply' of SBD tokens decreases by the 'amount' repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "The total supply of the SBD token is decreased by the `amount` being repaid (burned).",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total count of SBD tokens that have been permanently removed from circulation.",
            "why_is_is_important": "Provides a public record of the deflationary mechanism of the SBD token.",
            "when_is_it_updated": "Updated when `sbdToken.burn(msg.sender, amount)` is called within the `repay` function.",
            "how_to_validate_state_update": "Verify 'totalBurned' increases by the 'amount' repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "The cumulative amount of SBD tokens that have been burned is increased by the `amount` being repaid.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "struct Node",
            "what_does_it_track": "Individual nodes within the doubly linked list, storing their value (ratio) and pointers to previous and next nodes.",
            "why_is_is_important": "Maintains the ordered lists of CDPs for liquidation and redemption, which is critical for the protocol's stability mechanisms.",
            "when_is_it_updated": "Updated by `safesOrderedForLiquidation.upsert` or `safesOrderedForLiquidation.remove` and `safesOrderedForRedemption.remove` depending on the `_newRatio`.",
            "how_to_validate_state_update": "Check the `nodes` mapping for the `safeId` in `safesOrderedForLiquidation` and `safesOrderedForRedemption`. The node should be updated with the new ratio or removed if debt is zero. Verify `prev` and `next` pointers of adjacent nodes are correct.",
            "has_conditional_updates": true,
            "summary_of_update": "The node representing the `safeId` in the `safesOrderedForLiquidation` list is either updated with a new ratio (if `_newRatio != 0`) or removed (if `_newRatio == 0`). If `_newRatio == 0`, the node is also removed from `safesOrderedForRedemption`.",
            "conditions": [
              "If `_newRatio` (calculated from remaining debt and collateral) is not zero, the safe's node in `safesOrderedForLiquidation` is updated (upserted).",
              "If `_newRatio` is zero (debt is fully repaid), the safe's node is removed from both `safesOrderedForLiquidation` and `safesOrderedForRedemption`."
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the ordered doubly linked list.",
            "why_is_is_important": "Acts as the starting point for traversing the ordered list.",
            "when_is_it_updated": "Updated internally by `_insert` or `_remove` functions within `OrderedDoublyLinkedList` when `safesOrderedForLiquidation.upsert`, `safesOrderedForLiquidation.remove`, or `safesOrderedForRedemption.remove` are called.",
            "how_to_validate_state_update": "Verify the 'head' ID correctly points to the first node in the respective ordered list after modification.",
            "has_conditional_updates": true,
            "summary_of_update": "The `head` pointer of `safesOrderedForLiquidation` or `safesOrderedForRedemption` can be updated if a new node is inserted at the beginning of the list or if the current head node is removed.",
            "conditions": [
              "Only updated if a node is inserted at the head or the current head node is removed.",
              "Depends on the `_newRatio` calculation which determines whether `upsert` or `remove` is called and how the list is modified."
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the ordered doubly linked list.",
            "why_is_is_important": "Acts as the ending point for traversing the ordered list.",
            "when_is_it_updated": "Updated internally by `_insert` or `_remove` functions within `OrderedDoublyLinkedList` when `safesOrderedForLiquidation.upsert`, `safesOrderedForLiquidation.remove`, or `safesOrderedForRedemption.remove` are called.",
            "how_to_validate_state_update": "Verify the 'tail' ID correctly points to the last node in the respective ordered list after modification.",
            "has_conditional_updates": true,
            "summary_of_update": "The `tail` pointer of `safesOrderedForLiquidation` or `safesOrderedForRedemption` can be updated if a new node is inserted at the end of the list or if the current tail node is removed.",
            "conditions": [
              "Only updated if a node is inserted at the tail or the current tail node is removed.",
              "Depends on the `_newRatio` calculation which determines whether `upsert` or `remove` is called and how the list is modified."
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}