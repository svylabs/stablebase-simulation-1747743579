{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: Provide a valid safeId for an existing safe owned by the caller.",
      "amount: Provide a valid amount to repay, which must be less than or equal to the borrowedAmount of the safe and satisfy the MINIMUM_DEBT constraint after repayment.",
      "nearestSpotInLiquidationQueue: Provide a valid node ID in the liquidation queue to help speed up the upsert operation.  A value of 0 indicates that the search should start from the head."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "CDP Debt Repayment",
        "state_update_descriptions": [
          "Decrease the borrowedAmount of the safe with ID safeId by amount.",
          "Update the safe's position in the liquidation queue based on the new ratio or remove from both queues if fully repaid.",
          "Decrease the total debt of the protocol by amount.",
          "Burn SBD tokens from the msg.sender's account.",
          "Update liquidation snapshot if cumulative collateral per unit collateral changes."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "CDP Debt Repayment",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be decreased by amount.",
          "If safes[safeId].borrowedAmount becomes 0, the safe should be removed from both liquidation and redemption queues.",
          "The new ratio (_newRatio) should be equal to (_safe.borrowedAmount * PRECISION) / _safe.collateralAmount.",
          "If _newRatio is not 0, the safe should be upserted in the liquidation queue.",
          "totalDebt should be decreased by amount.",
          "The SBD token balance of msg.sender should be decreased by amount.",
          "The total supply of SBD tokens should be reduced by the repaid amount.",
          "If the safe is removed from the liquidation queue, safesOrderedForLiquidation.remove(safeId) should be called.",
          "If the safe is upserted in the liquidation queue and _newRatio is not zero, safesOrderedForLiquidation.upsert(safeId, _newRatio, nearestSpotInLiquidationQueue) should be called.",
          "If safe is removed from the redemption queue, safesOrderedForRedemption.remove(safeId) should be called.",
          "cumulativeDebtPerUnitCollateral should be correctly updated."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "Stores information about each safe, including collateral amount, borrowed amount, weight, total borrowed amount, and fee paid.",
            "why_is_is_important": "Crucial for tracking the state of each CDP, calculating liquidation ratios, and managing overall system risk.",
            "when_is_it_updated": "Updated when the safe's borrowedAmount changes due to repayment and when collateral and debt amounts are updated due to system-wide changes.",
            "how_to_validate_state_update": "Check that the borrowedAmount is decreased by the repayment amount. Also, check that collateralAmount is updated based on cumulativeCollateralPerUnitCollateral",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowedAmount within the 'safes' mapping is decreased by the 'amount' being repaid. Additionally, the collateralAmount is updated based on cumulative system-wide changes, captured by the difference between cumulativeCollateralPerUnitCollateral and the liquidation snapshot.",
            "conditions": [
              "Repayment amount must be valid (amount <= safe.borrowedAmount)",
              "Repayment amount must result in valid debt (safe.borrowedAmount - amount == 0 || safe.borrowedAmount - amount >= MINIMUM_DEBT)",
              "cumulativeCollateralPerUnitCollateral != liquidationSnapshots[_safeId].collateralPerCollateralSnapshot"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt in the system.",
            "why_is_is_important": "A key metric for assessing the overall health and risk of the protocol. It influences the system's ability to handle liquidations and redemptions.",
            "when_is_it_updated": "Updated when debt is either added (borrowed) or subtracted (repaid).",
            "how_to_validate_state_update": "Verify that 'totalDebt' is decreased by the 'amount' being repaid. The updated totalDebt should trigger a mode change (BOOTSTRAP to NORMAL) if it crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'totalDebt' is reduced by the 'amount' repaid. If the resulting debt falls below the BOOTSTRAP_MODE_DEBT_THRESHOLD while the protocol is in BOOTSTRAP mode, the protocol mode is switched to NORMAL.",
            "conditions": [
              "Debt is being repaid (repay function)",
              "Debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and protocol is in BOOTSTRAP mode"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the current operational mode of the protocol (e.g., BOOTSTRAP, NORMAL).",
            "why_is_is_important": "Determines the behavior of certain system functions and parameters, especially during early stages or emergency situations.",
            "when_is_it_updated": "Updated based on totalDebt crossing the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check that PROTOCOL_MODE is updated from SBStructs.Mode.BOOTSTRAP to SBStructs.Mode.NORMAL when totalDebt crosses BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "has_conditional_updates": true,
            "summary_of_update": "PROTOCOL_MODE is updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD while in BOOTSTRAP mode.",
            "conditions": [
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping(uint256 => LiquidationSnapshot)",
            "what_does_it_track": "Stores snapshots of collateral and debt per collateral for each safe at the time of their last update.",
            "why_is_is_important": "Used to calculate the debt and collateral increase for a safe that hasn't been updated recently, ensuring accurate accounting of debt and collateral.",
            "when_is_it_updated": "Updated when the cumulative collateral or debt per unit collateral changes, which happens during system-wide adjustments.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral and liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral when cumulative system-wide changes occur.",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshots for a safe are updated with the current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral to reflect system-wide adjustments to debt and collateral ratios.",
            "conditions": [
              "cumulativeCollateralPerUnitCollateral != liquidationSnapshots[_safeId].collateralPerCollateralSnapshot"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral deposited in the system.",
            "why_is_is_important": "Indicates the overall security of the system.",
            "when_is_it_updated": "Updated when collateral is added or removed due to cumulative system wide changes in collateral.",
            "how_to_validate_state_update": "Check that 'totalCollateral' is increased based on the difference between cumulativeCollateralPerUnitCollateral and the liquidation snapshot. This occurs when cumulative system-wide changes affect collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateral is updated based on collateral increases, calculated from the difference between cumulativeCollateralPerUnitCollateral and the liquidation snapshot. It reflects system-wide collateral adjustments.",
            "conditions": [
              "cumulativeCollateralPerUnitCollateral != liquidationSnapshots[_safeId].collateralPerCollateralSnapshot"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "An ordered list of safes based on their liquidation ratio.",
            "why_is_is_important": "Maintains the order in which safes should be liquidated, prioritizing those with the highest risk.",
            "when_is_it_updated": "Updated when the liquidation ratio of a safe changes. The safe is re-inserted into the queue based on its new ratio.",
            "how_to_validate_state_update": "Verify that the safesOrderedForLiquidation queue is updated using the upsert or remove function based on the new liquidation ratio. Also check head and tail",
            "has_conditional_updates": true,
            "summary_of_update": "The safesOrderedForLiquidation queue is updated based on the new liquidation ratio. If the new ratio is not zero, the safe is re-inserted into the queue using upsert. If the new ratio is zero, the safe is removed from both queues using _removeSafeFromBothQueues.",
            "conditions": [
              "_newRatio != 0",
              "_newRatio == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "An ordered list of safes based on their redemption ratio.",
            "why_is_is_important": "Maintains the order in which safes should be redeemed.",
            "when_is_it_updated": "The safe is removed from the queue when repaying all debt.",
            "how_to_validate_state_update": "Verify that the safesOrderedForRedemption queue is updated using the remove function.",
            "has_conditional_updates": true,
            "summary_of_update": "The safesOrderedForRedemption queue is updated using the remove function when debt is fully repaid.",
            "conditions": [
              "_newRatio == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Tracks the token balance of each address.",
            "why_is_is_important": "Essential for ensuring that users have sufficient balance to repay and accurately reflects token ownership.",
            "when_is_it_updated": "Updated when tokens are burned (during repayment).",
            "how_to_validate_state_update": "Check that the balance of msg.sender is decreased by the repayment amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of the user (msg.sender) is decreased by the 'amount' being repaid, which is burned.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of the token.",
            "why_is_is_important": "Reflects the total number of tokens in circulation and is crucial for maintaining tokenomics.",
            "when_is_it_updated": "Updated when tokens are burned (during repayment).",
            "how_to_validate_state_update": "Verify that '_totalSupply' is decreased by the repayment 'amount'.",
            "has_conditional_updates": false,
            "summary_of_update": "The '_totalSupply' of the token is decreased by the 'amount' that is being burned.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens that have been burned.",
            "why_is_is_important": "Useful for tracking the deflationary aspect of the token.",
            "when_is_it_updated": "Updated when tokens are burned during repayment.",
            "how_to_validate_state_update": "Check that 'totalBurned' is increased by the 'amount' burned.",
            "has_conditional_updates": false,
            "summary_of_update": "The 'totalBurned' count is increased by the 'amount' of tokens burned during repayment.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Stores the nodes of the linked list, where each node contains a value, a pointer to the previous node, and a pointer to the next node.",
            "why_is_is_important": "Essential for maintaining the correct order of safes in the liquidation and redemption queues.",
            "when_is_it_updated": "Updated when a safe's liquidation ratio changes (either inserted, updated or removed).",
            "how_to_validate_state_update": "Verify nodes are updated in upsert to relfect accurate previous and next node linkages. Verify nodes[id] is deleted in remove.",
            "has_conditional_updates": false,
            "summary_of_update": "The 'nodes' mapping is updated when safes are reordered in the linked list (upsert function) or removed completely (remove function).",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Points to the first node in the linked list.",
            "why_is_is_important": "Essential for traversing the linked list from the beginning.",
            "when_is_it_updated": "Updated when the first node is inserted or removed.",
            "how_to_validate_state_update": "Verify 'head' is updated when a new node is added at the beginning or the existing head node is removed.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'head' is updated to reflect the first node in the linked list after insertion or removal.",
            "conditions": [
              "node.prev == 0",
              "node.next == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Points to the last node in the linked list.",
            "why_is_is_important": "Essential for traversing the linked list from the end.",
            "when_is_it_updated": "Updated when the last node is inserted or removed.",
            "how_to_validate_state_update": "Verify 'tail' is updated when a new node is added at the end or the existing tail node is removed.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'tail' is updated to reflect the last node in the linked list after insertion or removal.",
            "conditions": [
              "node.next == 0",
              "node.prev == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      }
    ]
  }
}