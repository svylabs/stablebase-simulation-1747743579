{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId must correspond to an existing safe owned by msg.sender. safes[safeId] must exist and the owner must be msg.sender.",
      "amount must be greater than 0 and less than or equal to the borrowedAmount for the safe.",
      "amount must be such that after repayment, either borrowedAmount is 0 or borrowedAmount is greater than or equal to MINIMUM_DEBT.",
      "msg.sender must have a sufficient SBD token balance (sbdToken.balanceOf(msg.sender) >= amount).",
      "nearestSpotInLiquidationQueue should be a valid safeId that exists inside safesOrderedForLiquidation.",
      "Find a valid safeId that exists inside safesOrderedForLiquidation or set it to 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "The borrowedAmount of the safe with safeId is decreased by amount.",
          "The collateralAmount of the safe with safeId might be updated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshots.",
          "The weight of the safe with safeId is updated in the liquidation queue based on the new ratio of borrowedAmount to collateralAmount.",
          "If borrowedAmount becomes 0 after repayment, the safe is removed from both liquidation and redemption queues."
        ]
      },
      {
        "category": "Token State",
        "state_update_descriptions": [
          "The SBD token balance of msg.sender is decreased by amount as the tokens are burned."
        ]
      },
      {
        "category": "Protocol State",
        "state_update_descriptions": [
          "The totalDebt is decreased by amount.",
          "The PROTOCOL_MODE might be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "totalCollateral is updated by collateralIncrease"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be equal to the initial borrowedAmount minus the repayment amount and potential debt increase/decrease from the _updateSafe function call, reflecting any accrued inactive debt.",
          "If safes[safeId].borrowedAmount is greater than 0, then safes[safeId].borrowedAmount >= MINIMUM_DEBT.",
          "If safes[safeId].borrowedAmount is 0, the safe should be removed from both the liquidation and redemption queues. safesOrderedForLiquidation.getNode(safeId).value, safesOrderedForLiquidation.getNode(safeId).next and safesOrderedForLiquidation.getNode(safeId).prev should all be 0. The same should be true for safesOrderedForRedemption.getNode(safeId).",
          "The weight of the safe in the liquidation queue should reflect the new borrowedAmount to collateralAmount ratio if the safe is not removed from the queue."
        ]
      },
      {
        "category": "Token State",
        "rule_descriptions": [
          "sbdToken.balanceOf(msg.sender) should be decreased by the amount repaid. It is difficult to validate the precise balance due to potential concurrent transactions, but the balance should not have increased."
        ]
      },
      {
        "category": "Protocol State",
        "rule_descriptions": [
          "totalDebt should be decreased by the amount repaid and any changes that occur during the updateSafe function call.",
          "If the totalDebt is greater than BOOTSTRAP_MODE_DEBT_THRESHOLD, then PROTOCOL_MODE should be NORMAL."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A Repaid event should be emitted with the correct safeId, amount, newRatio, totalCollateral and totalDebt.",
          "A LiquidationQueueUpdated event should be emitted if the safe's position in the liquidation queue is updated and the safe is not removed.",
          "A SafeRemovedFromLiquidationQueue event should be emitted if the safe is removed from the liquidation queue.",
          "A SafeRemovedFromRedemptionQueue event should be emitted if the safe is removed from the redemption queue.",
          "A SafeUpdated event should be emitted if inactive debt/collateral has accumulated."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The outstanding debt for a specific CDP.",
            "why_is_is_important": "Reflects the current debt level of the CDP, crucial for calculating collateralization ratio and liquidation risk.",
            "when_is_it_updated": "When a user repays part or all of their debt.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and ensure that the borrowedAmount has decreased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the borrowed amount of a specific safe (CDP) by the amount repaid.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The aggregate debt across all CDPs.",
            "why_is_is_important": "Represents the overall risk of the protocol and is used in system-wide calculations.",
            "when_is_it_updated": "When a user repays their debt.",
            "how_to_validate_state_update": "Check the totalDebt variable to ensure it has decreased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total outstanding debt in the system.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The debt per collateral snapshot for a given safe.",
            "why_is_is_important": "Used in calculating the inactive debt of a safe.",
            "when_is_it_updated": "When the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping for the safeId and ensure that debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt snapshot for a safe used to calculate inactive debt.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The borrowed amount for a given safe.",
            "why_is_is_important": "Used in calculating the inactive debt of a safe.",
            "when_is_it_updated": "When the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and ensure that borrowedAmount is updated by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount for a safe by debtIncrease if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total borrowed amount for a given safe.",
            "why_is_is_important": "Used in calculating the inactive debt of a safe.",
            "when_is_it_updated": "When the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and ensure that totalBorrowedAmount is updated by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount for a safe by debtIncrease if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The collateral amount for a given safe.",
            "why_is_is_important": "Used in calculating the inactive debt of a safe.",
            "when_is_it_updated": "When the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and ensure that collateralAmount is updated by collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount for a safe by collateralIncrease if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The collateral per collateral snapshot for a given safe.",
            "why_is_is_important": "Used in calculating the inactive debt of a safe.",
            "when_is_it_updated": "When the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping for the safeId and ensure that collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the system.",
            "why_is_is_important": "Used in calculating the inactive debt of a safe.",
            "when_is_it_updated": "When the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check the totalCollateral variable to ensure it has increased by collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the system.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The protocol mode.",
            "why_is_is_important": "Used to determine the protocol mode.",
            "when_is_it_updated": "When the total debt is above the bootstrap mode debt threshold and the protocol mode is bootstrap.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE variable to ensure it is updated to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the total debt is above the threshold.",
            "conditions": [
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "The debt exceeds the bootstrap threshold, and the protocol is currently in bootstrap mode. This transition only happens once, from bootstrap to normal mode"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "contract",
            "what_does_it_track": "The liquidation queue.",
            "why_is_is_important": "Used to determine the order in which safes are liquidated.",
            "when_is_it_updated": "When the new ratio is not 0.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation contract to ensure that the safe is upserted.",
            "has_conditional_updates": true,
            "summary_of_update": "Upserts the safe into the liquidation queue if the CDP is not fully collateralized, maintaining the order for potential liquidation.",
            "conditions": [
              "_newRatio != 0",
              "The CDP's collateralization ratio is not zero after the repayment. A zero ratio implies the CDP is fully collateralized and should be removed from the queue"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "contract",
            "what_does_it_track": "The liquidation and redemption queues.",
            "why_is_is_important": "Used to determine the order in which safes are liquidated and redeemed.",
            "when_is_it_updated": "When the borrowed amount is equal to the amount repaid.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation and safesOrderedForRedemption contracts to ensure that the safe is removed.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the liquidation queue upon full repayment of debt, as the CDP is no longer at risk of liquidation.",
            "conditions": [
              "_safe.borrowedAmount - amount == 0",
              "The borrowed amount after repayment is zero, indicating full repayment of the debt.  Both liquidation and redemption queues are cleared upon full repayment"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "contract",
            "what_does_it_track": "The liquidation and redemption queues.",
            "why_is_is_important": "Used to determine the order in which safes are liquidated and redeemed.",
            "when_is_it_updated": "When the borrowed amount is equal to the amount repaid.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation and safesOrderedForRedemption contracts to ensure that the safe is removed.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the redemption queue upon full repayment, as the CDP no longer requires redemption.",
            "conditions": [
              "_safe.borrowedAmount - amount == 0",
              "The borrowed amount after repayment is zero, indicating full repayment of the debt. Both liquidation and redemption queues are cleared upon full repayment"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The token balance of a user.",
            "why_is_is_important": "Reflects the user's current token holdings.",
            "when_is_it_updated": "When a user repays their debt.",
            "how_to_validate_state_update": "Check the balance of the msg.sender to ensure it has decreased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns the SBD tokens from the user's balance.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens burned.",
            "why_is_is_important": "Reflects the total amount of tokens burned.",
            "when_is_it_updated": "When a user repays their debt.",
            "how_to_validate_state_update": "Check the totalBurned variable to ensure it has increased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total amount of tokens burned.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of tokens.",
            "why_is_is_important": "Reflects the total supply of tokens.",
            "when_is_it_updated": "When a user repays their debt.",
            "how_to_validate_state_update": "Check the totalSupply to ensure it has decreased by the amount repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total supply of tokens.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The nodes in the linked list.",
            "why_is_is_important": "Maintains the correct order of safes in the queue, crucial for liquidation and redemption processes.",
            "when_is_it_updated": "When a new safe needs to be added to the queue, and it's not already present.",
            "how_to_validate_state_update": "Check the nodes mapping to ensure that the node is inserted with the correct value, prev, and next pointers.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts a new node into the linked list if it doesn't already exist, maintaining the sorted order based on value.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0",
              "The node with the given ID does not exist in the linked list. A new node needs to be created and inserted"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The nodes in the linked list.",
            "why_is_is_important": "Maintains the correct order of safes in the queue, crucial for liquidation and redemption processes.",
            "when_is_it_updated": "When an existing safe's collateralization ratio changes, requiring a re-ordering in the queue.",
            "how_to_validate_state_update": "Check the nodes mapping to ensure the node's value is updated and its prev and next pointers are adjusted correctly to reflect its new position in the sorted list.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates a node in the linked list if it already exists, adjusting its value and position to maintain sorted order.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0",
              "The node with the given ID already exists in the linked list.  The existing node needs to be updated with the new value and repositioned within the list to maintain sorted order"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the linked list.",
            "why_is_is_important": "Points to the first element in the sorted list, essential for traversing the queue.",
            "when_is_it_updated": "When the linked list is empty and a new node is inserted.",
            "how_to_validate_state_update": "Check the head and tail variables to ensure they both point to the ID of the newly inserted node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the linked list when the list is empty, setting it to the new node.",
            "conditions": [
              "head == 0",
              "The linked list is currently empty.  This is the first node being inserted, so it becomes both the head and tail"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the linked list.",
            "why_is_is_important": "Points to the last element in the sorted list, allowing efficient addition to the end of the queue.",
            "when_is_it_updated": "When the linked list is empty and a new node is inserted.",
            "how_to_validate_state_update": "Check the head and tail variables to ensure they both point to the ID of the newly inserted node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the linked list when the list is empty, setting it to the new node.",
            "conditions": [
              "head == 0",
              "The linked list is currently empty. This is the first node being inserted, so it becomes both the head and tail"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The nodes in the linked list",
            "why_is_is_important": "Ensures correct positioning of the new node relative to the existing head.",
            "when_is_it_updated": "When the `_nearestSpot` provided is the head, directing insertion relative to the head",
            "how_to_validate_state_update": "Examine the `nodes` mapping to ensure the new node's `next` and `prev` pointers are correctly set, and that the head is updated if necessary.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts the new node either before or after the head node, maintaining the sorted order of the list.",
            "conditions": [
              "_nearestSpot == head",
              "The `_nearestSpot` provided is the current head of the list. The new node needs to be inserted either before or after the head, depending on its value"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The nodes in the linked list",
            "why_is_is_important": "Ensures correct positioning of the new node relative to the existing tail.",
            "when_is_it_updated": "When the `_nearestSpot` provided is the tail, directing insertion relative to the tail",
            "how_to_validate_state_update": "Examine the `nodes` mapping to ensure the new node's `next` and `prev` pointers are correctly set, and that the tail is updated if necessary.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts the new node either before or after the tail node, maintaining the sorted order of the list.",
            "conditions": [
              "_nearestSpot == tail",
              "The `_nearestSpot` provided is the current tail of the list. The new node needs to be inserted either before or after the tail, depending on its value"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the linked list",
            "why_is_is_important": "Maintains the correct start of the linked list after head removal.",
            "when_is_it_updated": "When the node being removed is the head",
            "how_to_validate_state_update": "Check that the `head` variable now points to the node that was previously after the removed node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the linked list when the head node is removed.",
            "conditions": [
              "node.prev == 0",
              "The node being removed is the head of the list.  The `head` pointer needs to be updated to the next node in the list"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the linked list",
            "why_is_is_important": "Maintains the correct end of the linked list after tail removal.",
            "when_is_it_updated": "When the node being removed is the tail",
            "how_to_validate_state_update": "Check that the `tail` variable now points to the node that was previously before the removed node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the linked list when the tail node is removed.",
            "conditions": [
              "node.next == 0",
              "The node being removed is the tail of the list. The `tail` pointer needs to be updated to the previous node in the list"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}