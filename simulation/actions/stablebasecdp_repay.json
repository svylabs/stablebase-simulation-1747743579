{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "Generate a `safeId` for an existing safe that the user owns.",
      "Generate an `amount` to repay, ensuring it's less than or equal to `borrowedAmount`, results in either 0 or >= `MINIMUM_DEBT`, and the user has sufficient SBD.",
      "Find `nearestSpotInLiquidationQueue` or set to 0 for contract to find."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Debt Management",
        "state_update_descriptions": [
          "Decrease the `borrowedAmount` of the safe identified by `safeId` by `amount`.",
          "Potentially increase `borrowedAmount` and collateral amount based on cumulative collateral and debt differences in `_updateSafe`.",
          "Remove the safe from liquidation and redemption queues if `borrowedAmount` becomes 0.",
          "Update the safe's position in the liquidation queue if `borrowedAmount` is not 0.",
          "Decrease `totalDebt` by `amount`.",
          "Potentially update `PROTOCOL_MODE` from `BOOTSTRAP` to `NORMAL` if debt conditions are met."
        ]
      },
      {
        "category": "Token Operations",
        "state_update_descriptions": [
          "Burn SBD tokens from the user's account, decreasing their SBD balance by `amount`.",
          "Decrease the total supply of SBD by `amount`."
        ]
      },
      {
        "category": "Queue Management",
        "state_update_descriptions": [
          "Update the `safesOrderedForLiquidation` doubly linked list based on the new collateralization ratio or remove the safe if fully repaid."
        ]
      },
      {
        "category": "Snapshot and Collateral Updates",
        "state_update_descriptions": [
          "Update the safe's liquidation snapshot with current cumulative collateral and debt if drifted.",
          "Increase the `totalCollateral` by the collateral increase amount if it has drifted."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Debt and Token State",
        "rule_descriptions": [
          "Verify `borrowedAmount` is initial value minus `amount` (accounting for `_updateSafe`).",
          "Verify `totalDebt` is initial value minus `amount` (accounting for `_updateSafe`).",
          "Confirm final `borrowedAmount` is either 0 or >= `MINIMUM_DEBT`.",
          "If final `borrowedAmount` is 0, ensure the safe is removed from queues.",
          "Verify user's SBD balance decreased by `amount`.",
          "Verify total SBD supply decreased by `amount`.",
          "Verify `totalCollateral` is updated correctly, accounting for changes in `_updateSafe`."
        ]
      },
      {
        "category": "Queue State",
        "rule_descriptions": [
          "If the safe's collateralization ratio changed, verify the correct update in `safesOrderedForLiquidation`.",
          "If the final `borrowedAmount` is 0, ensure removal from `safesOrderedForLiquidation` and `safesOrderedForRedemption`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Information of each safe, including its collateral amount, borrowed amount, weight, total borrowed amount and fee paid.",
            "why_is_is_important": "It ensures that the Safe's state is up-to-date with respect to accrued debt and collateral changes due to system-wide updates.",
            "when_is_it_updated": "This is updated at the beginning of the `repay` function, which will update the debt and collateral amount depending on the liquidationSnapshot values of cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Fetch the Safe struct for the given safeId before and after the transaction and compare the collateralAmount and borrowedAmount. Also check the SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the Safe struct with potentially new collateralAmount and borrowedAmount values based on cumulative debt and collateral changes since the last update. It reads from liquidationSnapshots and cumulative debt/collateral per unit collateral to calculate debt and collateral increases.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "amount <= _safe.borrowedAmount",
              "amount <= sbdToken.balanceOf(msg.sender)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Stores the collateral and debt per collateral snapshots for each safe.",
            "why_is_is_important": "It helps track changes of debt and collateral increase.",
            "when_is_it_updated": "It's updated when the collateralPerCollateralSnapshot is not equal to the cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Fetch liquidationSnapshots[safeId] before and after the transaction. Check the values of collateralPerCollateralSnapshot and debtPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates liquidation snapshot with the current cumulative debt and collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "variable",
            "what_does_it_track": "Tracks the total collateral in the system.",
            "why_is_is_important": "It's important for calculating global collateralization ratios and system health.",
            "when_is_it_updated": "It is updated inside _updateSafe when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the totalCollateral value before and after the transaction. If `collateralIncrease` is greater than 0, then `totalCollateral` should increase by `collateralIncrease`. Also, check the SafeUpdated event",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the global cumulative debt.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "variable",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "It is important for calculating global collateralization ratios and system health.",
            "when_is_it_updated": "It is updated inside _updateSafe when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check the totalDebt before and after the transaction. If `debtIncrease` is greater than 0, then `totalDebt` should increase by `debtIncrease`. Also, check the SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the global debt.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operational mode of the protocol.",
            "why_is_is_important": "It controls certain protocol behaviors based on the total debt level.",
            "when_is_it_updated": "This is updated when calling _updateTotalDebt when `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`.",
            "how_to_validate_state_update": "Check PROTOCOL_MODE before and after the transaction. Verify that if debt > BOOTSTRAP_MODE_DEBT_THRESHOLD and PROTOCOL_MODE was BOOTSTRAP, it changes to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the total debt crosses a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "variable",
            "what_does_it_track": "The balance of each address in the SBD token contract.",
            "why_is_is_important": "This is important for tracking the amount of SBD tokens each user holds.",
            "when_is_it_updated": "It is updated when the repay function is called and the user has sufficient SBD balance and the repayment amount is valid.",
            "how_to_validate_state_update": "Check the balance of msg.sender in SBD token before and after the transaction. Ensure it decreases by the amount being repaid.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns the SBD tokens held by the msg.sender",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "variable",
            "what_does_it_track": "The total amount of SBD tokens in circulation.",
            "why_is_is_important": "Important for ensuring the total amount of SBD in circulation is accurately tracked.",
            "when_is_it_updated": "It is updated inside the _update function which is called by the _burn function, reducing the total supply.",
            "how_to_validate_state_update": "Check the totalSupply of SBD token before and after the transaction. The totalSupply should decrease by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total supply of the token.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "variable",
            "what_does_it_track": "Tracks the total amount of SBD tokens that have been burned.",
            "why_is_is_important": "Important for accounting purposes within the DFIDToken contract.",
            "when_is_it_updated": "It is updated inside the burn function, when repay is called, which increases the totalBurned value.",
            "how_to_validate_state_update": "Check the totalBurned of SBD token before and after the transaction. The totalBurned should increase by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increase totalBurned by the amount burned.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The nodes for the linked list implementation.",
            "why_is_is_important": "It helps in managing the order of safes for liquidation and redemption purposes.",
            "when_is_it_updated": "The linked list is updated when `_safe.borrowedAmount - amount == 0` is false and `_safe.borrowedAmount - amount >= MINIMUM_DEBT` is true. Also, the linked list is updated when the liquidation ratio changes, or when the safe is removed from the queue when all debt is repaid.",
            "how_to_validate_state_update": "Check the linked list by traversing it from head to tail and verify that the order is correct based on safe ratios. Ensure that the removed safe is no longer in the list.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the linked list of safes ordered for liquidation (`safesOrderedForLiquidation`), if the repayment results in a new ratio. If the safe's borrowed amount becomes zero, it removes the safe from both queues.",
            "conditions": [
              "_newRatio != 0",
              "_safe.borrowedAmount > 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "variable",
            "what_does_it_track": "The head of the linked list",
            "why_is_is_important": "Used to identify the minimum weight.",
            "when_is_it_updated": "It is updated when a new node is inserted that is smaller than the current head, or when a current head is removed.",
            "how_to_validate_state_update": "Check the head before and after. The head node in the linked list represents the node with minimum weight.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the linked list, if the new safe becomes the head.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "variable",
            "what_does_it_track": "The tail of the linked list",
            "why_is_is_important": "Used to identify the maximum weight.",
            "when_is_it_updated": "It is updated when a new node is inserted that is larger than the current tail, or when a current tail is removed.",
            "how_to_validate_state_update": "Check the tail before and after. The tail node in the linked list represents the node with maximum weight.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the linked list, if the new safe becomes the tail.",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}