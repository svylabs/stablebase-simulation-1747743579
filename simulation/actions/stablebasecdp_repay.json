{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: Needs to be a valid safeId that exists in the safes mapping and is owned by the msg.sender.",
      "amount: Must be greater than 0 and less than or equal to the borrowedAmount of the specified safe. Must ensure that after repayment, borrowedAmount is either 0 or greater than or equal to MINIMUM_DEBT.",
      "nearestSpotInLiquidationQueue: Should be a valid safeId that is present inside the liquidation queue, used for the linked list insertion. Can be 0 if the list is empty."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId].borrowedAmount -= amount",
          "The weight of the safe might change depending on the updated borrowedAmount and collateralAmount. Call to 'safesOrderedForLiquidation.upsert' with appropriate values"
        ]
      },
      {
        "category": "SBD Token",
        "state_update_descriptions": [
          "sbdToken.burn(msg.sender, amount) is called, which decreases the balance of the msg.sender and reduces the total supply of SBD tokens."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "totalDebt is decreased by amount through _updateTotalDebt(totalDebt, amount, false)."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "The position of the safe in the liquidation queue may be updated via safesOrderedForLiquidation.upsert if the repayment changes the collateralization ratio.",
          "If the safe's borrowed amount is reduced to zero, it should be removed from the queue via _removeSafeFromBothQueues, which calls safesOrderedForLiquidation.remove and safesOrderedForRedemption.remove."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot might be updated to cumulativeDebtPerUnitCollateral. Before the debt is repaid, the safe is updated via _updateSafe(), which will check and update the liquidation snapshot if needed."
        ]
      },
      {
        "category": "Cumulative Debt",
        "state_update_descriptions": [
          "If cumulativeDebtPerUnitCollateral is updated, then the debt inside liquidationSnapshots[_safeId] is updated and also the _safe.borrowedAmount",
          "totalCollateral is also updated"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be decreased by amount.",
          "If safes[safeId].borrowedAmount becomes 0, the safe should be removed from both liquidation and redemption queues. Check that safesOrderedForLiquidation.remove(safeId) and safesOrderedForRedemption.remove(safeId) are called.",
          "If safes[safeId].borrowedAmount is not 0, safesOrderedForLiquidation.upsert(safeId, newRatio, nearestSpotInLiquidationQueue) should be called to update the safe's position in the liquidation queue based on the new ratio."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "totalDebt should be decreased by the repayment amount. Check that _updateTotalDebt is called with add = false."
        ]
      },
      {
        "category": "SBD Token",
        "rule_descriptions": [
          "The SBD token balance of the msg.sender should be decreased by amount. Check that sbdToken.burn(msg.sender, amount) is called."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral if cumulativeDebtPerUnitCollateral has been updated."
        ]
      },
      {
        "category": "Safe Liquidation and Redemption Queues",
        "rule_descriptions": [
          "If the safe's borrowed amount is reduced to zero, it should be removed from both the liquidation and redemption queues. Verify that `_removeSafeFromBothQueues` is called.",
          "If the safe's borrowed amount is not zero, verify that the safe's position in the liquidation queue is updated via `safesOrderedForLiquidation.upsert` based on the new debt ratio.",
          "Verify the event `LiquidationQueueUpdated` is emitted with the correct parameters (safeId, newRatio, node.next)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "mapping",
            "what_does_it_track": "The amount of debt borrowed for a specific safe.",
            "why_is_is_important": "Reflects the current outstanding debt of a safe, crucial for determining collateralization ratio and liquidation eligibility.",
            "when_is_it_updated": "When a user repays a portion of their borrowed amount.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and ensure that borrowedAmount has decreased by the amount repaid. Verify the Repaid event emitted.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the borrowedAmount of a specific safe by subtracting the repayment amount.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "sbdToken.balanceOf(msg.sender) >= amount",
              "amount <= safe.borrowedAmount",
              "safe.borrowedAmount - amount == 0 || safe.borrowedAmount - amount >= MINIMUM_DEBT"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "state_variable",
            "what_does_it_track": "The total outstanding debt of the entire protocol.",
            "why_is_is_important": "Key metric for assessing the overall risk and health of the protocol.",
            "when_is_it_updated": "When a user repays their debt (decreases) or borrows more (increases).",
            "how_to_validate_state_update": "Check the totalDebt state variable and ensure that it has decreased by the amount repaid. Verify the Repaid event emitted.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt of the protocol by subtracting the repayment amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "state_variable",
            "what_does_it_track": "Keeps track of the total collateral deposited across all safes.",
            "why_is_is_important": "Used to calculate the overall collateralization ratio of the protocol.",
            "when_is_it_updated": "Before repay is executed, during the call to _updateSafe which updates collateral when the cumulativeCollateralPerUnitCollateral has changed.",
            "how_to_validate_state_update": "Check the totalCollateral variable and ensure it has been updated correctly if cumulativeCollateralPerUnitCollateral has changed since the last update. Verify the SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalCollateral when inactive debt and collateral are synced.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId]",
            "type": "mapping",
            "what_does_it_track": "Stores the cumulative debt and collateral per unit collateral values at the time of the last snapshot for a given safe.",
            "why_is_is_important": "Used to calculate the inactive debt and collateral for a safe during the _updateSafe.",
            "when_is_it_updated": "Before repay is executed, during the call to _updateSafe when the cumulativeCollateralPerUnitCollateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check that the debtPerCollateralSnapshot and collateralPerCollateralSnapshot for the safeId have been updated to the current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral values respectively. Verify the SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates liquidationSnapshots mapping during the call to _updateSafe.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "state_variable",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "Impacts certain protocol functionalities and parameters based on the current mode.",
            "when_is_it_updated": "When the total debt crosses a predefined threshold while repay is executed.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE state variable after the function execution to see if it has been updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the PROTOCOL_MODE from BOOTSTRAP to NORMAL if the total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "conditions": [
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[from]",
            "type": "state_variable",
            "what_does_it_track": "The SBD token balance of each account.",
            "why_is_is_important": "Essential for tracking ownership and ensuring sufficient funds for transfers and other operations.",
            "when_is_it_updated": "When a user repays debt or when SBD tokens are transferred, minted or burned.",
            "how_to_validate_state_update": "Check the balance of the msg.sender before and after the burn, verifying that the balance has decreased by the 'amount'. Also verify the Burn event emitted.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns SBD tokens from the msg.sender's account, reducing their balance.",
            "conditions": [
              "msg.sender != address(0)",
              "amount > 0",
              "balanceOf(msg.sender) >= amount"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "state_variable",
            "what_does_it_track": "Total amount of SBD token in circulation.",
            "why_is_is_important": "Core metric of the SBD token's economics.",
            "when_is_it_updated": "Whenever new SBD tokens are minted or burned.",
            "how_to_validate_state_update": "Check the total supply of SBD tokens before and after the burn, and verify the emitted Transfer event. Verify that the total supply has decreased by the amount of the burned SBD tokens.",
            "has_conditional_updates": false,
            "summary_of_update": "Decrease the total supply of SBD tokens by burning tokens.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "state_variable",
            "what_does_it_track": "Total amount of SBD token burned.",
            "why_is_is_important": "Core metric of the SBD token's economics. Keeps track of how many tokens have been taken out of circulation by burning.",
            "when_is_it_updated": "Whenever SBD tokens are burned.",
            "how_to_validate_state_update": "Check the totalBurned SBD tokens before and after the burn. Also verify the Burn event.",
            "has_conditional_updates": false,
            "summary_of_update": "Increase the total amount of burned tokens",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "mapping",
            "what_does_it_track": "Nodes in the linked list, storing the safeId, its liquidation ratio (value), and pointers to the previous and next nodes.",
            "why_is_is_important": "Maintains the order of safes based on their liquidation ratio, allowing for efficient selection of safes for liquidation.",
            "when_is_it_updated": "When the borrowed amount or collateral amount of a safe changes, affecting its liquidation ratio.",
            "how_to_validate_state_update": "Check the nodes mapping for the given safeId and ensure the value, prev, and next fields are updated according to the linked list logic. Check LiquidationQueueUpdated event.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates or inserts a node in the liquidation queue with the safe's id and new ratio.",
            "conditions": [
              "_newRatio != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "state_variable",
            "what_does_it_track": "The ID of the safe with the lowest liquidation ratio in the queue.",
            "why_is_is_important": "Points to the first safe to be considered for liquidation.",
            "when_is_it_updated": "When a new safe with a lower liquidation ratio is added to the queue, or when the current head is removed.",
            "how_to_validate_state_update": "Check the head variable and confirm it points to the safe with the lowest liquidation ratio. Check LiquidationQueueUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the liquidation queue if the new node becomes the new head.",
            "conditions": [
              "nodes[_nearestSpot].value >= node.value",
              "_nearestSpot == _head"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "state_variable",
            "what_does_it_track": "The ID of the safe with the highest liquidation ratio in the queue.",
            "why_is_is_important": "Points to the last safe in the queue.",
            "when_is_it_updated": "When a new safe with a higher liquidation ratio is added to the queue, or when the current tail is removed.",
            "how_to_validate_state_update": "Check the tail variable and confirm it points to the safe with the highest liquidation ratio. Check LiquidationQueueUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the liquidation queue if the new node becomes the new tail.",
            "conditions": [
              "nodes[_nearestSpot].value < node.value",
              "_nearestSpot == _tail"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": []
        }
      }
    ]
  }
}