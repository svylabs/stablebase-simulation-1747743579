{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: This should be the ID of an existing safe owned by the message sender.",
      "amount: This should be a non-zero value, not greater than safe.borrowedAmount. amount should either result in safe.borrowedAmount becoming zero, or remaining greater than or equal to MINIMUM_DEBT.",
      "nearestSpotInLiquidationQueue: This can be any safeId currently in the liquidation queue, or zero. A sensible default would be zero. This value influences the efficiency of the doubly linked list upsert operation."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Updates",
        "state_update_descriptions": [
          "Decrease borrowedAmount of the safe with ID safeId by amount.",
          "Update collateralAmount of the safe with ID safeId based on cumulativeCollateralPerUnitCollateral, if cumulativeCollateralPerUnitCollateral has changed.",
          "Update liquidationSnapshots[safeId].debtPerCollateralSnapshot to cumulativeDebtPerUnitCollateral, if cumulativeDebtPerUnitCollateral has changed.",
          "Update liquidationSnapshots[safeId].collateralPerCollateralSnapshot to cumulativeCollateralPerUnitCollateral, if cumulativeCollateralPerUnitCollateral has changed."
        ]
      },
      {
        "category": "Token Updates",
        "state_update_descriptions": [
          "Decrease SBD token balance of the message sender by amount via burn."
        ]
      },
      {
        "category": "Liquidation Queue Updates",
        "state_update_descriptions": [
          "Remove the safe with ID safeId from the liquidation queue if the new ratio of borrowedAmount to collateralAmount is 0.",
          "Update the safe with ID safeId's position in the liquidation queue based on the new ratio of borrowedAmount to collateralAmount and nearestSpotInLiquidationQueue, if safeId is not removed."
        ]
      },
      {
        "category": "Redemption Queue Updates",
        "state_update_descriptions": [
          "Remove the safe with ID safeId from the redemption queue if the new ratio of borrowedAmount to collateralAmount is 0."
        ]
      },
      {
        "category": "Total Debt Updates",
        "state_update_descriptions": [
          "Decrease total debt (totalDebt) by amount."
        ]
      },
      {
        "category": "Protocol Mode Updates",
        "state_update_descriptions": [
          "Change the protocol mode (PROTOCOL_MODE) from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Total Collateral Updates",
        "state_update_descriptions": [
          "Increase total collateral (totalCollateral) based on cumulativeCollateralPerUnitCollateral, if cumulativeCollateralPerUnitCollateral has changed."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Updates",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount == (old safes[safeId].borrowedAmount - amount).",
          "If cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral have changed, safes[safeId].collateralAmount == (old safes[safeId].collateralAmount + (old safes[safeId].collateralAmount * (cumulativeCollateralPerUnitCollateral - old liquidationSnapshots[safeId].collateralPerCollateralSnapshot)) / PRECISION).",
          "If cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral have changed, safes[safeId].borrowedAmount == (old safes[safeId].borrowedAmount + (old safes[safeId].collateralAmount * (cumulativeDebtPerUnitCollateral - old liquidationSnapshots[safeId].debtPerCollateralSnapshot)) / PRECISION).",
          "If cumulativeDebtPerUnitCollateral changed, liquidationSnapshots[safeId].debtPerCollateralSnapshot == cumulativeDebtPerUnitCollateral.",
          "If cumulativeCollateralPerUnitCollateral changed, liquidationSnapshots[safeId].collateralPerCollateralSnapshot == cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Token Updates",
        "rule_descriptions": [
          "sbdToken.balanceOf(msg.sender) == (old sbdToken.balanceOf(msg.sender) - amount)."
        ]
      },
      {
        "category": "Liquidation Queue Updates",
        "rule_descriptions": [
          "If safes[safeId].borrowedAmount is zero, safesOrderedForLiquidation.getNode(safeId) == (0,0,0).",
          "If safes[safeId].borrowedAmount is not zero, safesOrderedForLiquidation.getNode(safeId).value reflects updated ratio of borrowedAmount to collateralAmount."
        ]
      },
      {
        "category": "Redemption Queue Updates",
        "rule_descriptions": [
          "If safes[safeId].borrowedAmount is zero, safesOrderedForRedemption.getNode(safeId) == (0,0,0)."
        ]
      },
      {
        "category": "Total Debt Updates",
        "rule_descriptions": [
          "totalDebt == (old totalDebt - amount)."
        ]
      },
      {
        "category": "Protocol Mode Updates",
        "rule_descriptions": [
          "If old totalDebt <= BOOTSTRAP_MODE_DEBT_THRESHOLD and totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD and old PROTOCOL_MODE == BOOTSTRAP, then PROTOCOL_MODE == NORMAL."
        ]
      },
      {
        "category": "Total Collateral Updates",
        "rule_descriptions": [
          "If cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral have changed, then totalCollateral == (old totalCollateral + (_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION)."
        ]
      },
      {
        "category": "Invariants",
        "rule_descriptions": [
          "totalDebt >= 0",
          "totalCollateral >= 0",
          "PROTOCOL_MODE is either BOOTSTRAP or NORMAL.",
          "If safe exists in liquidation queue, safes mapping exists and safes[safeId].borrowedAmount != 0.",
          "If safe exists in safes mapping and safes[safeId].borrowedAmount == 0, safe does not exist in liquidation queue."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt owed by a specific safe.",
            "why_is_is_important": "Reflects the current debt of the safe, crucial for assessing collateralization and liquidation risks for the specific safe's position in the protocol. A decrease indicates a reduction in the user's outstanding loan, affecting their liquidation threshold and overall risk profile within the system. ",
            "when_is_it_updated": "When a user repays part or all of their debt.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId to see if the borrowedAmount has decreased by the amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The borrowedAmount of the safe with safeId is decreased by the amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the system.",
            "why_is_is_important": "Reflects the overall system risk and is used in stability calculations. Crucial for monitoring the overall health and stability of the protocol. A reduction indicates a decrease in the total liabilities of the system, which can positively impact the protocol's resilience to market fluctuations and improve its solvency metrics. ",
            "when_is_it_updated": "When a user repays their debt.",
            "how_to_validate_state_update": "Check the totalDebt variable to confirm that it has decreased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalDebt is decreased by the amount.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the debt per collateral at the time of the last update.",
            "why_is_is_important": "Used to accurately calculate debt increases due to protocol-wide changes. Ensures that the debt associated with a safe accurately reflects accumulated interest and fees, crucial for maintaining fair and accurate accounting of user liabilities within the protocol. This is a snapshot in time, so helps in reconciling system level changes with user debt. ",
            "when_is_it_updated": "When the cumulative debt per unit collateral changes.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping for the safeId and ensure that the debtPerCollateralSnapshot is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debtPerCollateralSnapshot for the safe if the collateral per collateral snapshot has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the collateral per collateral at the time of the last update.",
            "why_is_is_important": "Used to accurately calculate collateral increases due to protocol-wide changes. Important for capturing system-wide adjustments to collateral holdings and ensuring that user positions reflect those adjustments, thereby safeguarding the integrity of collateralized assets within the protocol. This is a snapshot in time, so helps in reconciling system level changes with user collateral. ",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check the liquidationSnapshots mapping for the safeId and ensure that the collateralPerCollateralSnapshot is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralPerCollateralSnapshot for the safe if the collateral per collateral snapshot has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited by a specific safe.",
            "why_is_is_important": "Reflects the current collateral of the safe, critical for calculating collateralization ratio and liquidation thresholds. Indicates the current asset backing the user's debt and determines the loan-to-value ratio, impacting the safety and solvency of the user's position within the protocol. ",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and verify that collateralAmount has increased by collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateralAmount of the safe if the collateral per collateral snapshot has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol.",
            "why_is_is_important": "Controls certain protocol behaviors and parameters based on the system's debt level. Directly affects key parameters and mechanisms governing the protocol's stability and functionality, such as interest rates, liquidation thresholds, and governance rules. This directly indicates which operational parameters are in play. ",
            "when_is_it_updated": "When the total debt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE variable to confirm it has changed to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "An ordered list of safes eligible for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Maintains the order of safes for liquidation, ensuring the riskiest safes are liquidated first. Enables efficient and prioritized liquidation of undercollateralized positions, which helps to minimize losses and maintain the solvency of the overall system. ",
            "when_is_it_updated": "When a safe's collateralization ratio changes due to repayment.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation contract to see if the safeId has been upserted with the newRatio.",
            "has_conditional_updates": true,
            "summary_of_update": "Upserts the safe in the liquidation queue with the new collateralization ratio if _newRatio is not 0.",
            "conditions": [
              "_newRatio != 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "An ordered list of safes eligible for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Removes safes from queues when they no longer need to be there. Keeps track of safes in queues to prevent issues. Removing unneeded safes from queues also minimizes computational overhead. ",
            "when_is_it_updated": "When a safe's collateralization ratio becomes 0 due to repayment.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation and safesOrderedForRedemption contracts to ensure the safeId has been removed from both queues.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from both liquidation and redemption queues if _newRatio is 0.",
            "conditions": [
              "_newRatio == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "An ordered list of safes eligible for redemption based on their collateralization ratio.",
            "why_is_is_important": "Removes safes from queues when they no longer need to be there. Keeps track of safes in queues to prevent issues. Removing unneeded safes from queues also minimizes computational overhead. ",
            "when_is_it_updated": "When a safe's collateralization ratio becomes 0 due to repayment.",
            "how_to_validate_state_update": "Check the safesOrderedForLiquidation and safesOrderedForRedemption contracts to ensure the safeId has been removed from both queues.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from both liquidation and redemption queues if _newRatio is 0.",
            "conditions": [
              "_newRatio == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt owed by a specific safe.",
            "why_is_is_important": "Reflects the current debt of the safe, critical for calculating collateralization ratio and liquidation thresholds. Represents the current outstanding debt of a safe, which is used to determine if a safe needs to be adjusted due to changes in the protocol. ",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and verify that borrowedAmount has increased by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the borrowedAmount of the safe if the collateral per collateral snapshot has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount of debt borrowed by a specific safe over its lifetime.",
            "why_is_is_important": "Tracks the total debt borrowed, useful for historical analysis and potentially for calculating fees. Keeping track of the total borrowed amount helps in auditing and analyzing the behavior of individual safes over time, which can inform risk management and parameter tuning efforts for the protocol. ",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and verify that totalBorrowedAmount has increased by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalBorrowedAmount of the safe if the collateral per collateral snapshot has changed.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Total collateral deposited to the protocol.",
            "why_is_is_important": "Used in stability calculations. Impacts the overall stability and solvency of the protocol by influencing the collateralization ratio of the entire system. Changes to this affect all the users of the protocol. ",
            "when_is_it_updated": "When a safe is updated.",
            "how_to_validate_state_update": "Check the totalCollateral variable to confirm that it has increased by collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The SBD balance of each user.",
            "why_is_is_important": "Essential for tracking user's ability to repay debt. Direct impact on users' ability to interact with the protocol. This variable is used for enforcing payment rules. ",
            "when_is_it_updated": "When a user repays debt.",
            "how_to_validate_state_update": "Check the balanceOf mapping to confirm that the balance of msg.sender has decreased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of SBD tokens for the msg.sender is decreased by amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD tokens burned.",
            "why_is_is_important": "Tracks the total amount of burned SBD tokens. Vital for monitoring the deflationary aspects of the tokenomics and provides insights into the long-term sustainability of the SBD token. It is also useful for calculating the circulating supply of the token. ",
            "when_is_it_updated": "When a user repays debt.",
            "how_to_validate_state_update": "Check the totalBurned variable to confirm that it has increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalBurned amount is increased by amount.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of SBD tokens.",
            "why_is_is_important": "Maintains an accurate record of the total supply of SBD. Central to maintaining the price stability and overall health of the SBD token. It is an invariant that needs to be maintained for correct functioning of the protocol. ",
            "when_is_it_updated": "When a user repays debt.",
            "how_to_validate_state_update": "Check the totalSupply variable to confirm that it has decreased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalSupply of SBD tokens is decreased by amount.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Node information in liquidation or redemption queue.",
            "why_is_is_important": "Maintains the order of safes in the liquidation or redemption queue. Critical for managing the ordering of safes within the linked list structure. Each node update affects the sequence of safes to be liquidated or redeemed. ",
            "when_is_it_updated": "When a safe's collateralization ratio changes due to repayment.",
            "how_to_validate_state_update": "Check if the node with id 'safeId' is inserted into the list based on its 'value' (collateralization ratio) and '_nearestSpot'.",
            "has_conditional_updates": true,
            "summary_of_update": "If a node with a given safeId does not exist, insert it into the doubly linked list.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Node information in liquidation or redemption queue.",
            "why_is_is_important": "Maintains the order of safes in the liquidation or redemption queue. Critical for managing the ordering of safes within the linked list structure. Each node update affects the sequence of safes to be liquidated or redeemed. ",
            "when_is_it_updated": "When a safe's collateralization ratio changes due to repayment.",
            "how_to_validate_state_update": "Check if the node with id 'safeId' is updated in the list based on its 'value' (collateralization ratio) and '_nearestSpot'.",
            "has_conditional_updates": true,
            "summary_of_update": "If a node with a given safeId exists, update it in the doubly linked list.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head node of liquidation or redemption queue.",
            "why_is_is_important": "Maintains the head of safes in the liquidation or redemption queue. It is the entry point for traversing the list of safes, so updating the head is required for traversing the safes. ",
            "when_is_it_updated": "When a safe's collateralization ratio changes due to repayment.",
            "how_to_validate_state_update": "Check if head is updated when first node is inserted or when existing node is removed and it was head.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the head of the doubly linked list when node is inserted or removed.",
            "conditions": []
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail node of liquidation or redemption queue.",
            "why_is_is_important": "Maintains the tail of safes in the liquidation or redemption queue. Marks the end of the list, so is useful in traversing the safes in the queue. ",
            "when_is_it_updated": "When a safe's collateralization ratio changes due to repayment.",
            "how_to_validate_state_update": "Check if tail is updated when last node is inserted or when existing node is removed and it was tail.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the tail of the doubly linked list when node is inserted or removed.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "stabilityPool"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "mockPriceOracle"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "stabilityPool"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "dfireStaking"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "safesOrderedForRedemption"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}