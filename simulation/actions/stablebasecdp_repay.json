{
  "action": {
    "name": "Repay",
    "summary": "Repays debt for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId owned by the msg.sender. This can be obtained by querying existing safes.",
      "amount: A value greater than 0 and less than or equal to the safe's borrowedAmount. amount should be such that safe.borrowedAmount - amount == 0 || safe.borrowedAmount - amount >= MINIMUM_DEBT.",
      "nearestSpotInLiquidationQueue: A valid safeId present in the liquidation queue, used to optimize the queue update. Can be 0.",
      "msg.sender must have sufficient SBD tokens to repay the specified amount (sbdToken.balanceOf(msg.sender) >= amount)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Updates",
        "state_update_descriptions": [
          "Update borrowedAmount of the safe.",
          "Update collateralAmount of the safe.",
          "Potentially remove safe from liquidation and redemption queues if borrowedAmount becomes zero.",
          "Update totalBorrowedAmount of the safe based on cumulativeDebtPerUnitCollateral if cumulativeCollateralPerUnitCollateral is updated."
        ]
      },
      {
        "category": "Token Updates",
        "state_update_descriptions": [
          "Burn SBD tokens from the msg.sender's balance."
        ]
      },
      {
        "category": "System Debt Updates",
        "state_update_descriptions": [
          "Decrease totalDebt."
        ]
      },
      {
        "category": "Liquidation Queue Updates",
        "state_update_descriptions": [
          "Update position of the safe in the liquidation queue or remove if borrowedAmount becomes zero."
        ]
      },
      {
        "category": "Protocol Mode Updates",
        "state_update_descriptions": [
          "Potentially transition PROTOCOL_MODE from BOOTSTRAP to NORMAL."
        ]
      },
      {
        "category": "Liquidation Snapshot Updates",
        "state_update_descriptions": [
          "Update liquidationSnapshots for collateralPerCollateralSnapshot and debtPerCollateralSnapshot."
        ]
      },
      {
        "category": "System Collateral Updates",
        "state_update_descriptions": [
          "Total collateral can be updated based on cumulativeCollateralPerUnitCollateral"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Validation",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should be decreased by the amount.",
          "If the final safes[safeId].borrowedAmount is greater than 0, then (safes[safeId].borrowedAmount * PRECISION) / safes[safeId].collateralAmount should equal the newRatio emitted in the Repaid event.",
          "If the final safes[safeId].borrowedAmount is equal to 0, then the safe should be removed from both liquidation and redemption queues (safesOrderedForLiquidation and safesOrderedForRedemption).",
          "safes[safeId].collateralAmount should reflect any changes due to collateral updates.",
          "If the safe state has updated, then SafeUpdated event should be emitted."
        ]
      },
      {
        "category": "Token Validation",
        "rule_descriptions": [
          "sbdToken.balanceOf(msg.sender) should be decreased by the amount."
        ]
      },
      {
        "category": "System Debt Validation",
        "rule_descriptions": [
          "totalDebt should be decreased by the amount."
        ]
      },
      {
        "category": "Liquidation Queue Validation",
        "rule_descriptions": [
          "If borrowedAmount > 0, safesOrderedForLiquidation should reflect the updated position based on the new ratio (borrowedAmount * PRECISION) / collateralAmount.",
          "If borrowedAmount == 0, safeId should not exist in the safesOrderedForLiquidation linked list."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "A Repaid event should be emitted with the correct safeId, amount, newRatio, totalCollateral and totalDebt.",
          "If the safe is removed from the liquidation queue, a SafeRemovedFromLiquidationQueue event should be emitted.",
          "If the safe is removed from the redemption queue, a SafeRemovedFromRedemptionQueue event should be emitted."
        ]
      },
      {
        "category": "Protocol Mode Validation",
        "rule_descriptions": [
          "PROTOCOL_MODE should be NORMAL if totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD, and it was previously BOOTSTRAP."
        ]
      },
      {
        "category": "Invariants Validation",
        "rule_descriptions": [
          "Total collateral should be consistent with the sum of collateral across all safes.",
          "Total debt should be consistent with the sum of borrowed amounts across all safes."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Repay",
    "contract_name": "StableBaseCDP",
    "function_name": "repay",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The outstanding debt of a specific CDP.",
            "why_is_is_important": "Reflects the current debt level of a CDP, which is crucial for calculating collateralization ratio and liquidation risk.",
            "when_is_it_updated": "When a user repays a portion of their borrowed debt.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount has decreased by the repay amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the borrowedAmount of a specific safe (CDP) by the amount repaid.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The aggregate debt across all CDPs in the system.",
            "why_is_is_important": "Indicates the overall risk and health of the system. Used for system-wide calculations and governance decisions.",
            "when_is_it_updated": "When any user repays their debt.",
            "how_to_validate_state_update": "Verify that the totalDebt has decreased by the repay amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total debt in the system by the amount repaid.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The queue of safes ordered by their liquidation risk.",
            "why_is_is_important": "Maintaining the correct order of safes in the liquidation queue ensures that the riskiest safes are liquidated first.",
            "when_is_it_updated": "When the safe is fully repaid.",
            "how_to_validate_state_update": "Check that the safe has been removed from both queues by verifying that the doubly linked lists no longer contain the safeId",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the liquidation queue when the debt is fully repaid",
            "conditions": [
              "_safe.borrowedAmount - amount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The queue of safes ordered by their redemption risk.",
            "why_is_is_important": "Maintaining the correct order of safes in the redemption queue ensures that the riskiest safes are redeemed first.",
            "when_is_it_updated": "When the safe is fully repaid.",
            "how_to_validate_state_update": "Check that the safe has been removed from both queues by verifying that the doubly linked lists no longer contain the safeId",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a safe from the redemption queue when the debt is fully repaid",
            "conditions": [
              "_safe.borrowedAmount - amount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The queue of safes ordered by their liquidation risk.",
            "why_is_is_important": "Maintaining the correct order of safes in the liquidation queue ensures that the riskiest safes are liquidated first.",
            "when_is_it_updated": "After a partial repayment that results in a change to the collateralization ratio.",
            "how_to_validate_state_update": "Verify that the safeId is present in the liquidation queue, and its position is updated according to the newRatio and nearestSpotInLiquidationQueue.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the position of a safe in the liquidation queue based on the new collateralization ratio after repayment.",
            "conditions": [
              "_newRatio != 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral for a given safe",
            "why_is_is_important": "The collateral needs to be in sync with global parameters",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes",
            "how_to_validate_state_update": "Check that collateralAmount and borrowedAmount for the specified safeId have been increased appropriately",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount of a safe is updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt for a given safe",
            "why_is_is_important": "The debt needs to be in sync with global parameters",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes",
            "how_to_validate_state_update": "Check that collateralAmount and borrowedAmount for the specified safeId have been increased appropriately",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount of a safe is updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the protocol",
            "why_is_is_important": "The total collateral needs to be in sync with individual safe parameters",
            "when_is_it_updated": "When the cumulative collateral per unit collateral changes",
            "how_to_validate_state_update": "Verify that the totalCollateral has been updated by debtIncrease",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral is updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The protocol mode",
            "why_is_is_important": "The protocol needs to transition from bootstrap mode to normal mode to function correctly",
            "when_is_it_updated": "When the protocol debt goes above the bootstrap threshold",
            "how_to_validate_state_update": "Verify that PROTOCOL_MODE is set to NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode is updated.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The SBD balance of the user initiating the repay transaction.",
            "why_is_is_important": "Reflects the amount of SBD a user holds, ensuring accurate accounting during repayment.",
            "when_is_it_updated": "When a user repays their debt.",
            "how_to_validate_state_update": "Check the balance of msg.sender and ensure that it is decreased by amount. Also, check total supply.",
            "has_conditional_updates": false,
            "summary_of_update": "Burns (destroys) the repaid SBD tokens, reducing the user's balance.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD in circulation.",
            "why_is_is_important": "Maintains an accurate record of the circulating supply of SBD, influencing its stability and value.",
            "when_is_it_updated": "When SBD tokens are burned during repayment.",
            "how_to_validate_state_update": "Verify that totalSupply is decreased by the repayment amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total supply of SBD tokens due to burning.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "The total amount of SBD burned.",
            "why_is_is_important": "Provides a cumulative record of burned tokens, which helps in understanding the tokenomics and supply dynamics.",
            "when_is_it_updated": "When SBD tokens are burned during repayment.",
            "how_to_validate_state_update": "Verify the `totalBurned` amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Accumulates the total amount of burned SBD tokens.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[safeId]",
            "type": "Node",
            "what_does_it_track": "Nodes in the linked list representing safes.",
            "why_is_is_important": "Maintains the correct state of the linked list, which is crucial for efficient liquidation and redemption operations.",
            "when_is_it_updated": "When a safe is fully repaid and needs to be removed from the liquidation queue.",
            "how_to_validate_state_update": "Verify the removal from the linked list by checking head, tail and nodes mappings.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a node from the linked list when a safe is fully repaid.",
            "conditions": [
              "_safe.borrowedAmount - amount == 0"
            ]
          },
          {
            "state_variable_name": "nodes[safeId]",
            "type": "Node",
            "what_does_it_track": "Nodes in the linked list representing safes.",
            "why_is_is_important": "Maintaining correct order of safes in the linked list",
            "when_is_it_updated": "When the collateral ratio changes after repayment",
            "how_to_validate_state_update": "Verify the node has been updated in the list.",
            "has_conditional_updates": true,
            "summary_of_update": "Upserts a node in the linked list based on newRatio",
            "conditions": [
              "_newRatio != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head of the linked list",
            "why_is_is_important": "Maintains integrity of linked list",
            "when_is_it_updated": "When safe is fully repaid and happens to be head",
            "how_to_validate_state_update": "Verify the head and tail pointers are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head pointer if the safe being removed is the current head.",
            "conditions": [
              "_safe.borrowedAmount - amount == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail of the linked list",
            "why_is_is_important": "Maintains integrity of linked list",
            "when_is_it_updated": "When safe is fully repaid and happens to be tail",
            "how_to_validate_state_update": "Verify the head and tail pointers are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail pointer if the safe being removed is the current tail.",
            "conditions": [
              "_safe.borrowedAmount - amount == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function repay(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage _safe = safes[safeId];\n        _updateSafe(safeId, _safe);\n        require(_safe.borrowedAmount > 0, \"No borrowed amount to repay\");\n        require(sbdToken.balanceOf(msg.sender) >= amount, \"Insufficient SBD\");\n\n        // Check if the repayment amount is valid\n        require(\n            amount <= _safe.borrowedAmount,\n            \"Repayment amount exceeds borrowed amount\"\n        );\n        require(\n            _safe.borrowedAmount - amount == 0 ||\n                _safe.borrowedAmount - amount >= MINIMUM_DEBT,\n            \"Invalid repayment amount\"\n        );\n        sbdToken.burn(msg.sender, amount);\n        _safe.borrowedAmount -= amount;\n        uint256 _newRatio = (_safe.borrowedAmount * PRECISION) /\n            _safe.collateralAmount;\n        if (_newRatio != 0) {\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            _removeSafeFromBothQueues(safeId);\n        }\n        _updateTotalDebt(totalDebt, amount, false);\n        emit Repaid(safeId, amount, _newRatio, totalCollateral, totalDebt);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "head",
              "contract_name": "safesOrderedForRedemption"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      }
    ]
  }
}