{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: The ID of the safe (CDP) to add collateral to. Must be an existing safe.",
      "amount: The amount of collateral to add, in the same unit as the existing collateral. This should be greater than 0.",
      "nearestSpotInLiquidationQueue: A hint to the contract about where to insert/update the safe's position in the liquidation queue. Can be 0 if unknown.",
      "msg.value: Must be equal to the amount specified to be added as collateral. This represents the actual ETH being sent."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral and Debt Updates",
        "state_update_descriptions": [
          "Increase collateral amount of the specified safe.",
          "Update total collateral in the system.",
          "Update total debt in the system.",
          "Update borrowed amount for the safe based on cumulativeDebtPerUnitCollateral and liquidation snapshot values.",
          "Update liquidation snapshot to track debt and collateral per unit."
        ]
      },
      {
        "category": "Liquidation Queue Management",
        "state_update_descriptions": [
          "Update safe's position in the liquidation queue based on its collateral ratio.",
          "Update doubly linked list representing the liquidation queue (insert, update, or remove nodes).",
          "Update next and prev pointers of the doubly linked list."
        ]
      },
      {
        "category": "Protocol Mode Transition",
        "state_update_descriptions": [
          "Potentially change protocol mode from BOOTSTRAP to NORMAL if total debt exceeds a threshold."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State Validation",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be increased by amount.",
          "safes[safeId].borrowedAmount should be updated based on: safes[safeId].borrowedAmount += (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION.",
          "safes[safeId].totalBorrowedAmount should be updated based on: safes[safeId].totalBorrowedAmount += (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION."
        ]
      },
      {
        "category": "Total State Validation",
        "rule_descriptions": [
          "totalCollateral should be increased by the amount added, and also by any collateral increase from _updateSafe.",
          "totalDebt should be updated based on the increase in borrowed amount from _updateSafe."
        ]
      },
      {
        "category": "Liquidation Queue State Validation",
        "rule_descriptions": [
          "The position of safeId in the liquidation queue should be updated based on the new collateral ratio."
        ]
      },
      {
        "category": "Liquidation Snapshot State Validation",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should be updated to cumulativeDebtPerUnitCollateral.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot should be updated to cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Protocol Mode Validation",
        "rule_descriptions": [
          "PROTOCOL_MODE should be NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and the current mode is BOOTSTRAP."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount of a safe.",
            "why_is_is_important": "This tracks the amount of collateral for a specific safe.",
            "when_is_it_updated": "When collateral is added to a safe.",
            "how_to_validate_state_update": "Check the safes mapping for the safeId and verify that the collateralAmount has increased by the amount added.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the collateralAmount of a specific safe by the amount provided.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral in the system.",
            "why_is_is_important": "This tracks the total collateral in the system.",
            "when_is_it_updated": "When collateral is added to a safe.",
            "how_to_validate_state_update": "Check the totalCollateral state variable and verify that it has increased by the amount added.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the totalCollateral by the amount provided.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt amount of a safe.",
            "why_is_is_important": "The borrowed amount of a safe might change if the cumulative debt per unit collateral has changed since the last update. It's crucial for calculating the correct liquidation ratio and outstanding debt.",
            "when_is_it_updated": "Before adding collateral, if cumulative debt has changed.",
            "how_to_validate_state_update": "Fetch the liquidationSnapshot for the safeId and check if collateralPerCollateralSnapshot is different from cumulativeCollateralPerUnitCollateral. If they are different, calculate the debtIncrease and verify that borrowedAmount is updated accordingly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount of a safe based on cumulative debt changes since the last snapshot.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total borrowed amount of a safe.",
            "why_is_is_important": "The total borrowed amount of a safe might change if the cumulative debt per unit collateral has changed since the last update. This is a running total of all debt a safe has ever accrued.",
            "when_is_it_updated": "Before adding collateral, if cumulative debt has changed.",
            "how_to_validate_state_update": "Fetch the liquidationSnapshot for the safeId and check if collateralPerCollateralSnapshot is different from cumulativeCollateralPerUnitCollateral. If they are different, calculate the debtIncrease and verify that totalBorrowedAmount is updated accordingly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalBorrowedAmount of a safe based on cumulative debt changes since the last snapshot.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount of a safe.",
            "why_is_is_important": "The collateral amount of a safe might change if the cumulative collateral per unit collateral has changed since the last update. It's crucial for accurately representing the collateral backing the debt.",
            "when_is_it_updated": "Before adding collateral, if cumulative collateral has changed.",
            "how_to_validate_state_update": "Fetch the liquidationSnapshot for the safeId and check if collateralPerCollateralSnapshot is different from cumulativeCollateralPerUnitCollateral. If they are different, calculate the collateralIncrease and verify that collateralAmount is updated accordingly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralAmount of a safe based on cumulative collateral changes since the last snapshot.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral at the time of the snapshot.",
            "why_is_is_important": "The debtPerCollateralSnapshot tracks the cumulative debt per unit collateral at the time of the snapshot. It is crucial for determining how much debt has accrued since the last time the safe was updated.",
            "when_is_it_updated": "Before adding collateral, if cumulative debt has changed.",
            "how_to_validate_state_update": "Fetch the liquidationSnapshot for the safeId and check if collateralPerCollateralSnapshot is different from cumulativeCollateralPerUnitCollateral. If they are different, verify that debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debtPerCollateralSnapshot to the current cumulativeDebtPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per unit collateral at the time of the snapshot.",
            "why_is_is_important": "The collateralPerCollateralSnapshot tracks the cumulative collateral per unit collateral at the time of the snapshot. It is crucial for determining how much collateral has been added or removed since the last time the safe was updated.",
            "when_is_it_updated": "Before adding collateral, if cumulative collateral has changed.",
            "how_to_validate_state_update": "Fetch the liquidationSnapshot for the safeId and check if collateralPerCollateralSnapshot is different from cumulativeCollateralPerUnitCollateral. If they are different, verify that collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralPerCollateralSnapshot to the current cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Tracks the total debt in the system, important for protocol solvency.",
            "when_is_it_updated": "Before adding collateral, if cumulative debt has changed.",
            "how_to_validate_state_update": "Check the liquidationSnapshot for the safeId. If collateralPerCollateralSnapshot is different from cumulativeCollateralPerUnitCollateral, calculate the debtIncrease and verify that totalDebt is updated accordingly by checking its previous value and comparing.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalDebt based on cumulative debt changes since the last snapshot.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the operating mode of the protocol.",
            "why_is_is_important": "PROTOCOL_MODE determines whether the system is in BOOTSTRAP or NORMAL mode which influences system behavior.",
            "when_is_it_updated": "Before adding collateral, if cumulative debt has changed and totalDebt exceeds the threshold.",
            "how_to_validate_state_update": "Check the totalDebt. If totalDebt is greater than BOOTSTRAP_MODE_DEBT_THRESHOLD and PROTOCOL_MODE is BOOTSTRAP, verify that PROTOCOL_MODE is updated to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the PROTOCOL_MODE from BOOTSTRAP to NORMAL if totalDebt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "The position of the safe within the liquidation queue.",
            "why_is_is_important": "The linked list maintains an ordered structure, important for liquidation and redemption processes.",
            "when_is_it_updated": "When collateral is added, modifying the safe's liquidation ratio.",
            "how_to_validate_state_update": "Inspect the linked list structure before and after the upsert operation. Check head, tail, and the prev/next pointers of affected nodes to ensure correct ordering.",
            "has_conditional_updates": false,
            "summary_of_update": "Inserts or updates the safe's position in the liquidation queue based on its collateral ratio.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the linked list.",
            "why_is_is_important": "Maintains the head of the doubly linked list for ordering safes by liquidation ratio.  Crucial for efficient access to safes in liquidation order.",
            "when_is_it_updated": "When a safe with a lower collateral ratio than the current head is added.",
            "how_to_validate_state_update": "If the node being inserted is the new head, check that head is updated to safeId.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the list if the new safe has the lowest collateral ratio.",
            "conditions": [
              "nodes[_nearestSpot].value >= node.value",
              "_nearestSpot == head"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the linked list.",
            "why_is_is_important": "Maintains the tail of the doubly linked list for ordering safes by liquidation ratio. Crucial for efficient access to safes in redemption order.",
            "when_is_it_updated": "When a safe with a higher collateral ratio than the current tail is added.",
            "how_to_validate_state_update": "If the node being inserted is the new tail, check that tail is updated to safeId.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the list if the new safe has the highest collateral ratio.",
            "conditions": [
              "nodes[_nearestSpot].value < node.value",
              "_nearestSpot == tail"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}