{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should correspond to an existing, valid Safe (CDP).",
      "amount:  The amount of collateral to add, must be non-zero. Must be equal to msg.value sent with the transaction.",
      "nearestSpotInLiquidationQueue: Should correspond to the id of a node in the safesOrderedForLiquidation doubly linked list. Can be zero, which indicates head of the list.",
      "msg.value: Must be equal to the amount parameter."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId].collateralAmount is increased by amount.",
          "safes[safeId].borrowedAmount may be updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
          "safes[safeId].totalBorrowedAmount may be updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total State",
        "state_update_descriptions": [
          "totalCollateral is increased by amount, and possibly by collateralIncrease due to cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot.",
          "totalDebt may be updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot.",
          "PROTOCOL_MODE may be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "The position of the safe with safeId in the liquidation queue is updated based on the new collateral ratio. The DoublyLinkedList contract is used to manage the queue."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be equal to its previous value plus the amount parameter (and possible increase based on cumulativeCollateralPerUnitCollateral).",
          "safes[safeId].borrowedAmount should be correctly updated based on the difference between cumulativeDebtPerUnitCollateral and the liquidationSnapshot.debtPerCollateralSnapshot at the beginning of the function execution, if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral.",
          "safes[safeId].totalBorrowedAmount should be correctly updated based on the difference between cumulativeDebtPerUnitCollateral and the liquidationSnapshot.debtPerCollateralSnapshot at the beginning of the function execution if liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total State",
        "rule_descriptions": [
          "totalCollateral should be equal to its previous value plus the amount parameter (and possible increase based on cumulativeCollateralPerUnitCollateral).",
          "totalDebt should reflect the updated value after accounting for any changes in borrowedAmount.",
          "PROTOCOL_MODE is NORMAL if totalDebt is greater than BOOTSTRAP_MODE_DEBT_THRESHOLD, it remains unchanged otherwise."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The safe with safeId should be correctly positioned in the liquidation queue based on the new collateral ratio.",
          "The doubly linked list structure should be maintained (i.e., prev and next pointers should be consistent)."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should be updated to cumulativeDebtPerUnitCollateral if the debt was updated.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot should be updated to cumulativeCollateralPerUnitCollateral if the collateral was updated."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited for a specific safe.",
            "why_is_is_important": "Represents the user's collateral in the system, affecting their liquidation risk and borrowing power.",
            "when_is_it_updated": "When collateral is added to a safe via the `addCollateral` function.",
            "how_to_validate_state_update": "Check if the safe's collateral amount has increased by the `amount` added: `safe.collateralAmount += amount`. Verify by comparing the state before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of a specific safe (CDP).",
            "conditions": [
              "safe.collateralAmount > 0",
              "msg.value == amount"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Provides a system-wide view of the collateralization of the protocol.",
            "when_is_it_updated": "When collateral is added to any safe.",
            "how_to_validate_state_update": "Verify that the `totalCollateral` has increased by the amount added to the safe: `totalCollateral += amount`. Check the state before and after the execution.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total collateral held by the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt a safe has.",
            "why_is_is_important": "Tracks the debt of a safe, crucial for determining liquidation risk.",
            "when_is_it_updated": "When the safe is updated in the `_updateSafe` function, called by `addCollateral`.",
            "how_to_validate_state_update": "Calculate `debtIncrease` using the formula: `debtIncrease = (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`. Ensure `safe.borrowedAmount` increases accordingly: `safe.borrowedAmount += debtIncrease`. Also check `safe.totalBorrowedAmount` increases by the same amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a specific safe based on cumulative debt and collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of debt per collateral for the safe",
            "why_is_is_important": "Used to determine how much debt to adjust based on cumulative changes.",
            "when_is_it_updated": "When the safe is updated in the `_updateSafe` function, called by `addCollateral` and there's a change since last snapshot.",
            "how_to_validate_state_update": "Verify `liquidationSnapshots[safeId].debtPerCollateralSnapshot` equals `cumulativeDebtPerUnitCollateral`: `liquidationSnapshots.debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates debtPerCollateralSnapshot for the safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral a safe has.",
            "why_is_is_important": "Tracks the collateral of a safe, crucial for determining liquidation risk.",
            "when_is_it_updated": "When the safe is updated in the `_updateSafe` function, called by `addCollateral` and there's a change since last snapshot.",
            "how_to_validate_state_update": "Calculate `collateralIncrease` using the formula: `collateralIncrease = (_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`. Ensure `safe.collateralAmount` increases accordingly: `safe.collateralAmount += collateralIncrease`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralAmount for the safe based on cumulative collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of collateral per collateral for the safe",
            "why_is_is_important": "Used to determine how much collateral to adjust based on cumulative changes.",
            "when_is_it_updated": "When the safe is updated in the `_updateSafe` function, called by `addCollateral` and there's a change since last snapshot.",
            "how_to_validate_state_update": "Verify `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` equals `cumulativeCollateralPerUnitCollateral`: `liquidationSnapshot.collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralPerCollateralSnapshot for the safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the system.",
            "why_is_is_important": "Reflects system-wide collateralization.",
            "when_is_it_updated": "When the safe is updated in the `_updateSafe` function, called by `addCollateral` and there's a change since last snapshot.",
            "how_to_validate_state_update": "Verify `totalCollateral` increases by `collateralIncrease`: `totalCollateral += collateralIncrease`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral based on cumulative collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "Controls certain protocol behaviors based on the overall debt level.",
            "when_is_it_updated": "After updating `totalDebt` in the `_updateTotalDebt` function, which is called by `_updateSafe` which is called by `addCollateral`.",
            "how_to_validate_state_update": "Check if `totalDebt` is greater than `BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE` changes from `BOOTSTRAP` to `NORMAL`.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially changes the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the system.",
            "why_is_is_important": "Reflects the overall liability of the protocol.",
            "when_is_it_updated": "When the safe is updated in the `_updateSafe` function, which is called by `addCollateral`.",
            "how_to_validate_state_update": "Verify `totalDebt` is updated by `delta` (debtIncrease) when `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`, or is unchanged otherwise. If updated `totalDebt = currentDebt + delta`",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt of the protocol.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "struct",
            "what_does_it_track": "Nodes in the liquidation queue.",
            "why_is_is_important": "Maintains the order of safes based on their liquidation risk, influencing the liquidation process.",
            "when_is_it_updated": "When a safe's collateral ratio changes, as it is updated in the `upsert` function which is called in `addCollateral`.",
            "how_to_validate_state_update": "If the node doesn't exist, a new node is inserted into the linked list based on `value` and `nearestSpot`. Verify the insertion logic by checking the list's integrity (prev/next pointers).",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts or updates a node in the doubly linked list used for liquidation queue management.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head of the linked list",
            "why_is_is_important": "Points to the start of the queue.",
            "when_is_it_updated": "When a safe's collateral ratio changes, as it is updated in the `_insert` function which is called in `addCollateral` and head is 0.",
            "how_to_validate_state_update": "Verify `head` and `tail` are updated to the new `id`: `head = id`, `tail = id`.",
            "has_conditional_updates": true,
            "summary_of_update": "If the list is empty, the `head` pointer is updated to the new `id`.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail of the linked list",
            "why_is_is_important": "Points to the end of the queue.",
            "when_is_it_updated": "When a safe's collateral ratio changes, as it is updated in the `_insert` function which is called in `addCollateral` and head is 0.",
            "how_to_validate_state_update": "Verify `head` and `tail` are updated to the new `id`: `head = id`, `tail = id`.",
            "has_conditional_updates": true,
            "summary_of_update": "If the list is empty, the `tail` pointer is updated to the new `id`.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head of the linked list",
            "why_is_is_important": "Points to the start of the queue.",
            "when_is_it_updated": "When a safe's collateral ratio changes, as it is updated in the `_insert` function which is called in `addCollateral` and nearest spot is the head.",
            "how_to_validate_state_update": "Verify `node.next` is updated to `_nearestSpot`: `node.next = _nearestSpot`, `nodes[_nearestSpot].prev` is updated to `id`: `nodes[_nearestSpot].prev = id`, and `head` is updated to `id`: `head = id`.",
            "has_conditional_updates": true,
            "summary_of_update": "If the new node should be the new head of the list, update the `head` pointer.",
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail of the linked list",
            "why_is_is_important": "Points to the end of the queue.",
            "when_is_it_updated": "When a safe's collateral ratio changes, as it is updated in the `_insert` function which is called in `addCollateral` and nearest spot is the tail.",
            "how_to_validate_state_update": "Verify `node.prev` is updated to `_nearestSpot`: `node.prev = _nearestSpot`, `nodes[_nearestSpot].next` is updated to `id`: `nodes[_nearestSpot].next = id`, and `tail` is updated to `id`: `tail = id`.",
            "has_conditional_updates": true,
            "summary_of_update": "If the new node should be the new tail of the list, update the `tail` pointer.",
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}