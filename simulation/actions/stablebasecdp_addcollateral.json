{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: Must be the ID of an existing safe. Verify the safe exists before calling the function.",
      "amount: Must be a non-zero value representing the amount of collateral to add.",
      "msg.value: Must equal amount. The contract requires that the ether sent with the transaction matches the amount specified.",
      "nearestSpotInLiquidationQueue: Should be a valid node ID in the liquidation queue or 0 if the user wants to let the contract find a proper place. Providing 0 will let the contract determine the correct position.",
      "The user who initiates the transaction should be the owner of the safe (checked by _onlyOwner(safeId))."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral Update",
        "state_update_descriptions": [
          "Increase collateralAmount of the Safe with safeId.",
          "Increase totalCollateral."
        ]
      },
      {
        "category": "Debt Update",
        "state_update_descriptions": [
          "Update borrowedAmount of the Safe with safeId based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.",
          "Update totalBorrowedAmount of the Safe with safeId if the liquidation snapshot is outdated.",
          "Update totalDebt based on changes in borrowedAmount."
        ]
      },
      {
        "category": "Liquidation Queue Management",
        "state_update_descriptions": [
          "Update the position of the safe in the liquidation queue (safesOrderedForLiquidation) based on the new collateralization ratio.",
          "Modify the doubly linked list to insert the safe in the correct position based on its updated ratio."
        ]
      },
      {
        "category": "Snapshot Update",
        "state_update_descriptions": [
          "Update the liquidation snapshot with cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Protocol Mode Change",
        "state_update_descriptions": [
          "Potentially change protocol mode from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral Validation",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be increased by amount + collateralIncrease from _updateSafe.",
          "totalCollateral should be increased by the amount added."
        ]
      },
      {
        "category": "Debt Validation",
        "rule_descriptions": [
          "safes[safeId].borrowedAmount should reflect the update in _updateSafe.",
          "totalDebt should reflect the updates in _updateSafe."
        ]
      },
      {
        "category": "Liquidation Queue Validation",
        "rule_descriptions": [
          "The safe's position in the liquidation queue (safesOrderedForLiquidation) should be updated based on the new collateralization ratio.",
          "The next and prev pointers of the surrounding nodes in the liquidation queue should be correctly updated to maintain the integrity of the doubly linked list."
        ]
      },
      {
        "category": "Snapshot Validation",
        "rule_descriptions": [
          "liquidationSnapshots[safeId] should be updated with the current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral"
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "An AddedCollateral event should be emitted with the correct safeId, amount, newRatio, totalCollateral, and totalDebt.",
          "A LiquidationQueueUpdated event should be emitted with the updated safeId, newRatio, and nextNode in the queue.",
          "A SafeUpdated event should be emitted with relevant details if _updateSafe made changes to the debt or collateral amounts."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a specific safe.",
            "why_is_is_important": "It reflects the user's collateral position, affecting liquidation risk and borrowing power.",
            "when_is_it_updated": "When collateral is added to a safe via the addCollateral function.",
            "how_to_validate_state_update": "Check if safe.collateralAmount has increased by amount, totalCollateral has increased by amount, and the liquidation queue is updated with the new ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of a specific safe.",
            "conditions": [
              "safe.collateralAmount > 0",
              "msg.value == amount"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral deposited across all safes.",
            "why_is_is_important": "It represents the overall solvency of the system and is used in calculations for global metrics.",
            "when_is_it_updated": "When collateral is added to any safe via the addCollateral function.",
            "how_to_validate_state_update": "Check if totalCollateral has increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total collateral held by the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId]",
            "type": "LiquidationSnapshot",
            "what_does_it_track": "The snapshot of debt and collateral ratios used to calculate inactive debt and collateral.",
            "why_is_is_important": "Ensures accurate tracking of debt and collateral, preventing discrepancies during liquidations or redemptions.",
            "when_is_it_updated": "Before adding collateral, to account for any changes in cumulative debt or collateral.",
            "how_to_validate_state_update": "Verify that cumulative debt and collateral per unit collateral are updated, and total debt is also updated accordingly.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the liquidation snapshot for a safe, which includes collateralPerCollateralSnapshot and debtPerCollateralSnapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt a specific safe has accrued.",
            "why_is_is_important": "Reflects the actual debt owed by the safe, critical for calculating liquidation ratios.",
            "when_is_it_updated": "Before adding collateral if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check if safe.borrowedAmount has increased by the calculated debt increase, and safe.collateralAmount has increased by the calculated collateral increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount for a safe based on cumulative debt changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt across all safes.",
            "why_is_is_important": "Represents the overall liability of the system and is used to determine system health.",
            "when_is_it_updated": "When the debt of a safe changes during _updateSafe.",
            "how_to_validate_state_update": "Verify that totalDebt is updated based on whether debt is being added or removed.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt in the system.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current mode of the protocol.",
            "why_is_is_important": "Affects system parameters and behavior during different operational phases.",
            "when_is_it_updated": "During the _updateTotalDebt function when the debt threshold is exceeded.",
            "how_to_validate_state_update": "Check PROTOCOL_MODE is updated to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "The position of a safe within the liquidation queue.",
            "why_is_is_important": "Maintains the order of safes for efficient liquidation processing.",
            "when_is_it_updated": "When the collateral ratio changes, the safe's position in the liquidation queue is adjusted.",
            "how_to_validate_state_update": "Check if a new node is inserted into the linked list based on the provided value and nearest spot.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts or updates a node in the linked list, maintaining the order based on value.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the linked list.",
            "why_is_is_important": "Maintains the start of the queue.",
            "when_is_it_updated": "When inserting a new node at the beginning of the list.",
            "how_to_validate_state_update": "Check if the head node is updated, and the prev and next pointers of the relevant nodes are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the new node should be the first.",
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the linked list.",
            "why_is_is_important": "Maintains the end of the queue.",
            "when_is_it_updated": "When inserting a new node at the end of the list.",
            "how_to_validate_state_update": "Check if the tail node is updated, and the prev and next pointers of the relevant nodes are updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the new node should be the last.",
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}