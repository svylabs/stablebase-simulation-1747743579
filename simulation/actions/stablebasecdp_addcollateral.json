{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should be a valid, existing safe ID.",
      "amount: Should be a non-zero value, representing the amount of collateral to add.",
      "nearestSpotInLiquidationQueue: Suggest using 0 for simplicity, let the contract determine the nearest spot based on current ratios.",
      "msg.value: Should be equal to the amount parameter. The contract verifies this directly."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId].collateralAmount is increased by amount.",
          "safes[safeId].borrowedAmount may be updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshots[safeId].debtPerCollateralSnapshot.",
          "safes[safeId].totalBorrowedAmount may be updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshots[safeId].debtPerCollateralSnapshot."
        ]
      },
      {
        "category": "Global State",
        "state_update_descriptions": [
          "totalCollateral is increased by amount.",
          "totalDebt may be updated if safe.borrowedAmount is updated."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "The position of safeId in the liquidation queue is updated based on the new collateral ratio."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral if there is any change."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be equal to the initial collateralAmount plus the amount added.",
          "safes[safeId].borrowedAmount should be updated based on cumulativeDebtPerUnitCollateral.",
          "safes[safeId].totalBorrowedAmount should be updated based on cumulativeDebtPerUnitCollateral."
        ]
      },
      {
        "category": "Global State",
        "rule_descriptions": [
          "totalCollateral should be equal to the initial totalCollateral plus the amount added.",
          "totalDebt should be updated if safe.borrowedAmount is updated. Verify that if totalDebt crosses BOOTSTRAP_MODE_DEBT_THRESHOLD, the PROTOCOL_MODE is updated accordingly."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The position of safeId in the liquidation queue should be correctly updated based on the new collateral ratio. This can be validated by checking the prev and next pointers of the affected nodes in the doubly linked list."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should be updated to cumulativeDebtPerUnitCollateral if there is any change in the safe's debt."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in a specific CDP.",
            "why_is_is_important": "Reflects the current collateralization level of a CDP, which is crucial for determining its solvency and liquidation risk.",
            "when_is_it_updated": "When a user adds collateral to their CDP.",
            "how_to_validate_state_update": "Check if the safe exists by ensuring safe.collateralAmount > 0, then verify if msg.value equals the amount provided. After execution, check if safe.collateralAmount has increased by the amount added and totalCollateral also increased by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of a specific safe (CDP) if the safe exists and the correct amount is sent with the transaction.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral across all CDPs in the system.",
            "why_is_is_important": "Indicates the overall collateralization of the protocol and its ability to cover outstanding debt.",
            "when_is_it_updated": "When collateral is added to any CDP.",
            "how_to_validate_state_update": "Check if totalCollateral is increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total collateral held by the protocol.",
            "conditions": []
          },
          {
            "state_variable_name": "_newRatio",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateralization ratio of an individual safe.",
            "why_is_is_important": "The collateralization ratio is important in assessing the risk of liquidation.",
            "when_is_it_updated": "When collateral is added to an existing safe.",
            "how_to_validate_state_update": "Check the _newRatio and compare it with (safe.borrowedAmount * PRECISION) / safe.collateralAmount.",
            "has_conditional_updates": false,
            "summary_of_update": "Calculates the new collateralization ratio of the safe.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the borrowed amount for a specific safe.",
            "why_is_is_important": "Ensures the borrowed amount is up-to-date with respect to changes in the collateralization ratio.",
            "when_is_it_updated": "Updated when the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "If the condition is met, verify that `_safe.borrowedAmount` increases by the calculated `debtIncrease`, `_safe.totalBorrowedAmount` increases by `debtIncrease`, `liquidationSnapshot.debtPerCollateralSnapshot` is updated to `cumulativeDebtPerUnitCollateral`, `_safe.collateralAmount` increases by the calculated `collateralIncrease`, `liquidationSnapshot.collateralPerCollateralSnapshot` is updated to `cumulativeCollateralPerUnitCollateral`, and `totalCollateral` increases by `collateralIncrease`. Also, verify that `totalDebt` is updated using the `_updateTotalDebt` function.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount if the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount ever borrowed for a particular safe.",
            "why_is_is_important": "Maintains a record of the cumulative debt associated with a safe.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "If the condition is met, verify that `_safe.totalBorrowedAmount` increases by the calculated `debtIncrease`. If the condition is not met, no change should occur.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of the safe if the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The debt per collateral snapshot for a safe, used for calculating debt increases.",
            "why_is_is_important": "Provides a snapshot of the debt per collateral ratio for accurate debt calculation.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "If the condition is met, verify that `liquidationSnapshot.debtPerCollateralSnapshot` is updated to `cumulativeDebtPerUnitCollateral`. If the condition is not met, no change should occur.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt per collateral snapshot for the safe if the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in a specific CDP.",
            "why_is_is_important": "Reflects the current collateralization level of a CDP, which is crucial for determining its solvency and liquidation risk.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "If the condition is met, verify that `_safe.collateralAmount` increases by the calculated `collateralIncrease`. If the condition is not met, no change should occur.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount if the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The collateral per collateral snapshot for a safe, used for calculating collateral increases.",
            "why_is_is_important": "Provides a snapshot of the collateral per collateral ratio for accurate collateral calculation.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "If the condition is met, verify that `liquidationSnapshot.collateralPerCollateralSnapshot` is updated to `cumulativeCollateralPerUnitCollateral`. If the condition is not met, no change should occur.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral per collateral snapshot for the safe if the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral across all CDPs in the system.",
            "why_is_is_important": "Indicates the overall collateralization of the protocol and its ability to cover outstanding debt.",
            "when_is_it_updated": "When the liquidation snapshot's collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "If the condition is met, verify that `totalCollateral` increases by the calculated `collateralIncrease`. If the condition is not met, no change should occur.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total collateral held by the protocol if the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current operating mode of the protocol.",
            "why_is_is_important": "Controls the protocol's behavior based on the total debt level.",
            "when_is_it_updated": "When the total debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD while the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "If the condition is met, verify that `PROTOCOL_MODE` changes to `SBStructs.Mode.NORMAL`. If the condition is not met, no change should occur.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt outstanding in the protocol.",
            "why_is_is_important": "Reflects the overall liability of the protocol and is used in various calculations and checks.",
            "when_is_it_updated": "Updated when collateral is added or withdrawn.",
            "how_to_validate_state_update": "If the specified condition is met, verify that `totalDebt` is updated either by adding `delta` to it or subtracting `delta` from it, based on the `add` boolean.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt of the protocol.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "The order of safes for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Ensures that safes at higher risk of liquidation are processed first.",
            "when_is_it_updated": "When collateral is added to a safe, potentially changing its position in the liquidation queue.",
            "how_to_validate_state_update": "Check the value of `head`, `tail` and `nodes` before and after the execution of the `upsert` function to confirm the linked list structure changes as expected.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the doubly linked list to maintain the order of safes based on their collateralization ratio. The `upsert` function either inserts a new node or updates an existing one.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the list.",
            "why_is_is_important": "Points to the beginning of the list.",
            "when_is_it_updated": "When the list is empty.",
            "how_to_validate_state_update": "If the list is empty (`head == 0`), verify that both `head` and `tail` are set to the `id` of the newly inserted node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the list.",
            "why_is_is_important": "Points to the end of the list.",
            "when_is_it_updated": "When the list is empty.",
            "how_to_validate_state_update": "If the list is empty (`head == 0`), verify that both `head` and `tail` are set to the `id` of the newly inserted node.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first node in the list.",
            "why_is_is_important": "Ensures the list remains sorted.",
            "when_is_it_updated": "When the new node has a value less than the current head.",
            "how_to_validate_state_update": "If the conditions are met, verify that `node.next` is set to `_nearestSpot`, `nodes[_nearestSpot].prev` is set to `id`, and `head` is set to `id`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head when the new node should be the first in the list.",
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last node in the list.",
            "why_is_is_important": "Ensures the list remains sorted.",
            "when_is_it_updated": "When the new node has a value greater than the current tail.",
            "how_to_validate_state_update": "If the conditions are met, verify that `node.prev` is set to `_nearestSpot`, `nodes[_nearestSpot].next` is set to `id`, and `tail` is set to `id`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail when the new node should be the last in the list.",
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}