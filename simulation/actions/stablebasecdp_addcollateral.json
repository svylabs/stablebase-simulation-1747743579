{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "The 'safeId' parameter must correspond to an existing CDP that is owned by the transaction sender ('msg.sender'). The CDP must have a 'collateralAmount' greater than zero.",
      "The 'amount' parameter must be a positive integer representing the collateral to be added. This value must be sent as 'msg.value' with the transaction.",
      "The 'nearestSpotInLiquidationQueue' parameter is a 'uint256' that can be set to 0. If a non-zero value is provided, it should ideally be the 'safeId' of a node in the 'safesOrderedForLiquidation' doubly linked list that is near the expected new position of the 'safeId' after the collateral is added. This parameter serves as a hint for efficient searching in the linked list and does not strictly require an exact value, but a valid node ID can optimize the operation."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "CDP Specific State",
        "state_update_descriptions": [
          "The 'collateralAmount' for the specified 'safeId' will increase by the 'amount' of new collateral provided by the user (msg.value). This is in addition to any implicit collateral increase that might occur if the '_updateSafe' function is triggered.",
          "The 'borrowedAmount' for the specified 'safeId' might increase due to accumulated debt, if the '_updateSafe' function is triggered.",
          "The 'totalBorrowedAmount' for the specified 'safeId' might increase due to accumulated debt, if the '_updateSafe' function is triggered.",
          "The 'liquidationSnapshot.collateralPerCollateralSnapshot' for the 'safeId' will be updated to the current 'cumulativeCollateralPerUnitCollateral' if '_updateSafe' is triggered.",
          "The 'liquidationSnapshot.debtPerCollateralSnapshot' for the 'safeId' will be updated to the current 'cumulativeDebtPerUnitCollateral' if '_updateSafe' is triggered."
        ]
      },
      {
        "category": "Global Protocol State",
        "state_update_descriptions": [
          "The 'totalCollateral' in the StableBaseCDP contract will increase by the 'amount' of new collateral provided by the user (msg.value). This is in addition to any implicit collateral increase that might occur if the '_updateSafe' function is triggered.",
          "The 'totalDebt' in the StableBaseCDP contract might increase due to accumulated debt, if the '_updateSafe' function is triggered.",
          "The 'PROTOCOL_MODE' might change from 'BOOTSTRAP' to 'NORMAL' if the 'totalDebt' (after any updates from '_updateSafe') exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD'."
        ]
      },
      {
        "category": "Liquidation Queue State",
        "state_update_descriptions": [
          "The position of the 'safeId' in the 'safesOrderedForLiquidation' doubly linked list will be updated based on its new collateralization ratio. This might involve re-ordering the list by changing 'prev' and 'next' pointers of relevant nodes, and potentially updating the 'head' or 'tail' of the list."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "State Assertions",
        "rule_descriptions": [
          "Verify that the 'safes[safeId].collateralAmount' reflects the initial amount plus the 'amount' sent with the transaction, and any 'collateralIncrease' that occurred due to '_updateSafe'.",
          "Verify that the 'safes[safeId].borrowedAmount' reflects the initial amount plus any 'debtIncrease' that occurred due to '_updateSafe'.",
          "Verify that the 'safes[safeId].totalBorrowedAmount' reflects the initial amount plus any 'debtIncrease' that occurred due to '_updateSafe'.",
          "Verify that the 'totalCollateral' global variable in 'StableBaseCDP' reflects its initial value plus the 'amount' sent with the transaction, and any 'collateralIncrease' that occurred due to '_updateSafe'.",
          "Verify that the 'totalDebt' global variable in 'StableBaseCDP' reflects its initial value plus any 'debtIncrease' that occurred due to '_updateSafe'.",
          "Verify that 'liquidationSnapshots[safeId].collateralPerCollateralSnapshot' is equal to 'cumulativeCollateralPerUnitCollateral' if '_updateSafe' was triggered.",
          "Verify that 'liquidationSnapshots[safeId].debtPerCollateralSnapshot' is equal to 'cumulativeDebtPerUnitCollateral' if '_updateSafe' was triggered.",
          "Verify that the new collateralization ratio for 'safeId', calculated as '(safes[safeId].borrowedAmount * PRECISION) / safes[safeId].collateralAmount', matches the 'value' stored for 'safeId' in the 'safesOrderedForLiquidation' contract.",
          "Verify that the 'safeId' is correctly positioned within the 'safesOrderedForLiquidation' linked list according to its new collateralization ratio, by checking its 'prev' and 'next' pointers.",
          "If the 'PROTOCOL_MODE' was initially 'BOOTSTRAP' and the final 'totalDebt' is greater than 'BOOTSTRAP_MODE_DEBT_THRESHOLD', verify that 'PROTOCOL_MODE' has changed to 'NORMAL'."
        ]
      },
      {
        "category": "Event Assertions",
        "rule_descriptions": [
          "Assert that the 'AddedCollateral' event is emitted with the correct 'safeId', 'amount' (equal to msg.value), 'newRatio' (the calculated collateralization ratio), 'totalCollateral' (the final global value), and 'totalDebt' (the final global value).",
          "Assert that the 'LiquidationQueueUpdated' event is emitted with the correct 'safeId', 'newRatio' (the calculated collateralization ratio), and 'nextNode' (the ID of the next node in the liquidation queue after the update).",
          "If the '_updateSafe' function was triggered (i.e., 'liquidationSnapshot.collateralPerCollateralSnapshot' was not equal to 'cumulativeCollateralPerUnitCollateral' before the call), assert that the 'SafeUpdated' event is emitted with the correct 'safeId', updated 'collateralAmount' (after _updateSafe), updated 'debtAmount' (after _updateSafe), 'collateralIncrease', 'debtIncrease', updated 'totalCollateral' (after _updateSafe), and updated 'totalDebt' (after _updateSafe)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral held within a specific Safe (CDP).",
            "why_is_is_important": "Crucial for tracking the collateralization ratio of a CDP and for liquidation/redemption calculations.",
            "when_is_it_updated": "Updated in addCollateral to reflect the added collateral, and potentially in _updateSafe if the cumulative collateral per unit collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify that the collateralAmount for the given safeId has increased by the 'amount' parameter, in addition to any 'collateralIncrease' from the _updateSafe call.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount for the specified Safe (CDP) is increased by the 'amount' provided in the function call, and potentially further increased by 'collateralIncrease' if a collateral snapshot update occurs in _updateSafe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The aggregate sum of all collateral across all active Safes (CDPs) in the protocol.",
            "why_is_is_important": "Reflects the overall collateral backing the protocol's debt and is a key metric for systemic health.",
            "when_is_it_updated": "Updated in addCollateral to reflect the new collateral added to a safe, and potentially in _updateSafe when a safe's internal collateral amount is updated based on protocol-wide cumulative collateral changes.",
            "how_to_validate_state_update": "Verify that the totalCollateral has increased by the 'amount' parameter, in addition to any 'collateralIncrease' from the _updateSafe call.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral held by the protocol is increased by the 'amount' provided in the function call, and potentially further increased by 'collateralIncrease' if a collateral snapshot update occurs in _updateSafe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of stablecoin currently borrowed against a specific Safe (CDP).",
            "why_is_is_important": "Essential for determining the current debt burden of a CDP and its collateralization ratio.",
            "when_is_it_updated": "Updated within the internal `_updateSafe` function, specifically when the `collateralPerCollateralSnapshot` of the safe's liquidation snapshot is not equal to the current `cumulativeCollateralPerUnitCollateral`, indicating a need to update the safe's debt.",
            "how_to_validate_state_update": "Check that the borrowedAmount for the safeId has increased by 'debtIncrease' if the condition in _updateSafe was met.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount for the specified Safe (CDP) is increased by a calculated 'debtIncrease' based on the change in `cumulativeDebtPerUnitCollateral` since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative sum of stablecoin ever borrowed against a specific Safe (CDP).",
            "why_is_is_important": "Tracks the historical borrowing activity of a CDP, potentially used for fee calculations or analytical purposes.",
            "when_is_it_updated": "Updated within the internal `_updateSafe` function, specifically when the `collateralPerCollateralSnapshot` of the safe's liquidation snapshot is not equal to the current `cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Check that the totalBorrowedAmount for the safeId has increased by 'debtIncrease' if the condition in _updateSafe was met.",
            "has_conditional_updates": true,
            "summary_of_update": "The total borrowed amount ever for the specified Safe (CDP) is increased by a calculated 'debtIncrease' based on the change in `cumulativeDebtPerUnitCollateral` since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the `cumulativeDebtPerUnitCollateral` at the time of the last `_updateSafe` execution for a particular safe.",
            "why_is_is_important": "Used to calculate the accrued debt increase for a safe since its last update, based on the protocol-wide `cumulativeDebtPerUnitCollateral`.",
            "when_is_it_updated": "Updated within the internal `_updateSafe` function when the safe's `collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Verify that the debtPerCollateralSnapshot for the safeId is set to the current cumulativeDebtPerUnitCollateral if the condition in _updateSafe was met.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of cumulative debt per unit collateral for the specified Safe (CDP) is updated to the current `cumulativeDebtPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A snapshot of the `cumulativeCollateralPerUnitCollateral` at the time of the last `_updateSafe` execution for a particular safe.",
            "why_is_is_important": "Used to calculate the accrued collateral increase for a safe since its last update, based on the protocol-wide `cumulativeCollateralPerUnitCollateral`.",
            "when_is_it_updated": "Updated within the internal `_updateSafe` function when the safe's `collateralPerCollateralSnapshot` is not equal to `cumulativeCollateralPerUnitCollateral`.",
            "how_to_validate_state_update": "Verify that the collateralPerCollateralSnapshot for the safeId is set to the current cumulativeCollateralPerUnitCollateral if the condition in _updateSafe was met.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of cumulative collateral per unit collateral for the specified Safe (CDP) is updated to the current `cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol (e.g., BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Dictates protocol behavior, such as fee structures or liquidation rules, based on the total debt level.",
            "when_is_it_updated": "Updated within the internal `_updateTotalDebt` function, which is called by `_updateSafe`. This update is conditional on the total debt crossing a threshold and the protocol being in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check if the PROTOCOL_MODE has switched from BOOTSTRAP to NORMAL if the totalDebt exceeded BOOTSTRAP_MODE_DEBT_THRESHOLD while in BOOTSTRAP mode.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode changes from BOOTSTRAP to NORMAL if the `totalDebt` exceeds the `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP (in _updateTotalDebt)"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The aggregate sum of all outstanding debt across all active Safes (CDPs) in the protocol.",
            "why_is_is_important": "Reflects the overall debt of the protocol and is a key metric for systemic health and for triggering protocol mode changes.",
            "when_is_it_updated": "Updated within the internal `_updateTotalDebt` function, which is called by `_updateSafe`. This happens when a safe's `borrowedAmount` is updated due to changes in `cumulativeDebtPerUnitCollateral`.",
            "how_to_validate_state_update": "Verify that totalDebt has increased by 'debtIncrease' if a debt snapshot update occurred in _updateSafe.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt of the protocol is increased by 'debtIncrease' if a debt snapshot update occurred in `_updateSafe`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral (in _updateSafe)"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "struct IDoublyLinkedList.Node",
            "what_does_it_track": "A mapping from an ID (safeId) to a Node struct, which contains the node's value (ratio), and pointers to the previous and next nodes in the sorted doubly linked list.",
            "why_is_is_important": "Maintains the ordered list of Safes for efficient liquidation, allowing the protocol to quickly identify and process Safes that are under-collateralized.",
            "when_is_it_updated": "Updated when `safesOrderedForLiquidation.upsert` is called. This can occur either as an `_insert` (if the safeId was not previously in the list) or an `_update` (if it was already in the list), both of which re-position the node based on its new `_newRatio` value.",
            "how_to_validate_state_update": "Verify that the node at 'safeId' in the 'nodes' mapping is updated with the new value, and its 'prev' and 'next' pointers are correctly set to maintain the sorted order of the linked list.",
            "has_conditional_updates": true,
            "summary_of_update": "The node corresponding to the `safeId` in the `nodes` mapping is updated. This involves setting its new `value` (which is `_newRatio`) and re-linking its `prev` and `next` pointers within the doubly linked list to maintain sorted order based on the `value`. If the node previously existed, it's removed and re-inserted; if new, it's simply inserted.",
            "conditions": []
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node (highest ratio) in the ordered doubly linked list.",
            "why_is_is_important": "Essential for navigating the ordered list, specifically for operations that start from the highest ratio end, like finding liquidation candidates.",
            "when_is_it_updated": "Updated in `_insert` or `_update` if the inserted/updated node becomes the new tail of the list. Also updated in `_remove` if the removed node was the tail.",
            "how_to_validate_state_update": "Verify that 'tail' points to the correct last node in the ordered list after an insert or update operation.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'tail' pointer of the doubly linked list is updated to point to the new last element if the new or updated node becomes the new tail of the list.",
            "conditions": [
              "_head == 0 (for insert)",
              "nodes[_nearestSpot].value >= node.value && _nearestSpot == _head (for insert)",
              "nodes[_nearestSpot].value < node.value && node.next == 0 && _nearestSpot == _head (for insert)",
              "nodes[_nearestSpot].value >= node.value && node.prev == 0 && _nearestSpot == _tail (for insert)",
              "node.next == 0 (for remove)"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node (lowest ratio) in the ordered doubly linked list.",
            "why_is_is_important": "Essential for navigating the ordered list, specifically for operations that start from the lowest ratio end.",
            "when_is_it_updated": "Updated in `_insert` or `_update` if the inserted/updated node becomes the new head of the list. Also updated in `_remove` if the removed node was the head.",
            "how_to_validate_state_update": "Verify that 'head' points to the correct first node in the ordered list after an insert or update operation.",
            "has_conditional_updates": true,
            "summary_of_update": "The 'head' pointer of the doubly linked list is updated to point to the new first element if the new or updated node becomes the new head of the list.",
            "conditions": [
              "_head == 0 (for insert)",
              "nodes[_nearestSpot].value >= node.value && _nearestSpot == _head (for insert)",
              "nodes[_nearestSpot].value >= node.value && node.prev == 0 && _nearestSpot == _tail (for insert)",
              "node.prev == 0 (for remove)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}