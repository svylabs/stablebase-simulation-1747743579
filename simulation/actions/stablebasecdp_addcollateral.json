{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: Needs to be an existing and valid safeId (tokenId).",
      "amount: The amount of collateral to add, must be greater than 0.",
      "nearestSpotInLiquidationQueue: This should be the ID of a safe that is near where this safe should be in the liquidation queue. A value of 0 represents the head of the queue.",
      "msg.value:  This should be equal to amount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral Management",
        "state_update_descriptions": [
          "safes[safeId].collateralAmount is increased by amount.",
          "borrowedAmount and collateralAmount are updated based on cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral if they have changed since the last update.",
          "totalCollateral is increased by the amount added and any collateral increase due to _updateSafe.",
          "totalDebt is updated if _updateSafe modifies borrowedAmount.",
          "The safe's position in the liquidation queue is updated using safesOrderedForLiquidation.upsert().",
          "PROTOCOL_MODE may be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Liquidation Queue and Snapshots",
        "state_update_descriptions": [
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot updated to cumulativeDebtPerUnitCollateral",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot updated to cumulativeCollateralPerUnitCollateral",
          "The doubly linked list representing the liquidation queue may be modified.",
          "Nodes in the liquidation queue (nodes[id]) may have their prev and next pointers updated to reflect the new position of the safe."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral Management",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be increased by amount.",
          "safes[safeId].borrowedAmount should be updated based on cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral if they have changed since the last update.",
          "totalCollateral should be increased by the amount added and any collateral increase due to _updateSafe.",
          "totalDebt should be updated if _updateSafe modifies borrowedAmount.",
          "The ratio of borrowedAmount to collateralAmount for the safe should be recalculated."
        ]
      },
      {
        "category": "Liquidation Queue and Snapshots",
        "rule_descriptions": [
          "The position of the safe within the liquidation queue should be updated based on the new collateral ratio.",
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral.",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot should be equal to cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Input Validation",
        "rule_descriptions": [
          "msg.value should be equal to amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping(uint256 => Safe)",
            "what_does_it_track": "The collateral amount of a specific safe.",
            "why_is_is_important": "Stores the state of each safe, including collateral and debt.",
            "when_is_it_updated": "When collateral is added to a safe.",
            "how_to_validate_state_update": "Check the collateralAmount field of the Safe struct for the given safeId after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The collateralAmount field of the Safe struct at safes[safeId] is increased by the amount added.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral amount in the system.",
            "why_is_is_important": "Tracks the total amount of collateral in the system.",
            "when_is_it_updated": "When collateral is added to a safe.",
            "how_to_validate_state_update": "Read the totalCollateral state variable after the transaction. It should increase by the amount added.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalCollateral variable is increased by the amount of collateral added.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The ordering of safes in the liquidation queue.",
            "why_is_is_important": "Maintains an ordered list of safes for liquidation based on their collateralization ratio.",
            "when_is_it_updated": "After collateral is added, the safe's position in the liquidation queue is updated.",
            "how_to_validate_state_update": "Inspect the linked list structure by calling getNodes on the safesOrderedForLiquidation contract. The order of safes should reflect their liquidation ratios. Inspect the OrderedDoublyLinkedList contract.",
            "has_conditional_updates": true,
            "summary_of_update": "The upsert function of the OrderedDoublyLinkedList contract is called to update the safe's position in the liquidation queue based on its new collateralization ratio.",
            "conditions": [
              "newRatio",
              "nearestSpotInLiquidationQueue"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral, used in calculating debt increases.",
            "why_is_is_important": "Tracks the cumulative debt per unit collateral, used in calculating debt increases.",
            "when_is_it_updated": "If the liquidation snapshot's collateral per collateral snapshot differs from the current cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Read the cumulativeDebtPerUnitCollateral variable before and after the transaction and compare the difference with the expected value.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates cumulativeDebtPerUnitCollateral if the liquidation snapshot is outdated, affecting debt calculation.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks cumulative collateral per unit collateral, used in calculating collateral increases.",
            "why_is_is_important": "Tracks cumulative collateral per unit collateral, used in calculating collateral increases.",
            "when_is_it_updated": "If the liquidation snapshot's collateral per collateral snapshot differs from the current cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Read the cumulativeCollateralPerUnitCollateral variable before and after the transaction and compare the difference with the expected value.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates cumulativeCollateralPerUnitCollateral if the liquidation snapshot is outdated, affecting collateral increase.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping(uint256 => LiquidationSnapshot)",
            "what_does_it_track": "Tracks the liquidation snapshot information for each safe.",
            "why_is_is_important": "Stores snapshots of collateral and debt ratios for each safe, used in _updateSafe.",
            "when_is_it_updated": "Updated inside _updateSafe if the current snapshot is outdated, to reflect cumulative debt and collateral changes.",
            "how_to_validate_state_update": "Read the liquidationSnapshots mapping for the safeId before and after the transaction to check for changes in debtPerCollateralSnapshot and collateralPerCollateralSnapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates debtPerCollateralSnapshot and collateralPerCollateralSnapshot within the liquidationSnapshots mapping for the safeId.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Tracks the total debt in the system.",
            "when_is_it_updated": "Updated inside _updateSafe if there is a debt increase, reflecting cumulative debt changes.",
            "how_to_validate_state_update": "Read the totalDebt variable before and after the transaction. It should increase by debtIncrease if the snapshot is outdated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalDebt if the liquidation snapshot is outdated, increasing it by debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the current mode of the protocol.",
            "why_is_is_important": "Indicates the current operating mode of the protocol (e.g., BOOTSTRAP, NORMAL).",
            "when_is_it_updated": "Updated within _updateTotalDebt if the debt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD and the current mode is BOOTSTRAP.",
            "how_to_validate_state_update": "Read the PROTOCOL_MODE variable before and after the transaction. It changes from BOOTSTRAP to NORMAL if the debt threshold is crossed.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates PROTOCOL_MODE from BOOTSTRAP to NORMAL if the debt threshold is crossed.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Stores the value, prev, and next pointers for each node in the list.",
            "why_is_is_important": "Stores the nodes of the linked list, containing values, and pointers to the previous and next nodes.",
            "when_is_it_updated": "Updated in _insert and _update, which are called by upsert. The nodes mapping stores the value, prev, and next pointers for each node.",
            "how_to_validate_state_update": "Call getNode(id) on the OrderedDoublyLinkedList contract to inspect the Node struct. Check the value, prev, and next fields against expected values.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates or inserts nodes, modifying the list's structure based on values and nearest spots.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0",
              "_nearestSpot == 0",
              "nodes[_nearestSpot].value < node.value",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first element in the linked list.",
            "why_is_is_important": "Points to the first element in the linked list.",
            "when_is_it_updated": "Updated in _insert if the list is empty, or if the new node should be the new head.",
            "how_to_validate_state_update": "Call getHead() on the OrderedDoublyLinkedList contract to check the value of head.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head pointer if the list is empty or a new node becomes the head.",
            "conditions": [
              "head == 0",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last element in the linked list.",
            "why_is_is_important": "Points to the last element in the linked list.",
            "when_is_it_updated": "Updated in _insert if the list is empty, or if the new node should be the new tail.",
            "how_to_validate_state_update": "Call getTail() on the OrderedDoublyLinkedList contract to check the value of tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail pointer if the list is empty or a new node becomes the tail.",
            "conditions": [
              "head == 0",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      }
    ]
  }
}