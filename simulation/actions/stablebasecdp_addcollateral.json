{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId must exist in the safes mapping (safes[safeId].collateralAmount > 0).",
      "amount: The amount of collateral to add, should be greater than 0.",
      "msg.value: msg.value should be equal to the amount being added (amount).",
      "nearestSpotInLiquidationQueue: A valid safeId already existing in the liquidation queue; used as hint for efficient insertion in sorted queue. 0 if the queue is empty or no suitable hint is available.  It can be any safeId in the safes mapping. Best practice to provide id from close range."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Updates",
        "state_update_descriptions": [
          "Updates the collateral amount of the specified safe by adding the provided amount.",
          "If cumulative debt/collateral ratios have changed since the last update, borrowed and collateral amounts of the safe are updated accordingly, using _updateSafe.",
          "Updates the totalBorrowedAmount of the safe (if cumulative debt/collateral ratios have changed), using _updateSafe."
        ]
      },
      {
        "category": "Total Collateral Updates",
        "state_update_descriptions": [
          "Increases the total collateral by the amount added and the collateral increase from cumulative updates, using _updateSafe."
        ]
      },
      {
        "category": "Total Debt Updates",
        "state_update_descriptions": [
          "Updates the total debt based on cumulative debt/collateral ratio changes since the last update, using _updateSafe and _updateTotalDebt.",
          "The total debt amount might be updated, which in turn affects the protocol mode."
        ]
      },
      {
        "category": "Liquidation Queue Updates",
        "state_update_descriptions": [
          "Updates the safe's position in the liquidation queue based on the new collateral ratio, using safesOrderedForLiquidation.upsert.",
          "If the safe's collateral ratio changes, the safe is re-inserted into the liquidation queue at the appropriate position."
        ]
      },
      {
        "category": "Protocol Mode Update",
        "state_update_descriptions": [
          "The protocol mode might change from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD, handled in _updateTotalDebt."
        ]
      },
      {
        "category": "Liquidation Snapshots Update",
        "state_update_descriptions": [
          "liquidationSnapshots for the safe is updated with the cumulative debt/collateral ratios in _updateSafe."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be increased by amount + collateralIncrease where collateralIncrease accounts for cumulative collateral ratio changes, validated against the SafeUpdated event.",
          "safes[safeId].borrowedAmount should reflect cumulative debt ratio changes since last update, validated against the SafeUpdated event.",
          "safes[safeId].totalBorrowedAmount should reflect cumulative debt ratio changes since last update."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "totalCollateral should be increased by the amount added + collateralIncrease, where collateralIncrease accounts for cumulative collateral ratio changes, validated against the AddedCollateral and SafeUpdated events."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "totalDebt should be updated based on debtIncrease, where debtIncrease accounts for cumulative debt ratio changes since last update, validated against the AddedCollateral and SafeUpdated events."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The safe's position in safesOrderedForLiquidation should reflect the updated collateral ratio. Check next and prev pointers using getNodes method on safesOrderedForLiquidation.",
          "The next and prev pointers in the doubly linked list should be consistent after the upsert operation. The LiquidationQueueUpdated event provides the next node."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "AddedCollateral event should be emitted with the correct parameters (safeId, amount, newRatio, totalCollateral, totalDebt).",
          "LiquidationQueueUpdated event should be emitted with the correct parameters (safeId, newRatio, nextNode).",
          "SafeUpdated event should be emitted if cumulative collateral and debt ratios have changed, including collateralAmount, debtAmount, collateralIncrease, debtIncrease, totalCollateral, and totalDebt."
        ]
      },
      {
        "category": "Protocol Mode",
        "rule_descriptions": [
          "PROTOCOL_MODE should be NORMAL if totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD and it was previously BOOTSTRAP. Check the PROTOCOL_MODE state variable."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral held by a specific safe.",
            "why_is_is_important": "Reflects the current amount of collateral securing the debt of a safe; a key factor in determining liquidation risk and overall system solvency. It is crucial for calculating the safe's collateralization ratio and triggering liquidations if necessary. Incorrect collateral amounts directly impact system stability.",
            "when_is_it_updated": "Updated when collateral is added to a safe.",
            "how_to_validate_state_update": "Check if the safe's collateralAmount is increased by the amount added. Also, check msg.value, safe ownership.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount for a specific safe (CDP).",
            "conditions": [
              "safe.collateralAmount > 0",
              "msg.value == amount",
              "Owner of safe"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system across all safes.",
            "why_is_is_important": "Represents the overall collateralization level of the system, impacting the systemic risk. This is a key indicator of the protocol's ability to cover outstanding debts. An accurate total collateral is vital for maintaining confidence in the system.",
            "when_is_it_updated": "Updated whenever collateral is added to any safe.",
            "how_to_validate_state_update": "Check if the totalCollateral is increased by the amount added to the safe.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total collateral held by the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Determines the order in which safes are liquidated, directly impacts the efficiency of the liquidation process and overall system stability.",
            "when_is_it_updated": "Updated whenever the collateralization ratio of a safe changes due to adding collateral.",
            "how_to_validate_state_update": "Check if the doubly linked list is updated with the new ratio and correct safeId.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the position of the safe within the liquidation queue based on its collateralization ratio.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the outstanding debt for a given safe.",
            "why_is_is_important": "Ensures the safe's debt is accurately tracked, accounting for changes in the overall system debt.",
            "when_is_it_updated": "Updated when the cumulative debt per collateral changes since the last liquidation snapshot is available.",
            "how_to_validate_state_update": "Verify that borrowedAmount is increased by the calculated debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a safe if there's a difference in cumulative debt per unit collateral since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt ever borrowed by a safe.",
            "why_is_is_important": "Tracks historical debt for a safe, and is important for auditing and historical analysis. It provides insight into the total borrowing activity of a safe over its lifetime.",
            "when_is_it_updated": "Updated when the cumulative debt per collateral changes since the last liquidation snapshot.",
            "how_to_validate_state_update": "Verify that totalBorrowedAmount is increased by the calculated debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of a safe if there's a difference in cumulative debt per unit collateral since the last snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt per collateral ratio at the time of the last snapshot for a safe.",
            "why_is_is_important": "Used to calculate debt increases for a safe based on changes in the cumulative debt per collateral. This snapshot ensures fair and accurate debt tracking even when system-wide debt levels fluctuate.",
            "when_is_it_updated": "Updated when the cumulative debt per collateral changes since the last liquidation snapshot.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operational mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Controls certain system behaviors based on the overall debt level; transitioning out of bootstrap mode is critical for enabling full protocol functionality and unlocks new features.",
            "when_is_it_updated": "Updated when the total debt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check if the PROTOCOL_MODE is updated to NORMAL when totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and it was in BOOTSTRAP mode.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the overall outstanding debt in the protocol.",
            "why_is_is_important": "Represents the overall risk exposure of the system, indicating how much debt is outstanding. Changes here affect protocol fees and overall system solvency. It is essential for evaluating the sustainability of the entire protocol.",
            "when_is_it_updated": "Updated when debt is added or removed, to or from a safe.",
            "how_to_validate_state_update": "Verify that totalDebt is increased by the calculated debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt in the system.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Tracks the nodes in the doubly linked list, storing their values, and pointers to the previous and next nodes.",
            "why_is_is_important": "Maintains the correct order of safes for liquidation, ensuring that the riskiest safes are liquidated first. Accurate ordering is crucial for minimizing losses during liquidations.",
            "when_is_it_updated": "Updated when a safe's collateralization ratio changes, requiring its position in the queue to be updated.",
            "how_to_validate_state_update": "Check if the linked list is updated correctly based on the logic in _insert and _update functions.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the doubly linked list to maintain the order of safes for liquidation.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first element in the doubly linked list, acting as the entry point.",
            "why_is_is_important": "Points to the beginning of the list for traversal purposes; its accurate tracking ensures that the list operations start from the correct position, preventing potential errors or loss of data.",
            "when_is_it_updated": "Updated when the first safe is added to the list.",
            "how_to_validate_state_update": "Verify that head is set to the safeId when the list is empty.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list when the list is empty.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last element in the doubly linked list.",
            "why_is_is_important": "Points to the end of the list for traversal purposes. Accurate tracking is essential for efficient list operations, particularly when adding new elements or iterating through the list in reverse order.",
            "when_is_it_updated": "Updated when the first safe is added to the list.",
            "how_to_validate_state_update": "Verify that tail is set to the safeId when the list is empty.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list when the list is empty.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "_nearestSpot",
            "type": "uint256",
            "what_does_it_track": "Tracks the nearest spot for insertion within the linked list.",
            "why_is_is_important": "Used to insert the node into the right place in the list.",
            "when_is_it_updated": "Only if the nearest spot has not yet been initialized",
            "how_to_validate_state_update": "Verify that _nearestSpot is updated to head if the nearest spot is invalid.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the nearest spot if its node is invalid",
            "conditions": [
              "nodes[_nearestSpot].prev == 0 && nodes[_nearestSpot].next == 0 && nodes[_nearestSpot].value == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first element in the doubly linked list.",
            "why_is_is_important": "Points to the beginning of the list for traversal purposes.",
            "when_is_it_updated": "When the new node is inserted at the beginning of the list",
            "how_to_validate_state_update": "Verify that head is updated if the new node should be the new head.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the list if the new node should be the new head.",
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last element in the doubly linked list.",
            "why_is_is_important": "Points to the end of the list for traversal purposes.",
            "when_is_it_updated": "When the new node is inserted at the end of the list",
            "how_to_validate_state_update": "Verify that tail is updated if the new node should be the new tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the list if the new node should be the new tail.",
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}