{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: Must be a valid, existing safe ID. Use the safes mapping to check if a safe exists for the given ID.",
      "amount: Must be a non-zero amount of collateral to add, and msg.value should equal amount.  The amount should be greater than zero.",
      "nearestSpotInLiquidationQueue: Should be a safe ID that exists in the liquidation queue, used as hint for placing the safe in the queue. Can be 0 to indicate starting from head of the list. If non-zero, confirm that a node exists in safesOrderedForLiquidation for the provided ID."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the collateralAmount of the safe with safeId by adding the provided amount.",
          "May update the borrowedAmount of the safe with safeId based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot.  The borrowed amount is increased by the debtIncrease calculated as (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION.",
          "Updates the totalBorrowedAmount of the safe with safeId by adding the debtIncrease (if debtIncrease > 0).",
          "Potentially updates the collateralAmount of the safe with safeId based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot. The collateralAmount is increased by the collateralIncrease calculated as (_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION."
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "state_update_descriptions": [
          "Increases totalCollateral by the amount added and any collateral increase due to cumulativeCollateralPerUnitCollateral.",
          "May increase totalDebt based on _updateTotalDebt logic. The totalDebt is increased by debtIncrease if debtIncrease > 0. The function _updateTotalDebt also checks and potentially updates the PROTOCOL_MODE."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "The position of the safe with safeId in the liquidation queue is updated based on the new collateral ratio (_newRatio).  The upsert function is called on the safesOrderedForLiquidation doubly linked list."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates the liquidationSnapshots[safeId].debtPerCollateralSnapshot to cumulativeDebtPerUnitCollateral and liquidationSnapshots[safeId].collateralPerCollateralSnapshot to cumulativeCollateralPerUnitCollateral if applicable (if the snapshot values are different from the cumulative values)."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE might be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD within the _updateTotalDebt function.  This transition can only occur once."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be increased by amount + collateralIncrease (if collateralIncrease > 0).",
          "safes[safeId].borrowedAmount should be equal to previous borrowedAmount + debtIncrease (if debtIncrease > 0).",
          "safes[safeId].totalBorrowedAmount should reflect accumulated debt increases since the safe's creation. This value should equal the initial borrowed amount + the sum of all debtIncreases since the safe's creation.",
          "Verify that cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral are unchanged if _updateSafe was not called.",
          "If _updateSafe was called, verify that liquidationSnapshots[safeId].debtPerCollateralSnapshot and liquidationSnapshots[safeId].collateralPerCollateralSnapshot are updated to the current cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral respectively."
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "rule_descriptions": [
          "totalCollateral should be increased by the amount and any collateral increase.",
          "totalDebt should be increased by any debt increase.  If the protocol mode was changed, verify that PROTOCOL_MODE is NORMAL and totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD. Verify that PROTOCOL_MODE remains unchanged otherwise."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The safe with safeId should be correctly positioned in the liquidation queue based on _newRatio.",
          "Verify that the IDoublyLinkedList contract's state is updated correctly by checking the 'nodes' mapping for the safeId, and also verifying the head and tail of the list if necessary.  Confirm the 'prev' and 'next' pointers of neighboring nodes are updated correctly.",
          "If nearestSpotInLiquidationQueue was non-zero, check that the insertion occurred near the specified spot, respecting the sorted order."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot and liquidationSnapshots[safeId].collateralPerCollateralSnapshot are updated to cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral respectively if they were updated during execution."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a specific safe.",
            "why_is_is_important": "Reflects the collateralization level of a safe.",
            "when_is_it_updated": "When collateral is added to a safe.",
            "how_to_validate_state_update": "Check if the collateralAmount of the safe with ID safeId has increased by amount, and totalCollateral has increased by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of a specific safe.",
            "conditions": [
              "safe.collateralAmount > 0",
              "msg.value == amount"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Used for calculating global collateralization ratios.",
            "when_is_it_updated": "When collateral is added to any safe.",
            "how_to_validate_state_update": "Check if the totalCollateral has increased by amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total collateral held by the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt a safe has.",
            "why_is_is_important": "Accurately tracks the debt position of a safe.",
            "when_is_it_updated": "Whenever collateral is added or withdrawn, and cumulative debt has changed since the last update.",
            "how_to_validate_state_update": "Verify that borrowedAmount is updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a safe based on cumulative debt changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount ever borrowed by a safe.",
            "why_is_is_important": "Tracks the cumulative debt of a safe over its lifetime.",
            "when_is_it_updated": "Whenever collateral is added or withdrawn, and cumulative debt has changed since the last update.",
            "how_to_validate_state_update": "Verify that totalBorrowedAmount is updated based on cumulative debt changes.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The debt per collateral ratio at the time of the last snapshot.",
            "why_is_is_important": "Used to calculate debt increases due to cumulative debt changes.",
            "when_is_it_updated": "Whenever collateral is added or withdrawn and cumulative debt has changed.",
            "how_to_validate_state_update": "Verify that the liquidation snapshot's debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral in a specific safe.",
            "why_is_is_important": "Ensures the collateral amount reflects cumulative changes.",
            "when_is_it_updated": "Whenever collateral is added or withdrawn, and cumulative collateral has changed since the last update.",
            "how_to_validate_state_update": "Verify collateralAmount is updated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of a safe based on cumulative collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The collateral per collateral ratio at the time of the last snapshot.",
            "why_is_is_important": "Used to calculate collateral increases due to cumulative collateral changes.",
            "when_is_it_updated": "Whenever collateral is added or withdrawn, and cumulative collateral has changed.",
            "how_to_validate_state_update": "Verify that the liquidation snapshot's collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Used for calculating global collateralization ratios.",
            "when_is_it_updated": "Whenever collateral is added or withdrawn, and cumulative collateral has changed since the last update.",
            "how_to_validate_state_update": "Check that totalCollateral is updated to include the collateral increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total collateral held by the contract, accounting for cumulative changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "Critical for protocol solvency and stability.",
            "when_is_it_updated": "Whenever debt is added or removed from the system.",
            "how_to_validate_state_update": "Verify that totalDebt is updated based on the delta and the add flag.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt in the system.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol.",
            "why_is_is_important": "Controls protocol behavior based on debt levels.",
            "when_is_it_updated": "When total debt exceeds a predefined threshold in bootstrap mode.",
            "how_to_validate_state_update": "Check that PROTOCOL_MODE is updated to NORMAL when debt exceeds the threshold during bootstrap mode.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from bootstrap to normal when debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "The nodes in the doubly linked list, used for ordering safes for liquidation or redemption.",
            "why_is_is_important": "Maintains the correct order of safes for liquidation and redemption.",
            "when_is_it_updated": "When a safe's collateral ratio changes.",
            "how_to_validate_state_update": "Inspect the doubly linked list for correct insertion based on node values and _nearestSpot.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts a new node into the doubly linked list, updating the list's structure and node properties.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The first element in the doubly linked list.",
            "why_is_is_important": "Allows traversal of the list.",
            "when_is_it_updated": "When a safe is added to an empty list.",
            "how_to_validate_state_update": "Check that head and tail are updated to the new node's ID.",
            "has_conditional_updates": true,
            "summary_of_update": "If the list is empty, the head is set to the new node.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The last element in the doubly linked list.",
            "why_is_is_important": "Allows traversal of the list.",
            "when_is_it_updated": "When a safe is added to an empty list.",
            "how_to_validate_state_update": "Check that head and tail are updated to the new node's ID.",
            "has_conditional_updates": true,
            "summary_of_update": "If the list is empty, the tail is set to the new node.",
            "conditions": [
              "head == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForLiquidation"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "safesOrderedForRedemption"
            }
          ]
        }
      }
    ]
  }
}