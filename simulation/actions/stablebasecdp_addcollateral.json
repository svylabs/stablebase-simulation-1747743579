{
  "action": {
    "name": "Add Collateral",
    "summary": "Adds collateral to a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` parameter should correspond to an existing safe, i.e., `safes[safeId].collateralAmount > 0` should evaluate to true.",
      "The `amount` parameter should be a positive integer representing the amount of collateral to add. This value also has to be sent as msg.value when calling this function.",
      "The `nearestSpotInLiquidationQueue` parameter should be a `safeId` of another safe currently in the liquidation queue, and serves as a hint for the doubly linked list insertion. If the doubly linked list is empty, or this is the first element, it must be zero."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral & Debt Updates",
        "state_update_descriptions": [
          "The `_updateSafe` function is called, potentially modifying `safe.borrowedAmount` and `safe.collateralAmount` based on cumulative snapshots of debt and collateral per unit collateral.",
          "The `collateralAmount` field in the `safes` mapping for the given `safeId` is increased by `amount` (or potentially a different value if `_updateSafe` modifies it).",
          "The `totalCollateral` state variable is increased by `amount` (or potentially a different value if `_updateSafe` modifies `safe.collateralAmount`).",
          "The `liquidationSnapshots` mapping is updated for the given `safeId` with the current `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral` values.",
          "The `_updateTotalDebt` internal function might be called, updating the `totalDebt` state variable if `cumulativeDebtPerUnitCollateral` has changed since the last snapshot."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "The `safesOrderedForLiquidation` doubly linked list is updated to reflect the new collateral ratio of the safe.",
          "The position of the safe in the liquidation queue is updated based on its new collateral ratio."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral & Debt Updates",
        "rule_descriptions": [
          "The `collateralAmount` field in the `safes` mapping with key `safeId` should be increased. The exact amount depends on `_updateSafe`.",
          "The `borrowedAmount` field in the `safes` mapping with key `safeId` should be updated after the execution of `_updateSafe` function. Check that the value is consistent with the cumulative snapshots.",
          "The `totalCollateral` should be increased (or decreased if there were inactive collateral). The exact amount depends on `_updateSafe`.",
          "Check that `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral` are properly updated.",
          "Verify `totalDebt` is correctly updated based on potential debt increases."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The ratio of borrowed amount to collateral amount for the safe with ID `safeId` should be updated in the liquidation queue.",
          "The position of the safe in the liquidation queue should be updated based on the new ratio."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Add Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "addCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral locked in a Safe.",
            "why_is_is_important": "Tracks the total collateral held by a specific Safe (CDP).",
            "when_is_it_updated": "When collateral is added to the Safe.",
            "how_to_validate_state_update": "Check the Safe's collateralAmount after the function call. It should increase by the amount added.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by the amount of collateral added (msg.value).",
            "conditions": [
              "msg.value must be equal to amount",
              "safe.collateralAmount must be greater than 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held in all Safes.",
            "why_is_is_important": "Tracks the total collateral in the system.",
            "when_is_it_updated": "When collateral is added to any Safe.",
            "how_to_validate_state_update": "Check the totalCollateral after the function call.  It should increase by the amount added.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by the amount of collateral added (msg.value).",
            "conditions": [
              "msg.value must be equal to amount",
              "safe.collateralAmount must be greater than 0"
            ]
          },
          {
            "state_variable_name": "_newRatio",
            "type": "uint256",
            "what_does_it_track": "Ratio of borrowed amount to collateral amount for a given safe",
            "why_is_is_important": "Tracks the debt to collateral ratio",
            "when_is_it_updated": "When collateral is added to any Safe.",
            "how_to_validate_state_update": "Calculate the new ratio, borrowedAmount / collateralAmount.  Verify on chain value matches.",
            "has_conditional_updates": true,
            "summary_of_update": "The ratio is updated by dividing borrowed amount by collateral amount",
            "conditions": [
              "safe.collateralAmount must be greater than 0",
              "msg.value must be equal to amount"
            ]
          },
          {
            "state_variable_name": "safe.borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt per unit of collateral.",
            "why_is_is_important": "Allows accounting for interest accrued on debt.",
            "when_is_it_updated": "When the collateral per collateral snapshot does not equal the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Verify borrowedAmount is updated with new debt.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safe.totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt per unit of collateral.",
            "why_is_is_important": "Allows accounting for interest accrued on debt.",
            "when_is_it_updated": "When the collateral per collateral snapshot does not equal the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Verify totalBorrowedAmount is updated with new debt.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safe.collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative collateral per unit of collateral.",
            "why_is_is_important": "Allows accounting for interest accrued on collateral.",
            "when_is_it_updated": "When the collateral per collateral snapshot does not equal the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Verify collateralAmount is updated with new collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by collateralIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The cumulative collateral per unit of collateral.",
            "why_is_is_important": "Allows accounting for interest accrued on collateral.",
            "when_is_it_updated": "When the collateral per collateral snapshot does not equal the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Verify totalCollateral is updated with new collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by collateralIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the protocol.",
            "why_is_is_important": "Maintains the total debt in the system, used for protocol mode transitions and overall debt tracking.",
            "when_is_it_updated": "Whenever debt is added or subtracted, including through interest accrual.",
            "how_to_validate_state_update": "Check totalDebt after the function call. It should reflect the added debt if adding collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by debtIncrease if adding collateral, decreased otherwise.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId]",
            "type": "LiquidationSnapshot",
            "what_does_it_track": "Collateral and debt values at the snapshot.",
            "why_is_is_important": "Stores the snapshot of collateral and debt at the time of the last update, important for accurate debt calculation.",
            "when_is_it_updated": "When the cumulative debt or collateral changes.",
            "how_to_validate_state_update": "Verify liquidationSnapshots is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates debtPerCollateralSnapshot and collateralPerCollateralSnapshot",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The protocol mode (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Determines if the protocol should be in bootstrap or normal mode.",
            "when_is_it_updated": "When total debt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE after the function call. It should be NORMAL if the debt condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated from BOOTSTRAP to NORMAL if debt exceeds the threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "A doubly-linked list of Safe IDs, ordered by their liquidation ratio.",
            "why_is_is_important": "Maintains the order of Safes for liquidation purposes.",
            "when_is_it_updated": "When a Safe's liquidation ratio changes (due to adding collateral, borrowing, or price fluctuations).",
            "how_to_validate_state_update": "Inspect the linked list structure (head, tail, prev, next pointers) to ensure the Safe is in the correct position based on its ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts or updates a Safe's position in the liquidation queue based on its new liquidation ratio.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0",
              "nodes[_nearestSpot].prev == 0 && nodes[_nearestSpot].next == 0 && nodes[_nearestSpot].value == 0",
              "_nearestSpot != _tail && nodes[_nearestSpot].value < node.value",
              "_nearestSpot != _head && nodes[_nearestSpot].value >= node.value",
              "_nearestSpot == _head",
              "_nearestSpot == _tail",
              "else"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "Maintains the head of the doubly linked list.",
            "when_is_it_updated": "If the head of the list is 0, sets the head.",
            "how_to_validate_state_update": "Inspect the linked list structure (head) to ensure the Safe is in the correct position based on its ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the head of the doubly linked list.",
            "conditions": [
              "_head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "Maintains the tail of the doubly linked list.",
            "when_is_it_updated": "If the head of the list is 0, sets the tail.",
            "how_to_validate_state_update": "Inspect the linked list structure (tail) to ensure the Safe is in the correct position based on its ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the tail of the doubly linked list.",
            "conditions": [
              "_head == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function addCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external payable _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"Safe does not exist\");\n        require(msg.value == amount, \"Invalid amount\");\n\n        safe.collateralAmount += amount;\n        totalCollateral += amount;\n\n        uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n            safe.collateralAmount;\n        IDoublyLinkedList.Node memory node = safesOrderedForLiquidation.upsert(\n            safeId,\n            _newRatio,\n            nearestSpotInLiquidationQueue\n        );\n        emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n\n        emit AddedCollateral(\n            safeId,\n            amount,\n            _newRatio,\n            totalCollateral,\n            totalDebt\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}