{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should be a valid safeId that exists in the safes mapping, and the msg.sender should be the owner of the safe (validated by _onlyOwner modifier).",
      "amount: Should be a non-zero value and less than or equal to safe.collateralAmount. If borrowedAmount > 0, amount must be less than or equal to maxWithdrawal which ensures liquidation ratio is maintained: amount <= safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR).",
      "nearestSpotInLiquidationQueue: Should be a valid safeId that exists in the safesOrderedForLiquidation doubly linked list. This helps optimize the upsert operation in the liquidation queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral and Debt Updates",
        "state_update_descriptions": [
          "Update safe's collateral: safe.collateralAmount -= amount. Potentially also update with collateralIncrease if cumulativeCollateralPerUnitCollateral has changed in _updateSafe.",
          "Potentially update safe's borrowed amount and total borrowed amount if cumulativeDebtPerUnitCollateral has changed in _updateSafe.",
          "Decrease totalCollateral: totalCollateral -= amount. Potentially also update with collateralIncrease if cumulativeCollateralPerUnitCollateral has changed in _updateSafe.",
          "Potentially update totalDebt (within the _updateTotalDebt function called by _updateSafe) based on the debtIncrease calculated if cumulativeDebtPerUnitCollateral has changed since the last snapshot.",
          "Update the liquidation snapshot debtPerCollateralSnapshot and collateralPerCollateralSnapshot if cumulativeDebtPerUnitCollateral or cumulativeCollateralPerUnitCollateral has changed since the last snapshot inside _updateSafe."
        ]
      },
      {
        "category": "Liquidation Queue Management",
        "state_update_descriptions": [
          "If borrowedAmount > 0, update the liquidation queue using safesOrderedForLiquidation.upsert with a new ratio and emit LiquidationQueueUpdated event.",
          "If borrowedAmount is 0, remove the safe from both liquidation and redemption queues by calling _removeSafeFromBothQueues(safeId), emitting SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE may change from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD in _updateTotalDebt function."
        ]
      },
      {
        "category": "ETH Transfer",
        "state_update_descriptions": [
          "Transfer ETH to the msg.sender based on the withdrawn amount."
        ]
      },
      {
        "category": "Event Emission",
        "state_update_descriptions": [
          "Emit WithdrawnCollateral event with safeId, amount, totalCollateral, and totalDebt.",
          "Emit SafeUpdated event with _safeId, _safe.collateralAmount, _safe.borrowedAmount, collateralIncrease, debtIncrease, totalCollateral, and totalDebt when _updateSafe is called.",
          "Emit LiquidationQueueUpdated when the liquidation queue is updated.",
          "Emit SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events when the safe is removed from the queues."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral and Debt Validation",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be decreased by the withdrawn amount (plus any collateralIncrease from _updateSafe).",
          "If borrowedAmount > 0 before withdrawal, then (safe.borrowedAmount * PRECISION) / (safe.collateralAmount - amount) should equal the new ratio in the liquidation queue.",
          "If borrowedAmount was 0, safe should be removed from both liquidation and redemption queues, so safesOrderedForLiquidation.getNode(safeId) and safesOrderedForRedemption.getNode(safeId) should return a node with value 0, next 0, and prev 0.",
          "totalCollateral should be decreased by the withdrawn amount (plus any collateralIncrease from _updateSafe).",
          "Verify totalDebt is updated correctly (taking into account debtIncrease from _updateSafe)."
        ]
      },
      {
        "category": "Liquidation Queue Validation",
        "rule_descriptions": [
          "If borrowedAmount > 0, verify the safe's position in the liquidation queue is updated correctly based on the new collateral ratio. Check safesOrderedForLiquidation.getNode(safeId) to ensure the 'value' field reflects the updated ratio, and 'next' and 'prev' point to the correct nodes.",
          "If borrowedAmount was 0, verify safesOrderedForLiquidation.getNode(safeId) and safesOrderedForRedemption.getNode(safeId) return a node with value 0, next 0, and prev 0."
        ]
      },
      {
        "category": "Protocol Mode Validation",
        "rule_descriptions": [
          "If PROTOCOL_MODE was BOOTSTRAP before, verify it changed to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD. If it was already NORMAL, it should remain NORMAL."
        ]
      },
      {
        "category": "ETH Balance Validation",
        "rule_descriptions": [
          "The msg.sender's ETH balance should be increased by the withdrawn amount after the transaction (gas costs need to be accounted for)."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "Verify a WithdrawnCollateral event is emitted with the correct safeId, amount, totalCollateral, and totalDebt.",
          "Verify a SafeUpdated event is emitted with the updated safe details (_safeId, _safe.collateralAmount, _safe.borrowedAmount, collateralIncrease, debtIncrease, totalCollateral, totalDebt) when _updateSafe is called.",
          "If the safe is removed from the liquidation queue, verify SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events are emitted with the correct safeId.",
          "If the liquidation queue is updated, verify a LiquidationQueueUpdated event is emitted with the correct safeId and newRatio."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a specific safe.",
            "why_is_is_important": "Reflects the actual amount of collateral backing the borrowed debt.",
            "when_is_it_updated": "When collateral is withdrawn from a safe.",
            "how_to_validate_state_update": "Check that the safe's collateralAmount is decreased by amount, which is the amount of collateral being withdrawn.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the collateral amount of a specific safe.",
            "conditions": [
              "safe.collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral deposited across all safes in the protocol.",
            "why_is_is_important": "Reflects the overall collateralization of the protocol.",
            "when_is_it_updated": "When collateral is withdrawn from any safe.",
            "how_to_validate_state_update": "Check that the totalCollateral is decreased by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total collateral in the protocol.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of debt associated with a specific safe, accounting for accrued debt.",
            "why_is_is_important": "Ensures the borrowed amount is up-to-date with the current protocol state.",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Verify that `safes[safeId].borrowedAmount` is increased by `debtIncrease`, calculated as `(_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a specific safe based on cumulative debt.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt ever borrowed by a safe.",
            "why_is_is_important": "Tracks the total debt over the safe's lifetime.",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Verify that `safes[safeId].totalBorrowedAmount` is increased by `debtIncrease`, calculated as `(_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of a specific safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt per unit of collateral at the time of the snapshot.",
            "why_is_is_important": "Used to calculate and apply accrued debt.",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check that `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` is updated to `cumulativeDebtPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a specific safe, accounting for accrued collateral.",
            "why_is_is_important": "Ensures collateral amount is consistent with overall system accounting",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Verify that `safes[safeId].collateralAmount` is increased by `collateralIncrease`, calculated as `(_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of a specific safe based on cumulative collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The cumulative collateral per unit of collateral at the time of the snapshot.",
            "why_is_is_important": "Used to calculate and apply accrued collateral.",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check that `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot` is updated to `cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral deposited across all safes in the protocol, including accrued collateral.",
            "why_is_is_important": "Maintains an accurate record of total collateral in the system.",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Verify that `totalCollateral` is increased by `collateralIncrease`, calculated as `(_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral amount in the system.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "The order of safes based on their liquidation ratio.",
            "why_is_is_important": "Ensures the liquidation queue is accurate for liquidations.",
            "when_is_it_updated": "When a safe's liquidation ratio changes after collateral withdrawal.",
            "how_to_validate_state_update": "The liquidation queue is updated with `_newRatio` calculated as `(safe.borrowedAmount * PRECISION) / (safe.collateralAmount - amount)` for the given `safeId`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue with the new liquidation ratio after withdrawing collateral.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "Order of safes based on liquidation ratio",
            "why_is_is_important": "To avoid unnecessary iteration during liquidation",
            "when_is_it_updated": "When borrowed amount is 0",
            "how_to_validate_state_update": "Check that safe is removed from both liquidation and redemption queues",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from liquidation queue if borrowed amount is 0.",
            "conditions": [
              "safe.borrowedAmount <= 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "address",
            "what_does_it_track": "Order of safes based on redemption ratio",
            "why_is_is_important": "To avoid unnecessary iteration during redemption",
            "when_is_it_updated": "When borrowed amount is 0",
            "how_to_validate_state_update": "Check that safe is removed from both liquidation and redemption queues",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from redemption queue if borrowed amount is 0.",
            "conditions": [
              "safe.borrowedAmount <= 0"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Current mode of protocol",
            "why_is_is_important": "To adjust behaviour based on debt level.",
            "when_is_it_updated": "When debt threshold is reached",
            "how_to_validate_state_update": "Check that PROTOCOL_MODE is updated to NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "change protocol mode when debt threshold is reached.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt in the protocol, accounting for accrued debt.",
            "why_is_is_important": "Maintains an accurate record of total debt in the system.",
            "when_is_it_updated": "Before collateral withdrawal, if the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Verify that `totalDebt` is increased by `debtIncrease`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt in the system.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "The nodes in the linked list, representing safes and their liquidation ratios.",
            "why_is_is_important": "Maintains the correct order of safes for liquidation.",
            "when_is_it_updated": "When the liquidation ratio of a safe changes.",
            "how_to_validate_state_update": "The `upsert` function is called, which either inserts or updates a node in the linked list. Validate that the node corresponding to `safeId` has the correct `value` (liquidation ratio) and its `prev` and `next` pointers are correctly set.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue by inserting or updating a node.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "The nodes in the linked list, representing safes and their liquidation ratios.",
            "why_is_is_important": "Maintains the integrity of the liquidation queue.",
            "when_is_it_updated": "When a safe is closed or its borrowed amount becomes zero.",
            "how_to_validate_state_update": "The `remove` function is called to remove the node corresponding to `safeId`. Validate that `nodes[safeId]` is deleted, and that the `head` and `tail` pointers of the linked list are updated if necessary.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes a node from the linked list when a safe is closed or its borrowed amount becomes zero.",
            "conditions": [
              "safe.borrowedAmount <= 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the list.",
            "why_is_is_important": "Maintains the correct beginning of the list.",
            "when_is_it_updated": "When the head node is removed or a new node is inserted at the beginning.",
            "how_to_validate_state_update": "If the node being removed is the head node, then the `head` state variable should be updated to the next node in the list (or 0 if the list becomes empty).",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list.",
            "conditions": [
              "safe.borrowedAmount <= 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the list.",
            "why_is_is_important": "Maintains the correct end of the list.",
            "when_is_it_updated": "When the tail node is removed or a new node is inserted at the end.",
            "how_to_validate_state_update": "If the node being removed is the tail node, then the `tail` state variable should be updated to the previous node in the list (or 0 if the list becomes empty).",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list.",
            "conditions": [
              "safe.borrowedAmount <= 0"
            ]
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}