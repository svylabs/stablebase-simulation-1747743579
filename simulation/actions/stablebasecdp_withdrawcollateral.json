{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "The `msg.value` sent with the transaction must be 0, as this is a `nonpayable` function that performs an outgoing transfer of collateral.",
      "The `safeId` must correspond to an existing CDP (Safe) owned by the `msg.sender`.",
      "The `amount` parameter must be a positive integer representing the amount of collateral (ETH) to withdraw from the Safe.",
      "The `amount` must be less than or equal to the `safe.collateralAmount` before withdrawal.",
      "If the safe has a `borrowedAmount` greater than 0, the `amount` must be less than or equal to the maximum withdrawal allowed, which ensures the safe's collateralization ratio remains above the liquidation ratio (`safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR)`).",
      "The `nearestSpotInLiquidationQueue` parameter should be an existing `safeId` that serves as a hint for efficient insertion/update in the `safesOrderedForLiquidation` linked list. If no specific hint is available or desired, it can be set to 0. This parameter is only relevant if the safe has `borrowedAmount > 0`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "CDP State Updates",
        "state_update_descriptions": [
          "The `collateralAmount` for the specified `safeId` in the `safes` mapping is decreased by the `amount` withdrawn.",
          "The `borrowedAmount` for the specified `safeId` may be increased due to accrued debt based on `cumulativeDebtPerUnitCollateral` since the last update (via `_updateSafe`).",
          "The `totalBorrowedAmount` for the specified `safeId` may be increased due to accrued debt (via `_updateSafe`).",
          "The `collateralPerCollateralSnapshot` for the `safeId` in `liquidationSnapshots` is updated to the current `cumulativeCollateralPerUnitCollateral` (via `_updateSafe`).",
          "The `debtPerCollateralSnapshot` for the `safeId` in `liquidationSnapshots` is updated to the current `cumulativeDebtPerUnitCollateral` (via `_updateSafe`)."
        ]
      },
      {
        "category": "Protocol Global State Updates",
        "state_update_descriptions": [
          "The `totalCollateral` state variable is decreased by the `amount` withdrawn.",
          "The `totalDebt` state variable may be increased if `_updateSafe` calculated any accrued debt for the safe.",
          "The `PROTOCOL_MODE` may transition from `BOOTSTRAP` to `NORMAL` if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`."
        ]
      },
      {
        "category": "Queue State Updates",
        "state_update_descriptions": [
          "If the safe had a `borrowedAmount` greater than 0, its position in the `safesOrderedForLiquidation` queue is updated based on its new collateralization ratio, or it is inserted if it wasn't there.",
          "If the safe had a `borrowedAmount` of 0, it is removed from both the `safesOrderedForLiquidation` and `safesOrderedForRedemption` queues."
        ]
      },
      {
        "category": "External Interactions",
        "state_update_descriptions": [
          "The `amount` of collateral (ETH) is transferred from the StableBaseCDP contract to the `msg.sender` (the owner of the safe)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "CDP State Validation",
        "rule_descriptions": [
          "The `collateralAmount` of `safes[safeId]` must be equal to its original value minus `amount` (adjusted for any `_updateSafe` collateral increase).",
          "If the safe had a `borrowedAmount > 0` before the call, `safes[safeId].borrowedAmount` and `safes[safeId].totalBorrowedAmount` should reflect any accrued debt calculated by `_updateSafe`.",
          "If the safe had a `borrowedAmount > 0` before the call, the `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` should be equal to the `cumulativeCollateralPerUnitCollateral` at the time of `_updateSafe` execution.",
          "If the safe had a `borrowedAmount > 0` before the call, the `liquidationSnapshots[safeId].debtPerCollateralSnapshot` should be equal to the `cumulativeDebtPerUnitCollateral` at the time of `_updateSafe` execution."
        ]
      },
      {
        "category": "Protocol Global State Validation",
        "rule_descriptions": [
          "The `totalCollateral` state variable must be equal to its original value minus `amount` (adjusted for any `_updateSafe` collateral increase).",
          "The `totalDebt` state variable should be equal to its original value plus any debt increase calculated by `_updateSafe`.",
          "The `PROTOCOL_MODE` should be `NORMAL` if the post-execution `totalDebt` is greater than or equal to `BOOTSTRAP_MODE_DEBT_THRESHOLD`, otherwise it retains its previous mode."
        ]
      },
      {
        "category": "Queue State Validation",
        "rule_descriptions": [
          "If the safe had a `borrowedAmount > 0` before the call, the `safesOrderedForLiquidation` contract's internal state must reflect that `safeId` has been updated with a new ratio `(safe.borrowedAmount * PRECISION) / (safe.collateralAmount - amount)`.",
          "If the safe had a `borrowedAmount == 0` before the call, the `safesOrderedForLiquidation.get(safeId)` and `safesOrderedForRedemption.get(safeId)` calls should return a node with all zero values, indicating removal."
        ]
      },
      {
        "category": "User Balance Validation",
        "rule_descriptions": [
          "The `msg.sender`'s ETH/collateral balance must have increased by `amount`."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "A `WithdrawnCollateral` event must be emitted with the correct `safeId`, `amount`, updated `totalCollateral`, and updated `totalDebt`.",
          "If the safe had a `borrowedAmount > 0` before the call, a `LiquidationQueueUpdated` event must be emitted with the `safeId`, `newRatio`, and `nextNode`.",
          "If the safe had a `borrowedAmount == 0` before the call, a `SafeRemovedFromLiquidationQueue` event must be emitted with the `safeId`.",
          "If the safe had a `borrowedAmount == 0` before the call, a `SafeRemovedFromRedemptionQueue` event must be emitted with the `safeId`.",
          "If `_updateSafe` was executed (i.e., `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`), a `SafeUpdated` event must be emitted with the correct `safeId`, `collateralAmount`, `debtAmount`, `collateralIncrease`, `debtIncrease`, `totalCollateral`, and `totalDebt`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "mapping",
            "what_does_it_track": "The amount of collateral deposited in a specific CDP (Safe).",
            "why_is_is_important": "It tracks the current collateral backing the CDP, which is crucial for calculating the collateralization ratio and determining liquidation risk.",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe if the Safe needs to be updated based on accumulated protocol-wide collateral, and then directly in withdrawCollateral to reflect the user's withdrawal.",
            "how_to_validate_state_update": "Verify that safes[safeId].collateralAmount has been reduced by collateralIncrease (if _updateSafe's conditions were met) and then by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateralAmount of the specified Safe is first increased proportionally if global cumulative collateral has increased since the last snapshot, and then decreased by the amount of collateral withdrawn by the user.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral)."
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "mapping",
            "what_does_it_track": "The amount of debt currently attributed to a specific CDP (Safe).",
            "why_is_is_important": "It tracks the current debt of the CDP, essential for health checks and liquidation calculations.",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe if the Safe needs to be updated based on accumulated protocol-wide debt.",
            "how_to_validate_state_update": "Verify that safes[safeId].borrowedAmount has been increased by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowedAmount of the specified Safe is increased proportionally if global cumulative debt has increased since the last snapshot.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral)."
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "mapping",
            "what_does_it_track": "The total cumulative amount of debt ever borrowed against a specific CDP (Safe), including any increases due to accumulated protocol debt.",
            "why_is_is_important": "It provides a historical record of the total debt accrued by a Safe, which can be useful for fee calculations or analysis.",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe if the Safe needs to be updated based on accumulated protocol-wide debt.",
            "how_to_validate_state_update": "Verify that safes[safeId].totalBorrowedAmount has been increased by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The totalBorrowedAmount of the specified Safe is increased proportionally if global cumulative debt has increased since the last snapshot.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral)."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "mapping",
            "what_does_it_track": "The value of cumulativeCollateralPerUnitCollateral at the last time a specific Safe was updated.",
            "why_is_is_important": "It's critical for calculating the change in a Safe's collateralAmount due to system-wide collateral adjustments (e.g., liquidations or redemptions affecting the ratio).",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe when the Safe's collateralAmount is adjusted based on the cumulativeCollateralPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to the current cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the protocol's cumulativeCollateralPerUnitCollateral for a specific Safe is updated to the current global value.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral)."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "mapping",
            "what_does_it_track": "The value of cumulativeDebtPerUnitCollateral at the last time a specific Safe was updated.",
            "why_is_is_important": "It's critical for calculating the change in a Safe's borrowedAmount due to system-wide debt adjustments (e.g., new debt accrual or debt redistribution).",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe when the Safe's borrowedAmount is adjusted based on the cumulativeDebtPerUnitCollateral.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to the current cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the protocol's cumulativeDebtPerUnitCollateral for a specific Safe is updated to the current global value.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral)."
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral held across all active CDPs in the system.",
            "why_is_is_important": "It represents the overall collateralization of the protocol, influencing stability and overall health of the system.",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe if Safe collateral is updated due to cumulativeCollateralPerUnitCollateral changes, and then directly within withdrawCollateral to reflect the withdrawn amount.",
            "how_to_validate_state_update": "Verify that totalCollateral has been increased by collateralIncrease (if _updateSafe's conditions were met) and then decreased by amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral in the system is first increased proportionally if global cumulative collateral has increased since the last snapshot, and then decreased by the amount of collateral withdrawn by the user.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral)."
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operating mode of the protocol (e.g., BOOTSTRAP or NORMAL).",
            "why_is_is_important": "The protocol mode might dictate certain operational parameters, fees, or access controls.",
            "when_is_it_updated": "It is updated indirectly when _updateSafe is called, which in turn calls _updateTotalDebt. This happens if the totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD while the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "If PROTOCOL_MODE was BOOTSTRAP and totalDebt (after adding debtIncrease) became greater than BOOTSTRAP_MODE_DEBT_THRESHOLD, then PROTOCOL_MODE should be NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode can transition from BOOTSTRAP to NORMAL if the total debt in the system exceeds a certain threshold.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral).",
              "PROTOCOL_MODE is BOOTSTRAP and totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD after the debt increase, PROTOCOL_MODE changes to NORMAL mode. This is an internal update within _updateTotalDebt which is called by _updateSafe.",
              "This state update occurs when the totalDebt in the system crosses a predefined threshold, signaling a transition from an initial 'bootstrap' phase to a regular operating 'normal' phase for the protocol.",
              "This transition is one-way (from BOOTSTRAP to NORMAL)."
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total amount of debt (SBD) outstanding across all active CDPs in the system.",
            "why_is_is_important": "It represents the overall debt liability of the protocol and is critical for determining the PROTOCOL_MODE.",
            "when_is_it_updated": "It is updated at the beginning of the withdrawCollateral function call via _updateSafe if the Safe's debt is updated due to cumulativeDebtPerUnitCollateral changes.",
            "how_to_validate_state_update": "Verify that totalDebt has been increased by debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt in the system is increased proportionally if global cumulative debt has increased since the last snapshot, via the _updateTotalDebt function called by _updateSafe.",
            "conditions": [
              "The _updateSafe function is called at the beginning of withdrawCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot is not equal to cumulativeCollateralPerUnitCollateral to trigger a re-calculation of the Safe's collateral and debt based on protocol-wide accumulated values (cumulative collateral/debt per unit collateral).",
              "add is true when called from _updateSafe for debtIncrease.",
              "totalDebt (after adding debtIncrease) becomes greater than BOOTSTRAP_MODE_DEBT_THRESHOLD while PROTOCOL_MODE is BOOTSTRAP (this affects PROTOCOL_MODE too)."
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "mapping",
            "what_does_it_track": "A mapping from id (Safe ID) to Node struct, where Node contains value (collateralization ratio), prev (previous node ID), and next (next node ID) within the ordered linked list.",
            "why_is_is_important": "It maintains the ordered list of Safes by their collateralization ratio, crucial for efficient liquidation processes.",
            "when_is_it_updated": "If safe.borrowedAmount is greater than 0, upsert is called to update the safe's position in the liquidation queue based on its new ratio. If safe.borrowedAmount is 0, remove is called to remove the safe from the liquidation queue.",
            "how_to_validate_state_update": "Verify that the Node corresponding to safeId is either inserted or its value, prev, and next pointers are updated correctly within the nodes mapping (when safe.borrowedAmount > 0), or deleted (when safe.borrowedAmount == 0).",
            "has_conditional_updates": true,
            "summary_of_update": "A node representing the safeId is either inserted/updated in the safesOrderedForLiquidation linked list (if safe.borrowedAmount > 0) or removed from it (if safe.borrowedAmount == 0). When updated/inserted, its value (liquidation ratio) is adjusted, and its prev and next pointers are set to maintain the sorted order.",
            "conditions": [
              "The safe.borrowedAmount is greater than 0, leading to a call to safesOrderedForLiquidation.upsert.",
              "The safe.borrowedAmount is zero, leading to a call to _removeSafeFromBothQueues which calls safesOrderedForLiquidation.remove.",
              "The node id does not exist in nodes (for _insert during upsert).",
              "The node id exists in nodes (for _update during upsert or remove).",
              "The node is the head or tail of the list, requiring adjustment of head or tail pointers.",
              "The node is in the middle of the list, requiring adjustment of prev and next pointers of surrounding nodes.",
              "The _nearestSpot parameter is used to optimize the search for insertion/update position, but if invalid, it defaults to head and then searches from there.",
              "The value of the node (collateralization ratio) determines its position in the ordered list (sorted by ratio)."
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node (the one with the lowest collateralization ratio, meaning most at risk of liquidation) in the ordered linked list.",
            "why_is_is_important": "It provides quick access to the most liquidatable Safe, critical for the liquidation mechanism.",
            "when_is_it_updated": "It's updated by _insert or _remove functions, which are called by upsert or remove respectively.",
            "how_to_validate_state_update": "If a node was inserted and became the new head, head should point to its id. If the head node was removed, head should point to the next node or 0 if the list became empty.",
            "has_conditional_updates": true,
            "summary_of_update": "The head of the safesOrderedForLiquidation linked list is updated if the safeId becomes the new head (due to upsert and a new lowest ratio) or if the current head is removed.",
            "conditions": [
              "The safe.borrowedAmount is greater than 0, leading to a call to safesOrderedForLiquidation.upsert. If the list was empty (head == 0), head will be set to id.",
              "The safe.borrowedAmount is zero, leading to a call to _removeSafeFromBothQueues which calls safesOrderedForLiquidation.remove. If the removed node was the head (node.prev == 0), head will be updated to node.next.",
              "During _insert (part of upsert), if the new node becomes the first element (smallest value or inserted before current head), head is updated.",
              "During _remove, if the removed node was the current head, head is updated to the next node in the list. If it was the only node, head becomes 0 (null)."
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node (the one with the highest collateralization ratio, meaning least at risk of liquidation) in the ordered linked list.",
            "why_is_is_important": "It provides quick access to the least liquidatable Safe.",
            "when_is_it_updated": "It's updated by _insert or _remove functions, which are called by upsert or remove respectively.",
            "how_to_validate_state_update": "If a node was inserted and became the new tail, tail should point to its id. If the tail node was removed, tail should point to the previous node or 0 if the list became empty.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail of the safesOrderedForLiquidation linked list is updated if the safeId becomes the new tail (due to upsert and a new highest ratio) or if the current tail is removed.",
            "conditions": [
              "The safe.borrowedAmount is greater than 0, leading to a call to safesOrderedForLiquidation.upsert. If the list was empty (head == 0), tail will be set to id.",
              "The safe.borrowedAmount is zero, leading to a call to _removeSafeFromBothQueues which calls safesOrderedForLiquidation.remove. If the removed node was the tail (node.next == 0), tail will be updated to node.prev.",
              "During _insert (part of upsert), if the new node becomes the last element (largest value or inserted after current tail), tail is updated.",
              "During _remove, if the removed node was the current tail, tail is updated to the previous node in the list. If it was the only node, tail becomes 0 (null)."
            ]
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "mapping",
            "what_does_it_track": "A mapping from id (Safe ID) to Node struct within the ordered linked list for redemption.",
            "why_is_is_important": "It maintains the ordered list of Safes for redemption, ensuring efficient redemption processes.",
            "when_is_it_updated": "Only when safe.borrowedAmount is 0, the _removeSafeFromBothQueues function is called, which explicitly removes the safeId from the safesOrderedForRedemption list.",
            "how_to_validate_state_update": "Verify that the Node corresponding to safeId is deleted from the nodes mapping.",
            "has_conditional_updates": true,
            "summary_of_update": "A node representing the safeId is removed from the safesOrderedForRedemption linked list when there is no borrowed amount for that Safe.",
            "conditions": [
              "The safe.borrowedAmount is zero, leading to a call to _removeSafeFromBothQueues which calls safesOrderedForRedemption.remove.",
              "The node id exists in nodes for removal.",
              "The node is the head or tail of the list, requiring adjustment of head or tail pointers.",
              "The node is in the middle of the list, requiring adjustment of prev and next pointers of surrounding nodes.",
              "If the node doesn't exist, no update occurs (though it returns a zero node)."
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node in the ordered linked list for redemption.",
            "why_is_is_important": "It provides quick access to the first Safe in the redemption queue.",
            "when_is_it_updated": "It's updated by the _remove function, which is called by remove when safe.borrowedAmount is 0.",
            "how_to_validate_state_update": "If the head node was removed, head should point to the next node or 0 if the list became empty.",
            "has_conditional_updates": true,
            "summary_of_update": "The head of the safesOrderedForRedemption linked list is updated if the current head node is removed.",
            "conditions": [
              "The safe.borrowedAmount is zero, leading to a call to _removeSafeFromBothQueues which calls safesOrderedForRedemption.remove.",
              "If the removed node was the head (node.prev == 0), head will be updated to node.next.",
              "If the removed node was the only node, head becomes 0 (null)."
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node in the ordered linked list for redemption.",
            "why_is_is_important": "It provides quick access to the last Safe in the redemption queue.",
            "when_is_it_updated": "It's updated by the _remove function, which is called by remove when safe.borrowedAmount is 0.",
            "how_to_validate_state_update": "If the tail node was removed, tail should point to the previous node or 0 if the list became empty.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail of the safesOrderedForRedemption linked list is updated if the current tail node is removed.",
            "conditions": [
              "The safe.borrowedAmount is zero, leading to a call to _removeSafeFromBothQueues which calls safesOrderedForRedemption.remove.",
              "If the removed node was the tail (node.next == 0), tail will be updated to node.prev.",
              "If the removed node was the only node, tail becomes 0 (null)."
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}