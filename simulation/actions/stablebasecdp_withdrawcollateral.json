{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing Safe owned by `msg.sender`.",
      "The `amount` to withdraw must be greater than 0.",
      "If `borrowedAmount` > 0, the `amount` to withdraw must not exceed the maximum withdrawal amount that maintains the liquidation ratio, which is: safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR).",
      "If `borrowedAmount` is 0, the `amount` to withdraw must not exceed the `collateralAmount` of the Safe.",
      "`nearestSpotInLiquidationQueue` can be any `safeId` already in the liquidation queue, or 0 if the user doesn't care about the position in the queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the `collateralAmount` of the Safe with `safeId` by subtracting the `amount` withdrawn.",
          "If `borrowedAmount` is greater than 0, the liquidation queue is updated based on the new collateral ratio; otherwise, the Safe is removed from both liquidation and redemption queues.",
          "If cumulative collateral or debt per unit collateral have changed since the last snapshot, the safe's `borrowedAmount` and `collateralAmount` are updated to reflect accrued debt and collateral."
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "state_update_descriptions": [
          "Decreases the `totalCollateral` by the `amount` withdrawn.",
          "The `totalDebt` might be updated within the `_updateSafe` function if there are inactive debt and collateral."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "If `borrowedAmount` > 0, updates the liquidation queue by upserting the safe with a new liquidation ratio based on the reduced collateral. Emits `LiquidationQueueUpdated` event.",
          "If `borrowedAmount` is 0, removes the Safe from both the liquidation and redemption queues using `_removeSafeFromBothQueues`. Emits `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` events."
        ]
      },
      {
        "category": "Contract Balance",
        "state_update_descriptions": [
          "Transfers the `amount` of withdrawn collateral to `msg.sender`."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates the `liquidationSnapshots[safeId]` if there is a difference between `liquidationSnapshot.collateralPerCollateralSnapshot` and `cumulativeCollateralPerUnitCollateral`."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "The `PROTOCOL_MODE` state might be updated in the `_updateTotalDebt` function if `totalDebt` crosses the `BOOTSTRAP_MODE_DEBT_THRESHOLD`."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "Emits a `WithdrawnCollateral` event indicating the `safeId`, `amount` withdrawn, updated `totalCollateral`, and `totalDebt`.",
          "Emits `SafeUpdated` event if the safe's collateral and debt are updated.",
          "Emits `LiquidationQueueUpdated` event if the safe is upserted into liquidation queue.",
          "Emits `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` if the safe is removed from liquidation and redemption queues."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "Verify that the `safeId` exists by calling `safes(safeId)`. The call should not revert.",
          "Verify that the Safe with `safeId` is owned by `msg.sender`. Call `ownerOf(safeId)` and compare with `msg.sender`.",
          "The `collateralAmount` of the Safe with `safeId` should be decreased by the `amount` withdrawn.",
          "If `borrowedAmount` is greater than 0, the position of the Safe in the liquidation queue should reflect the new collateral ratio. Check using `safesOrderedForLiquidation.getNode(safeId)`.",
          "If `borrowedAmount` is 0, the Safe should be removed from both the liquidation and redemption queues. Check using `safesOrderedForLiquidation.getNode(safeId)` and `safesOrderedForRedemption.getNode(safeId)`."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "The `totalCollateral` should be decreased by the `amount` withdrawn. Verify by reading the state variable `totalCollateral`."
        ]
      },
      {
        "category": "Contract Balance",
        "rule_descriptions": [
          "The balance of `msg.sender` should increase by the `amount` withdrawn."
        ]
      },
      {
        "category": "Amount Validation",
        "rule_descriptions": [
          "If `borrowedAmount` > 0, verify that `amount <= safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR)`",
          "If `borrowedAmount` is 0, verify that `amount <= safe.collateralAmount`"
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "Verify that a `WithdrawnCollateral` event is emitted with the correct parameters (`safeId`, `amount`, updated `totalCollateral`, and `totalDebt`).",
          "If the safe's collateral and debt are updated, verify that a `SafeUpdated` event is emitted with the correct parameters.",
          "If the safe is upserted into the liquidation queue, verify that a `LiquidationQueueUpdated` event is emitted with the correct parameters.",
          "If the safe is removed from liquidation and redemption queues, verify that `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` events are emitted."
        ]
      },
      {
        "category": "Invariants",
        "rule_descriptions": [
          "The contract's total collateral must always be greater than or equal to zero.",
          "The contract's total debt must always be greater than or equal to zero.",
          "The liquidation and redemption queues should remain consistent after the operation.  Check the linked list integrity using `safesOrderedForLiquidation` and `safesOrderedForRedemption`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a specific safe.",
            "why_is_is_important": "Reflects the amount of collateral available for the safe, impacting its liquidation risk and withdrawal limits.",
            "when_is_it_updated": "When collateral is withdrawn from the safe, provided the user is the owner and the withdrawal doesn't violate the liquidation ratio.",
            "how_to_validate_state_update": "Check if safe.collateralAmount has decreased by amount, totalCollateral has decreased by amount, and the LiquidationQueue has been updated with the new liquidation ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the collateral amount of the safe with safeId by the withdrawn amount if sufficient collateral exists and the withdrawal maintains the liquidation ratio. It updates collateralAmount by subtracting the amount.",
            "conditions": [
              "safe.collateralAmount > 0",
              "amount <= maxWithdrawal",
              "safe.borrowedAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral held across all safes.",
            "why_is_is_important": "Provides a global view of the system's collateralization and affects system-wide calculations like global debt ratio.",
            "when_is_it_updated": "When collateral is withdrawn from any safe.",
            "how_to_validate_state_update": "Check if totalCollateral has decreased by the amount withdrawn.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total collateral held by the contract by the withdrawn amount.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The order of safes based on their liquidation risk.",
            "why_is_is_important": "Determines the order in which safes are liquidated, affecting the stability of the system.",
            "when_is_it_updated": "When collateral is withdrawn from a safe with a borrowed amount, impacting its collateral ratio.",
            "how_to_validate_state_update": "Verify that the liquidation queue is updated with the new liquidation ratio (borrowedAmount * PRECISION) / (collateralAmount - amount) using the IDoublyLinkedList.upsert function",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue based on the new collateral ratio after withdrawal, if there is a borrowed amount.",
            "conditions": [
              "safe.borrowedAmount > 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation and safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The order of safes in the liquidation and redemption queues.",
            "why_is_is_important": "Ensures that only safes with debt are actively tracked for liquidation and redemption.",
            "when_is_it_updated": "When the safe has no borrowed amount, removing it from active risk management.",
            "how_to_validate_state_update": "Check that the safe is removed from both liquidation and redemption queues using _removeSafeFromBothQueues.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from both liquidation and redemption queues if there is no borrowed amount.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount borrowed against the collateral in the safe, adjusted for cumulative debt.",
            "why_is_is_important": "Keeps the borrowed amount accurate, influencing liquidation ratios and overall risk assessment.",
            "when_is_it_updated": "Before withdrawing collateral, if there have been changes in cumulative debt since the last liquidation snapshot.",
            "how_to_validate_state_update": "Verify the borrowedAmount and collateralAmount of the safe are updated using cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount for the safe, potentially increasing it based on cumulative debt changes since the last snapshot. This update happens within the _updateSafe function.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The current mode of the protocol.",
            "why_is_is_important": "The current mode of the protocol, used to ensure proper execution.",
            "when_is_it_updated": "When totalDebt crosses BOOTSTRAP_MODE_DEBT_THRESHOLD within the `_updateTotalDebt` function.",
            "how_to_validate_state_update": "Check PROTOCOL_MODE is NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol mode is updated from BOOTSTRAP to NORMAL if the total debt exceeds the threshold. This update happens within the _updateTotalDebt function.",
            "conditions": [
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total amount of debt outstanding in the system.",
            "why_is_is_important": "Critical for assessing systemic risk and calculating global collateralization ratios.",
            "when_is_it_updated": "When debt is borrowed or repaid, or when system parameters affect cumulative debt. Indirectly updated through the `_updateSafe` function.",
            "how_to_validate_state_update": "Verify that the global totalDebt is updated indirectly through the internal function `_updateSafe`.",
            "has_conditional_updates": false,
            "summary_of_update": "The total debt across all safes. This is indirectly updated through the internal function _updateSafe.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "The value, previous node, and next node of each safe in the linked list.",
            "why_is_is_important": "Maintains the correct order of safes for liquidation and redemption, which directly affects system stability and user experience.",
            "when_is_it_updated": "When the liquidation or redemption queue is updated due to changes in collateral ratios from borrowing, repaying, adding, or withdrawing collateral.",
            "how_to_validate_state_update": "Check the nodes mapping for the specific safeId to see the new value, prev, and next pointers. Also, verify that the head and tail pointers of the list are correct.",
            "has_conditional_updates": true,
            "summary_of_update": "The doubly linked list nodes are updated to reflect the new order of safes after collateral withdrawal. The upsert function may insert, update, or remove nodes based on the new collateral ratio, influencing the prev and next pointers of affected nodes and potentially the head/tail of the list.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "Maintains the correct head of safes for liquidation and redemption, which directly affects system stability and user experience.",
            "when_is_it_updated": "The head of the doubly linked list is updated when the liquidation or redemption queue is updated due to changes in collateral ratios from borrowing, repaying, adding, or withdrawing collateral, and the list is empty",
            "how_to_validate_state_update": "Verify the head pointer is updated to safeId",
            "has_conditional_updates": true,
            "summary_of_update": "The head pointer of the doubly linked list is updated when the list is empty.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal",
              "head == 0",
              "Initial insertion into the list"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "Maintains the correct tail of safes for liquidation and redemption, which directly affects system stability and user experience.",
            "when_is_it_updated": "The tail of the doubly linked list is updated when the liquidation or redemption queue is updated due to changes in collateral ratios from borrowing, repaying, adding, or withdrawing collateral, and the list is empty.",
            "how_to_validate_state_update": "Verify the tail pointer is updated to safeId",
            "has_conditional_updates": true,
            "summary_of_update": "The tail pointer of the doubly linked list is updated when the list is empty.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal",
              "tail == 0",
              "Initial insertion into the list"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}