{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing Safe owned by `msg.sender`.",
      "The `amount` to withdraw must be greater than 0.",
      "If `safe.borrowedAmount > 0`, the withdrawal amount must not cause the collateral ratio to drop below the liquidation ratio: `amount <= safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR)`.",
      "If `safe.borrowedAmount == 0`, the withdrawal `amount` must be less than or equal to `safe.collateralAmount`.",
      "`nearestSpotInLiquidationQueue` can be 0, `head` or `tail` of the liquidation queue, or any `safeId` that is present in the queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Decreases the `collateralAmount` of the specified Safe (`safes[safeId].collateralAmount -= amount`).",
          "If `safe.borrowedAmount > 0`, the liquidation ratio of the Safe might be updated, and the Safe might be re-ordered in the liquidation queue.",
          "If `safe.borrowedAmount == 0`, the Safe is removed from both the liquidation and redemption queues.",
          "Collateral amount can not be negative after withdrawal."
        ]
      },
      {
        "category": "Protocol State",
        "state_update_descriptions": [
          "Decreases `totalCollateral` by the withdrawn amount (`totalCollateral -= amount`).",
          "Potentially updates the protocol mode from BOOTSTRAP to NORMAL if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`."
        ]
      },
      {
        "category": "Accounting",
        "state_update_descriptions": [
          "Updates borrowed amount based on cumulative debt per collateral if there are inactive debts/collateral."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfers the withdrawn collateral amount to the message sender (`msg.sender`)."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "Updates the liquidation queue if `safe.borrowedAmount > 0` and the withdrawal affects the safe's liquidation ratio."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "`safes[safeId].collateralAmount` should be decreased by `amount`.",
          "If `borrowedAmount > 0`, the liquidation ratio should be correctly updated, and the safe should be positioned at a correct place in `safesOrderedForLiquidation` based on the new ratio.",
          "If `borrowedAmount == 0`, `safeId` should be removed from `safesOrderedForLiquidation` and `safesOrderedForRedemption`.",
          "`safes[safeId].collateralAmount` must be non-negative."
        ]
      },
      {
        "category": "Protocol State",
        "rule_descriptions": [
          "`totalCollateral` should be decreased by `amount`.",
          "If protocol mode was BOOTSTRAP and totalDebt became greater than BOOTSTRAP_MODE_DEBT_THRESHOLD, the `PROTOCOL_MODE` should be NORMAL."
        ]
      },
      {
        "category": "Balance Validation",
        "rule_descriptions": [
          "The contract's ETH balance should be decreased by the withdrawn `amount`."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A `WithdrawnCollateral` event should be emitted with the correct parameters (`safeId`, `amount`, `totalCollateral`, `totalDebt`).",
          "A `LiquidationQueueUpdated` event should be emitted if the safe exists in the liquidation queue and its liquidation ratio was updated.",
          "A `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` events should be emitted if the safe was removed from the queues."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in a specific safe (CDP).",
            "why_is_is_important": "Accurately reflects the user's available collateral, influencing liquidation risk and borrowing power. Necessary to validate sufficient collateral for existing debt and prevent over-withdrawal of collateral",
            "when_is_it_updated": "When the owner of a safe withdraws collateral from their CDP.",
            "how_to_validate_state_update": "Check if safe.collateralAmount is decreased by amount. Verify that the amount withdrawn does not exceed the available collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the collateral amount of a specific safe, representing the amount withdrawn by the user.",
            "conditions": [
              "safe.collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral held within the protocol across all safes.",
            "why_is_is_important": "Provides a global view of the protocol's collateralization, essential for assessing the overall health and stability of the system",
            "when_is_it_updated": "When collateral is withdrawn from a safe.",
            "how_to_validate_state_update": "Check if totalCollateral is decreased by amount. Verify that the total collateral is reduced by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total collateral in the protocol, reflecting the aggregate amount of collateral held across all safes.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes for liquidation based on their collateralization ratio.",
            "why_is_is_important": "Maintains an accurate ordering of safes by risk, crucial for the liquidation mechanism to function correctly and protect the protocol's solvency",
            "when_is_it_updated": "When collateral is withdrawn from a safe that has a borrowed amount, and the withdrawal affects its collateral ratio.",
            "how_to_validate_state_update": "Verify the liquidation queue is updated with the new ratio (safe.borrowedAmount * PRECISION) / (safe.collateralAmount - amount). Check that the safe's position is updated in the queue based on the new collateral ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue based on the new collateral ratio, ensuring that safes are ordered correctly for potential liquidation.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= (safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR))"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes for liquidation.",
            "why_is_is_important": "Maintains the accuracy and efficiency of the liquidation queue by removing safes that pose no liquidation risk",
            "when_is_it_updated": "When collateral is withdrawn from a safe with no borrowed amount.",
            "how_to_validate_state_update": "Check if safe is removed from both the liquidation and redemption queues. Confirm that the safe's ID is no longer present in either queue.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the liquidation queue if it has no outstanding debt, simplifying the queue and improving efficiency.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes for redemption.",
            "why_is_is_important": "Maintains the accuracy and efficiency of the redemption queue by removing safes that are not eligible for redemption",
            "when_is_it_updated": "When collateral is withdrawn from a safe with no borrowed amount.",
            "how_to_validate_state_update": "Check if safe is removed from both the liquidation and redemption queues. Confirm that the safe's ID is no longer present in either queue.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the redemption queue if it has no outstanding debt, preventing unnecessary processing during redemption.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount borrowed in a specific safe (CDP).",
            "why_is_is_important": "Accurately reflects the user's debt, ensuring proper accounting of interest and fees and influencing liquidation thresholds",
            "when_is_it_updated": "Before collateral is withdrawn from a safe, as part of an update process to account for changes in cumulative debt.",
            "how_to_validate_state_update": "Verify that safe.borrowedAmount is increased by (safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION, safe.totalBorrowedAmount is increased by the same amount, and liquidationSnapshot.debtPerCollateralSnapshot is equal to cumulativeDebtPerUnitCollateral. Validate that the borrowed amount is adjusted correctly based on the cumulative debt and collateral ratios.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a specific safe based on cumulative debt, accounting for accrued interest or fees.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount ever borrowed in a specific safe.",
            "why_is_is_important": "Provides a historical record of the total debt, useful for analytics and assessing long-term risk",
            "when_is_it_updated": "Before collateral is withdrawn from a safe, to reflect changes in cumulative debt.",
            "how_to_validate_state_update": "Verify that safe.borrowedAmount is increased by (safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION, safe.totalBorrowedAmount is increased by the same amount, and liquidationSnapshot.debtPerCollateralSnapshot is equal to cumulativeDebtPerUnitCollateral. Confirm that the total borrowed amount is consistently updated with the borrowed amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount ever in a specific safe based on cumulative debt, reflecting the total debt accrued over time.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in a specific safe (CDP).",
            "why_is_is_important": "Maintains an accurate representation of the user's collateral, which directly affects their liquidation risk and borrowing power",
            "when_is_it_updated": "Before collateral is withdrawn from a safe, to account for changes in cumulative collateral.",
            "how_to_validate_state_update": "Verify that safe.collateralAmount is increased by (_safe.collateralAmount *(cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION, and liquidationSnapshot.collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral. Ensure that the collateral amount is adjusted correctly based on the cumulative collateral ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of a specific safe based on cumulative collateral, accounting for any changes in the collateral's value.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral held within the protocol.",
            "why_is_is_important": "Provides a global view of the protocol's collateralization, essential for assessing its overall health and stability",
            "when_is_it_updated": "Before collateral is withdrawn from a safe, to account for changes in cumulative collateral.",
            "how_to_validate_state_update": "Verify that totalCollateral is increased by (_safe.collateralAmount *(cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION. Confirm that the total collateral is updated consistently with the safe's collateral adjustment.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the protocol, reflecting changes in the value of collateral across all safes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt within the protocol.",
            "why_is_is_important": "Provides a global view of the protocol's debt, essential for monitoring the overall risk and solvency of the system",
            "when_is_it_updated": "Before collateral is withdrawn, to account for changes in cumulative debt.",
            "how_to_validate_state_update": "Verify that totalDebt is updated using the _updateTotalDebt function. Trace the execution of _updateTotalDebt to ensure that the total debt is adjusted correctly based on the debt increase or decrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt in the protocol, reflecting changes due to accrued interest or fees.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the current operational mode of the protocol (e.g., BOOTSTRAP, NORMAL).",
            "why_is_is_important": "Controls the protocol's behavior based on its current state, affecting various parameters and functionalities.",
            "when_is_it_updated": "Before collateral is withdrawn, if the total debt exceeds a predefined threshold while the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Verify that PROTOCOL_MODE is updated to NORMAL. Confirm that this change only occurs when the debt exceeds the threshold and the protocol is in BOOTSTRAP mode.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the PROTOCOL_MODE from BOOTSTRAP to NORMAL, transitioning the protocol out of its initial bootstrapping phase.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "Node",
            "what_does_it_track": "Tracks all the nodes",
            "why_is_is_important": "It's important to keep track of all existing nodes.",
            "when_is_it_updated": "when a safe is either updated or inserted into the queue",
            "how_to_validate_state_update": "Verify that new node is inserted.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts a new node in the doubly linked list",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the head of the list",
            "why_is_is_important": "It's important to keep track of the head",
            "when_is_it_updated": "When a safe is either updated or inserted into the queue",
            "how_to_validate_state_update": "Verify that head is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the tail of the list",
            "why_is_is_important": "It's important to keep track of the tail",
            "when_is_it_updated": "When a safe is either updated or inserted into the queue",
            "how_to_validate_state_update": "Verify that tail is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}