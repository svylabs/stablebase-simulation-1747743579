{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing Safe owned by `msg.sender`. This can be verified by checking the `safes` mapping.",
      "`amount` must be greater than 0.",
      "`amount` must be less than or equal to the safe's current `collateralAmount`.",
      "If the safe has a borrowed amount, `amount` must be less than or equal to the maximum withdrawal amount that maintains the liquidation ratio.  The maximum withdrawal amount can be calculated using the formula: `safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR)`.",
      "The `nearestSpotInLiquidationQueue` is a `safeId` that represents a spot in the liquidation queue close to the safe being withdrawn from. If there is no known spot, set to 0.",
      "Ensure `amount` is a reasonable value. Tests should include withdrawing a small amount, a large amount (close to the maximum allowed), and the maximum allowed amount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Decreases `safe.collateralAmount` by the withdrawn `amount`.",
          "Updates `safe.borrowedAmount` based on `_updateSafe` function logic if `safe.borrowedAmount > 0`.",
          "Potentially removes the safe from liquidation and redemption queues if `safe.borrowedAmount` is zero after withdrawal using `_removeSafeFromBothQueues`."
        ]
      },
      {
        "category": "Global State",
        "state_update_descriptions": [
          "Decreases `totalCollateral` by the withdrawn `amount`.",
          "Updates `totalDebt` based on `_updateSafe` function logic if `safe.borrowedAmount > 0` via the internal function `_updateTotalDebt`."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "If `safe.borrowedAmount > 0`, the liquidation queue position of the safe is updated via `safesOrderedForLiquidation.upsert`, which may involve reordering the queue based on the new collateralization ratio."
        ]
      },
      {
        "category": "Account Balance",
        "state_update_descriptions": [
          "Increases the msg.sender's ETH balance by the withdrawn `amount`."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "Emits a `WithdrawnCollateral` event with the correct `safeId`, `amount`, `totalCollateral`, and `totalDebt`.",
          "If the safe's liquidation queue position changes, emits a `LiquidationQueueUpdated` event with the updated ratio and queue position.",
          "If the safe is removed from the queues, emits `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` events."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "Verify that `safes[safeId].collateralAmount` is decreased by `amount` after the withdrawal.",
          "If `safe.borrowedAmount > 0` before the withdrawal, confirm the collateralization ratio is correctly updated and reflected in `safesOrderedForLiquidation`.",
          "If `safe.borrowedAmount == 0` before the withdrawal, confirm the safe is removed from both liquidation and redemption queues.",
          "If `amount` is 0, ensure that no changes to contract state are made."
        ]
      },
      {
        "category": "Global State",
        "rule_descriptions": [
          "Confirm that `totalCollateral` is decreased by `amount` after the withdrawal.",
          "If `safe.borrowedAmount > 0` before the withdrawal, verify `totalDebt` is updated according to the `_updateSafe` calculation."
        ]
      },
      {
        "category": "Account Balance",
        "rule_descriptions": [
          "Assert that the `msg.sender`'s ETH balance is increased by `amount` after the withdrawal."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "Ensure that a `WithdrawnCollateral` event is emitted with the correct `safeId`, `amount`, `totalCollateral`, and `totalDebt`.",
          "If the safe's liquidation queue position changes, ensure that a `LiquidationQueueUpdated` event is emitted with the updated ratio and queue position.",
          "If the safe is removed from the queues, verify the `SafeRemovedFromLiquidationQueue` and `SafeRemovedFromRedemptionQueue` events are emitted."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The collateral amount deposited for a specific safe.",
            "why_is_is_important": "Reflects the actual amount of collateral backing the borrowed debt.",
            "when_is_it_updated": "When collateral is withdrawn.",
            "how_to_validate_state_update": "Check if safe.collateralAmount is reduced by amount",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the collateral amount of a specific safe.",
            "conditions": [
              "safe.collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held by the contract.",
            "why_is_is_important": "Provides a global view of the collateralization of the system.",
            "when_is_it_updated": "When collateral is withdrawn.",
            "how_to_validate_state_update": "Check if totalCollateral is reduced by amount",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases total collateral held by the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "The queue for liquidation.",
            "why_is_is_important": "It ensures that safes are ordered correctly for liquidation based on their collateralization ratio.",
            "when_is_it_updated": "When collateral is withdrawn and there is a borrowed amount.",
            "how_to_validate_state_update": "Verify that the LiquidationQueueUpdated event is emitted with the correct parameters and the new ratio is calculated correctly",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the liquidation queue when collateral is withdrawn and borrowedAmount > 0. It will insert or update the position of safeId in the liquidation queue based on _newRatio.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "The queue for liquidation.",
            "why_is_is_important": "It ensures that safes are removed from the liquidation queue when no longer relevant.",
            "when_is_it_updated": "When collateral is withdrawn and there is no borrowed amount.",
            "how_to_validate_state_update": "Verify that the SafeRemovedFromLiquidationQueue event is emitted",
            "has_conditional_updates": true,
            "summary_of_update": "Removes safe from the liquidation queue when there is no borrowed amount.",
            "conditions": [
              "safe.borrowedAmount == 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total borrowed amount for a safe.",
            "why_is_is_important": "It ensures that the borrowed amount is consistent with cumulative debt and collateral snapshots.",
            "when_is_it_updated": "When the safe is updated.",
            "how_to_validate_state_update": "Verify that borrowedAmount is updated correctly based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Update borrowed amount based on cumulative debt and collateral snapshots.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total borrowed amount for a given safe.",
            "why_is_is_important": "It helps tracking the total debt for a given safe.",
            "when_is_it_updated": "When collateral is added or debt is repaid.",
            "how_to_validate_state_update": "Verify that totalBorrowedAmount is updated correctly based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount for a given safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral for a given safe.",
            "why_is_is_important": "It helps tracking the collateral for a given safe.",
            "when_is_it_updated": "When collateral is added.",
            "how_to_validate_state_update": "Verify that collateralAmount is updated correctly based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount for a given safe based on cumulative collateral snapshots.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "It helps tracking the total collateral in the system.",
            "when_is_it_updated": "When collateral is added.",
            "how_to_validate_state_update": "Verify that totalCollateral is updated correctly based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the system based on cumulative collateral snapshots.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operational mode of the protocol.",
            "why_is_is_important": "Controls certain protocol behaviors based on the system's overall debt.",
            "when_is_it_updated": "When totalDebt crosses a threshold during debt modifications.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE is changed to NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if totalDebt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt.",
            "why_is_is_important": "It tracks the total debt in the system.",
            "when_is_it_updated": "When borrowed amount is updated.",
            "how_to_validate_state_update": "Check if totalDebt is updated correctly based on delta and add",
            "has_conditional_updates": false,
            "summary_of_update": "Update the total debt.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}