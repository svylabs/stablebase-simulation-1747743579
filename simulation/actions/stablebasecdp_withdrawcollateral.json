{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "The 'safeId' parameter must correspond to an existing Safe owned by the user.",
      "The 'amount' parameter must be a non-zero value and less than or equal to the collateral amount in the Safe (safe.collateralAmount).",
      "If the Safe has a borrowed amount, the 'amount' parameter must be less than or equal to the maximum withdrawal amount that maintains the liquidation ratio. This ratio is calculated as: safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR).",
      "The 'nearestSpotInLiquidationQueue' parameter should be set to 0 if the user does not have any information about the location of safe in liquidation queue. If available it should be set to a valid safeId existing inside of safesOrderedForLiquidation."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral Update",
        "state_update_descriptions": [
          "The collateralAmount of the specified Safe (safes[safeId].collateralAmount) is decreased by the withdrawn amount.",
          "The global totalCollateral is decreased by the withdrawn amount."
        ]
      },
      {
        "category": "Liquidation/Redemption Queue Update",
        "state_update_descriptions": [
          "If the Safe has a borrowed amount, its position in the liquidation queue (safesOrderedForLiquidation) may be updated based on the new collateral ratio.",
          "If the Safe has no borrowed amount, it is removed from both liquidation and redemption queues."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "The contract sends the withdrawn amount of ETH or ERC20 token to the msg.sender (user)."
        ]
      },
      {
        "category": "Safe Update",
        "state_update_descriptions": [
          "The cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral are used to update the borrowedAmount and collateralAmount of the safe.",
          "The liquidationSnapshots[safeId].debtPerCollateralSnapshot and liquidationSnapshots[safeId].collateralPerCollateralSnapshot are updated to cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral",
          "The totalDebt is updated based on debtIncrease using _updateTotalDebt.",
          "The totalCollateral is updated adding collateralIncrease.",
          "The event SafeUpdated is emitted."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral Validation",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be equal to the initial collateralAmount minus the withdrawn amount.",
          "totalCollateral should be equal to the initial totalCollateral minus the withdrawn amount.",
          "safe.collateralAmount should be greater than or equal to 0 after the withdrawal.",
          "totalCollateral should be greater than or equal to 0 after the withdrawal."
        ]
      },
      {
        "category": "Liquidation/Redemption Queue Validation",
        "rule_descriptions": [
          "If the Safe had a borrowed amount before withdrawal, safesOrderedForLiquidation should contain updated order based on new ratio",
          "If the Safe had no borrowed amount, the safeId should no longer exist in safesOrderedForLiquidation and safesOrderedForRedemption.",
          "If Safe has borrowedAmount greater than 0, its position in the liquidation queue should reflect the new collateral ratio, i.e. safesOrderedForLiquidation.getNode(safeId).value == (safe.borrowedAmount * PRECISION) / (safe.collateralAmount)."
        ]
      },
      {
        "category": "Token Balance Validation",
        "rule_descriptions": [
          "The msg.sender (user) token balance should increase by amount."
        ]
      },
      {
        "category": "Safe Validation",
        "rule_descriptions": [
          "The liquidationSnapshots[safeId].debtPerCollateralSnapshot should be updated to cumulativeDebtPerUnitCollateral.",
          "The liquidationSnapshots[safeId].collateralPerCollateralSnapshot should be updated to cumulativeCollateralPerUnitCollateral."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a specific CDP.",
            "why_is_is_important": "Reflects the amount of collateral available in the CDP after withdrawal.",
            "when_is_it_updated": "Always updated when collateral is successfully withdrawn, and the msg.sender.call is successful and safe has collateral.",
            "how_to_validate_state_update": "Check if the collateralAmount of the specific safeId is decreased by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the collateralAmount of the safe.",
            "conditions": [
              "msg.sender.call success",
              "safe.collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral deposited across all CDPs.",
            "why_is_is_important": "Tracks total collateral in the system to ensure proper accounting and liquidation calculations.",
            "when_is_it_updated": "Always updated when collateral is successfully withdrawn, and the msg.sender.call is successful, and safe has collateral.",
            "how_to_validate_state_update": "Verify totalCollateral is reduced by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the totalCollateral.",
            "conditions": [
              "msg.sender.call success",
              "safe.collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the borrowed amount for a given safe, accounting for cumulative debt.",
            "why_is_is_important": "Tracks debt accurately considering cumulative debt changes.",
            "when_is_it_updated": "Updated if cumulativeDebtPerUnitCollateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check if the borrowedAmount of the specific safeId is updated based on cumulative debt per unit collateral",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount based on cumulative debt.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total borrowed amount for a given safe.",
            "why_is_is_important": "Tracks total debt borrowed by safe accurately considering cumulative debt changes.",
            "when_is_it_updated": "Updated if cumulativeDebtPerUnitCollateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Check if the totalBorrowedAmount of the specific safeId is updated based on cumulative debt per unit collateral",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalBorrowedAmount based on cumulative debt.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of cumulative debt per collateral unit at the time of the last update.",
            "why_is_is_important": "Maintains an accurate snapshot of debt per collateral for each safe.",
            "when_is_it_updated": "Updated when the cumulative debt has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify the debtPerCollateralSnapshot is updated to current cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debtPerCollateralSnapshot with current cumulativeDebtPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount for a given safe, accounting for cumulative collateral.",
            "why_is_is_important": "Tracks collateral accurately considering cumulative collateral changes.",
            "when_is_it_updated": "Updated if cumulativeCollateralPerUnitCollateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify collateralAmount is updated based on cumulative collateral per unit collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralAmount based on cumulative collateral.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of cumulative collateral per collateral unit at the time of the last update.",
            "why_is_is_important": "Maintains an accurate snapshot of collateral per collateral for each safe.",
            "when_is_it_updated": "Updated when the cumulative collateral has changed since the last snapshot.",
            "how_to_validate_state_update": "Verify the collateralPerCollateralSnapshot is updated to current cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralPerCollateralSnapshot with current cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral amount.",
            "why_is_is_important": "Tracks the total collateral in the system.",
            "when_is_it_updated": "When cumulative collateral changes.",
            "how_to_validate_state_update": "Verify that the totalCollateral is correctly incremented.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the totalCollateral",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt amount.",
            "why_is_is_important": "Tracks the total debt in the system.",
            "when_is_it_updated": "When cumulative debt changes.",
            "how_to_validate_state_update": "Verify the totalDebt is correctly incremented/decremented",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the totalDebt",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "The operational mode of the protocol.",
            "why_is_is_important": "Switches protocol mode based on total debt.",
            "when_is_it_updated": "When debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check if the debt has increased beyond the threshold, verify PROTOCOL_MODE is NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes PROTOCOL_MODE from BOOTSTRAP to NORMAL.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt amount.",
            "why_is_is_important": "Tracks the total debt in the system.",
            "when_is_it_updated": "Always",
            "how_to_validate_state_update": "Verify that the totalDebt is correctly incremented/decremented",
            "has_conditional_updates": false,
            "summary_of_update": "Increase/decrease the totalDebt",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "address",
            "what_does_it_track": "The order of safes that can be liquidated.",
            "why_is_is_important": "Maintains an accurate queue of safes for liquidation.",
            "when_is_it_updated": "When the borrowed amount is 0.",
            "how_to_validate_state_update": "Check if the safeId is removed from safesOrderedForLiquidation and SafeRemovedFromLiquidationQueue event is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the liquidation queue.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "address",
            "what_does_it_track": "The order of safes that can be redeemed.",
            "why_is_is_important": "Maintains an accurate queue of safes for redemption.",
            "when_is_it_updated": "When the borrowed amount is 0.",
            "how_to_validate_state_update": "Check if the safeId is removed from safesOrderedForRedemption and SafeRemovedFromRedemptionQueue event is emitted.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the redemption queue.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Order of safes based on liquidation ratio",
            "why_is_is_important": "Keeps liquidation queue ordered correctly.",
            "when_is_it_updated": "If safe.borrowedAmount > 0.",
            "how_to_validate_state_update": "Verify that node in liquidation queue is updated with new ratio.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safesOrderedForLiquidation queue.",
            "conditions": [
              "safe.borrowedAmount > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}