{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: User must input the ID of an existing Safe (CDP) from which they want to withdraw collateral. This ID must correspond to a Safe owned by the user.",
      "amount: User must input the amount of collateral they want to withdraw. This amount must be a positive integer and should be less than or equal to the total collateral deposited in the Safe.",
      "nearestSpotInLiquidationQueue: User should provide the ID of a Safe that is near the desired position in the liquidation queue. If unsure, setting this to 0 will make the contract search from the head of the queue."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Collateral",
        "state_update_descriptions": [
          "Updates the Safe's collateral amount by subtracting the withdrawn amount.",
          "Updates the total collateral in the system by subtracting the withdrawn amount."
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "Updates the liquidation queue if the Safe has a borrowed amount. This involves potentially inserting or updating the Safe's position in the queue based on its collateralization ratio."
        ]
      },
      {
        "category": "Queue Removal",
        "state_update_descriptions": [
          "If the Safe has no borrowed amount, it is removed from both the liquidation and redemption queues."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates the `liquidationSnapshots` mapping for the `safeId` to reflect the current `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`.  This ensures accurate debt and collateral tracking for future updates."
        ]
      },
      {
        "category": "Debt and collateral update",
        "state_update_descriptions": [
          "If cumulative debt or collateral have changed since the last snapshot for this safe, update the safe's borrowed amount and collateral amount accordingly.",
          "Update the total borrowed amount and total collateral of the system."
        ]
      },
      {
        "category": "Collateral Transfer",
        "state_update_descriptions": [
          "Transfers the specified amount of collateral (ETH or ERC20 token) to the user who initiated the transaction."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Collateral Balance",
        "rule_descriptions": [
          "Verify that the Safe's collateral amount has decreased by the withdrawn amount.",
          "Check that the total collateral has decreased by the withdrawn amount."
        ]
      },
      {
        "category": "Liquidation Queue State",
        "rule_descriptions": [
          "If the Safe has a borrowed amount, confirm that its position in the liquidation queue has been updated correctly based on the new collateralization ratio.",
          "If the Safe has no borrowed amount after the withdrawal, ensure it has been removed from both liquidation and redemption queues."
        ]
      },
      {
        "category": "Debt and collateral state",
        "rule_descriptions": [
          "If the safe had inactive debt and collateral amounts before the withdrawal, confirm they are properly updated and reflected in the safe's state."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "Confirm the 'WithdrawnCollateral' event is emitted with the correct `safeId`, `amount`, `totalCollateral`, and `totalDebt` values.",
          "If the liquidation queue is updated, confirm the 'LiquidationQueueUpdated' event is emitted with the correct `safeId` and `newRatio` values.",
          "If the safe is removed from the liquidation queue, confirm the 'SafeRemovedFromLiquidationQueue' event is emitted with the correct `safeId`.",
          "If the safe is removed from the redemption queue, confirm the 'SafeRemovedFromRedemptionQueue' event is emitted with the correct `safeId`.",
          "If the safe is updated , confirm the 'SafeUpdated' event is emitted with the correct parameters"
        ]
      },
      {
        "category": "Collateral Transfer Success",
        "rule_descriptions": [
          "Verify that the contract successfully transferred the withdrawn collateral amount to the user who initiated the transaction."
        ]
      },
      {
        "category": "Authorization",
        "rule_descriptions": [
          "Confirm that the Safe owner is msg.sender"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Stores the state of a specific safe, including collateral amount, borrowed amount, weight, total borrowed amount and fee paid.",
            "why_is_is_important": "This retrieves the current state of the safe, which is crucial for determining whether the withdrawal is valid and calculating the maximum permissible withdrawal amount.",
            "when_is_it_updated": "Before any calculations, the safe is retrieved from the `safes` mapping and stored in memory.",
            "how_to_validate_state_update": "Check the Safe's data for correctness using the safeId as an index after state change.",
            "has_conditional_updates": false,
            "summary_of_update": "Fetches the Safe struct from the `safes` mapping using `safeId` for reading Safe's data.",
            "conditions": []
          },
          {
            "state_variable_name": "_updateSafe",
            "type": "function_call",
            "what_does_it_track": "Updates the safe's borrowed amount and collateral amount based on cumulative debt and collateral per unit collateral if liquidation snapshots are outdated.",
            "why_is_is_important": "This function ensures that the borrowed and collateral amounts are up to date before any calculations occur. Failing to update these amounts could lead to incorrect calculations, resulting in either insufficient collateral or incorrect maxWithdrawal.",
            "when_is_it_updated": "Always, before any calculation related to withdrawing collateral",
            "how_to_validate_state_update": "Check that the collateralAmount and borrowedAmount in the safes mapping for the given safeId have been updated correctly after calling _updateSafe, considering the liquidation snapshot values.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's state including `borrowedAmount` and `collateralAmount` if cumulative snapshots have changed since the last update, ensuring accrued debt and collateral are accounted for.",
            "conditions": [
              "The LiquidationSnapshot's collateralPerCollateralSnapshot is not equal to the cumulativeCollateralPerUnitCollateral.",
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safe.collateralAmount > 0",
            "type": "require",
            "what_does_it_track": "A boolean value to verify that the safe contains collateral before attempting to withdraw.",
            "why_is_is_important": "It is not possible to withdraw if there is no collateral.",
            "when_is_it_updated": "This require is always triggered when there is no collateral to withdraw.",
            "how_to_validate_state_update": "Check if the `safe.collateralAmount > 0` before withdrawing the amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Verifies that the safe has a collateral amount greater than zero.",
            "conditions": []
          },
          {
            "state_variable_name": "amount <= maxWithdrawal",
            "type": "require",
            "what_does_it_track": "A boolean value to verify that the amount to withdraw is less than or equal to maxWithdrawal amount.",
            "why_is_is_important": "This check prevents withdrawing more collateral than is allowed, ensuring that the CDP remains adequately collateralized and not under the required liquidation ratio.",
            "when_is_it_updated": "When the safe.borrowedAmount is greater than 0",
            "how_to_validate_state_update": "Calculate the `maxWithdrawal` and verify that the withdrawn `amount` is less than or equal to `maxWithdrawal`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `amount` withdrawn must be less than or equal to `maxWithdrawal`. Otherwise, collateral withdrawal is insufficient.",
            "conditions": [
              "safe.borrowedAmount > 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.upsert",
            "type": "function_call",
            "what_does_it_track": "It will update the state of linked list, by updating the node or inserting new node.",
            "why_is_is_important": "This maintains the correct ordering of safes in the liquidation queue based on their collateralization ratio. By updating the position, the protocol can efficiently identify and liquidate undercollateralized safes, maintaining system solvency.",
            "when_is_it_updated": "when the safe.borrowedAmount > 0",
            "how_to_validate_state_update": "Check that the position of the safe in the `safesOrderedForLiquidation` queue is updated correctly based on the new collateralization ratio. Also, verify that the previous and next node pointers are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "When `borrowedAmount` is greater than 0, it calls the `upsert` function to update the Liquidation Queue.",
            "conditions": [
              "safe.borrowedAmount > 0"
            ]
          },
          {
            "state_variable_name": "amount <= safe.collateralAmount",
            "type": "require",
            "what_does_it_track": "A boolean value to verify that the amount to withdraw is less than or equal to safe.collateralAmount",
            "why_is_is_important": "It prevents withdrawing more collateral than deposited if the user has no debt.",
            "when_is_it_updated": "When the safe.borrowedAmount is equal to 0",
            "how_to_validate_state_update": "Check that amount is less than or equal to the existing collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "When the safe has no debt (borrowedAmount == 0), it checks that the amount to withdraw is less than or equal to the existing collateral",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "_removeSafeFromBothQueues",
            "type": "function_call",
            "what_does_it_track": "Removes the safe from the Liquidation Queue and Redemption Queue",
            "why_is_is_important": "If a safe has no borrowed amount, it doesn't need to be tracked in either queue, so removing it reduces unnecessary overhead.",
            "when_is_it_updated": "When safe.borrowedAmount equals 0",
            "how_to_validate_state_update": "Check that the safe is no longer present in both the `safesOrderedForLiquidation` and `safesOrderedForRedemption` queues after calling `_removeSafeFromBothQueues`.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from both liquidation and redemption queues if the safe has no borrowed amount.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safe.collateralAmount",
            "type": "update",
            "what_does_it_track": "It will update the safe's collateral amount",
            "why_is_is_important": "Reflects the change in the user's collateral balance within the safe.  It correctly represents the actual collateral held within the Safe after the withdrawal.",
            "when_is_it_updated": "Always, if it passes all the require statements",
            "how_to_validate_state_update": "Verify the `safe.collateralAmount` is decreased by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Reduces the safe's collateral amount by the withdrawn amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "update",
            "what_does_it_track": "Tracks the total collateral in the protocol.",
            "why_is_is_important": "This is crucial for the overall health and solvency of the protocol. `totalCollateral` is important for calculating global collateralization ratios and assessing system risk.",
            "when_is_it_updated": "Always, if it passes all the require statements",
            "how_to_validate_state_update": "Verify that the `totalCollateral` is decreased by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total collateral by the withdrawn amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "update",
            "what_does_it_track": "Updates the total debt of the protocol.",
            "why_is_is_important": "Accurately reflects the total debt, critical for assessing protocol solvency and stability.",
            "when_is_it_updated": "When the borrowed amount changes and potentially crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "how_to_validate_state_update": "Check that `totalDebt` is correctly updated based on the debt increase or decrease, and verify `PROTOCOL_MODE` changes if `BOOTSTRAP_MODE_DEBT_THRESHOLD` is crossed.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `totalDebt` based on borrowing or repayment, and adjusts `PROTOCOL_MODE` if the `BOOTSTRAP_MODE_DEBT_THRESHOLD` is crossed.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "update",
            "what_does_it_track": "Updates the protocol mode based on the total debt.",
            "why_is_is_important": "Controls the protocol's operating mode, affecting fee structures and other parameters.",
            "when_is_it_updated": "When the total debt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Verify that the `PROTOCOL_MODE` changes from `BOOTSTRAP` to `NORMAL` when `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the `PROTOCOL_MODE` from `BOOTSTRAP` to `NORMAL` if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "success",
            "type": "require",
            "what_does_it_track": "Verifies the success of the transfer to msg.sender.",
            "why_is_is_important": "Ensures that the collateral is successfully transferred to the user, preventing loss of funds.",
            "when_is_it_updated": "After attempting to transfer collateral to the user.",
            "how_to_validate_state_update": "Check that the `success` boolean is true after calling `msg.sender.call{value: amount}(\"\")`.",
            "has_conditional_updates": false,
            "summary_of_update": "Requires that the transfer of collateral to the user is successful.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForLiquidation.upsert",
            "type": "function_call",
            "what_does_it_track": "Updates the position of the safe in the linked list.",
            "why_is_is_important": "The `upsert` function maintains the correct ordering of safes in the liquidation queue, allowing for efficient identification of safes that are close to or have breached their liquidation threshold.",
            "when_is_it_updated": "When safe.borrowedAmount is greater than 0",
            "how_to_validate_state_update": "Check that the `upsert` function correctly updates the safe's position in the `safesOrderedForLiquidation` queue based on the new collateralization ratio, ensuring that the queue remains properly ordered.",
            "has_conditional_updates": true,
            "summary_of_update": "When the safe's borrowedAmount is greater than 0, the `upsert` function is called to update or insert the safe's node in the liquidation queue based on the calculated `_newRatio`.",
            "conditions": [
              "safe.borrowedAmount > 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.remove",
            "type": "function_call",
            "what_does_it_track": "Removes the safe from the linked list.",
            "why_is_is_important": "If a safe has no debt (borrowedAmount is 0), it should not be in the liquidation queue. Removing it ensures that only relevant safes are tracked for liquidation, reducing overhead.",
            "when_is_it_updated": "When safe.borrowedAmount equals 0",
            "how_to_validate_state_update": "Check that the safe is no longer present in the `safesOrderedForLiquidation` queue after calling `remove`.  Verify the `nodes` mapping no longer contains an entry for the `safeId` within the queue's storage.",
            "has_conditional_updates": true,
            "summary_of_update": "When `borrowedAmount` is 0, the `remove` function is called to remove the safe from the liquidation queue.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.remove",
            "type": "function_call",
            "what_does_it_track": "Removes the safe from the linked list.",
            "why_is_is_important": "If a safe has no debt (borrowedAmount is 0), it should not be in the redemption queue. Removing it ensures that only relevant safes are tracked for redemption, reducing overhead.",
            "when_is_it_updated": "When safe.borrowedAmount equals 0",
            "how_to_validate_state_update": "Check that the safe is no longer present in the `safesOrderedForRedemption` queue after calling `remove`. Verify the `nodes` mapping no longer contains an entry for the `safeId` within the queue's storage.",
            "has_conditional_updates": true,
            "summary_of_update": "When `borrowedAmount` is 0, the `remove` function is called to remove the safe from the redemption queue.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}