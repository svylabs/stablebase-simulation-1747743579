{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: This should be the ID of the safe from which the collateral (ETH or the managed ERC20 token) is to be withdrawn. Ensure the safeId exists and is owned by the caller.",
      "amount: This is the amount of collateral to withdraw. It must be a non-zero value and less than or equal to the total collateral deposited in the safe. If the safe has a borrowed amount, the withdrawal must also satisfy the liquidation ratio condition.",
      "nearestSpotInLiquidationQueue: This parameter is used to optimize the updating of the liquidation queue. A reasonable default value is 0, which will cause the contract to search the queue from the head. Otherwise, it should be an existing safeId from the liquidation queue, ideally near the expected position of the safe being modified."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId].collateralAmount is decreased by amount.",
          "If the safe has associated debt, its position in the liquidation queue, safesOrderedForLiquidation, may be updated.  A LiquidationQueueUpdated event is emitted.",
          "If the safe has no borrowed amount, it will be removed from both liquidation and redemption queues. SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events are emitted.",
          "The Safe struct itself (safes[safeId]) is updated via the _updateSafe internal function which adjusts the borrowedAmount and collateralAmount based on cumulative debt and collateral per unit collateral.",
          "The SafeUpdated event is emitted with the updated values."
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "state_update_descriptions": [
          "totalCollateral is decreased by amount.",
          "totalDebt may be updated in _updateSafe if cumulative debt or collateral has changed since the last snapshot."
        ]
      },
      {
        "category": "Contract Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE may transition from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD in _updateTotalDebt."
        ]
      },
      {
        "category": "Accounting",
        "state_update_descriptions": [
          "The msg.sender will receive the withdrawn collateral (ETH or the managed ERC20 token)."
        ]
      },
      {
        "category": "Liquidation Snapshots",
        "state_update_descriptions": [
          "liquidationSnapshots[_safeId] is updated with cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral if there were updates to borrowedAmount or collateralAmount"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be equal to the initial collateral amount minus the withdrawn amount, accounting for any debt or collateral updates via _updateSafe.",
          "If safe.borrowedAmount > 0, the liquidation ratio (safe.borrowedAmount * PRECISION) / (safe.collateralAmount * price * BASIS_POINTS_DIVISOR) should still be less than or equal to the liquidationRatio.",
          "If safe.borrowedAmount is 0, safesOrderedForLiquidation should not contain the safeId.",
          "If safe.borrowedAmount is 0, safesOrderedForRedemption should not contain the safeId.",
          "The _updateSafe function ensures that inactive debt and collateral are synchronized."
        ]
      },
      {
        "category": "Total Collateral and Debt",
        "rule_descriptions": [
          "totalCollateral should be decreased by the withdrawn amount.",
          "totalDebt should reflect any changes made during the _updateSafe function."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A WithdrawnCollateral event should be emitted with the correct safeId, amount, totalCollateral, and totalDebt.",
          "A LiquidationQueueUpdated event should be emitted if the safe's position in the liquidation queue has changed.",
          "SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events should be emitted if there was no borrowed amount."
        ]
      },
      {
        "category": "Balance",
        "rule_descriptions": [
          "The msg.sender ETH or managed ERC20 token balance should increase by the withdrawn amount. This needs to be validated off-chain."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "mapping",
            "what_does_it_track": "Information about each safe (CDP), including collateral amount, borrowed amount, etc.",
            "why_is_is_important": "This reflects the actual collateral held by the safe after the withdrawal, and is crucial for calculating liquidation risk.",
            "when_is_it_updated": "When collateral is withdrawn, the collateralAmount is decreased by the amount withdrawn.  If there's a borrowed amount, the safe may be added/updated in the liquidation queue.",
            "how_to_validate_state_update": "Check that the safe's collateralAmount is reduced by the withdrawn amount.  Also check the liquidation queue to verify correct placement/update.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount of a specific safe (identified by safeId) is reduced by the amount withdrawn.",
            "conditions": [
              "safe.collateralAmount > 0",
              "amount <= maxWithdrawal (if safe.borrowedAmount > 0)",
              "amount <= safe.collateralAmount (if safe.borrowedAmount == 0)"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "variable",
            "what_does_it_track": "Total collateral across all safes.",
            "why_is_is_important": "This provides a global view of the system's collateralization and is important for overall system health monitoring.",
            "when_is_it_updated": "When collateral is withdrawn, totalCollateral is decreased by the amount withdrawn.",
            "how_to_validate_state_update": "Verify that totalCollateral is reduced by the withdrawn amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The total collateral is reduced by the amount withdrawn.",
            "conditions": []
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "variable_snapshot",
            "what_does_it_track": "Snapshot of debt.",
            "why_is_is_important": "Snapshot of debt.",
            "when_is_it_updated": "The snapshot is updated when cumulativeCollateralPerUnitCollateral != liquidationSnapshot.collateralPerCollateralSnapshot.",
            "how_to_validate_state_update": "Validate the  cumulativeDebtPerUnitCollateral is tracked in the snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "cumulativeDebtPerUnitCollateral is tracked in the snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "variable_snapshot",
            "what_does_it_track": "Snapshot of collateral.",
            "why_is_is_important": "Tracks collateral for correct collateral calculations.",
            "when_is_it_updated": "The snapshot is updated when cumulativeCollateralPerUnitCollateral != liquidationSnapshot.collateralPerCollateralSnapshot",
            "how_to_validate_state_update": "cumulativeCollateralPerUnitCollateral is tracked in the snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "cumulativeCollateralPerUnitCollateral is tracked in the snapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "variable",
            "what_does_it_track": "Cumulative debt per collateral",
            "why_is_is_important": "Cumulative debt per collateral",
            "when_is_it_updated": "totalDebt updates when collateral snapshot is updated and debt increases",
            "how_to_validate_state_update": "Validate totalDebt has increased by debtIncrease",
            "has_conditional_updates": true,
            "summary_of_update": "Total debt is updated to account for increases in debt when collateral snapshots are updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "variable",
            "what_does_it_track": "PROTOCOL_MODE",
            "why_is_is_important": "System functionality changes during Bootstrap and Normal Modes.",
            "when_is_it_updated": "PROTOCOL_MODE is updated to NORMAL when debt passes a threshold",
            "how_to_validate_state_update": "PROTOCOL_MODE == SBStructs.Mode.NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "PROTOCOL_MODE updated to NORMAL when debt threshold passed.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation and safesOrderedForRedemption",
            "type": "queue_removal",
            "what_does_it_track": "The state of both queues.",
            "why_is_is_important": "The state of both queues.",
            "when_is_it_updated": "When the safe has no borrowed amount, it's removed from both queues.",
            "how_to_validate_state_update": "Verify that if the safe has no borrowed amount, the safe is removed from both the liquidation and redemption queues.",
            "has_conditional_updates": true,
            "summary_of_update": "The safe is removed from both the liquidation and redemption queues if it has no borrowed amount.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "mapping",
            "what_does_it_track": "Amount borrowed per safe.",
            "why_is_is_important": "Must be accurate to correctly assess debt.",
            "when_is_it_updated": "When the safe's snapshot is updated.  borrowedAmount is updated if cumulativeDebtPerUnitCollateral is not equal to liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "how_to_validate_state_update": "Check the safe's borrowedAmount has been updated if applicable",
            "has_conditional_updates": true,
            "summary_of_update": "borrowedAmount updated",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "mapping",
            "what_does_it_track": "totalBorrowedAmount per safe.",
            "why_is_is_important": "Tracks total amount borrowed by safe.",
            "when_is_it_updated": "When the safe's snapshot is updated. totalBorrowedAmount is updated if cumulativeDebtPerUnitCollateral is not equal to liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "how_to_validate_state_update": "Check the safe's totalBorrowedAmount has been updated if applicable",
            "has_conditional_updates": true,
            "summary_of_update": "totalBorrowedAmount updated",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "mapping",
            "what_does_it_track": "Collateral amount per safe.",
            "why_is_is_important": "Track collateral amount for safe.",
            "when_is_it_updated": "When the safe's snapshot is updated. collateralAmount is updated if cumulativeCollateralPerUnitCollateral is not equal to liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "how_to_validate_state_update": "Check the safe's collateralAmount has been updated if applicable",
            "has_conditional_updates": true,
            "summary_of_update": "collateralAmount updated",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId]",
            "type": "mapping",
            "what_does_it_track": "liquidationSnapshots.",
            "why_is_is_important": "Track liquidationSnapshots.",
            "when_is_it_updated": "When the safe's snapshot is updated. collateralAmount is updated if cumulativeCollateralPerUnitCollateral is not equal to liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "how_to_validate_state_update": "Check the liquidationSnapshots for safe has been updated if applicable",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshots updated",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "queue_removal",
            "what_does_it_track": "Redemption queue.",
            "why_is_is_important": "Safes with no borrowed amounts should not exist in the redemption queue.",
            "when_is_it_updated": "When the safe has no borrowed amount, it is removed from the redemption queue.",
            "how_to_validate_state_update": "Verify safe is removed from safesOrderedForRedemption",
            "has_conditional_updates": true,
            "summary_of_update": "safe removed from safesOrderedForRedemption",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "queue_removal",
            "what_does_it_track": "Liquidation queue.",
            "why_is_is_important": "Safes with no borrowed amounts should not exist in the liquidation queue.",
            "when_is_it_updated": "When the safe has no borrowed amount, it is removed from the liquidation queue.",
            "how_to_validate_state_update": "Verify safe is removed from safesOrderedForLiquidation",
            "has_conditional_updates": true,
            "summary_of_update": "safe removed from safesOrderedForLiquidation",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "mapping",
            "what_does_it_track": "Stores the nodes in the liquidation queue.",
            "why_is_is_important": "The liquidation queue is essential for identifying safes that are at risk of liquidation, ensuring the stability of the system.",
            "when_is_it_updated": "If the safe has a borrowed amount, the safe might need to be added to the liquidation queue based on its liquidation ratio. If the safe has no borrowed amount, it is removed from the liquidation queue.",
            "how_to_validate_state_update": "Check if the safe's id is in the liquidation queue, and its value (liquidation ratio) is correct.",
            "has_conditional_updates": true,
            "summary_of_update": "Safes are added, updated, or removed in the liquidation queue based on their borrowed amount, collateral, and liquidation ratio.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}