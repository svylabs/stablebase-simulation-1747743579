{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "'safeId' must correspond to an existing Safe that is currently owned by the transaction sender ('msg.sender').",
      "'amount' must be a positive integer greater than 0.",
      "The 'amount' must be less than or equal to the current collateral amount of the Safe ('safe.collateralAmount') after any potential internal updates from '_updateSafe'.",
      "If the Safe has an outstanding borrowed amount ('safe.borrowedAmount > 0') after '_updateSafe', the 'amount' to be withdrawn must ensure that the Safe's collateralization ratio remains above the liquidation threshold. Specifically, 'amount' must be less than or equal to 'safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR)', where 'price' is fetched from the 'priceOracle.fetchPrice()'.",
      "'nearestSpotInLiquidationQueue' is an optional parameter that can be 0 or a 'safeId' that is currently present in the 'safesOrderedForLiquidation' linked list. It assists in optimizing the insertion/update logic within the linked list; if 0, the linked list's internal logic will determine the insertion point, usually starting from the head."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "StableBaseCDP Contract State Updates",
        "state_update_descriptions": [
          "The 'collateralAmount' of the 'Safe' identified by 'safeId' will decrease by the 'amount' specified.",
          "The global 'totalCollateral' variable in the StableBaseCDP contract will decrease by the 'amount' specified.",
          "If the 'liquidationSnapshot.collateralPerCollateralSnapshot' for the 'safeId' is not equal to 'cumulativeCollateralPerUnitCollateral' prior to the call, the internal '_updateSafe' function will be triggered. This will potentially increase 'safe.borrowedAmount', 'safe.totalBorrowedAmount', 'safe.collateralAmount', 'totalCollateral', and 'totalDebt' due to accumulated interest/collateral increases.",
          "The 'liquidationSnapshot.collateralPerCollateralSnapshot' for the 'safeId' will be updated to the current 'cumulativeCollateralPerUnitCollateral' if '_updateSafe' is triggered.",
          "The 'liquidationSnapshot.debtPerCollateralSnapshot' for the 'safeId' will be updated to the current 'cumulativeDebtPerUnitCollateral' if '_updateSafe' is triggered.",
          "The 'PROTOCOL_MODE' might transition from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD' after any debt increase caused by '_updateSafe'."
        ]
      },
      {
        "category": "Ordered Doubly Linked List Updates",
        "state_update_descriptions": [
          "If the 'Safe' identified by 'safeId' has an outstanding 'borrowedAmount' greater than 0, its position in the 'safesOrderedForLiquidation' linked list will be updated or re-inserted based on its new collateralization ratio.",
          "If the 'Safe' identified by 'safeId' has a 'borrowedAmount' equal to 0, it will be removed from both the 'safesOrderedForLiquidation' and 'safesOrderedForRedemption' linked lists."
        ]
      },
      {
        "category": "External Transfers",
        "state_update_descriptions": [
          "An 'amount' of native currency (ETH) will be transferred from the StableBaseCDP contract's balance to the caller ('msg.sender')."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "State Assertions",
        "rule_descriptions": [
          "Verify that the native currency balance of the caller ('msg.sender') has increased by the 'amount' of collateral withdrawn.",
          "Verify that 'safes[safeId].collateralAmount' has decreased by the 'amount' initially specified for withdrawal, taking into account any potential adjustments made by the '_updateSafe' function.",
          "Verify that 'totalCollateral' has decreased by the 'amount' initially specified for withdrawal, taking into account any potential adjustments made by the '_updateSafe' function.",
          "If the '_updateSafe' function was executed (i.e., 'liquidationSnapshots[safeId].collateralPerCollateralSnapshot' was not equal to 'cumulativeCollateralPerUnitCollateral' before the transaction), verify that 'safes[safeId].borrowedAmount' and 'safes[safeId].totalBorrowedAmount' reflect the calculated 'debtIncrease'.",
          "If '_updateSafe' was executed, verify that 'liquidationSnapshots[safeId].collateralPerCollateralSnapshot' is updated to the current 'cumulativeCollateralPerUnitCollateral'.",
          "If '_updateSafe' was executed, verify that 'liquidationSnapshots[safeId].debtPerCollateralSnapshot' is updated to the current 'cumulativeDebtPerUnitCollateral'.",
          "If '_updateSafe' was executed, verify that 'totalDebt' is updated correctly based on the 'debtIncrease'.",
          "If 'safe.borrowedAmount' was greater than 0 before the withdrawal, verify that the 'safeId' is correctly positioned in the 'safesOrderedForLiquidation' linked list according to its new collateralization ratio.",
          "If 'safe.borrowedAmount' was 0 before the withdrawal, verify that the 'safeId' is no longer present in the 'safesOrderedForLiquidation' and 'safesOrderedForRedemption' linked lists."
        ]
      },
      {
        "category": "Event Emissions",
        "rule_descriptions": [
          "Verify that a 'WithdrawnCollateral' event was emitted with the correct 'safeId', 'amount', the final 'totalCollateral', and 'totalDebt'.",
          "If the 'safe.borrowedAmount' was greater than 0 before the withdrawal, verify that a 'LiquidationQueueUpdated' event was emitted with the correct 'safeId', the calculated '_newRatio', and the 'node.next' value from the upsert operation.",
          "If the 'safe.borrowedAmount' was 0 before the withdrawal, verify that a 'SafeRemovedFromLiquidationQueue' event was emitted with the correct 'safeId'.",
          "If the 'safe.borrowedAmount' was 0 before the withdrawal, verify that a 'SafeRemovedFromRedemptionQueue' event was emitted with the correct 'safeId'.",
          "If the '_updateSafe' function was executed, verify that a 'SafeUpdated' event was emitted with the correct 'safeId', updated 'collateralAmount', 'debtAmount', 'collateralIncrease', 'debtIncrease', 'totalCollateral', and 'totalDebt'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral (e.g., ETH) held in a particular CDP (Safe).",
            "why_is_is_important": "It reflects the user's current collateral holdings in their CDP, directly impacting their collateralization ratio and ability to withdraw or borrow.",
            "when_is_it_updated": "At the beginning of the transaction via `_updateSafe` (for system-wide adjustments) and then immediately after conditional logic in `withdrawCollateral` (for the actual withdrawal amount).",
            "how_to_validate_state_update": "Verify that safe.collateralAmount is increased by the calculated collateral increase based on the difference in cumulativeCollateralPerUnitCollateral since the last snapshot, and then immediately decreased by the amount withdrawn.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount for the specific Safe is first potentially increased to account for system-wide collateral adjustments (via an internal update mechanism), and then directly decreased by the amount of collateral withdrawn by the user.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of stablecoin borrowed against the Safe's collateral that is currently active.",
            "why_is_is_important": "It represents the user's outstanding debt against their CDP, crucial for calculating the collateralization ratio and liquidation risk.",
            "when_is_it_updated": "At the beginning of the transaction via the `_updateSafe` function.",
            "how_to_validate_state_update": "Verify that safe.borrowedAmount is increased by the calculated debt increase based on the difference in cumulativeDebtPerUnitCollateral since the last snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount for the specific Safe is potentially increased to account for system-wide debt accrual (interest) since the last time the Safe was updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount of stablecoin ever borrowed against the Safe, including accrued debt.",
            "why_is_is_important": "It tracks the cumulative debt associated with a Safe, providing a historical record and potentially used for fee calculations or other internal accounting.",
            "when_is_it_updated": "At the beginning of the transaction via the `_updateSafe` function.",
            "how_to_validate_state_update": "Verify that safe.totalBorrowedAmount is increased by the calculated debt increase, mirroring the update to safe.borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total borrowed amount for the specific Safe is potentially increased to account for system-wide debt accrual (interest) since the last time the Safe was updated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The cumulative debt per unit of collateral at the last time the Safe's debt was updated.",
            "why_is_is_important": "It is used to calculate the accrued debt on a Safe since its last update, ensuring that each Safe reflects its fair share of system-wide debt.",
            "when_is_it_updated": "At the beginning of the transaction via the `_updateSafe` function, after calculating any accrued debt.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to the current cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the cumulative debt per unit collateral for the specific Safe is updated to the current system-wide cumulative debt per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The cumulative collateral per unit of collateral at the last time the Safe's collateral was updated.",
            "why_is_is_important": "It is used to calculate the accrued collateral on a Safe since its last update, ensuring that each Safe reflects its fair share of system-wide collateral adjustments.",
            "when_is_it_updated": "At the beginning of the transaction via the `_updateSafe` function, after calculating any collateral gains.",
            "how_to_validate_state_update": "Verify that liquidationSnapshots[safeId].collateralPerCollateralSnapshot is updated to the current cumulativeCollateralPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the cumulative collateral per unit collateral for the specific Safe is updated to the current system-wide cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held across all active CDPs (Safes) in the system.",
            "why_is_is_important": "It represents the total collateral backing the system's stablecoin, impacting the overall health and stability of the protocol.",
            "when_is_it_updated": "At the beginning of the transaction via `_updateSafe` (for system adjustments) and then immediately after conditional logic in `withdrawCollateral` (for the direct withdrawal).",
            "how_to_validate_state_update": "Verify that totalCollateral is increased by the calculated collateral increase (from _updateSafe) and then decreased by the 'amount' withdrawn.",
            "has_conditional_updates": true,
            "summary_of_update": "The total amount of collateral locked in the system is first potentially increased due to system-wide adjustments (via `_updateSafe`), and then definitively decreased by the amount of collateral withdrawn from the specific Safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The sum of all stablecoin debt across all active CDPs (Safes) in the system.",
            "why_is_is_important": "It represents the total stablecoin supply backed by collateral, a critical metric for the protocol's solvency and stablecoin peg.",
            "when_is_it_updated": "At the beginning of the transaction via the `_updateSafe` function, which calls `_updateTotalDebt`.",
            "how_to_validate_state_update": "Verify that totalDebt is increased by the calculated debt increase from _updateSafe.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt in the system is potentially increased to account for system-wide debt accrual (interest) calculated during the `_updateSafe` call.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "debtIncrease > 0 (within _updateTotalDebt)"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "string",
            "what_does_it_track": "The current operating mode of the protocol (e.g., BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Different protocol modes may imply different fee structures, liquidation mechanisms, or other operational parameters, affecting user behavior and system stability.",
            "when_is_it_updated": "Within the `_updateTotalDebt` function, which is called by `_updateSafe` at the beginning of the transaction.",
            "how_to_validate_state_update": "Verify that if the total debt exceeds the threshold and the protocol is in BOOTSTRAP mode, it transitions to NORMAL mode.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol's operating mode can transition from `BOOTSTRAP` to `NORMAL` if the `totalDebt` in the system exceeds a predefined threshold.",
            "conditions": [
              "totalDebt (after potential increase) > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForLiquidation.nodes[id]",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "The individual nodes (Safe ID, value/ratio, prev/next pointers) within the ordered doubly linked list used for liquidation.",
            "why_is_is_important": "It maintains the ordered list of Safes by their collateralization ratio, crucial for efficient liquidation processes.",
            "when_is_it_updated": "Conditionally after the `_updateSafe` call, based on the `safe.borrowedAmount` value.",
            "how_to_validate_state_update": "If safe.borrowedAmount > 0, verify the safeId's node is correctly inserted/updated in the ordered list based on _newRatio. If safe.borrowedAmount == 0, verify the safeId's node is removed.",
            "has_conditional_updates": true,
            "summary_of_update": "A node representing the Safe in the liquidation queue (which stores the Safe ID and its collateral-to-debt ratio) is either updated/inserted or removed, depending on whether the Safe still has borrowed debt after the withdrawal.",
            "conditions": [
              "safe.borrowedAmount > 0 (for upsert)",
              "safe.borrowedAmount == 0 (for remove)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node (Safe) in the `safesOrderedForLiquidation` linked list.",
            "why_is_is_important": "It serves as the entry point for iterating through the liquidation queue, typically to find Safes with the lowest collateralization ratios.",
            "when_is_it_updated": "Conditionally during the `upsert` or `remove` operations on `safesOrderedForLiquidation`.",
            "how_to_validate_state_update": "Verify that the head pointer correctly reflects the new first element in the liquidation queue, if any change occurred to the list's beginning.",
            "has_conditional_updates": true,
            "summary_of_update": "The pointer to the head of the liquidation queue is updated if the insertion or removal of the Safe's node changes the first element in the ordered list.",
            "conditions": [
              "safe.borrowedAmount > 0 (leading to upsert and potential head change)",
              "safe.borrowedAmount == 0 (leading to remove and potential head change)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation.tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node (Safe) in the `safesOrderedForLiquidation` linked list.",
            "why_is_is_important": "It serves as an entry point for iterating through the liquidation queue in reverse, or quickly accessing the highest collateralization ratio Safes.",
            "when_is_it_updated": "Conditionally during the `upsert` or `remove` operations on `safesOrderedForLiquidation`.",
            "how_to_validate_state_update": "Verify that the tail pointer correctly reflects the new last element in the liquidation queue, if any change occurred to the list's end.",
            "has_conditional_updates": true,
            "summary_of_update": "The pointer to the tail of the liquidation queue is updated if the insertion or removal of the Safe's node changes the last element in the ordered list.",
            "conditions": [
              "safe.borrowedAmount > 0 (leading to upsert and potential tail change)",
              "safe.borrowedAmount == 0 (leading to remove and potential tail change)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.nodes[id]",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "The individual nodes (Safe ID, value/weight, prev/next pointers) within the ordered doubly linked list used for redemption.",
            "why_is_is_important": "It maintains the ordered list of Safes for redemption, allowing for efficient allocation of liquidated collateral.",
            "when_is_it_updated": "Conditionally after the `_updateSafe` call, if `safe.borrowedAmount` is 0.",
            "how_to_validate_state_update": "If safe.borrowedAmount == 0, verify the safeId's node is removed from the redemption queue.",
            "has_conditional_updates": true,
            "summary_of_update": "The node representing the Safe in the redemption queue is removed if the Safe no longer has any borrowed debt after the collateral withdrawal.",
            "conditions": [
              "safe.borrowedAmount == 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.head",
            "type": "uint256",
            "what_does_it_track": "The ID of the first node (Safe) in the `safesOrderedForRedemption` linked list.",
            "why_is_is_important": "It serves as the entry point for iterating through the redemption queue.",
            "when_is_it_updated": "Conditionally during the `remove` operation on `safesOrderedForRedemption`.",
            "how_to_validate_state_update": "Verify that the head pointer correctly reflects the new first element in the redemption queue, if the removed node was the head.",
            "has_conditional_updates": true,
            "summary_of_update": "The pointer to the head of the redemption queue is updated if the removal of the Safe's node changes the first element in the ordered list.",
            "conditions": [
              "safe.borrowedAmount == 0 (leading to remove and potential head change)"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the last node (Safe) in the `safesOrderedForRedemption` linked list.",
            "why_is_is_important": "It serves as an entry point for iterating through the redemption queue in reverse.",
            "when_is_it_updated": "Conditionally during the `remove` operation on `safesOrderedForRedemption`.",
            "how_to_validate_state_update": "Verify that the tail pointer correctly reflects the new last element in the redemption queue, if the removed node was the tail.",
            "has_conditional_updates": true,
            "summary_of_update": "The pointer to the tail of the redemption queue is updated if the removal of the Safe's node changes the last element in the ordered list.",
            "conditions": [
              "safe.borrowedAmount == 0 (leading to remove and potential tail change)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}