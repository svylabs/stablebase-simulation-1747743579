{
  "action": {
    "name": "Withdraw Collateral",
    "summary": "Withdraws collateral from a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "probability": 0.5
  },
  "action_detail": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId that exists in the safes mapping.",
      "amount: A value greater than zero and less than or equal to the safe's collateralAmount.",
      "amount: If borrowedAmount > 0, the amount must be less than or equal to maxWithdrawal, calculated as safe.collateralAmount - (safe.borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR).",
      "nearestSpotInLiquidationQueue: A valid safeId that is near to the safeId being updated in the liquidation queue. Can be zero if the queue is empty or the position is not relevant.",
      "The msg.sender must be the owner of the Safe identified by safeId."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "The collateralAmount of the Safe identified by safeId is decreased by the amount withdrawn.",
          "If the borrowedAmount is greater than zero, the liquidation ratio of the Safe will be updated and the Safe's position in the liquidation queue may change. This is reflected in the LiquidationQueueUpdated event.",
          "If borrowedAmount is zero, the Safe is removed from both liquidation and redemption queues."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "The totalCollateral is decreased by the amount withdrawn."
        ]
      },
      {
        "category": "Event Emission",
        "state_update_descriptions": [
          "A WithdrawnCollateral event is emitted, containing the safeId, the amount withdrawn, the updated totalCollateral, and the totalDebt."
        ]
      },
      {
        "category": "Debt Update",
        "state_update_descriptions": [
          "The _updateSafe function may update the borrowed amount of a safe based on cumulative debt and collateral per unit collateral, impacting liquidation snapshots."
        ]
      },
      {
        "category": "Total Debt Update",
        "state_update_descriptions": [
          "The _updateTotalDebt function will update the total debt if necessary"
        ]
      },
      {
        "category": "Liquidation Queue",
        "state_update_descriptions": [
          "The LiquidationQueueUpdated event is emitted if the safe's liquidation ratio has changed."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "The SafeRemovedFromRedemptionQueue event is emitted if the safe has been removed from the redemption queue."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].collateralAmount should be equal to the previous collateralAmount minus the amount withdrawn.",
          "If borrowedAmount > 0, the liquidation ratio (borrowedAmount * liquidationRatio * PRECISION) / (price * BASIS_POINTS_DIVISOR) should be <= safes[safeId].collateralAmount.",
          "If borrowedAmount == 0, safes[safeId].collateralAmount should be less than or equal to the initial collateralAmount prior to withdrawal.",
          "If borrowedAmount == 0, safe should be removed from liquidation queue.",
          "If borrowedAmount == 0, safe should be removed from redemption queue."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "totalCollateral should be equal to the previous totalCollateral minus the amount withdrawn."
        ]
      },
      {
        "category": "Balance",
        "rule_descriptions": [
          "The msg.sender's ETH balance should increase by the amount withdrawn."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Withdraw Collateral",
    "contract_name": "StableBaseCDP",
    "function_name": "withdrawCollateral",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral deposited in a specific safe.",
            "why_is_is_important": "Reflects the actual collateral amount available for the safe, impacting liquidation ratio and withdrawal limits.",
            "when_is_it_updated": "When collateral is withdrawn from a safe.",
            "how_to_validate_state_update": "Check if safe.collateralAmount is decreased by amount. Verify WithdrawnCollateral event.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the collateral amount of a specific safe.",
            "conditions": [
              "safe.collateralAmount > 0"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral held across all safes.",
            "why_is_is_important": "Provides a global view of the collateralization of the system and impacts system-wide risk parameters.",
            "when_is_it_updated": "When collateral is withdrawn from any safe.",
            "how_to_validate_state_update": "Check if totalCollateral is decreased by amount. Verify WithdrawnCollateral event.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the total collateral held by the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes based on their liquidation ratio, prioritizing risk assessment.",
            "why_is_is_important": "Ensures proper ordering for liquidation in case of undercollateralization, protecting the protocol from losses.",
            "when_is_it_updated": "When collateral is withdrawn from a safe with an outstanding debt, thus changing liquidation ratio.",
            "how_to_validate_state_update": "Check if the safesOrderedForLiquidation list is updated with the new liquidation ratio. Verify LiquidationQueueUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the position of the safe in the liquidation queue based on the new liquidation ratio after collateral withdrawal.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes based on their liquidation ratio, prioritizing risk assessment.",
            "why_is_is_important": "Safe with no borrowed amount should not be in liquidation queue",
            "when_is_it_updated": "When collateral is withdrawn from a safe with zero debt.",
            "how_to_validate_state_update": "Check if the safe is removed from both liquidation and redemption queues. Verify SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the liquidation queue if the borrowed amount is zero.",
            "conditions": [
              "safe.borrowedAmount <= 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "Tracks the order of safes based on their redemption eligibility.",
            "why_is_is_important": "Safe with no borrowed amount should not be in redemption queue",
            "when_is_it_updated": "When collateral is withdrawn from a safe with zero debt.",
            "how_to_validate_state_update": "Check if the safe is removed from both liquidation and redemption queues. Verify SafeRemovedFromLiquidationQueue and SafeRemovedFromRedemptionQueue events.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the redemption queue if the borrowed amount is zero.",
            "conditions": [
              "safe.borrowedAmount <= 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the outstanding debt of a safe, crucial for calculating liquidation risk.",
            "why_is_is_important": "Ensures accurate accounting of debt increases due to accrued interest or other factors.",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if borrowedAmount and totalBorrowedAmount are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a safe based on cumulative debt and collateral snapshots.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total outstanding debt of a safe, including all increases due to accrued interest or other factors.",
            "why_is_is_important": "Ensures accurate accounting of total debt, critical for determining overall system risk.",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if borrowedAmount and totalBorrowedAmount are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of a safe based on cumulative debt and collateral snapshots.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt per collateral snapshot to calculate inactive debt.",
            "why_is_is_important": "Used for calculating inactive debt and collateral",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if liquidationSnapshots[safeId].debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debt per collateral snapshot for a safe.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Keeps track of total collateral for the safe",
            "why_is_is_important": "used to calculate inactive debt",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if collateralAmount is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the deposited amount",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral snapshots for debt calculation",
            "why_is_is_important": "used to calculate inactive debt",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if collateralAmount is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral per collateral snapshot",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Keeps track of total collateral for the CDP",
            "why_is_is_important": "used to calculate inactive debt",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if totalCollateral is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Keeps track of total debt for the CDP",
            "why_is_is_important": "used to calculate inactive debt",
            "when_is_it_updated": "When the liquidation snapshot is not equal to the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check if totalDebt is updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the current operating mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Controls certain protocol behaviors based on the overall debt level, impacting stability and risk parameters.",
            "when_is_it_updated": "When the total debt rises above the BOOTSTRAP_MODE_DEBT_THRESHOLD while the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE is NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Aggregates the overall outstanding debt within the system.",
            "why_is_is_important": "Key metric for assessing the solvency and risk profile of the entire protocol.",
            "when_is_it_updated": "Whenever debt is either created (borrowed) or destroyed (repaid).",
            "how_to_validate_state_update": "Check if totalDebt is modified by delta value, either increased or decreased.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt of the protocol by adding or subtracting a delta value.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "MockPriceOracle",
        "state_updated": [
          {
            "state_variable_name": "price",
            "type": "uint256",
            "what_does_it_track": "Tracks the price of the collateral asset.",
            "why_is_is_important": "Used in calculations to determine liquidation ratios and maximum withdrawal amounts.",
            "when_is_it_updated": "This is a view function, so it returns the current price, when it is called.",
            "how_to_validate_state_update": "The function returns the current price, but does not update any state variables.",
            "has_conditional_updates": false,
            "summary_of_update": "Fetches the current price of the collateral; it does not update any state, it's a view function.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Tracks the nodes within the doubly linked list, maintaining the order of safes based on liquidation risk.",
            "why_is_is_important": "Maintains the correct order for efficient liquidation processing.",
            "when_is_it_updated": "When the liquidation ratio of a safe changes due to collateral withdrawal or debt adjustment.",
            "how_to_validate_state_update": "Check if the nodes mapping is updated correctly, with correct previous and next node pointers. Verify the LiquidationQueueUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the doubly linked list of safes ordered for liquidation, potentially reordering based on updated liquidation ratio.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first element of the liquidation queue.",
            "why_is_is_important": "Points to the safe with the lowest collateral ratio.",
            "when_is_it_updated": "When the safe with lowest collateral ratio is updated.",
            "how_to_validate_state_update": "Check if the head pointer of the linked list is updated if the safe being updated is the current head. Check the LiquidationQueueUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the safe being updated is the head.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last element of the liquidation queue.",
            "why_is_is_important": "Points to the safe with the highest collateral ratio.",
            "when_is_it_updated": "When the safe with highest collateral ratio is updated.",
            "how_to_validate_state_update": "Check if the tail pointer of the linked list is updated if the safe being updated is the current tail. Check the LiquidationQueueUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the safe being updated is the tail.",
            "conditions": [
              "safe.borrowedAmount > 0",
              "amount <= maxWithdrawal"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping(uint256 => Node)",
            "what_does_it_track": "Tracks the nodes within the doubly linked list, maintaining the order of safes based on liquidation risk.",
            "why_is_is_important": "Maintains the correct order for efficient liquidation processing.",
            "when_is_it_updated": "When collateral is withdrawn from a safe with zero debt.",
            "how_to_validate_state_update": "Verify SafeRemovedFromLiquidationQueue event.",
            "has_conditional_updates": true,
            "summary_of_update": "Removes the safe from the doubly linked list of safes ordered for liquidation.",
            "conditions": [
              "safe.borrowedAmount <= 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first element of the liquidation queue.",
            "why_is_is_important": "Points to the safe with the lowest collateral ratio.",
            "when_is_it_updated": "When collateral is withdrawn from a safe with zero debt.",
            "how_to_validate_state_update": "Verify SafeRemovedFromLiquidationQueue event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the safe being updated is the head.",
            "conditions": [
              "safe.borrowedAmount <= 0",
              "amount <= safe.collateralAmount"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last element of the liquidation queue.",
            "why_is_is_important": "Points to the safe with the highest collateral ratio.",
            "when_is_it_updated": "When collateral is withdrawn from a safe with zero debt.",
            "how_to_validate_state_update": "Verify SafeRemovedFromLiquidationQueue event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the safe being updated is the tail.",
            "conditions": [
              "safe.borrowedAmount <= 0",
              "amount <= safe.collateralAmount"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function withdrawCollateral(\n        uint256 safeId,\n        uint256 amount,\n        uint256 nearestSpotInLiquidationQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        require(safe.collateralAmount > 0, \"No collateral to withdraw\");\n\n        if (safe.borrowedAmount > 0) {\n            // Calculate the price of the collateral\n            uint256 price = priceOracle.fetchPrice();\n\n            // Calculate the maximum withdrawal amount that maintains the liquidation ratio\n            uint256 maxWithdrawal = safe.collateralAmount -\n                (safe.borrowedAmount * liquidationRatio * PRECISION) /\n                (price * BASIS_POINTS_DIVISOR);\n            require(amount <= maxWithdrawal, \"Insufficient collateral\");\n            uint256 _newRatio = (safe.borrowedAmount * PRECISION) /\n                (safe.collateralAmount - amount);\n            IDoublyLinkedList.Node memory node = safesOrderedForLiquidation\n                .upsert(safeId, _newRatio, nearestSpotInLiquidationQueue);\n            emit LiquidationQueueUpdated(safeId, _newRatio, node.next);\n        } else {\n            // If there's no borrowed amount, ensure the withdrawal does not exceed deposited collateral\n            require(amount <= safe.collateralAmount, \"Insufficient collateral\");\n            _removeSafeFromBothQueues(safeId);\n        }\n\n        // Update the Safe's deposited amount\n        safe.collateralAmount -= amount;\n        totalCollateral -= amount;\n        emit WithdrawnCollateral(safeId, amount, totalCollateral, totalDebt);\n\n        // Withdraw ETH or ERC20 token using SBUtils library\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      }
    ]
  }
}