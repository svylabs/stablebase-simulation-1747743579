{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be greater than 0.",
      "The `_amount` parameter should be a valid amount of staking tokens that the user owns and has approved the StabilityPool contract to transfer via `transferFrom`.",
      "The `frontend` parameter should be a valid address. If no frontend is intended, it can be set to the zero address.",
      "The `fee` parameter should be a valid fee percentage represented in basis points. E.g., 100 for 1%.",
      "Consider claiming rewards first (with claim function) to ensure accurate reward calculation."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User State",
        "state_update_descriptions": [
          "The user's stake is increased by the staked amount: `user.stake += _amount`",
          "The user's reward snapshot is updated to the current total reward per token: `user.rewardSnapshot = totalRewardPerToken`",
          "The user's collateral snapshot is updated to the current total collateral per token: `user.collateralSnapshot = totalCollateralPerToken`",
          "The user's cumulative product scaling factor is updated to the current stake scaling factor: `user.cumulativeProductScalingFactor = stakeScalingFactor`",
          "The user's stake reset count is updated to the current stake reset count: `user.stakeResetCount = stakeResetCount`",
          "The user's SBR reward snapshot is updated to the current total SBR reward per token: `sbrRewardSnapshots[msg.sender].rewardSnapshot = totalSbrRewardPerToken` if SBR rewards are still being distributed.",
          "The user's SBR reward snapshot status is set to CLAIMED if SBR rewards are not being distributed and the snapshot status is not already CLAIMED: `sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution.CLAIMED`."
        ]
      },
      {
        "category": "Total State",
        "state_update_descriptions": [
          "The total staked amount is increased by the staked amount: `totalStakedRaw += _amount`",
          "If the total staked amount was zero before staking and the reward sender is active, the StabilityPool is enabled to receive rewards from the StableBaseCDP: `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)`",
          "SBR rewards are added if the SBR reward distribution status is STARTED, potentially increasing `totalSbrRewardPerToken` and updating `lastSBRRewardDistributedTime`.",
          "If SBR reward distribution is NOT_STARTED, it is initialized, setting `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime`, and `sbrRewardDistributionStatus`."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "The staked tokens are transferred from the user to the StabilityPool: `stakingToken.transferFrom(msg.sender, address(this), _amount)`",
          "Pending rewards are transferred to the user, minus any frontend fee.",
          "Pending collateral is transferred to the user, minus any frontend fee.",
          "Pending SBR rewards are minted for the user, minus any frontend fee."
        ]
      },
      {
        "category": "Frontend Fees",
        "state_update_descriptions": [
          "Reward fees, collateral fees, and SBR reward fees are transferred to the specified frontend if they are greater than zero.",
          "The frontend fee is calculated as a percentage of the pending rewards, collateral, and SBR rewards."
        ]
      },
      {
        "category": "Events Emitted",
        "state_update_descriptions": [
          "A Staked event is emitted with the user's address and the staked amount: `emit Staked(msg.sender, _amount)`",
          "A RewardClaimed event is emitted with the user's address, reward amount, reward fee, collateral amount, and collateral fee.",
          "A DFireRewardClaimed event is emitted with the user's address, SBR reward amount, and SBR reward fee if SBR rewards are claimed.",
          "An SBRRewardsAdded event is emitted when SBR rewards are added during the claim process."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stake should be increased by the staked amount compared to its initial state.  Any pending rewards should be claimed.",
          "The user's `rewardSnapshot` should equal the contract's `totalRewardPerToken` after staking.",
          "The user's `collateralSnapshot` should equal the contract's `totalCollateralPerToken` after staking.",
          "The user's `cumulativeProductScalingFactor` should be equal to `stakeScalingFactor` after staking.",
          "The user's `stakeResetCount` should be equal to `stakeResetCount` after staking."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "The contract's `totalStakedRaw` should be increased by the staked amount.",
          "If the contract's `totalStakedRaw` was initially 0 and `rewardSenderActive` is true, `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)` should have been called successfully."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The user's staking token balance should be decreased by the staked amount.",
          "The StabilityPool's staking token balance should be increased by the staked amount.",
          "If rewards are claimed, the user's staking token balance should reflect the rewards received (minus fees).",
          "If collateral is claimed, the user should have received the collateral amount (minus fees), validated via eth balance change.",
          "If SBR rewards are claimed, the user's SBR token balance should reflect the SBR rewards received (minus fees)."
        ]
      },
      {
        "category": "SBR Rewards",
        "rule_descriptions": [
          "If SBR rewards are distributed, `totalSbrRewardPerToken` should increase accordingly.",
          "`lastSBRRewardDistributedTime` should be updated to the current block timestamp if SBR rewards are distributed."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A `Staked` event should be emitted with the correct user address and staked amount.",
          "A `RewardClaimed` event should be emitted with the correct user address, reward amount, and collateral amount. Also check frontend fees if a frontend address is specified."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Used to calculate the user's share of rewards and collateral.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the user's `stake` mapping at `users[msg.sender]` to see if it increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's stake by the amount staked.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the pool.",
            "why_is_is_important": "Used to calculate the reward distribution rate.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the `totalStakedRaw` variable to see if it increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total staked amount by the amount staked.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP.setCanStabilityPoolReceiveRewards(true)",
            "type": "bool",
            "what_does_it_track": "A boolean indicating if the StabilityPool contract can receive rewards.",
            "why_is_is_important": "Controls whether the StabilityPool can receive rewards from the RewardSender.",
            "when_is_it_updated": "When the pool transitions from having no staked tokens to having staked tokens.",
            "how_to_validate_state_update": "Check the return value of `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)` is true. This is a call to the stableBaseCDP contract",
            "has_conditional_updates": true,
            "summary_of_update": "Calls a function on stableBaseCDP contract to set the ability of the StabilityPool to receive rewards when the pool goes from empty to having staked tokens.",
            "conditions": [
              "oldTotalStakedRaw == 0 && rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the state of SBR reward distribution.",
            "why_is_is_important": "Manages the distribution of SBR rewards to stakers.",
            "when_is_it_updated": "When the `claim` or `stake` functions are called and SBR rewards are not yet ended.",
            "how_to_validate_state_update": "Check the return value of `_addSBRRewards()` function.",
            "has_conditional_updates": true,
            "summary_of_update": "Possibly modifies the SBR reward distribution status, end time, and last distribution time. Also updates `totalSbrRewardPerToken` and `sbrRewardLoss`",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot, user.collateralSnapshot, sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshots of reward and collateral per token for each user.",
            "why_is_is_important": "Used to calculate pending rewards and collateral for each user.",
            "when_is_it_updated": "When a user stakes or claims rewards.",
            "how_to_validate_state_update": "Compare user.rewardSnapshot, user.collateralSnapshot and sbrRewardSnapshots[msg.sender].rewardSnapshot before and after the transaction. Also check the DFIREToken balance of the user.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates reward snapshots to current reward per token values. Transfers pending rewards, collateral and SBR rewards to the user and the frontend, if any.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor, user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks scaling factor and reset count for a user's stake.",
            "why_is_is_important": "Used to adjust the user's stake based on scaling factor resets.",
            "when_is_it_updated": "When a user stakes or unstakes.",
            "how_to_validate_state_update": "Compare user.cumulativeProductScalingFactor and user.stakeResetCount to stakeScalingFactor and stakeResetCount respectively.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's scaling factor and stake reset count to the current values.",
            "conditions": []
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the effective stake of the user.",
            "why_is_is_important": "Calculates the user's current stake based on scaling factors.",
            "when_is_it_updated": "When a user stakes or unstakes.",
            "how_to_validate_state_update": "Use the formula to recalculate the effective stake, `(((user.stake * stakeScalingFactor) * precision) / user.cumulativeProductScalingFactor) / precision;` and compare to `user.stake`.",
            "has_conditional_updates": false,
            "summary_of_update": "Adjusts user's stake based on the current stake scaling factor.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender), balanceOf(StabilityPool)",
            "type": "uint256",
            "what_does_it_track": "Tracks the token balances of the user and the `StabilityPool` contract.",
            "why_is_is_important": "Reflects the transfer of tokens from the user to the pool.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the balance of the `StabilityPool` contract increased by `_amount` and `msg.sender`'s balance decreased by `_amount` using `balanceOf` function.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers `_amount` of staking tokens from the user to the `StabilityPool` contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender), balanceOf(frontend)",
            "type": "uint256",
            "what_does_it_track": "Tracks the DFIRE token balances of the user and frontend.",
            "why_is_is_important": "Reflects the distribution of SBR rewards in DFIRE tokens.",
            "when_is_it_updated": "When a user claims SBR rewards.",
            "how_to_validate_state_update": "Check the user's DFIREToken balance increased by `pendingSbrRewards - sbrFee` and frontend's DFIREToken balance increased by `sbrFee` using the `balanceOf` function.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints DFIRE tokens to the user and frontend as SBR rewards and fees.",
            "conditions": [
              "pendingSbrRewards > 0"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of DFIRE tokens.",
            "why_is_is_important": "Ensure to track accurate amount of tokens in the system",
            "when_is_it_updated": "When a user stakes and has pending SBR rewards to claim",
            "how_to_validate_state_update": "Check the total supply of DFIRE tokens has increased by `pendingSbrRewards`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the total supply by pendingSbrRewards.",
            "conditions": [
              "sbrFee > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}