{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer, representing the number of staking tokens to stake.",
      "The `frontend` parameter should be a valid Ethereum address. If no specific frontend is involved, this can be set to the zero address (address(0)).",
      "The `fee` parameter represents the fee percentage, typically in basis points (e.g., 100 for 1%), which will be applied to rewards and collateral claimed. It should be a non-negative integer.",
      "The caller (msg.sender) must possess at least `_amount` of `stakingToken` in their balance.",
      "The caller (msg.sender) must have approved the `StabilityPool` contract to spend at least `_amount` of `stakingToken` on their behalf via the `stakingToken`'s `approve` function."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Specific State Updates",
        "state_update_descriptions": [
          "The caller's (msg.sender) `stakingToken` balance decreases by the `_amount` staked.",
          "The caller's `StabilityPool.users[msg.sender].stake` increases by `_amount`.",
          "The caller's `StabilityPool.users[msg.sender].rewardSnapshot` is updated to the current `totalRewardPerToken` value.",
          "The caller's `StabilityPool.users[msg.sender].collateralSnapshot` is updated to the current `totalCollateralPerToken` value.",
          "The caller's `StabilityPool.sbrRewardSnapshots[msg.sender].rewardSnapshot` is updated to the current `totalSbrRewardPerToken` (if SBR reward distribution is not ended).",
          "The caller's `StabilityPool.sbrRewardSnapshots[msg.sender].status` is set to `CLAIMED` if SBR reward distribution has ended and not previously claimed.",
          "The caller's `StabilityPool.users[msg.sender].cumulativeProductScalingFactor` is updated to the current `stakeScalingFactor`.",
          "The caller's `StabilityPool.users[msg.sender].stakeResetCount` is updated to the current `stakeResetCount`.",
          "The caller's `stakingToken` balance may increase due to claimed pending rewards (pendingReward - rewardFee).",
          "The caller's native token (ETH/Matic) balance may increase due to claimed pending collateral (pendingCollateral - collateralFee).",
          "The caller's `sbrToken` balance may increase due to claimed pending SBR rewards (pendingSbrRewards - sbrFee)."
        ]
      },
      {
        "category": "StabilityPool Contract State Updates",
        "state_update_descriptions": [
          "The `StabilityPool` contract's `stakingToken` balance increases by `_amount` (transferred from msg.sender).",
          "The `StabilityPool` contract's `stakingToken` balance may decrease if rewards were transferred to the user or frontend.",
          "The `StabilityPool` contract's native token (ETH/Matic) balance may decrease if collateral was transferred to the user or frontend.",
          "The `StabilityPool.totalStakedRaw` increases by `_amount`.",
          "The `StabilityPool.lastSBRRewardDistributedTime` is updated to `block.timestamp` if SBR reward distribution is active or starts.",
          "The `StabilityPool.sbrRewardDistributionEndTime` is set to `block.timestamp + 365 days` if SBR reward distribution status changes from `NOT_STARTED` to `STARTED`.",
          "The `StabilityPool.sbrRewardDistributionStatus` may change from `NOT_STARTED` to `STARTED` or from `STARTED` to `ENDED`.",
          "The `StabilityPool.totalSbrRewardPerToken` is updated based on elapsed time and `sbrDistributionRate`.",
          "The `StabilityPool.sbrRewardLoss` is updated based on calculated `totalSbrRewardPerToken`."
        ]
      },
      {
        "category": "Frontend Specific State Updates",
        "state_update_descriptions": [
          "The `frontend` address's `stakingToken` balance may increase due to reward fees.",
          "The `frontend` address's native token (ETH/Matic) balance may increase due to collateral fees.",
          "The `frontend` address's `sbrToken` balance may increase due to SBR reward fees."
        ]
      },
      {
        "category": "External Contract State Updates",
        "state_update_descriptions": [
          "If `StabilityPool.totalStakedRaw` was initially 0 and `rewardSenderActive` is true, the `StableBaseCDP` contract's `canStabilityPoolReceiveRewards` state variable is set to `true`.",
          "The `sbrToken` (DFIREToken) contract's `totalSupply` increases due to minting SBR rewards for the user and frontend (if applicable)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Core State Changes",
        "rule_descriptions": [
          "Verify that `StabilityPool.users[msg.sender].stake` equals its initial value plus the `_amount` staked.",
          "Verify that `StabilityPool.totalStakedRaw` equals its initial value plus the `_amount` staked.",
          "Verify that the `stakingToken` balance of the `StabilityPool` contract has increased by `_amount` minus any `stakingToken` rewards transferred out during the transaction.",
          "Verify that the `stakingToken` balance of `msg.sender` has decreased by `_amount` minus any `stakingToken` rewards received during the transaction (i.e., net change)."
        ]
      },
      {
        "category": "Reward Claiming and Snapshots",
        "rule_descriptions": [
          "Verify that `StabilityPool.users[msg.sender].rewardSnapshot` is updated to the `totalRewardPerToken` value observed immediately after `_claim`.",
          "Verify that `StabilityPool.users[msg.sender].collateralSnapshot` is updated to the `totalCollateralPerToken` value observed immediately after `_claim`.",
          "Verify that `StabilityPool.sbrRewardSnapshots[msg.sender].rewardSnapshot` is updated to the `totalSbrRewardPerToken` value observed immediately after `_claim` (if SBR reward distribution is not ended).",
          "Verify that the caller's native token balance reflects any claimed pending collateral rewards.",
          "Verify that the caller's `sbrToken` balance reflects any claimed pending SBR rewards.",
          "If a `frontend` address was provided, verify its `stakingToken`, native token, and `sbrToken` balances reflect any received fees."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "rule_descriptions": [
          "Verify that `StabilityPool.lastSBRRewardDistributedTime` is updated to `block.timestamp`.",
          "If `StabilityPool.sbrRewardDistributionStatus` was `NOT_STARTED` at the start of the transaction, verify it is now `STARTED` and `StabilityPool.sbrRewardDistributionEndTime` is set to `block.timestamp + 365 days`.",
          "If `StabilityPool.sbrRewardDistributionStatus` was `STARTED` and `block.timestamp` exceeded `sbrRewardDistributionEndTime`, verify `sbrRewardDistributionStatus` is `ENDED`.",
          "Verify that `StabilityPool.totalSbrRewardPerToken` has been correctly updated based on the `sbrDistributionRate` and `timeElapsed`.",
          "Verify that `StabilityPool.sbrRewardLoss` has been correctly recalculated."
        ]
      },
      {
        "category": "External Contract Interactions",
        "rule_descriptions": [
          "If `StabilityPool.totalStakedRaw` was 0 prior to this transaction and `rewardSenderActive` was true, verify that `StableBaseCDP.setCanStabilityPoolReceiveRewards(true)` was called, making `StableBaseCDP.canStabilityPoolReceiveRewards()` return `true`.",
          "Verify that `DFIREToken.totalSupply` has increased by the amount of SBR tokens minted (total of user's claimed SBR rewards and frontend fees)."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "Verify that a `Staked` event is emitted with `user` equal to `msg.sender` and `amount` equal to `_amount`.",
          "If any rewards (stakingToken, collateral, SBR) were claimed, verify that a `RewardClaimed` event is emitted with the correct `user`, `totalReward`, `rewardFrontendFee`, `totalCollateral`, and `collateralFrontendFee`.",
          "If SBR rewards were claimed, verify that a `DFireRewardClaimed` event is emitted with the correct `user`, `amount` (SBR rewards), and `frontendFee` (SBR frontend fee).",
          "If SBR rewards were added to the pool, verify that an `SBRRewardsAdded` event is emitted with `lastTime`, `currentTime`, `rewardAmount`, and `totalRewardPerToken`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens currently staked by a specific user.",
            "why_is_is_important": "It reflects the user's current stake in the pool, which determines their share of rewards and collateral during liquidations.",
            "when_is_it_updated": "Always, when a user successfully stakes tokens.",
            "how_to_validate_state_update": "Verify that `users[msg.sender].stake` for the calling user has increased by the `_amount` provided in the function call. This is directly updated with `user.stake += _amount;`.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's staked amount is increased by the `_amount` provided.",
            "conditions": []
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The aggregate sum of all tokens currently staked in the Stability Pool across all users.",
            "why_is_is_important": "It represents the total liquidity available in the Stability Pool for liquidations and is used in various reward calculations.",
            "when_is_it_updated": "Always, when a user successfully stakes tokens.",
            "how_to_validate_state_update": "Verify that `totalStakedRaw` has increased by the `_amount` provided in the function call. This is directly updated with `totalStakedRaw += _amount;`.",
            "has_conditional_updates": false,
            "summary_of_update": "The total raw amount of tokens staked in the Stability Pool is increased by the `_amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "IRewardSender(stableBaseCDP).canStabilityPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "A flag indicating whether the Stability Pool is eligible to receive rewards from the `stableBaseCDP` contract.",
            "why_is_is_important": "It controls the flow of rewards from the StableBaseCDP contract to the Stability Pool, ensuring rewards are distributed only when the pool is active with staked funds.",
            "when_is_it_updated": "Only if `totalStakedRaw` was 0 before the current stake and `rewardSenderActive` is true.",
            "how_to_validate_state_update": "Check the `setCanStabilityPoolReceiveRewards` function call on the `stableBaseCDP` contract. It should be called with `true` if the conditions are met.",
            "has_conditional_updates": true,
            "summary_of_update": "The `canStabilityPoolReceiveRewards` flag on the `stableBaseCDP` contract is set to true, enabling the Stability Pool to receive rewards from the reward sender.",
            "conditions": [
              "rewardSenderActive is true",
              "oldTotalStakedRaw (value of totalStakedRaw before the current stake) was 0"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp when SBR rewards were last distributed or when the distribution started.",
            "why_is_is_important": "It's crucial for calculating the elapsed time to determine the amount of SBR rewards to be distributed.",
            "when_is_it_updated": "If `sbrRewardDistributionStatus` is `NOT_STARTED` (initial setup) or `STARTED` (regular update for reward calculation).",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` was `NOT_STARTED`, verify that `lastSBRRewardDistributedTime` is updated to `block.timestamp`.",
            "has_conditional_updates": true,
            "summary_of_update": "The timestamp of the last SBR reward distribution is updated to the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus is SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp at which the SBR reward distribution period is scheduled to end.",
            "why_is_is_important": "It defines the duration of the SBR reward distribution, after which no more SBR rewards will be added based on elapsed time.",
            "when_is_it_updated": "Only if `sbrRewardDistributionStatus` is `SBRRewardDistribution.NOT_STARTED`.",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` was `NOT_STARTED`, verify that `sbrRewardDistributionEndTime` is set to `block.timestamp + 365 days`.",
            "has_conditional_updates": true,
            "summary_of_update": "The end time for SBR reward distribution is set to 365 days from the current block timestamp.",
            "conditions": [
              "sbrRewardDistributionStatus is SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum (uint8)",
            "what_does_it_track": "The current phase of SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "It dictates whether SBR rewards are currently being accumulated and distributed, impacting `totalSbrRewardPerToken` calculation and user claims.",
            "when_is_it_updated": "When the distribution is initialized (`NOT_STARTED` to `STARTED`) or when the distribution period ends (`STARTED` to `ENDED`).",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` was `NOT_STARTED`, it should change to `STARTED`. If it was `STARTED` and `block.timestamp` exceeds `sbrRewardDistributionEndTime`, it should change to `ENDED`.",
            "has_conditional_updates": true,
            "summary_of_update": "The status of SBR reward distribution changes based on the current time and its initial state.",
            "conditions": [
              "sbrRewardDistributionStatus is SBRRewardDistribution.NOT_STARTED",
              "sbrRewardDistributionStatus is SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBR reward accrued per unit of staked token over time.",
            "why_is_is_important": "It's a global accumulator used to calculate individual user's pending SBR rewards based on their stake and snapshot.",
            "when_is_it_updated": "When SBR reward distribution is `STARTED` and `totalStakedRaw` is greater than 0, based on time elapsed since the last update.",
            "how_to_validate_state_update": "Verify that `totalSbrRewardPerToken` is updated by adding `(_sbrReward * stakeScalingFactor * precision / totalStakedRaw / precision)`. The calculation is complex but involves the time elapsed, `sbrDistributionRate`, and `totalStakedRaw`.",
            "has_conditional_updates": true,
            "summary_of_update": "The total SBR reward per token staked is updated, reflecting new SBR rewards distributed to the pool proportionally to the staked amount.",
            "conditions": [
              "sbrRewardDistributionStatus is SBRRewardDistribution.STARTED",
              "totalStakedRaw is greater than 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Undistributed SBR reward dust from previous calculations.",
            "why_is_is_important": "It helps in minimizing loss of SBR rewards due to integer division by carrying over remainders to future distributions.",
            "when_is_it_updated": "When SBR reward distribution is `STARTED` and `totalStakedRaw` is greater than 0, to account for precision loss in SBR reward calculation.",
            "how_to_validate_state_update": "Verify that `sbrRewardLoss` is updated based on the difference between the calculated `_sbrReward` and the amount actually distributed to `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Any fractional SBR reward amount that couldn't be precisely distributed due to integer arithmetic is accumulated here.",
            "conditions": [
              "sbrRewardDistributionStatus is SBRRewardDistribution.STARTED",
              "totalStakedRaw is greater than 0"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The `totalRewardPerToken` value at the last time the user's rewards were claimed or stake was modified.",
            "why_is_is_important": "It's used to calculate the pending general rewards for the user (difference between current `totalRewardPerToken` and this snapshot).",
            "when_is_it_updated": "Always, before a user's stake is updated or rewards are processed.",
            "how_to_validate_state_update": "Verify that `users[msg.sender].rewardSnapshot` is updated to the current `totalRewardPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's snapshot of `totalRewardPerToken` is updated to the current global value.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The `totalCollateralPerToken` value at the last time the user's collateral rewards were claimed or stake was modified.",
            "why_is_is_important": "It's used to calculate the pending collateral rewards for the user (difference between current `totalCollateralPerToken` and this snapshot).",
            "when_is_it_updated": "Always, before a user's stake is updated or rewards are processed.",
            "how_to_validate_state_update": "Verify that `users[msg.sender].collateralSnapshot` is updated to the current `totalCollateralPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's snapshot of `totalCollateralPerToken` is updated to the current global value.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The `totalSbrRewardPerToken` value at the last time the user's SBR rewards were claimed or stake was modified.",
            "why_is_is_important": "It's used to calculate the pending SBR rewards for the user (difference between current `totalSbrRewardPerToken` and this snapshot).",
            "when_is_it_updated": "When SBR reward distribution is not `ENDED`, before a user's stake is updated or rewards are processed.",
            "how_to_validate_state_update": "If `sbrRewardDistributionStatus` is not `ENDED`, verify that `sbrRewardSnapshots[msg.sender].rewardSnapshot` is updated to the current `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's snapshot of `totalSbrRewardPerToken` is updated to the current global value.",
            "conditions": [
              "sbrRewardDistributionStatus is not SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum (uint8)",
            "what_does_it_track": "The claiming status of a user's SBR rewards.",
            "why_is_is_important": "It prevents users from accumulating new SBR rewards once the distribution period is over and ensures their SBR rewards are 'finalized'.",
            "when_is_it_updated": "When the global SBR reward distribution ends and the user's rewards are processed.",
            "how_to_validate_state_update": "If the conditions are met, `sbrRewardSnapshots[msg.sender].status` should be set to `CLAIMED`.",
            "has_conditional_updates": true,
            "summary_of_update": "The user's SBR reward snapshot status is marked as `CLAIMED` if the global SBR distribution has ended and the user hasn't claimed yet.",
            "conditions": [
              "sbrRewardDistributionStatus is SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status is not SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "A factor used to normalize a user's stake value relative to the global stake scaling factor, crucial for accurate reward calculation after scaling factor resets.",
            "why_is_is_important": "It ensures that a user's effective stake and reward calculations are correctly scaled even if the global `stakeScalingFactor` changes due to liquidations.",
            "when_is_it_updated": "Always, when a user stakes tokens or their stake is otherwise updated (e.g., claim, unstake, liquidation).",
            "how_to_validate_state_update": "Verify that `users[msg.sender].cumulativeProductScalingFactor` is updated to the current `stakeScalingFactor`.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's cumulative product scaling factor is updated to the current global `stakeScalingFactor`.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "A counter representing the number of times the global stake scaling factor has been reset.",
            "why_is_is_important": "It helps in correctly accounting for rewards and stake value across multiple scaling factor reset periods by referencing the appropriate `stakeResetSnapshots`.",
            "when_is_it_updated": "Always, when a user stakes tokens or their stake is otherwise updated (e.g., claim, unstake, liquidation).",
            "how_to_validate_state_update": "Verify that `users[msg.sender].stakeResetCount` is updated to the current global `stakeResetCount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's stake reset count is updated to the current global `stakeResetCount`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFID tokens held by a specific address.",
            "why_is_is_important": "Reflects the reduction in the user's liquid DFID token holdings.",
            "when_is_it_updated": "Always, when a user stakes `_amount` of tokens, as per the `transferFrom` call.",
            "how_to_validate_state_update": "Verify that the `balanceOf(msg.sender)` in DFIDToken decreases by `_amount` after the `transferFrom` call.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of the staking token held by the `msg.sender` is decreased by the staked `_amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "The total amount of DFID tokens held by the StabilityPool contract.",
            "why_is_is_important": "Represents the total pooled staking tokens within the Stability Pool.",
            "when_is_it_updated": "Always, when a user stakes `_amount` of tokens, as per the `transferFrom` call.",
            "how_to_validate_state_update": "Verify that the `balanceOf(address(this))` (StabilityPool contract) in DFIDToken increases by `_amount` after the `transferFrom` call.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of the staking token held by the StabilityPool contract is increased by the staked `_amount`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFIRE tokens held by a specific address.",
            "why_is_is_important": "Reflects the distribution of earned SBR rewards to the staker.",
            "when_is_it_updated": "Conditionally, if the user has pending SBR rewards to claim.",
            "how_to_validate_state_update": "If `pendingSbrRewards` is positive, verify that `balances[msg.sender]` in DFIREToken increases by `pendingSbrRewards - sbrFee` after the `mint` call.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of DFIRE tokens held by the `msg.sender` is increased by their calculated pending SBR rewards, minus any frontend fee.",
            "conditions": [
              "pendingSbrRewards is greater than 0"
            ]
          },
          {
            "state_variable_name": "balances[frontend]",
            "type": "uint256",
            "what_does_it_track": "The amount of DFIRE tokens held by a specific address.",
            "why_is_is_important": "Accounts for the frontend fees collected in DFIRE tokens.",
            "when_is_it_updated": "Conditionally, if the user has pending SBR rewards and a frontend fee is applicable.",
            "how_to_validate_state_update": "If `sbrFee` is positive, verify that `balances[frontend]` in DFIREToken increases by `sbrFee` after the `mint` call.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of DFIRE tokens held by the specified `frontend` address is increased by the SBR frontend fee.",
            "conditions": [
              "pendingSbrRewards is greater than 0",
              "sbrFee is greater than 0"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of DFIRE tokens in existence.",
            "why_is_is_important": "Reflects the overall supply of DFIRE tokens, which is a key metric for tokenomics and valuation.",
            "when_is_it_updated": "Conditionally, if pending SBR rewards are minted.",
            "how_to_validate_state_update": "If `pendingSbrRewards` is positive, verify that the `totalSupply` of DFIREToken increases by `pendingSbrRewards` (total amount minted, including fees).",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of DFIRE tokens is increased by the amount of SBR rewards minted.",
            "conditions": [
              "pendingSbrRewards is greater than 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}