{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter should be a positive integer representing the amount of tokens to stake. It should be greater than 0.",
      "The frontend parameter should be a valid Ethereum address, representing the address to receive frontend fees. It can be the zero address if no frontend is involved.",
      "The fee parameter should be an integer representing the fee percentage in basis points. It can be 0 if no fee is charged."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake Update",
        "state_update_descriptions": [
          "users[msg.sender].stake is increased by _amount, representing the user's new stake.",
          "user.cumulativeProductScalingFactor is updated to stakeScalingFactor.",
          "user.stakeResetCount is updated to stakeResetCount."
        ]
      },
      {
        "category": "Total Stake Update",
        "state_update_descriptions": [
          "totalStakedRaw is increased by _amount, reflecting the overall increase in staked tokens."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "User's pending rewards (reward, collateral, and SBR rewards) are calculated and transferred to the user, frontend fees are taken if applicable. Snapshots (rewardSnapshot, collateralSnapshot, sbrRewardSnapshots[msg.sender].rewardSnapshot) are updated to reflect the current totalRewardPerToken, totalCollateralPerToken and totalSbrRewardPerToken respectively, if applicable."
        ]
      },
      {
        "category": "SBR Reward Distribution Status",
        "state_update_descriptions": [
          "If SBR reward distribution is not started, it is initiated. If started and the end time is reached, the status is set to ENDED. If it's started, the totalSbrRewardPerToken might be updated based on time elapsed and sbrDistributionRate."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "state_update_descriptions": [
          "If totalStakedRaw was previously 0 and rewardSenderActive is true, the stableBaseCDP contract's setCanStabilityPoolReceiveRewards function is called to enable reward distribution."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake Validation",
        "rule_descriptions": [
          "users[msg.sender].stake should be increased by the staked amount, considering scaling factors and stake reset counts.",
          "users[msg.sender].cumulativeProductScalingFactor should be equal to the current stakeScalingFactor.",
          "users[msg.sender].stakeResetCount should be equal to the current stakeResetCount."
        ]
      },
      {
        "category": "Total Stake Validation",
        "rule_descriptions": [
          "totalStakedRaw should be increased by the staked amount."
        ]
      },
      {
        "category": "Token Transfer Validation",
        "rule_descriptions": [
          "The stakingToken's balance of the StabilityPool contract should increase by the staked amount.",
          "The stakingToken's balance of the msg.sender should decrease by the staked amount."
        ]
      },
      {
        "category": "Reward Validation",
        "rule_descriptions": [
          "If applicable, the stakingToken's balance of the msg.sender should increase by the pending reward minus the reward fee (if any).",
          "If applicable, the stakingToken's balance of the frontend should increase by the reward fee (if any).",
          "The msg.sender's ETH balance should increase by the pending collateral minus the collateral fee (if any).",
          "The frontend's ETH balance should increase by the collateral fee (if any).",
          "The sbrToken's balance of the msg.sender should increase by the pending SBR rewards minus the SBR fee (if any).",
          "The sbrToken's balance of the frontend should increase by the SBR fee (if any)."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "A 'Staked' event should be emitted with the user's address and the staked amount.",
          "A 'RewardClaimed' event should be emitted with the user's address, reward, rewardFee, collateral, and collateralFee, if rewards/collateral were claimed.",
          "A 'DFireRewardClaimed' event should be emitted with the user's address, pendingSbrRewards and sbrFee, if SBR rewards were claimed."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Used to calculate rewards and collateral for each user.",
            "when_is_it_updated": "Updated when a user stakes tokens.",
            "how_to_validate_state_update": "Compare the user's stake balance before and after the stake function call. Check Staked event.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's stake by the amount staked (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the pool.",
            "why_is_is_important": "Used to calculate the rewards and collateral distribution ratio.",
            "when_is_it_updated": "Updated when a user stakes tokens.",
            "how_to_validate_state_update": "Compare the totalStakedRaw before and after stake function call. Check Staked event.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total amount of tokens staked in the pool by _amount.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP",
            "type": "address",
            "what_does_it_track": "Address of stableBaseCDP contract.",
            "why_is_is_important": "Used to control reward distribution to the StabilityPool.",
            "when_is_it_updated": "When the first stake happens after the pool is initiated and rewardSenderActive is true.",
            "how_to_validate_state_update": "Check if IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true) is called when oldTotalStakedRaw is 0 and rewardSenderActive is true.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the stableBaseCDP to allow reward distribution if it's the first stake and rewardSenderActive is true.",
            "conditions": [
              "oldTotalStakedRaw == 0 && rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed.",
            "why_is_is_important": "Used to calculate SBR reward distribution.",
            "when_is_it_updated": "Updated within the claim function, before calculating rewards.",
            "how_to_validate_state_update": "Verify the internal call to _addSBRRewards()",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time SBR rewards were distributed if the distribution is ongoing.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total SBR reward per token.",
            "why_is_is_important": "Used to calculate SBR reward for users.",
            "when_is_it_updated": "Updated during SBR reward distribution.",
            "how_to_validate_state_update": "Verify the internal call to _addSBRRewards(). Also check SBRRewardsAdded event",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total SBR reward per token.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Keeps track of the undistributed SBR reward due to precision loss",
            "why_is_is_important": "Important for accurately distributing SBR rewards.",
            "when_is_it_updated": "Updated during SBR reward distribution.",
            "how_to_validate_state_update": "Verify the internal call to _addSBRRewards()",
            "has_conditional_updates": true,
            "summary_of_update": "Tracks the remaining SBR reward that couldn't be distributed.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the end time of SBR reward distribution.",
            "why_is_is_important": "Used to determine when SBR rewards can be claimed.",
            "when_is_it_updated": "Updated if the distribution hasn't started yet.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionEndTime is updated correctly to block.timestamp + 365 days and sbrRewardDistributionStatus is STARTED",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the end time for SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks status of SBR reward distribution.",
            "why_is_is_important": "Control SBR reward distribution.",
            "when_is_it_updated": "If the distribution hasn't started.",
            "how_to_validate_state_update": "Check if sbrRewardDistributionStatus is updated correctly to STARTED",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the status of the SBR reward distribution to STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "pendingReward",
            "type": "uint256",
            "what_does_it_track": "Tracks pending rewards for users.",
            "why_is_is_important": "Calculate correct reward amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the internal call userPendingRewardAndCollateral(user)",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates and stores pending reward.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "pendingCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks pending collateral for users.",
            "why_is_is_important": "Calculate correct collateral amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the internal call userPendingRewardAndCollateral(user)",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates and stores pending collateral.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "pendingSbrRewards",
            "type": "uint256",
            "what_does_it_track": "Tracks pending SBR rewards for users.",
            "why_is_is_important": "Calculate correct reward amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the internal call userPendingRewardAndCollateral(user)",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates and stores pending SBR rewards.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks user reward snapshot",
            "why_is_is_important": "Calculate correct reward amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the sbrRewardSnapshots[msg.sender].rewardSnapshot update",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the sbrRewardSnapshots rewardSnapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks user reward status",
            "why_is_is_important": "Calculate correct reward amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the sbrRewardSnapshots[msg.sender].status update",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardSnapshots status.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "stakingToken",
            "type": "address",
            "what_does_it_track": "Reward token.",
            "why_is_is_important": "Transfers earned reward.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the stakingToken.transfer call.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers pending reward to the user.",
            "conditions": [
              "pendingReward != 0"
            ]
          },
          {
            "state_variable_name": "stakingToken",
            "type": "address",
            "what_does_it_track": "Reward token.",
            "why_is_is_important": "Transfers earned fee.",
            "when_is_it_updated": "When claim is triggered and reward fee is greater than 0.",
            "how_to_validate_state_update": "Check the stakingToken.transfer call.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward fee to the frontend.",
            "conditions": [
              "rewardFee > 0"
            ]
          },
          {
            "state_variable_name": "msg.sender",
            "type": "address",
            "what_does_it_track": "User address.",
            "why_is_is_important": "Transfers earned collateral.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the msg.sender.call.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers pending collateral to the user.",
            "conditions": [
              "pendingCollateral != 0"
            ]
          },
          {
            "state_variable_name": "frontend",
            "type": "address",
            "what_does_it_track": "Frontend address.",
            "why_is_is_important": "Transfers earned collateral.",
            "when_is_it_updated": "When claim is triggered and collateral fee is greater than 0.",
            "how_to_validate_state_update": "Check the frontend.call.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers collateral fee to the frontend.",
            "conditions": [
              "collateralFee > 0"
            ]
          },
          {
            "state_variable_name": "sbrToken",
            "type": "address",
            "what_does_it_track": "SBR token contract address.",
            "why_is_is_important": "Mints earned SBR reward.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Check the sbrToken.mint call.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the user.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "sbrToken",
            "type": "address",
            "what_does_it_track": "SBR token contract address.",
            "why_is_is_important": "Transfers earned collateral.",
            "when_is_it_updated": "When claim is triggered and sbr fee is greater than 0.",
            "how_to_validate_state_update": "Check the sbrToken.mint call.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the frontend.",
            "conditions": [
              "sbrFee > 0"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "Tracks user stake.",
            "why_is_is_important": "To calculate claim amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Verify the internal call to _updateUserStake(user)",
            "has_conditional_updates": false,
            "summary_of_update": "Adjust user's stake",
            "conditions": []
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks user scaling factor",
            "why_is_is_important": "To calculate claim amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Verify the internal call to _updateUserStake(user)",
            "has_conditional_updates": false,
            "summary_of_update": "Update user's scaling factor",
            "conditions": []
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks user stakeResetCount",
            "why_is_is_important": "To calculate claim amount.",
            "when_is_it_updated": "When claim is triggered.",
            "how_to_validate_state_update": "Verify the internal call to _updateUserStake(user)",
            "has_conditional_updates": false,
            "summary_of_update": "Update user's stakeResetCount",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the reward snapshot of the user.",
            "why_is_is_important": "Used to calculate the pending rewards for the user.",
            "when_is_it_updated": "Updated when the user claims rewards.",
            "how_to_validate_state_update": "Check the user.rewardSnapshot update within _claim",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral snapshot of the user.",
            "why_is_is_important": "Used to calculate the pending collateral for the user.",
            "when_is_it_updated": "Updated when the user claims collateral.",
            "how_to_validate_state_update": "Check the user.collateralSnapshot update within _claim",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "msg.sender",
            "type": "address",
            "what_does_it_track": "Tracks the user's token balance.",
            "why_is_is_important": "Reflects the user's reduced token balance after staking.",
            "when_is_it_updated": "Updated when a user stakes tokens.",
            "how_to_validate_state_update": "Check that stakingToken.transferFrom is called with the correct amount and addresses.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers tokens from the user to the StabilityPool contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "address",
            "what_does_it_track": "Tracks user token balance",
            "why_is_is_important": "To reflect earned reward",
            "when_is_it_updated": "When claim is triggered",
            "how_to_validate_state_update": "Check that sbrToken.mint is called with correct amount and address",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to user",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "_balances[frontend]",
            "type": "address",
            "what_does_it_track": "Tracks frontend token balance",
            "why_is_is_important": "To reflect earned fee",
            "when_is_it_updated": "When claim is triggered",
            "how_to_validate_state_update": "Check that sbrToken.mint is called with correct amount and address",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens to frontend",
            "conditions": [
              "sbrFee > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}