{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "_amount: A positive integer representing the amount of tokens to stake. Should be greater than 0.",
      "frontend: An address to receive fees from reward claims (can be the zero address if no fee is intended).",
      "fee: An integer representing the fee percentage (in basis points) to be charged on claimed rewards. Valid range is 0 to 10000 (representing 0% to 100%)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Update",
        "state_update_descriptions": [
          "Increase user's stake by _amount.",
          "Update totalStakedRaw by adding _amount.",
          "Update user's rewardSnapshot, collateralSnapshot, cumulativeProductScalingFactor, and stakeResetCount.",
          "Transfer staking tokens from user to StabilityPool contract."
        ]
      },
      {
        "category": "Reward Distribution",
        "state_update_descriptions": [
          "Potentially enable reward distribution to the StabilityPool if totalStakedRaw was 0 and rewardSenderActive is true."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "state_update_descriptions": [
          "Potentially add SBR rewards based on time elapsed since last distribution.",
          "Update totalSbrRewardPerToken and sbrRewardLoss."
        ]
      },
      {
        "category": "Reward Claiming",
        "state_update_descriptions": [
          "Calculate and transfer pending rewards (reward tokens, collateral, and SBR rewards) to the user.",
          "Potentially transfer fees to frontend address.",
          "Update user's rewardSnapshot and collateralSnapshot.",
          "Update SBR reward snapshots."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Update",
        "rule_descriptions": [
          "users[msg.sender].stake should reflect the increased stake after accounting for stake scaling.",
          "totalStakedRaw should be equal to the initial totalStakedRaw plus _amount.",
          "stakingToken balance of msg.sender should decrease by _amount.",
          "stakingToken balance of StabilityPool contract should increase by _amount."
        ]
      },
      {
        "category": "Reward Distribution",
        "rule_descriptions": [
          "Verify that IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true) was called if applicable."
        ]
      },
      {
        "category": "SBR Reward Distribution",
        "rule_descriptions": [
          "totalSbrRewardPerToken should reflect the added SBR rewards if applicable."
        ]
      },
      {
        "category": "Reward Claiming",
        "rule_descriptions": [
          "If rewards were claimed, user's staking token, ETH and SBR token balances should reflect received rewards.",
          "If fees were applied, frontend address should receive corresponding fee amounts in staking tokens, ETH and SBR tokens.",
          "users[msg.sender].rewardSnapshot should be equal to totalRewardPerToken.",
          "users[msg.sender].collateralSnapshot should be equal to totalCollateralPerToken."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Used to calculate rewards and collateral for the user. Also influences the total stake in the pool which can be used for system health calculations of the protocol. Also used to calculate reward distribution. Also used in _updateUserStake to scale the users stake based on scaling factors if they exist. In particular the user stake is calculated by _getUserEffectiveStake",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check if the user's stake is increased by the staked amount, and totalStakedRaw is increased by the staked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's stake by the amount staked.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the pool.",
            "why_is_is_important": "Used to calculate reward distribution and system health metrics. Impacts SBR reward distribution decisions. Total supply variable is also useful in the calculation and normal functioning of various contract methods such as `_addSBRRewards`",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check if the totalStakedRaw is increased by the staked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total staked amount by the amount staked.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)",
            "type": "external_call",
            "what_does_it_track": "Communicates with external contract about reward distribution.",
            "why_is_is_important": "Used to kickstart the reward distribution. Ensures other contracts are informed when StabilityPool is ready to receive rewards. StableBaseCDP is an external contract that determines certain rules of the rewards program",
            "when_is_it_updated": "When the first stake is made and rewardSenderActive is true.",
            "how_to_validate_state_update": "Verify that IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true) is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls an external function to set the reward distribution status when the pool goes from empty to having some stake.",
            "conditions": [
              "oldTotalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "_addSBRRewards()",
            "type": "internal_call",
            "what_does_it_track": "Handles the distribution of SBR rewards.",
            "why_is_is_important": "Used to distribute rewards for stakers of the pool. Function handles all aspects of updating sbr rewards",
            "when_is_it_updated": "Before claiming, if SBR rewards are active.",
            "how_to_validate_state_update": "Check if _addSBRRewards() is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Adds SBR rewards to the pool.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed to allow for fair distribution to stakers.",
            "why_is_is_important": "Tracks last distribution time to calculate the rewards since the last distribution. Incorrect value will skew results of sbr dist",
            "when_is_it_updated": "When SBR reward distribution is started.",
            "how_to_validate_state_update": "Verify if `lastSBRRewardDistributedTime` is updated to current block timestamp, also verify that `sbrRewardDistributionEndTime` remains unchanged and  `sbrRewardDistributionStatus` remains unchanged",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time SBR rewards were distributed.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of the SBR reward distribution.",
            "why_is_is_important": "Used to determine how much SBR rewards should be distributed. If sbr rewards is incorrectly set, stakers would not receive rewards",
            "when_is_it_updated": "When the distribution ends.",
            "how_to_validate_state_update": "Check that SBR rewards are calculated correctly by verifying that `block.timestamp` is greater than `sbrRewardDistributionEndTime` and that `sbrRewardDistributionStatus` is updated to `SBRRewardDistribution.ENDED`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status to ended when the distribution end time has passed.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total SBR reward per token.",
            "why_is_is_important": "Used to calculate SBR rewards for users. Necessary for rewards accounting",
            "when_is_it_updated": "When SBR rewards are added and there are stakers.",
            "how_to_validate_state_update": "Verify that `totalSbrRewardPerToken` is increased and `sbrRewardLoss` is updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total SBR reward per token.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBR reward loss.",
            "why_is_is_important": "Used to track any loss due to precision errors in calculations. Proper calculation ensures that extra rewards are not distributed",
            "when_is_it_updated": "When SBR rewards are added and there are stakers.",
            "how_to_validate_state_update": "Verify that `sbrRewardLoss` is updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward loss.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed to allow for fair distribution to stakers.",
            "why_is_is_important": "Tracks last distribution time to calculate the rewards since the last distribution. Incorrect value will skew results of sbr dist",
            "when_is_it_updated": "When SBR reward distribution is not started.",
            "how_to_validate_state_update": "Check that `lastSBRRewardDistributedTime` is updated to current `block.timestamp`, also check that `sbrRewardDistributionEndTime` is updated to current `block.timestamp + 365 days` and that `sbrRewardDistributionStatus` is updated to `SBRRewardDistribution.STARTED`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the last time SBR rewards were distributed to block timestamp when distribution is not started",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Keeps track of distribution end time to determine amount of SBR rewards to be distributed.",
            "why_is_is_important": "Helps determine when to stop distribution. Incorrect end time would mess with reward dist",
            "when_is_it_updated": "When distribution is not started",
            "how_to_validate_state_update": "Check that `sbrRewardDistributionEndTime` is updated to current `block.timestamp + 365 days` and that `sbrRewardDistributionStatus` is updated to `SBRRewardDistribution.STARTED`",
            "has_conditional_updates": true,
            "summary_of_update": "Set distribution end time to one year.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "Tracks the status of the SBR reward distribution.",
            "why_is_is_important": "Used to determine how much SBR rewards should be distributed. incorrect reward status would block distributions",
            "when_is_it_updated": "When the distribution starts.",
            "how_to_validate_state_update": "Check that `sbrRewardDistributionStatus` is updated to `SBRRewardDistribution.STARTED`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward distribution status to started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "userPendingRewardAndCollateral(user)",
            "type": "internal_call",
            "what_does_it_track": "Calculates rewards and collateral for users who are already staked.",
            "why_is_is_important": "Calculate how much rewards the user is due. Incorrect results lead to miscalculations of rewards",
            "when_is_it_updated": "Before snapshots are taken, if user has been staking before",
            "how_to_validate_state_update": "Verify by calling `userPendingRewardAndCollateral(user)` that the correct values are returned for the pending reward, collateral and sbr rewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates the pending reward and collateral for the user.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the reward snapshot for the user.",
            "why_is_is_important": "Used to calculate rewards when user claims. Snapshots are a historical tool for calculating rewards",
            "when_is_it_updated": "When user claims reward.",
            "how_to_validate_state_update": "Verify that reward snapshot of user is updated to current `totalRewardPerToken`",
            "has_conditional_updates": false,
            "summary_of_update": "Sets the reward snapshot for the user.",
            "conditions": []
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral snapshot for the user.",
            "why_is_is_important": "Used to calculate collateral when user claims. Snapshot important for historical claims",
            "when_is_it_updated": "When user claims collateral.",
            "how_to_validate_state_update": "Verify that collateral snapshot of user is updated to current `totalCollateralPerToken`",
            "has_conditional_updates": false,
            "summary_of_update": "Sets the collateral snapshot for the user.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBR reward snapshot for the user.",
            "why_is_is_important": "Used to calculate SBR rewards when user claims. Rewards snapshot ensures that correct rewards are distributed to stakers",
            "when_is_it_updated": "When sbr rewards distribution is not ended.",
            "how_to_validate_state_update": "Check that `sbrRewardSnapshots[msg.sender].rewardSnapshot` is updated to `totalSbrRewardPerToken`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward snapshot for the user.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks the status of SBR reward snapshot for the user.",
            "why_is_is_important": "Used to prevent double-claiming of SBR rewards when sbr reward distribution is ended. Once distribution ends, snapshot needs to be claimed",
            "when_is_it_updated": "When sbr rewards distribution is ended.",
            "how_to_validate_state_update": "Verify that `sbrRewardSnapshots[msg.sender].status` is set to `SBRRewardDistribution.CLAIMED`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the SBR reward snapshot status for the user.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "Tracks user's stake so reward calculation can be done",
            "why_is_is_important": "Adjust the actual user stake for reward calculation. Must be updated or old stake will be used which is incorrect",
            "when_is_it_updated": "When `user.cumulativeProductScalingFactor != 0`",
            "how_to_validate_state_update": "Verify that user's stake is updated by calling `_getUserEffectiveStake(user)`",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts user's stake by calling internal function.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "tracks the scaling factor so reward calculation can be done.",
            "why_is_is_important": "Important for reward calculation. Scaling factor changes how rewards are caluclated",
            "when_is_it_updated": "Always.",
            "how_to_validate_state_update": "Verify that `user.cumulativeProductScalingFactor` is updated to current `stakeScalingFactor`",
            "has_conditional_updates": false,
            "summary_of_update": "Update user's scaling factor",
            "conditions": []
          },
          {
            "state_variable_name": "user.stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks how many stake resets a user has to participate in reward calculations.",
            "why_is_is_important": "Important for tracking stake resets. Reset count is needed when multiple resets have been triggered",
            "when_is_it_updated": "Always.",
            "how_to_validate_state_update": "Check that `user.stakeResetCount` is updated to current `stakeResetCount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user stake reset count.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}