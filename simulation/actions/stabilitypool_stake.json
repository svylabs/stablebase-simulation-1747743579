{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer representing the amount of tokens to stake. It should be greater than 0.",
      "The `frontend` parameter should be a valid Ethereum address. If there is no frontend, it can be set to the zero address (0x0000000000000000000000000000000000000000).",
      "The `fee` parameter should be a uint256 representing the fee to be charged, expressed in basis points (e.g., 100 for 1%). It should be less than or equal to BASIS_POINTS_DIVISOR.",
      "The user must have approved the StabilityPool contract to spend at least `_amount` of their staking tokens. Check the `stakingToken.allowance(msg.sender, address(this))` is greater than or equal to `_amount`"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User State",
        "state_update_descriptions": [
          "The user's stake (`users[msg.sender].stake`) is updated.",
          "The user's reward snapshot (`users[msg.sender].rewardSnapshot`) is updated.",
          "The user's collateral snapshot (`users[msg.sender].collateralSnapshot`) is updated.",
          "The user's cumulative product scaling factor (`users[msg.sender].cumulativeProductScalingFactor`) is updated.",
          "The user's stake reset count (`users[msg.sender].stakeResetCount`) is updated.",
          "The SBR reward snapshot status (`sbrRewardSnapshots[msg.sender].status`) is updated if SBR reward distribution has ended."
        ]
      },
      {
        "category": "Contract State",
        "state_update_descriptions": [
          "The total staked raw amount (`totalStakedRaw`) is updated.",
          "The reward distribution status of `stableBaseCDP` may be updated.",
          "SBR reward related variables (`totalSbrRewardPerToken`, `sbrRewardLoss`) are updated, if SBR reward distribution is ongoing."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "Staking tokens are transferred from the user to the StabilityPool contract.",
          "Rewards, collateral and SBR tokens may be transferred to the user and frontend, if applicable."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User State",
        "rule_descriptions": [
          "The user's stake (`users[msg.sender].stake`) should be increased by the staked amount `_amount` compared to its previous value, after accounting for scaling factor changes.",
          "The user's reward snapshot (`users[msg.sender].rewardSnapshot`) should be equal to `totalRewardPerToken` after the staking operation.",
          "The user's collateral snapshot (`users[msg.sender].collateralSnapshot`) should be equal to `totalCollateralPerToken` after the staking operation.",
          "The user's cumulativeProductScalingFactor should be equal to the current stakeScalingFactor",
          "The user's stakeResetCount should be equal to the current stakeResetCount"
        ]
      },
      {
        "category": "Contract State",
        "rule_descriptions": [
          "The total staked amount (`totalStakedRaw`) should be increased by `_amount` compared to its previous value.",
          "The staking token balance of the StabilityPool contract should increase by `_amount`."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The staking token balance of the user (`msg.sender`) should decrease by `_amount`.",
          "The contract's staking token balance should increase by `_amount`."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A `Staked` event should be emitted with the user's address (`msg.sender`) and the staked amount (`_amount`)."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender]",
            "type": "mapping(address => UserInfo)",
            "what_does_it_track": "The staking information of a user.",
            "why_is_is_important": "Tracks the staking information for each user, including their stake, reward snapshot, collateral snapshot, cumulative product scaling factor, and stake reset count. Allows calculating and distributing rewards correctly to users based on their stake and historical snapshots of reward distribution states. ",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the user's stake value after the stake function is executed. It should increase by the staked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's stake by the amount staked (_amount) and updates reward-related snapshots.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked.",
            "why_is_is_important": "Keeps track of the total amount of tokens staked in the StabilityPool. Used to calculate rewards and scaling factors accurately. ",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the totalStakedRaw value after the stake function is executed. It should increase by the staked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the totalStakedRaw by the staked amount (_amount).",
            "conditions": []
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Timestamp of last SBR reward distribution.",
            "why_is_is_important": "Used in SBR reward calculation. Ensures rewards are distributed properly when SBR distribution starts",
            "when_is_it_updated": "When staking and SBR reward distribution has not started.",
            "how_to_validate_state_update": "Check the value of lastSBRRewardDistributedTime after staking if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the lastSBRRewardDistributedTime to the current block timestamp if the SBR reward distribution has not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp when SBR reward distribution ends.",
            "why_is_is_important": "Determines the duration of SBR reward distribution. Used in calculation of rewards for stakers. ",
            "when_is_it_updated": "When staking and SBR reward distribution has not started.",
            "how_to_validate_state_update": "Check the value of sbrRewardDistributionEndTime after staking if the condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the sbrRewardDistributionEndTime to the current block timestamp + 365 days if the SBR reward distribution has not started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The current status of SBR reward distribution.",
            "why_is_is_important": "Crucial for controlling the SBR reward distribution lifecycle, influencing how rewards are calculated and distributed. ",
            "when_is_it_updated": "During staking and if the distribution status changes.",
            "how_to_validate_state_update": "Check the value of sbrRewardDistributionStatus after staking under specified conditions.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardDistributionStatus to STARTED if it was previously NOT_STARTED and to ENDED if the current timestamp is greater than sbrRewardDistributionEndTime.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Accumulated SBR rewards per token.",
            "why_is_is_important": "Used to calculate how much SBR reward each staker is entitled to, based on their stake. ",
            "when_is_it_updated": "When staking and SBR rewards are being distributed.",
            "how_to_validate_state_update": "Check the value of totalSbrRewardPerToken after staking under specified conditions. It should increase based on reward calculations.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalSbrRewardPerToken based on the time elapsed and the distribution rate if sbrRewardDistributionStatus is STARTED and totalStakedRaw > 0.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "Unallocated SBR rewards due to precision loss.",
            "why_is_is_important": "Accounts for any precision loss in SBR reward calculations, ensuring that any remaining SBR rewards are tracked properly. ",
            "when_is_it_updated": "When staking and SBR rewards are being distributed.",
            "how_to_validate_state_update": "Check the value of sbrRewardLoss after staking under specified conditions. It should reflect any unallocated rewards.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardLoss based on the difference between the calculated SBR reward and the actual distributed reward if sbrRewardDistributionStatus is STARTED and totalStakedRaw > 0.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "A user's snapshot of SBR rewards.",
            "why_is_is_important": "Records a user's snapshot of SBR rewards, allowing for accurate calculation of rewards when the user claims them. ",
            "when_is_it_updated": "When a user stakes and the SBR reward distribution is ongoing.",
            "how_to_validate_state_update": "Check the value of sbrRewardSnapshots[msg.sender].rewardSnapshot after staking under specified conditions. It should match the totalSbrRewardPerToken.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardSnapshots[msg.sender].rewardSnapshot with the current totalSbrRewardPerToken if the SBR reward distribution is not ENDED.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Status of a user's SBR reward claim.",
            "why_is_is_important": "Tracks whether a user has claimed their SBR rewards, preventing duplicate claims. ",
            "when_is_it_updated": "When a user stakes, the SBR reward distribution is ended, and the user has not claimed rewards.",
            "how_to_validate_state_update": "Check the value of sbrRewardSnapshots[msg.sender].status after staking under specified conditions. It should be CLAIMED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates sbrRewardSnapshots[msg.sender].status to CLAIMED if the SBR reward distribution is ENDED and the status is not already CLAIMED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "A user's reward snapshot.",
            "why_is_is_important": "Maintains a snapshot of reward distribution at the time of staking, allowing fair distribution of rewards later when the user claims them. ",
            "when_is_it_updated": "When a user stakes.",
            "how_to_validate_state_update": "Check the value of users[msg.sender].rewardSnapshot after staking. It should match the totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the users[msg.sender].rewardSnapshot with the current totalRewardPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "A user's collateral snapshot.",
            "why_is_is_important": "Maintains a snapshot of collateral distribution at the time of staking, allowing fair distribution of collateral later when the user claims them. ",
            "when_is_it_updated": "When a user stakes.",
            "how_to_validate_state_update": "Check the value of users[msg.sender].collateralSnapshot after staking. It should match the totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the users[msg.sender].collateralSnapshot with the current totalCollateralPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Users current stake.",
            "why_is_is_important": "Stores the current amount staked by user. It's important for calculating rewards and collateral. ",
            "when_is_it_updated": "When the user stakes.",
            "how_to_validate_state_update": "Check the user's stake after they stake.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's effective stake based on stake scaling factor.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Scaling factor.",
            "why_is_is_important": "Tracks the product of scaling factors applied to the user's stake. It's important to calculate rewards and collateral properly. ",
            "when_is_it_updated": "When a user stakes.",
            "how_to_validate_state_update": "Check the value of scaling factor for the user.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the cumulative product scaling factor.",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Stake reset count.",
            "why_is_is_important": "Tracks the number of stake resets that have occurred for a user. It's important to calculate rewards and collateral after a stake reset has occurred.",
            "when_is_it_updated": "When a user stakes.",
            "how_to_validate_state_update": "Check the value of stake reset count for the user.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the stake reset count.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}