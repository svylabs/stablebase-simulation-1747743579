{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be greater than 0.",
      "The `msg.sender` must have sufficient balance of the `stakingToken` to transfer `_amount` to the `StabilityPool` contract. Approve StabilityPool contract before calling stake function.",
      "The `frontend` parameter should be a valid Ethereum address.",
      "The `fee` parameter should be a valid fee amount, typically within a reasonable range (e.g., 0 to 10000 for basis points)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User State",
        "state_update_descriptions": [
          "The `stake` field of the `users` mapping for the `msg.sender` is increased by `_amount`.",
          "The user's reward snapshot is updated to the current `totalRewardPerToken`.",
          "The user's collateral snapshot is updated to the current `totalCollateralPerToken`.",
          "The user's sbr reward snapshot is updated to the current `totalSbrRewardPerToken` if SBR rewards distribution is not ended.",
          "The user's cumulativeProductScalingFactor is updated to `stakeScalingFactor`.",
          "The user's stakeResetCount is updated to `stakeResetCount`.",
          "The user's effective stake is updated based on the stakeScalingFactor and cumulativeProductScalingFactor."
        ]
      },
      {
        "category": "Total State",
        "state_update_descriptions": [
          "The `totalStakedRaw` variable is increased by `_amount`.",
          "If `oldTotalStakedRaw` was 0 and `rewardSenderActive` is true, then `stableBaseCDP.setCanStabilityPoolReceiveRewards(true)` is called."
        ]
      },
      {
        "category": "SBR Rewards",
        "state_update_descriptions": [
          "If SBR reward distribution is started, `_addSBRRewards` is called, potentially updating `totalSbrRewardPerToken`, `sbrRewardLoss`, and `lastSBRRewardDistributedTime`.",
          "If SBR reward distribution is not started, its status, start time and end time are updated.",
          "User might claim pending reward, collateral and SBR rewards."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "The staking token (`stakingToken`) is transferred from the `msg.sender` to the StabilityPool contract (`address(this)`) by `_amount`."
        ]
      },
      {
        "category": "Rewards Distribution",
        "state_update_descriptions": [
          "Rewards, collateral, and SBR rewards are distributed to the user based on their stake and the accumulated rewards and collateral per token.",
          "Frontend might receive fees for reward, collateral, and SBR rewards."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "A `Staked` event is emitted with the `msg.sender` and `_amount`.",
          "A `RewardClaimed` event is emitted with reward, rewardFee, collateral, and collateralFee.",
          "A `DFireRewardClaimed` event is emitted with sbrReward, sbrRewardFee."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The `stake` field of the `users` mapping for the `msg.sender` should be increased by `_amount` compared to its previous value.",
          "The balance of the staking token (`stakingToken`) held by the StabilityPool contract should be increased by `_amount`.",
          "User's reward snapshot should be equal to `totalRewardPerToken`",
          "User's collateral snapshot should be equal to `totalCollateralPerToken`",
          "User's sbr reward snapshot should be equal to `totalSbrRewardPerToken` if SBR rewards distribution is not ended",
          "User's cumulativeProductScalingFactor should be equal to `stakeScalingFactor`",
          "User's stakeResetCount should be equal to `stakeResetCount`"
        ]
      },
      {
        "category": "Total Staked",
        "rule_descriptions": [
          "The `totalStakedRaw` variable should be increased by `_amount` compared to its previous value."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The `balanceOf` the `msg.sender` in the `stakingToken` contract should be decreased by `_amount`.",
          "The balance of the `StabilityPool` contract in the `stakingToken` contract should be increased by `_amount`.",
          "User's staking token balance might increase if user has pending rewards",
          "User's collateral balance might increase if user has pending collateral",
          "User's DFIRE token balance might increase if user has pending SBR rewards"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users",
            "type": "mapping",
            "what_does_it_track": "The amount of tokens staked by each user.",
            "why_is_is_important": "This reflects the user's deposit in the pool, which determines their share of rewards and collateral from liquidations and is the basis for reward calculations and liquidation participation. It also determines rewards and collateral claimable by each user. Crucial to calculate effective stake when scaling factors come into play because of stake resets (scalingFactor & stakeResetSnapshots).",
            "when_is_it_updated": "When a user successfully stakes tokens by calling the `stake` function.",
            "how_to_validate_state_update": "Check the user's `stake` mapping at `users[msg.sender]` to see if it increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "The `stake` field of the `users` mapping is increased by `_amount` for the `msg.sender`. This represents the user's staked amount.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total raw amount of staked tokens in the StabilityPool.",
            "why_is_is_important": "Used to calculate rewards distribution ratios. It represents the total deposits in the pool and is a key metric for the system's overall stability. ",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check if `totalStakedRaw` is increased by `_amount` after the stake operation.",
            "has_conditional_updates": true,
            "summary_of_update": "The `totalStakedRaw` variable is increased by `_amount`. It tracks the total amount of tokens staked in the pool.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseCDP",
            "type": "contract_call",
            "what_does_it_track": "Whether the StabilityPool can receive rewards from the reward sender.",
            "why_is_is_important": "Enables reward distribution to the StabilityPool. It is a one-time initialization step. Specifically, it calls `setCanStabilityPoolReceiveRewards(true)` on the `stableBaseCDP` contract.",
            "when_is_it_updated": "Only when the `totalStakedRaw` was 0 and the `rewardSenderActive` flag is true.",
            "how_to_validate_state_update": "Check that `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)` is called successfully.",
            "has_conditional_updates": true,
            "summary_of_update": "If this is the first stake and `rewardSenderActive` is `true`, the contract calls `setCanStabilityPoolReceiveRewards(true)` on the `stableBaseCDP` contract.",
            "conditions": [
              "oldTotalStakedRaw == 0",
              "rewardSenderActive == true"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "internal_function_call",
            "what_does_it_track": "SBR reward distribution status and associated parameters.",
            "why_is_is_important": "Handles the distribution of SBR rewards, incentivizing users to stake and participate in the system. ",
            "when_is_it_updated": "Before updating rewards, if the SBR reward distribution is not ended.",
            "how_to_validate_state_update": "Check if the `_addSBRRewards()` function is called. Verify state changes within `_addSBRRewards()` are executed.",
            "has_conditional_updates": true,
            "summary_of_update": "Conditionally calls `_addSBRRewards()`, which distributes SBR rewards to stakers.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user",
            "type": "internal_function_call",
            "what_does_it_track": "Pending rewards, collateral and SBR rewards for the user.",
            "why_is_is_important": "It distributes claimable amounts to stakers based on their participation and the system's performance. ",
            "when_is_it_updated": "Before updating the user's reward and collateral snapshots.",
            "how_to_validate_state_update": "Check the values returned by `userPendingRewardAndCollateral(user)` before and after the `_updateRewards` function is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates and transfers pending rewards, collateral, and SBR rewards to the user based on their stake and snapshots of `totalRewardPerToken`, `totalCollateralPerToken` and `totalSbrRewardPerToken`.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "users",
            "type": "mapping",
            "what_does_it_track": "The user's reward and collateral snapshots.",
            "why_is_is_important": "Used to calculate future rewards. Snapshots are the reference points to determine reward accrual. ",
            "when_is_it_updated": "After pending rewards and collateral are calculated and potentially transferred.",
            "how_to_validate_state_update": "Check if `user.rewardSnapshot` is updated to `totalRewardPerToken` and `user.collateralSnapshot` is updated to `totalCollateralPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward and collateral snapshots to the current global values.",
            "conditions": []
          },
          {
            "state_variable_name": "sbrRewardSnapshots",
            "type": "mapping",
            "what_does_it_track": "The user's SBR reward snapshot.",
            "why_is_is_important": "Used for calculation of SBR rewards to individual stakers. ",
            "when_is_it_updated": "When claiming rewards and if the SBR reward distribution is still active.",
            "how_to_validate_state_update": "If the SBR reward distribution is not ended, check if `sbrRewardSnapshots[msg.sender].rewardSnapshot` is updated to `totalSbrRewardPerToken`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot if the SBR reward distribution is ongoing.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots",
            "type": "mapping",
            "what_does_it_track": "The claim status of SBR rewards for the user.",
            "why_is_is_important": "Tracks whether the user has finalized their SBR reward claim. ",
            "when_is_it_updated": "When claiming rewards and the SBR reward distribution has ended.",
            "how_to_validate_state_update": "If SBR rewards distribution has ended but the user has not claimed it, verify that `sbrRewardSnapshots[msg.sender].status` is set to `SBRRewardDistribution.CLAIMED`.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the user's SBR reward snapshot status to CLAIMED if the distribution has ended.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED",
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "users",
            "type": "mapping",
            "what_does_it_track": "User's effective stake, scaling factor, and stake reset count.",
            "why_is_is_important": "Ensures that the user's stake is correctly adjusted after claiming rewards.",
            "when_is_it_updated": "After rewards and snapshots are updated, just prior to the stake action concluding.",
            "how_to_validate_state_update": "After calling `_updateUserStake(user)`, check if the user's stake and scaling factors are updated correctly based on calculations within that function.",
            "has_conditional_updates": false,
            "summary_of_update": "Adjusts the user's stake based on scaling factors and updates their scaling factor and reset count.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "ERC20_transfer",
            "what_does_it_track": "Token balances of users and the StabilityPool contract.",
            "why_is_is_important": "Represents the transfer of tokens from the user to the contract for staking.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Verify that `stakingToken.transferFrom(msg.sender, address(this), _amount)` is executed successfully and the balance of the `StabilityPool` contract has increased by `_amount` and the `msg.sender` balance is reduced by `_amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers `_amount` of staking tokens from the user to the StabilityPool contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "ERC20_mint",
            "what_does_it_track": "SBR token balances of users.",
            "why_is_is_important": "Distributes SBR tokens to users as rewards for staking. ",
            "when_is_it_updated": "When a user claims rewards and has pending SBR rewards.",
            "how_to_validate_state_update": "Verify that `sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee)` is executed successfully and the balance of `msg.sender` in `DFIREToken` contract is increased by `pendingSbrRewards - sbrFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the user if they have pending SBR rewards.",
            "conditions": [
              "pendingSbrRewards != 0"
            ]
          },
          {
            "state_variable_name": "balances",
            "type": "ERC20_mint",
            "what_does_it_track": "SBR token balances of the frontend.",
            "why_is_is_important": "Incentivizes frontends to participate in the system. ",
            "when_is_it_updated": "When a user claims rewards, has pending SBR rewards and the system charges a fee.",
            "how_to_validate_state_update": "Verify that `sbrToken.mint(frontend, sbrFee)` is executed successfully and the balance of `frontend` in `DFIREToken` contract is increased by `sbrFee`.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBR tokens for the frontend as fees if there are pending SBR rewards and a fee is charged.",
            "conditions": [
              "pendingSbrRewards != 0",
              "sbrFee > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total SBR reward per token and the SBR reward loss.",
            "why_is_is_important": "Tracks the accumulation of SBR rewards over time. ",
            "when_is_it_updated": "During reward claiming, if the SBR reward distribution is STARTED.",
            "how_to_validate_state_update": "Check if time elapsed since last distribution is calculated, `sbrReward` is calculated, and `totalSbrRewardPerToken` and `sbrRewardLoss` are updated accordingly.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total SBR reward per token based on the time elapsed and the SBR distribution rate. Also updates `sbrRewardLoss`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The status of the SBR reward distribution.",
            "why_is_is_important": "Manages the lifecycle of the SBR reward distribution.",
            "when_is_it_updated": "During reward claiming if the SBR reward distribution is NOT_STARTED.",
            "how_to_validate_state_update": "Check if `lastSBRRewardDistributedTime` is set to `block.timestamp`, `sbrRewardDistributionEndTime` is set to `block.timestamp + 365 days` and `sbrRewardDistributionStatus` is set to `SBRRewardDistribution.STARTED`.",
            "has_conditional_updates": true,
            "summary_of_update": "Starts the SBR reward distribution if it's not started yet.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}