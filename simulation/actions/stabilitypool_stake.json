{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be greater than zero.",
      "The `frontend` parameter can be any address; consider using a zero address if no frontend is involved.",
      "The `fee` parameter should be between 0 and `BASIS_POINTS_DIVISOR` (inclusive) to represent the fee percentage."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Action",
        "state_update_descriptions": [
          "Staking tokens are transferred from the user to the StabilityPool: `stakingToken.transferFrom(msg.sender, address(this), _amount)`.",
          "The user's stake is increased: `user.stake += _amount`.",
          "The total staked amount is increased: `totalStakedRaw += _amount`.",
          "The user's reward snapshot is updated: `user.rewardSnapshot = totalRewardPerToken`.",
          "The user's collateral snapshot is updated: `user.collateralSnapshot = totalCollateralPerToken`.",
          "The user's SBR reward snapshot is updated (if applicable): `sbrRewardSnapshots[msg.sender].rewardSnapshot = totalSbrRewardPerToken` or `sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution.CLAIMED`.",
          "The user's cumulative product scaling factor is updated: `user.cumulativeProductScalingFactor = stakeScalingFactor`.",
          "The user's stake reset count is updated: `user.stakeResetCount = stakeResetCount`.",
          "Potentially updates `totalSbrRewardPerToken` and `sbrRewardLoss` if SBR rewards are active and totalStakedRaw was zero before the stake.",
          "The StabilityPool may call `setCanStabilityPoolReceiveRewards` on the `stableBaseCDP` contract.",
          "SBR rewards are added if the distribution is not ended: `_addSBRRewards()` which can update `totalSbrRewardPerToken`, `sbrRewardLoss`, `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime`, and `sbrRewardDistributionStatus`.",
          "Rewards, collateral and/or SBR rewards can be claimed, transferred to the user and a frontend if they exist based on prior staking and reward distribution status."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Validation",
        "rule_descriptions": [
          "The user's staking token balance should decrease by the staked amount.",
          "The contract's staking token balance should increase by the staked amount.",
          "The user's stake, `users[msg.sender].stake`, should be increased by the staked amount, accounting for scaling factors if stake reset occurred. Use `_getUserEffectiveStake` to calculate the effective stake.",
          "The total staked amount (`totalStakedRaw`) should be increased by the staked amount.",
          "The user's reward snapshot, `users[msg.sender].rewardSnapshot`, should be equal to `totalRewardPerToken`.",
          "The user's collateral snapshot, `users[msg.sender].collateralSnapshot`, should be equal to `totalCollateralPerToken`.",
          "If SBR rewards are active, the `totalSbrRewardPerToken` should have increased, and `sbrRewardLoss` may have been updated.",
          "If the `totalStakedRaw` was zero before staking and `rewardSenderActive` is true, `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)` should have been successfully called.",
          "If rewards are claimed, the user's staking token balance, ETH balance, and/or SBR token balance should increase based on accrued rewards and fees. Check the balances after potential reward claiming.",
          "A `Staked` event should be emitted with the user's address and the staked amount.",
          "A `RewardClaimed` event should be emitted if rewards were claimed with the corresponding amounts and fees.",
          "A `DFireRewardClaimed` event should be emitted if SBR rewards were claimed."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Represents the user's share in the pool and determines their reward and collateral claim amounts.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the user's `stake` value in the `users` mapping to see if it increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's stake by the specified amount.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the pool.",
            "why_is_is_important": "Used to calculate reward distribution and scaling factors.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the `totalStakedRaw` variable to see if it increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total staked amount by the specified amount.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)",
            "type": "bool",
            "what_does_it_track": "Whether the StabilityPool can receive rewards from the RewardSender contract.",
            "why_is_is_important": "Enables reward distribution to the StabilityPool.",
            "when_is_it_updated": "When the first stake occurs after the pool was empty and reward sender is active.",
            "how_to_validate_state_update": "Check the return value of `IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(true)` to confirm it returns true.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the StabilityPool to receive rewards if it was previously empty and reward sender is active.",
            "conditions": [
              "oldTotalStakedRaw == 0 && rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime, sbrRewardDistributionStatus, totalSbrRewardPerToken, sbrRewardLoss",
            "type": "uint256, enum, uint256, uint256",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed, the distribution status, and total reward per token.",
            "why_is_is_important": "Ensures fair distribution of SBR rewards to stakers.",
            "when_is_it_updated": "When SBR rewards are added based on the time elapsed since the last distribution.",
            "how_to_validate_state_update": "Check `lastSBRRewardDistributedTime` and `sbrRewardLoss`. Check the emitted `SBRRewardsAdded` event and verify the `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates SBR reward distribution parameters, calculating and adding SBR rewards based on time elapsed.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime, sbrRewardDistributionEndTime, sbrRewardDistributionStatus",
            "type": "uint256, uint256, enum",
            "what_does_it_track": "Tracks the last time SBR rewards were distributed, the end time, and the distribution status.",
            "why_is_is_important": "Initializes the SBR reward distribution process.",
            "when_is_it_updated": "When SBR reward distribution is not started yet.",
            "how_to_validate_state_update": "Check `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime`, and `sbrRewardDistributionStatus` to ensure they are updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes SBR reward distribution parameters when it hasn't started yet.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "pendingReward, pendingCollateral, pendingSbrRewards",
            "type": "uint256, uint256, uint256",
            "what_does_it_track": "Tracks pending rewards, collateral, and SBR rewards.",
            "why_is_is_important": "Calculates the rewards and collateral the user is entitled to.",
            "when_is_it_updated": "When the user has a non-zero `cumulativeProductScalingFactor`.",
            "how_to_validate_state_update": "Check the values of `pendingReward`, `pendingCollateral`, `pendingSbrRewards`.",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates pending rewards and collateral for the user.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot, user.collateralSnapshot",
            "type": "uint256, uint256",
            "what_does_it_track": "Tracks user's reward and collateral snapshots.",
            "why_is_is_important": "Used to calculate future rewards and collateral.",
            "when_is_it_updated": "Always updated during the claim process.",
            "how_to_validate_state_update": "Check `user.rewardSnapshot` and `user.collateralSnapshot` to verify they are equal to `totalRewardPerToken` and `totalCollateralPerToken` respectively.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward and collateral snapshots.",
            "conditions": [
              "always"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the user's SBR reward snapshot.",
            "why_is_is_important": "Used to calculate future SBR rewards.",
            "when_is_it_updated": "When SBR reward distribution is not ended.",
            "how_to_validate_state_update": "Check `sbrRewardSnapshots[msg.sender].rewardSnapshot` to ensure it equals `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's SBR reward snapshot.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "enum",
            "what_does_it_track": "Tracks the user's SBR reward status.",
            "why_is_is_important": "Indicates that the user has claimed their SBR rewards.",
            "when_is_it_updated": "When SBR reward distribution is ended.",
            "how_to_validate_state_update": "Check `sbrRewardSnapshots[msg.sender].status` to ensure it is set to `SBRRewardDistribution.CLAIMED`.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the user's SBR reward snapshot status to CLAIMED.",
            "conditions": [
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED",
              "sbrRewardDistributionStatus == SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "user.stake",
            "type": "uint256",
            "what_does_it_track": "The effective stake of the user, considering scaling factors.",
            "why_is_is_important": "Ensures correct calculation of rewards and collateral.",
            "when_is_it_updated": "When a user's stake needs to be adjusted.",
            "how_to_validate_state_update": "Check that `user.stake` is updated using `_getUserEffectiveStake()`.",
            "has_conditional_updates": true,
            "summary_of_update": "Adjusts user's stake based on scaling factors.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "user.cumulativeProductScalingFactor, user.stakeResetCount",
            "type": "uint256, uint256",
            "what_does_it_track": "Tracks the scaling factor and stake reset count of the user.",
            "why_is_is_important": "Ensures correct scaling of user's stake for reward calculation.",
            "when_is_it_updated": "Always updated to maintain stake consistency.",
            "how_to_validate_state_update": "Check that `user.cumulativeProductScalingFactor` is set to `stakeScalingFactor` and `user.stakeResetCount` is set to `stakeResetCount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's scaling factor and reset count.",
            "conditions": [
              "always"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender), balanceOf(StabilityPool)",
            "type": "uint256, uint256",
            "what_does_it_track": "Tracks the token balances of the user and the StabilityPool contract.",
            "why_is_is_important": "Reflects the transfer of tokens from the staker to the pool.",
            "when_is_it_updated": "When the user stakes tokens.",
            "how_to_validate_state_update": "Check the balance of `msg.sender` decreased and the balance of `StabilityPool` contract increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the staked amount from the user to the StabilityPool contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": []
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}