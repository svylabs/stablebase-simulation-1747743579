{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of tokens.",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "probability": 0.7
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer representing the amount of tokens to stake.",
      "The `frontend` parameter should be a valid address. It represents the address that will receive a fee from claimed rewards, can be the zero address if no fee is desired.",
      "The `fee` parameter should be a valid fee represented as an integer, where 10000 represents 100%. It must be between 0 and `BASIS_POINTS_DIVISOR`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Operation",
        "state_update_descriptions": [
          "The `stake` field in the `users` mapping for the `msg.sender` is increased by `_amount` after adjusting for any stake scaling factors that may have been applied through stake resets. The `cumulativeProductScalingFactor` and `stakeResetCount` are updated for the user, reflecting the current stake scaling factor and reset count.",
          "The `totalStakedRaw` variable is increased by `_amount`, representing the total raw amount of tokens staked in the pool.",
          "User's reward and collateral snapshots are updated to the current global reward and collateral per-token values.",
          "Pending reward, collateral, and SBR rewards are calculated based on the difference between the user's snapshot and current global values, proportional to their stake. These rewards are then transferred to the user, potentially incurring fees sent to the `frontend` address.",
          "SBR reward distribution status is checked, and if active, SBR rewards are added to the pool based on the time elapsed since the last distribution and the distribution rate. If the distribution has ended, the user's SBR reward snapshot status is updated to CLAIMED.",
          "If the pool was previously empty (`oldTotalStakedRaw == 0`) and `rewardSenderActive` is true, the `setCanStabilityPoolReceiveRewards` function on the `stableBaseCDP` contract is called to enable reward distribution from the reward sender.",
          "The `Staked` event is emitted with the user's address and the staked amount.",
          "The `RewardClaimed` event is emitted with the user's address, reward amount, reward frontend fee, collateral amount and collateral frontend fee.",
          "The `DFireRewardClaimed` event is emitted if there were any SBR rewards claimed including user address, sbrReward and sbrRewardFee."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Operation",
        "rule_descriptions": [
          "The `users[msg.sender].stake` should be increased by `_amount` after adjusting for any stake scaling factors that may have been applied through stake resets.",
          "The `users[msg.sender].cumulativeProductScalingFactor` should be equal to `stakeScalingFactor`.",
          "The `users[msg.sender].stakeResetCount` should be equal to `stakeResetCount`.",
          "The `totalStakedRaw` should be increased by `_amount`.",
          "The contract's `stakingToken` balance should increase by `_amount`.",
          "The user's `stakingToken` balance should decrease by `_amount`.",
          "Any reward tokens or collateral should be transferred correctly to the user and the frontend address (if a fee is specified).",
          "The user's `rewardSnapshot` should be updated to the current `totalRewardPerToken`.",
          "The user's `collateralSnapshot` should be updated to the current `totalCollateralPerToken`.",
          "If SBR reward distribution is active (`sbrRewardDistributionStatus != SBRRewardDistribution.ENDED`), the `totalSbrRewardPerToken` may increase.",
          "If SBR reward distribution is not active(`sbrRewardDistributionStatus == SBRRewardDistribution.ENDED`), `sbrRewardSnapshots[msg.sender].status` should be `SBRRewardDistribution.CLAIMED`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "StabilityPool",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "users[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens staked by a user.",
            "why_is_is_important": "Tracks user's stake in the pool",
            "when_is_it_updated": "Always, when stake function is called",
            "how_to_validate_state_update": "Check the user's stake variable directly",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's stake by the specified amount.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked in the pool.",
            "why_is_is_important": "Tracks total stake in the pool, important for reward calculation",
            "when_is_it_updated": "Always, when stake function is called",
            "how_to_validate_state_update": "Check the totalStakedRaw variable directly",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total staked amount by the specified amount.",
            "conditions": []
          },
          {
            "state_variable_name": "stakingToken.transferFrom(msg.sender, address(this), _amount)",
            "type": "transfer",
            "what_does_it_track": "Transfer of staking tokens from user to the contract.",
            "why_is_is_important": "Reflects the transfer of staked tokens.",
            "when_is_it_updated": "Always, when the stake function is called.",
            "how_to_validate_state_update": "Check the balance of the StabilityPool contract and the user before and after the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers the staked tokens from the user to the StabilityPool contract.",
            "conditions": []
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "last time that SBR reward was distributed",
            "why_is_is_important": "sbr rewards can be added",
            "when_is_it_updated": "if sbrRewardDistributionStatus is not ENDED",
            "how_to_validate_state_update": "check the value of sbrRewardDistributionStatus",
            "has_conditional_updates": true,
            "summary_of_update": "Add SBR Rewards",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Total SBR rewards per token.",
            "why_is_is_important": "check SBR rewards to distribute",
            "when_is_it_updated": "if sbrRewardDistributionStatus is STARTED",
            "how_to_validate_state_update": "verify the value of sbrRewardDistributionStatus is STARTED",
            "has_conditional_updates": true,
            "summary_of_update": "Calculate and distribute sbr rewards.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "SBR reward distribution status",
            "why_is_is_important": "check SBR rewards distribution",
            "when_is_it_updated": "if sbrRewardDistributionStatus is NOT_STARTED",
            "how_to_validate_state_update": "verify the value of sbrRewardDistributionStatus is NOT_STARTED",
            "has_conditional_updates": true,
            "summary_of_update": "Starts SBR reward distribution.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "total reward per token.",
            "why_is_is_important": "Calculates pending rewards",
            "when_is_it_updated": "if user.cumulativeProductScalingFactor != 0",
            "how_to_validate_state_update": "verify the value of user.cumulativeProductScalingFactor",
            "has_conditional_updates": true,
            "summary_of_update": "Calculates and transfers pending rewards, collateral, and SBR rewards.",
            "conditions": [
              "user.cumulativeProductScalingFactor != 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Total SBR reward per token",
            "why_is_is_important": "SBR rewards are available to claim",
            "when_is_it_updated": "if sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
            "how_to_validate_state_update": "verify the value of sbrRewardDistributionStatus",
            "has_conditional_updates": true,
            "summary_of_update": "Update the snapshot of sbr rewards.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardSnapshots[msg.sender].status",
            "type": "uint8",
            "what_does_it_track": "Distribution status",
            "why_is_is_important": "sbr rewards distribution status",
            "when_is_it_updated": "if sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED",
            "how_to_validate_state_update": "verify the value of sbrRewardSnapshots[msg.sender].status",
            "has_conditional_updates": true,
            "summary_of_update": "set SBR reward distribution to Claimed.",
            "conditions": [
              "sbrRewardSnapshots[msg.sender].status != SBRRewardDistribution.CLAIMED"
            ]
          },
          {
            "state_variable_name": "users[msg.sender].cumulativeProductScalingFactor",
            "type": "uint256",
            "what_does_it_track": "User's cumulative product scaling factor",
            "why_is_is_important": "Updates user's scaling factor for accurate reward calculations.",
            "when_is_it_updated": "Always.",
            "how_to_validate_state_update": "check value of user.cumulativeProductScalingFactor",
            "has_conditional_updates": false,
            "summary_of_update": "Update user's scaling factor and reset count",
            "conditions": []
          },
          {
            "state_variable_name": "users[msg.sender].stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "stakeResetCount",
            "why_is_is_important": "Tracks the user's stake reset count.",
            "when_is_it_updated": "Always.",
            "how_to_validate_state_update": "Check user.stakeResetCount",
            "has_conditional_updates": false,
            "summary_of_update": "User's stake reset count",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function stake(uint256 _amount, address frontend, uint256 fee) public {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        UserInfo storage user = users[msg.sender];\n        _claim(user, frontend, fee);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 oldTotalStakedRaw = totalStakedRaw;\n        totalStakedRaw += _amount;\n\n        if (oldTotalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    true\n                ),\n                \"Unable to set reward distribution\"\n            );\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    ) internal {\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n        (\n            uint256 reward,\n            uint256 rewardFee,\n            uint256 collateral,\n            uint256 collateralFee,\n            uint256 sbrReward,\n            uint256 sbrRewardFee\n        ) = _updateRewards(user, frontend, fee);\n        _updateUserStake(user);\n        emit RewardClaimed(\n            msg.sender,\n            reward,\n            rewardFee,\n            collateral,\n            collateralFee\n        );\n        if (sbrReward > 0) {\n            emit DFireRewardClaimed(msg.sender, sbrReward, sbrRewardFee);\n        }\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }\nfunction _updateRewards(\n        UserInfo storage user,\n        address frontend,\n        uint256 fee\n    )\n        internal\n        returns (\n            uint256 pendingReward,\n            uint256 rewardFee,\n            uint256 pendingCollateral,\n            uint256 collateralFee,\n            uint256 pendingSbrRewards,\n            uint256 sbrFee\n        )\n    {\n        if (user.cumulativeProductScalingFactor != 0) {\n            (\n                pendingReward,\n                pendingCollateral,\n                pendingSbrRewards\n            ) = userPendingRewardAndCollateral(user);\n        }\n\n        user.rewardSnapshot = totalRewardPerToken;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            sbrRewardSnapshots[msg.sender]\n                .rewardSnapshot = totalSbrRewardPerToken;\n        } else if (\n            sbrRewardSnapshots[msg.sender].status !=\n            SBRRewardDistribution.CLAIMED\n        ) {\n            sbrRewardSnapshots[msg.sender].status = SBRRewardDistribution\n                .CLAIMED;\n        }\n\n        if (pendingReward != 0) {\n            rewardFee = (fee * pendingReward) / BASIS_POINTS_DIVISOR;\n            require(\n                stakingToken.transfer(msg.sender, pendingReward - rewardFee),\n                \"Reward transfer failed\"\n            );\n            if (rewardFee > 0) {\n                require(\n                    stakingToken.transfer(frontend, rewardFee),\n                    \"Fee transfer failed\"\n                );\n            }\n        }\n        if (pendingCollateral != 0) {\n            collateralFee = (fee * pendingCollateral) / BASIS_POINTS_DIVISOR;\n            (bool success, ) = msg.sender.call{\n                value: pendingCollateral - collateralFee\n            }(\"\");\n            require(success, \"Collateral transfer failed\");\n            if (collateralFee > 0) {\n                (success, ) = frontend.call{value: collateralFee}(\"\");\n                require(success, \"Fee transfer failed\");\n            }\n        }\n        if (pendingSbrRewards != 0) {\n            sbrFee = (fee * pendingSbrRewards) / BASIS_POINTS_DIVISOR;\n            require(\n                sbrToken.mint(msg.sender, pendingSbrRewards - sbrFee),\n                \"Mint failed\"\n            );\n            if (sbrFee > 0) {\n                require(sbrToken.mint(frontend, sbrFee), \"Fee transfer failed\");\n            }\n        }\n    }\nfunction userPendingRewardAndCollateral(\n        UserInfo storage user\n    )\n        internal\n        view\n        returns (\n            uint256 pendingReward,\n            uint256 pendingCollateral,\n            uint256 pendingSbrRewards\n        )\n    {\n        bool calculateSbrRewards = true;\n        if (\n            sbrRewardSnapshots[msg.sender].status ==\n            SBRRewardDistribution.CLAIMED\n        ) {\n            calculateSbrRewards = false;\n        }\n        if (user.stakeResetCount == stakeResetCount) {\n            pendingReward =\n                ((((totalRewardPerToken - user.rewardSnapshot) * user.stake) *\n                    precision) / user.cumulativeProductScalingFactor) /\n                precision;\n            pendingCollateral =\n                ((((totalCollateralPerToken - user.collateralSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((totalSbrRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            pendingReward =\n                ((((snapshot.totalRewardPerToken - user.rewardSnapshot) *\n                    user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            pendingCollateral =\n                ((((snapshot.totalCollateralPerToken -\n                    user.collateralSnapshot) * user.stake) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (calculateSbrRewards) {\n                pendingSbrRewards =\n                    ((((snapshot.totalSBRRewardPerToken -\n                        sbrRewardSnapshots[msg.sender].rewardSnapshot) *\n                        user.stake) * precision) /\n                        user.cumulativeProductScalingFactor) /\n                    precision;\n            }\n\n            // Calculate the user stake at reset snapshot\n            uint256 userStake = ((user.stake *\n                snapshot.scalingFactor *\n                precision) / user.cumulativeProductScalingFactor) / precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                pendingReward +=\n                    (snapshot.totalRewardPerToken * userStake) /\n                    precision;\n                pendingCollateral +=\n                    (snapshot.totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (snapshot.totalSBRRewardPerToken * userStake) /\n                        precision;\n                }\n            } else {\n                pendingReward += (totalRewardPerToken * userStake) / precision;\n                pendingCollateral +=\n                    (totalCollateralPerToken * userStake) /\n                    precision;\n                if (calculateSbrRewards) {\n                    pendingSbrRewards +=\n                        (totalSbrRewardPerToken * userStake) /\n                        precision;\n                }\n            }\n        }\n    }\nfunction _updateUserStake(UserInfo storage user) internal {\n        // Adjust user's stake\n        if (user.cumulativeProductScalingFactor != 0) {\n            user.stake = _getUserEffectiveStake(user);\n        }\n\n        // Update user's scaling factor and reset count\n        user.cumulativeProductScalingFactor = stakeScalingFactor;\n        user.stakeResetCount = stakeResetCount;\n    }\nfunction _getUserEffectiveStake(\n        UserInfo memory user\n    ) internal view returns (uint256 stake) {\n        if (user.stakeResetCount == stakeResetCount) {\n            stake =\n                (((user.stake * stakeScalingFactor) * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n        } else {\n            StakeResetSnapshot memory snapshot = stakeResetSnapshots[\n                user.stakeResetCount\n            ];\n            stake =\n                ((user.stake * snapshot.scalingFactor * precision) /\n                    user.cumulativeProductScalingFactor) /\n                precision;\n\n            if (user.stakeResetCount + 1 != stakeResetCount) {\n                snapshot = stakeResetSnapshots[user.stakeResetCount + 1];\n                stake = (stake * snapshot.scalingFactor) / precision;\n            } else {\n                stake = (stake * stakeScalingFactor) / precision;\n            }\n        }\n        /*\n        return\n            (((user.stake * stakeScalingFactor) * precision) /\n                user.cumulativeProductScalingFactor) / precision;\n                */\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}