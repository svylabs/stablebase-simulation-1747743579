{
  "action": {
    "name": "Liquidate",
    "summary": "Initiates liquidation.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "probability": 0.9
  },
  "action_detail": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "pre_execution_parameter_generation_rules": [
      "Find a safe (_safeId) that meets the liquidation criteria.",
      "Safe should exist (safes[_safeId] must not be empty).",
      "collateralAmount should be > 0.",
      "borrowedAmount should be > 0.",
      "If StabilityPool path, StabilityPool should have sufficient funds.",
      "Determine if StabilityPool or secondary mechanism will be used."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Updates",
        "state_update_descriptions": [
          "collateralAmount is reduced.",
          "borrowedAmount might be updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.",
          "totalBorrowedAmount is updated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.",
          "Safe is removed from the safes mapping.",
          "Weight of the Safe is reset."
        ]
      },
      {
        "category": "System Debt and Collateral Updates",
        "state_update_descriptions": [
          "totalCollateral is decreased.",
          "totalDebt is decreased.",
          "cumulativeCollateralPerUnitCollateral is updated if liquidation occurs through the secondary mechanism.",
          "cumulativeDebtPerUnitCollateral is updated if liquidation occurs through the secondary mechanism.",
          "collateralLoss may be updated if liquidation occurs through the secondary mechanism.",
          "debtLoss may be updated if liquidation occurs through the secondary mechanism."
        ]
      },
      {
        "category": "Queue Updates",
        "state_update_descriptions": [
          "Safe is removed from the liquidation queue.",
          "Safe is removed from the redemption queue."
        ]
      },
      {
        "category": "Stability Pool Updates",
        "state_update_descriptions": [
          "StabilityPool's totalStakedRaw is decreased if StabilityPool is used.",
          "StabilityPool's stakeScalingFactor is updated if StabilityPool is used.",
          "SBD token balance of the Stability Pool is reduced if StabilityPool is used."
        ]
      },
      {
        "category": "Rewards Distribution",
        "state_update_descriptions": [
          "Liquidation fee might be distributed to sbrStakingPool or StabilityPool.",
          "Gas compensation refund might be sent to msg.sender."
        ]
      },
      {
        "category": "Protocol Mode Update",
        "state_update_descriptions": [
          "PROTOCOL_MODE may change from BOOTSTRAP to NORMAL."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Validation",
        "rule_descriptions": [
          "safes[_safeId] should no longer exist.",
          "collateralAmount should be zero.",
          "borrowedAmount should be zero."
        ]
      },
      {
        "category": "System Debt and Collateral Validation",
        "rule_descriptions": [
          "totalCollateral should be decreased by the liquidated Safe's collateralAmount.",
          "totalDebt should be decreased by the liquidated Safe's borrowedAmount."
        ]
      },
      {
        "category": "Queue Validation",
        "rule_descriptions": [
          "safesOrderedForLiquidation should no longer contain _safeId.",
          "safesOrderedForRedemption should no longer contain _safeId."
        ]
      },
      {
        "category": "Stability Pool Validation",
        "rule_descriptions": [
          "If StabilityPool is used, totalStakedRaw should be decreased.",
          "If StabilityPool is used, stakeScalingFactor should be updated.",
          "If StabilityPool is used, the SBD token balance of the stability pool should be reduced by the borrowed amount."
        ]
      },
      {
        "category": "Protocol Mode Validation",
        "rule_descriptions": [
          "PROTOCOL_MODE should be NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Event Validation",
        "rule_descriptions": [
          "LiquidatedUsingStabilityPool or LiquidatedUsingSecondaryMechanism event should be emitted.",
          "SafeRemovedFromLiquidationQueue event should be emitted.",
          "SafeRemovedFromRedemptionQueue event should be emitted.",
          "RemovedSafe event should be emitted.",
          "LiquidationFeePaid event should be emitted if fee is paid.",
          "LiquidationGasCompensationPaid event should be emitted if refund is paid."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral held by the contract.",
            "why_is_is_important": "Reflects the overall collateralization of the system.",
            "when_is_it_updated": "When a safe is liquidated.",
            "how_to_validate_state_update": "Check if the totalCollateral has decreased by the liquidated safe's collateral amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by the liquidated safe's collateral amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total amount of debt outstanding in the system.",
            "why_is_is_important": "Reflects the overall debt level of the system.",
            "when_is_it_updated": "When a safe is liquidated.",
            "how_to_validate_state_update": "Verify if the totalDebt has decreased by the liquidated safe's borrowed amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by the liquidated safe's borrowed amount.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the protocol mode, either BOOTSTRAP or NORMAL.",
            "why_is_is_important": "Determines the operational state of the protocol.",
            "when_is_it_updated": "During the liquidation process when total debt is updated.",
            "how_to_validate_state_update": "Check if PROTOCOL_MODE is equal to SBStructs.Mode.NORMAL",
            "has_conditional_updates": true,
            "summary_of_update": "If debt is greater than BOOTSTRAP_MODE_DEBT_THRESHOLD and PROTOCOL_MODE is BOOTSTRAP, then PROTOCOL_MODE updated to NORMAL.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per unit collateral",
            "why_is_is_important": "Important for accurately calculating collateralization ratios and accounting for system-wide debt distribution.",
            "when_is_it_updated": "During the distribution of debt and collateral",
            "how_to_validate_state_update": "Check the cumulativeCollateralPerUnitCollateral",
            "has_conditional_updates": true,
            "summary_of_update": "cumulativeCollateralPerUnitCollateral += collPerUnitColl",
            "conditions": [
              "totalCollateralAfterLiquidation > 0"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral.",
            "why_is_is_important": "Crucial for maintaining an accurate record of the overall debt-to-collateral ratio across the system.",
            "when_is_it_updated": "During the distribution of debt and collateral.",
            "how_to_validate_state_update": "Check cumulativeDebtPerUnitCollateral value",
            "has_conditional_updates": true,
            "summary_of_update": "cumulativeDebtPerUnitCollateral += debtPerUnitColl",
            "conditions": [
              "totalCollateralAfterLiquidation > 0"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks residual collateral loss due to distribution.",
            "why_is_is_important": "Accumulates dust and small discrepancies during debt/collateral redistribution.",
            "when_is_it_updated": "During the distribution of debt and collateral.",
            "how_to_validate_state_update": "Check the collateralLoss value",
            "has_conditional_updates": true,
            "summary_of_update": "collateralLoss = collateralToDistribute - (collPerUnitColl * totalCollateralAfterLiquidation) / PRECISION;",
            "conditions": [
              "totalCollateralAfterLiquidation > 0"
            ]
          },
          {
            "state_variable_name": "debtLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks residual debt loss due to distribution",
            "why_is_is_important": "Accumulates dust and small discrepancies during debt/collateral redistribution.",
            "when_is_it_updated": "During distribution of debt and collateral",
            "how_to_validate_state_update": "Check debtLoss value",
            "has_conditional_updates": true,
            "summary_of_update": "debtLoss = debtToDistribute - (debtPerUnitColl * totalCollateralAfterLiquidation) / PRECISION;",
            "conditions": [
              "totalCollateralAfterLiquidation > 0"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral amount",
            "why_is_is_important": "Tracks the collateral amount of a specific safe",
            "when_is_it_updated": "When _safe is updated, prior to liquidation",
            "how_to_validate_state_update": "Check collateralAmount for safeId in safes mapping",
            "has_conditional_updates": true,
            "summary_of_update": "_safe.collateralAmount += collateralIncrease",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks borrowedAmount amount",
            "why_is_is_important": "Tracks the borrowed amount of a specific safe",
            "when_is_it_updated": "When _safe is updated, prior to liquidation",
            "how_to_validate_state_update": "Check borrowedAmount for safeId in safes mapping",
            "has_conditional_updates": true,
            "summary_of_update": "_safe.borrowedAmount += debtIncrease",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "Safe",
            "what_does_it_track": "Tracks safe information",
            "why_is_is_important": "Represents a safe in the system",
            "when_is_it_updated": "When safe is liquidated, it is removed.",
            "how_to_validate_state_update": "Check safes mapping for safeId",
            "has_conditional_updates": false,
            "summary_of_update": "delete safes[_safeId]",
            "conditions": [
              "_safeId exists"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the head of the queue",
            "why_is_is_important": "Keeps track of first element of queue",
            "when_is_it_updated": "when first element is removed",
            "how_to_validate_state_update": "Check head",
            "has_conditional_updates": true,
            "summary_of_update": "head = node.next",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes[node.next].prev",
            "type": "uint256",
            "what_does_it_track": "Tracks the previous node",
            "why_is_is_important": "Keeps track of previous node",
            "when_is_it_updated": "When first element is removed",
            "how_to_validate_state_update": "Check nodes[node.next].prev",
            "has_conditional_updates": true,
            "summary_of_update": "nodes[node.next].prev = 0",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes[node.prev].next",
            "type": "uint256",
            "what_does_it_track": "Tracks the next node",
            "why_is_is_important": "Keeps track of next node",
            "when_is_it_updated": "Element is being removed",
            "how_to_validate_state_update": "Check nodes[node.prev].next",
            "has_conditional_updates": true,
            "summary_of_update": "nodes[node.prev].next = node.next;",
            "conditions": [
              "node.prev != 0"
            ]
          },
          {
            "state_variable_name": "nodes[node.next].prev",
            "type": "uint256",
            "what_does_it_track": "Tracks the previous node",
            "why_is_is_important": "Keeps track of previous node",
            "when_is_it_updated": "Element is being removed",
            "how_to_validate_state_update": "Check nodes[node.next].prev",
            "has_conditional_updates": true,
            "summary_of_update": "nodes[node.next].prev = node.prev;",
            "conditions": [
              "node.next != 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks tail",
            "why_is_is_important": "Keeps track of last element of queue",
            "when_is_it_updated": "last element is removed",
            "how_to_validate_state_update": "Check tail",
            "has_conditional_updates": true,
            "summary_of_update": "tail = node.prev",
            "conditions": [
              "node.next == 0"
            ]
          },
          {
            "state_variable_name": "nodes[node.prev].next",
            "type": "uint256",
            "what_does_it_track": "Tracks next",
            "why_is_is_important": "Keeps track of the node coming up",
            "when_is_it_updated": "Last element is removed",
            "how_to_validate_state_update": "Check nodes[node.prev].next",
            "has_conditional_updates": true,
            "summary_of_update": "nodes[node.prev].next = 0",
            "conditions": [
              "node.next == 0"
            ]
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "Node",
            "what_does_it_track": "Tracks nodes",
            "why_is_is_important": "Holds data about nodes in the queue",
            "when_is_it_updated": "When element is removed",
            "how_to_validate_state_update": "Check nodes mapping",
            "has_conditional_updates": false,
            "summary_of_update": "delete nodes[id]",
            "conditions": [
              "id exists"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks total burned.",
            "why_is_is_important": "Keeps track of amount burned.",
            "when_is_it_updated": "Amount is being burned",
            "how_to_validate_state_update": "Check totalBurned",
            "has_conditional_updates": true,
            "summary_of_update": "totalBurned += amount",
            "conditions": [
              "from != address(0)",
              "amount > 0",
              "balanceOf(from) >= amount"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply",
            "why_is_is_important": "Important for keeping track of the token supply",
            "when_is_it_updated": "When _burn function is called",
            "how_to_validate_state_update": "Check totalSupply",
            "has_conditional_updates": true,
            "summary_of_update": "_totalSupply -= value",
            "conditions": [
              "account == address(0)"
            ]
          },
          {
            "state_variable_name": "_balances[from]",
            "type": "uint256",
            "what_does_it_track": "Tracks balance of user",
            "why_is_is_important": "Important for keeping track of balance of user",
            "when_is_it_updated": "When _burn function is called",
            "how_to_validate_state_update": "Check balances mapping",
            "has_conditional_updates": true,
            "summary_of_update": "_balances[from] = fromBalance - value",
            "conditions": [
              "fromBalance >= value"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks the staking scaling factor.",
            "why_is_is_important": "Keeps track of the scaling factor",
            "when_is_it_updated": "when performLiquidation is called",
            "how_to_validate_state_update": "Check stakeScalingFactor",
            "has_conditional_updates": true,
            "summary_of_update": "stakeScalingFactor = cumulativeProductScalingFactor",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total collateral per token",
            "why_is_is_important": "Keeps track of total collateral per token",
            "when_is_it_updated": "When performLiquidation is called",
            "how_to_validate_state_update": "Check totalCollateralPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateralPerToken += _totalCollateralPerToken",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral Loss",
            "why_is_is_important": "Keeps track of the loss of collateral",
            "when_is_it_updated": "When performLiquidation is called",
            "how_to_validate_state_update": "Check collateralLoss",
            "has_conditional_updates": true,
            "summary_of_update": "collateralLoss =  _collateral - (((_totalCollateralPerToken * totalStakedRaw * precision) / previousScalingFactor)/precision)",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks total amount staked",
            "why_is_is_important": "Keeps track of the amount being staked",
            "when_is_it_updated": "Amount being unstaked",
            "how_to_validate_state_update": "Check totalStakedRaw",
            "has_conditional_updates": true,
            "summary_of_update": "totalStakedRaw -= amount",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Tracks if reward sender active",
            "why_is_is_important": "Checks if it can recieve rewards",
            "when_is_it_updated": "When totalStakedRaw is 0",
            "how_to_validate_state_update": "Check rewardSenderActive",
            "has_conditional_updates": true,
            "summary_of_update": "IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(false)",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots[stakeResetCount]",
            "type": "StakeResetSnapshot",
            "what_does_it_track": "Tracks reset snapshot",
            "why_is_is_important": "Snapshot of scaling factor",
            "when_is_it_updated": "When scaling factor drops too low",
            "how_to_validate_state_update": "Check stakeResetSnapshots",
            "has_conditional_updates": true,
            "summary_of_update": "stakeResetSnapshots[stakeResetCount] = resetSnapshot",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral per token.",
            "why_is_is_important": "Tracks collateral for all users",
            "when_is_it_updated": "The condition when the scaling factor resets",
            "how_to_validate_state_update": "Check totalCollateralPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateralPerToken = 0",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total reward per token",
            "why_is_is_important": "Snapshot of rewards",
            "when_is_it_updated": "The condition when the scaling factor resets",
            "how_to_validate_state_update": "Check totalRewardPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "totalRewardPerToken = 0",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total sbr reward per token",
            "why_is_is_important": "Snapshot of rewards",
            "when_is_it_updated": "The condition when the scaling factor resets",
            "how_to_validate_state_update": "Check totalSbrRewardPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "totalSbrRewardPerToken = 0",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks stake scaling factor",
            "why_is_is_important": "Snapshot of scaling factor",
            "when_is_it_updated": "The condition when the scaling factor resets",
            "how_to_validate_state_update": "Check stakeScalingFactor",
            "has_conditional_updates": true,
            "summary_of_update": "stakeScalingFactor = precision",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "uint256",
            "what_does_it_track": "Tracks the count of stake resets",
            "why_is_is_important": "Snapshot of resets",
            "when_is_it_updated": "The condition when the scaling factor resets",
            "how_to_validate_state_update": "Check stakeResetCount",
            "has_conditional_updates": true,
            "summary_of_update": "stakeResetCount++",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total collateral per token",
            "why_is_is_important": "Reward of collateral",
            "when_is_it_updated": "When collateral is rewarded",
            "how_to_validate_state_update": "Check totalCollateralPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateralPerToken += _collateralPerToken;",
            "conditions": [
              "amount > 0",
              "msg.value == amount"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral loss",
            "why_is_is_important": "Tracks loss of collateral",
            "when_is_it_updated": "When collateral is rewarded",
            "how_to_validate_state_update": "Check collateralLoss",
            "has_conditional_updates": true,
            "summary_of_update": "collateralLoss = _totalAmount - (((_collateralPerToken * _totalStakedRaw * precision) / stakeScalingFactor) / precision);",
            "conditions": [
              "amount > 0",
              "msg.value == amount"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral per token.",
            "why_is_is_important": "Tracks total amount of collateral.",
            "when_is_it_updated": "When collateral reward is added.",
            "how_to_validate_state_update": "Check totalCollateralPerToken",
            "has_conditional_updates": true,
            "summary_of_update": "totalCollateralPerToken += (_amount * PRECISION) / _totalStake",
            "conditions": [
              "_totalStake > 0",
              "msg.value == _amount"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidate() external nonReentrant {\n        uint256 gasStart = gasleft();\n        uint256 _safeId = safesOrderedForLiquidation.getTail();\n        _liquidate(_safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getTail() external view override returns (uint256) {\n        return tail;\n    }\nfunction getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}