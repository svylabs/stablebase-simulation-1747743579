{
  "action": {
    "name": "Liquidate",
    "summary": "Initiates liquidation.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "probability": 0.9
  },
  "action_detail": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "pre_execution_parameter_generation_rules": [
      "The function 'liquidate()' does not require any direct parameters as input.",
      "A Safe must exist in the 'safesOrderedForLiquidation' queue, as the function liquidates the safe at the tail of this queue.",
      "The safe at the tail of 'safesOrderedForLiquidation' must be in a liquidatable state, meaning its 'collateralValue' must be less than the calculated 'liquidationRatio' applied to its 'borrowedAmount'. This implies that the 'priceOracle.fetchPrice()' result, when multiplied by the safe's collateral, must fall below the liquidation threshold.",
      "The safe to be liquidated must have a 'collateralAmount' greater than zero.",
      "The safe to be liquidated must have a 'borrowedAmount' greater than zero."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "StableBaseCDP Contract State Updates",
        "state_update_descriptions": [
          "The 'safe.borrowedAmount' and 'safe.totalBorrowedAmount' for the safe being liquidated are increased based on the 'cumulativeDebtPerUnitCollateral' and 'liquidationSnapshot.debtPerCollateralSnapshot' in the '_updateSafe' function.",
          "The 'safe.collateralAmount' for the safe being liquidated is increased based on the 'cumulativeCollateralPerUnitCollateral' and 'liquidationSnapshot.collateralPerCollateralSnapshot' in the '_updateSafe' function.",
          "The 'liquidationSnapshots[_safeId].debtPerCollateralSnapshot' and 'liquidationSnapshots[_safeId].collateralPerCollateralSnapshot' are updated to the current 'cumulativeDebtPerUnitCollateral' and 'cumulativeCollateralPerUnitCollateral' respectively.",
          "The 'totalCollateral' global variable is decreased by the 'collateralAmount' of the liquidated safe, but first increased by any 'collateralIncrease' from '_updateSafe'.",
          "The 'totalDebt' global variable is decreased by the 'borrowedAmount' of the liquidated safe, but first increased by any 'debtIncrease' from '_updateSafe'.",
          "The 'Safe' struct corresponding to the liquidated safe ID ('safes[_safeId]') is deleted from storage.",
          "The owner of the safe NFT ('_owners[_safeId]') is set to address(0), effectively burning the NFT.",
          "The ERC721 balance of the previous owner of the safe NFT ('_balances[previousOwner]') is decreased by 1.",
          "If the liquidation is handled by distributing debt and collateral to existing borrowers, 'cumulativeCollateralPerUnitCollateral' is increased.",
          "If the liquidation is handled by distributing debt and collateral to existing borrowers, 'cumulativeDebtPerUnitCollateral' is increased.",
          "If the liquidation is handled by distributing debt and collateral to existing borrowers, 'collateralLoss' and 'debtLoss' in StableBaseCDP are updated.",
          "If the 'totalDebt' exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD' during the initial safe update, 'PROTOCOL_MODE' may transition from 'BOOTSTRAP' to 'NORMAL'.",
          "If the StabilityPool's 'totalStakedRaw' becomes zero after a liquidation, 'stabilityPoolCanReceiveRewards' in StableBaseCDP is set to 'false' via an external call."
        ]
      },
      {
        "category": "OrderedDoublyLinkedList (Liquidation Queue) State Updates",
        "state_update_descriptions": [
          "The liquidated safe ID is removed from the 'safesOrderedForLiquidation' linked list, updating the 'head', 'tail', and 'nodes' mappings."
        ]
      },
      {
        "category": "OrderedDoublyLinkedList (Redemption Queue) State Updates",
        "state_update_descriptions": [
          "The liquidated safe ID is removed from the 'safesOrderedForRedemption' linked list, updating the 'head', 'tail', and 'nodes' mappings."
        ]
      },
      {
        "category": "StabilityPool Contract State Updates (Conditional)",
        "state_update_descriptions": [
          "If 'stabilityPool.isLiquidationPossible' returns true, 'totalStakedRaw' in StabilityPool is decreased by the 'borrowedAmount' of the liquidated safe.",
          "If 'stabilityPool.isLiquidationPossible' returns true, 'stakeScalingFactor' in StabilityPool is updated based on the amount liquidated.",
          "If 'stabilityPool.isLiquidationPossible' returns true, 'totalCollateralPerToken' in StabilityPool is updated based on the liquidated collateral.",
          "If 'stabilityPool.isLiquidationPossible' returns true, 'collateralLoss' in StabilityPool is updated.",
          "If 'cumulativeProductScalingFactor' falls below 'minimumScalingFactor' in StabilityPool, a new 'StakeResetSnapshot' is added to 'stakeResetSnapshots', and 'totalCollateralPerToken', 'totalRewardPerToken', 'totalSbrRewardPerToken', and 'stakeScalingFactor' are reset to their initial values in StabilityPool.",
          "If StabilityPool receives a portion of the liquidation fee as a reward, 'totalCollateralPerToken' and 'collateralLoss' in StabilityPool are updated via 'addCollateralReward'."
        ]
      },
      {
        "category": "DFIDToken Contract State Updates (Conditional)",
        "state_update_descriptions": [
          "If liquidation uses the Stability Pool, 'sbdToken.balanceOf(address(stabilityPool))' is decreased by the 'borrowedAmount'.",
          "If liquidation uses the Stability Pool, 'sbdToken.totalSupply' is decreased by the 'borrowedAmount'.",
          "If liquidation uses the Stability Pool, 'sbdToken.totalBurned' is increased by the 'borrowedAmount'."
        ]
      },
      {
        "category": "DFIREStaking Contract State Updates (Conditional)",
        "state_update_descriptions": [
          "If 'sbrStakingPoolCanReceiveRewards' is true and the DFIREStaking contract receives a portion of the liquidation fee, 'totalCollateralPerToken' in DFIREStaking is updated via 'addCollateralReward'."
        ]
      },
      {
        "category": "ETH Transfers",
        "state_update_descriptions": [
          "The 'msg.sender' of the transaction receives an ETH refund ('refund' amount)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Core Liquidation Outcome",
        "rule_descriptions": [
          "Verify that either 'LiquidatedUsingStabilityPool' or 'LiquidatedUsingSecondaryMechanism' event is emitted.",
          "Verify that 'totalCollateral' in 'StableBaseCDP' has decreased by the net collateral change of the liquidated safe (initial collateral + update collateral increase - liquidation collateral).",
          "Verify that 'totalDebt' in 'StableBaseCDP' has decreased by the net borrowed amount change of the liquidated safe (initial borrowed amount + update debt increase - liquidation borrowed amount).",
          "Verify that the 'Safe' struct for the liquidated ID ('safes[_safeId]') is effectively deleted or reset to default values (e.g., all fields are zero).",
          "Verify that the owner of the safe NFT ('_ownerOf(_safeId)') is now address(0).",
          "Verify that the ERC721 balance of the previous owner of the safe NFT ('balanceOf(previousOwner)') has decreased by 1."
        ]
      },
      {
        "category": "Queue State Validation",
        "rule_descriptions": [
          "Verify that the liquidated safe ID is no longer present in the 'safesOrderedForLiquidation' linked list (e.g., 'safesOrderedForLiquidation.getNode(_safeId).value' is 0, and the queue's head/tail are updated correctly).",
          "Verify that the liquidated safe ID is no longer present in the 'safesOrderedForRedemption' linked list (e.g., 'safesOrderedForRedemption.getNode(_safeId).value' is 0, and the queue is updated if applicable)."
        ]
      },
      {
        "category": "StabilityPool Specific Validation (Conditional)",
        "rule_descriptions": [
          "If 'stabilityPool.isLiquidationPossible' was true prior to execution:",
          "Verify that 'stabilityPool.totalStakedRaw' has decreased by the 'borrowedAmount' that was liquidated.",
          "Verify that 'stabilityPool.stakeScalingFactor' has been updated as per the liquidation logic.",
          "Verify that 'stabilityPool.totalCollateralPerToken' has been updated.",
          "Verify that 'stabilityPool.collateralLoss' is updated.",
          "If 'stabilityPool.totalStakedRaw' became zero, verify that 'StableBaseCDP.stabilityPoolCanReceiveRewards' is 'false'.",
          "If a 'ScalingFactorReset' occurred in StabilityPool, verify 'totalCollateralPerToken', 'totalRewardPerToken', 'totalSbrRewardPerToken', and 'stakeScalingFactor' in StabilityPool are reset to their initial values, and a 'ScalingFactorReset' event is emitted."
        ]
      },
      {
        "category": "DFIDToken Specific Validation (Conditional)",
        "rule_descriptions": [
          "If liquidation used the Stability Pool, verify that 'sbdToken.balanceOf(address(stabilityPool))' has decreased by the 'borrowedAmount'.",
          "If liquidation used the Stability Pool, verify that 'sbdToken.totalSupply' has decreased by the 'borrowedAmount'.",
          "If liquidation used the Stability Pool, verify that 'sbdToken.totalBurned' has increased by the 'borrowedAmount'."
        ]
      },
      {
        "category": "Secondary Mechanism Specific Validation (Conditional)",
        "rule_descriptions": [
          "If 'stabilityPool.isLiquidationPossible' was false prior to execution:",
          "Verify that 'StableBaseCDP.cumulativeCollateralPerUnitCollateral' has increased.",
          "Verify that 'StableBaseCDP.cumulativeDebtPerUnitCollateral' has increased.",
          "Verify that 'StableBaseCDP.collateralLoss' and 'StableBaseCDP.debtLoss' have been updated."
        ]
      },
      {
        "category": "Fee and Compensation Validation",
        "rule_descriptions": [
          "Verify that the 'msg.sender's ETH balance has increased by the calculated 'refund' amount.",
          "If 'sbrStakingPoolCanReceiveRewards' was true and the DFIREStaking contract received a fee, verify 'dfireTokenStaking.totalCollateralPerToken' was updated.",
          "If 'stabilityPoolCanReceiveRewards' was true (and SBR staking pool did not receive the fee), verify 'stabilityPool.totalCollateralPerToken' was updated due to fee distribution."
        ]
      },
      {
        "category": "Event Emissions",
        "rule_descriptions": [
          "Verify that 'SafeUpdated' event is emitted if the safe's debt/collateral amounts were updated prior to liquidation.",
          "Verify that 'SafeRemovedFromLiquidationQueue' and 'SafeRemovedFromRedemptionQueue' events are emitted.",
          "Verify that 'RemovedSafe' event is emitted.",
          "Verify that a 'Transfer' event (ERC721 burn) is emitted from the safe owner to address(0).",
          "Verify that 'LiquidationGasCompensationPaid' event is emitted.",
          "Verify that 'LiquidationFeePaid' event is emitted if a liquidation fee was paid to the staking pool or stability pool.",
          "If liquidation used Stability Pool, verify that 'LiquidationPerformed' event is emitted from the StabilityPool contract.",
          "If liquidation used Stability Pool, verify that a 'Burn' event is emitted from the DFIDToken contract.",
          "If collateral rewards were added to DFIREStaking or StabilityPool, verify 'CollateralRewardAdded' event from the respective contract."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[_safeId].borrowedAmount",
            "type": "increase",
            "what_does_it_track": "The current outstanding debt of a specific Safe (CDP).",
            "why_is_is_important": "Ensures that the Safe's debt accurately reflects system-wide accrued debt before liquidation.",
            "when_is_it_updated": "Conditionally updated within the '_updateSafe' internal function before the main liquidation logic.",
            "how_to_validate_state_update": "Verify that the new 'borrowedAmount' equals the previous 'borrowedAmount' plus the calculated 'debtIncrease' due to system accruals.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount for the specific safe is increased to account for accrued debt since its last snapshot.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].totalBorrowedAmount",
            "type": "increase",
            "what_does_it_track": "The total amount of debt ever borrowed against a specific Safe, including accrued debt.",
            "why_is_is_important": "Provides a historical record of the total debt associated with a Safe.",
            "when_is_it_updated": "Conditionally updated within the '_updateSafe' internal function before the main liquidation logic.",
            "how_to_validate_state_update": "Verify that the new 'totalBorrowedAmount' equals the previous 'totalBorrowedAmount' plus the calculated 'debtIncrease'.",
            "has_conditional_updates": true,
            "summary_of_update": "The total borrowed amount for the specific safe is increased to reflect the total debt incurred over its lifetime, including system accruals.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "set",
            "what_does_it_track": "A snapshot of the 'cumulativeDebtPerUnitCollateral' at the last update of a specific Safe.",
            "why_is_is_important": "Crucial for calculating future debt accruals for the Safe.",
            "when_is_it_updated": "Conditionally updated within the '_updateSafe' internal function before the main liquidation logic.",
            "how_to_validate_state_update": "Verify that 'debtPerCollateralSnapshot' is set to the current value of 'cumulativeDebtPerUnitCollateral'.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the cumulative debt per unit collateral for the specific safe is updated to the current system value.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[_safeId].collateralAmount",
            "type": "increase",
            "what_does_it_track": "The current amount of collateral held by a specific Safe.",
            "why_is_is_important": "Ensures that the Safe's collateral accurately reflects system-wide accrued collateral before liquidation.",
            "when_is_it_updated": "Conditionally updated within the '_updateSafe' internal function before the main liquidation logic.",
            "how_to_validate_state_update": "Verify that the new 'collateralAmount' equals the previous 'collateralAmount' plus the calculated 'collateralIncrease' due to system accruals.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateral amount for the specific safe is increased to account for accrued collateral since its last snapshot.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "set",
            "what_does_it_track": "A snapshot of the 'cumulativeCollateralPerUnitCollateral' at the last update of a specific Safe.",
            "why_is_is_important": "Crucial for calculating future collateral accruals for the Safe.",
            "when_is_it_updated": "Conditionally updated within the '_updateSafe' internal function before the main liquidation logic.",
            "how_to_validate_state_update": "Verify that 'collateralPerCollateralSnapshot' is set to the current value of 'cumulativeCollateralPerUnitCollateral'.",
            "has_conditional_updates": true,
            "summary_of_update": "The snapshot of the cumulative collateral per unit collateral for the specific safe is updated to the current system value.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "decrease",
            "what_does_it_track": "The aggregate sum of all collateral locked in active Safes within the protocol.",
            "why_is_is_important": "Reflects the total backing value for the protocol's outstanding debt.",
            "when_is_it_updated": "Conditionally increased within '_updateSafe' if the safe's snapshot is outdated, then unconditionally decreased by the safe's collateral amount within '_liquidate'.",
            "how_to_validate_state_update": "If the safe's position was updated, 'totalCollateral' first increases by 'collateralIncrease'. Then, it decreases by the (potentially updated) 'collateralAmount' of the liquidated safe. The net effect is a decrease by the initial 'collateralAmount' of the liquidated safe.",
            "has_conditional_updates": true,
            "summary_of_update": "The total collateral held by the protocol decreases by the amount of collateral in the liquidated Safe. This also includes a conditional increase if the safe's position was updated prior to liquidation.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "None"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "decrease",
            "what_does_it_track": "The aggregate sum of all outstanding debt (SBD tokens) across active Safes.",
            "why_is_is_important": "Represents the total amount of stablecoin minted by the protocol.",
            "when_is_it_updated": "Conditionally increased within '_updateSafe' if the safe's snapshot is outdated, then unconditionally decreased by the safe's borrowed amount within '_liquidate'. It is updated via the '_updateTotalDebt' function.",
            "how_to_validate_state_update": "If the safe's position was updated, 'totalDebt' first increases by 'debtIncrease'. Then, it decreases by the (potentially updated) 'borrowedAmount' of the liquidated safe. The net effect is a decrease by the initial 'borrowedAmount' of the liquidated safe. The protocol mode might also change based on the new total debt.",
            "has_conditional_updates": true,
            "summary_of_update": "The total debt in the protocol decreases by the borrowed amount of the liquidated Safe. This also includes a conditional increase if the safe's position was updated prior to liquidation, and may trigger a protocol mode change.",
            "conditions": [
              "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral",
              "None",
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "set",
            "what_does_it_track": "The current operational mode of the protocol, influencing certain behaviors.",
            "why_is_is_important": "Dictates the protocol's behavior, especially during its initial bootstrapping phase.",
            "when_is_it_updated": "Conditionally updated within '_updateTotalDebt', which is called both from '_updateSafe' and '_liquidate'.",
            "how_to_validate_state_update": "Verify that 'PROTOCOL_MODE' changes from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD' when '_updateTotalDebt' is called.",
            "has_conditional_updates": true,
            "summary_of_update": "The protocol's operating mode is switched from 'BOOTSTRAP' to 'NORMAL' if the 'totalDebt' surpasses a predefined threshold.",
            "conditions": [
              "totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "increase",
            "what_does_it_track": "A cumulative factor used to distribute collateral from liquidations to existing safes proportionally.",
            "why_is_is_important": "Ensures fair distribution of liquidated collateral to non-liquidated safes.",
            "when_is_it_updated": "Updated when liquidation is performed using the secondary mechanism (i.e., not via the Stability Pool).",
            "how_to_validate_state_update": "Verify that it increases by `(collateralToDistribute * PRECISION) / totalCollateralAfterLiquidation` when the secondary liquidation mechanism is used.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases to account for collateral distributed among remaining active safes when the stability pool cannot perform the liquidation.",
            "conditions": [
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "increase",
            "what_does_it_track": "A cumulative factor used to distribute debt from liquidations to existing safes proportionally.",
            "why_is_is_important": "Ensures fair distribution of liquidated debt to non-liquidated safes.",
            "when_is_it_updated": "Updated when liquidation is performed using the secondary mechanism (i.e., not via the Stability Pool).",
            "how_to_validate_state_update": "Verify that it increases by `(debtToDistribute * PRECISION) / totalCollateralAfterLiquidation` when the secondary liquidation mechanism is used.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases to account for debt distributed among remaining active safes when the stability pool cannot perform the liquidation.",
            "conditions": [
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "set",
            "what_does_it_track": "A small remainder of collateral that cannot be perfectly distributed during secondary liquidations.",
            "why_is_is_important": "Prevents loss of small collateral amounts due to precision issues.",
            "when_is_it_updated": "Updated when liquidation is performed using the secondary mechanism (i.e., not via the Stability Pool).",
            "how_to_validate_state_update": "Verify that it is set to the remainder after distributing collateral, i.e., `collateralToDistribute - (collPerUnitColl * totalCollateralAfterLiquidation) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "Stores any residual collateral that could not be precisely distributed among remaining safes due to fractional amounts.",
            "conditions": [
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "debtLoss",
            "type": "set",
            "what_does_it_track": "A small remainder of debt that cannot be perfectly distributed during secondary liquidations.",
            "why_is_is_important": "Prevents loss of small debt amounts due to precision issues.",
            "when_is_it_updated": "Updated when liquidation is performed using the secondary mechanism (i.e., not via the Stability Pool).",
            "how_to_validate_state_update": "Verify that it is set to the remainder after distributing debt, i.e., `debtToDistribute - (debtPerUnitColl * totalCollateralAfterLiquidation) / PRECISION`.",
            "has_conditional_updates": true,
            "summary_of_update": "Stores any residual debt that could not be precisely distributed among remaining safes due to fractional amounts.",
            "conditions": [
              "!stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "safes[_safeId]",
            "type": "delete",
            "what_does_it_track": "A mapping of Safe IDs to their corresponding Safe struct, storing collateral, borrowed amount, etc.",
            "why_is_is_important": "Removes the liquidated Safe from the protocol's active records.",
            "when_is_it_updated": "Unconditionally deleted at the end of the liquidation process.",
            "how_to_validate_state_update": "Confirm that the entry for the liquidated `_safeId` in the 'safes' mapping no longer exists or returns default values.",
            "has_conditional_updates": false,
            "summary_of_update": "The entire 'Safe' struct corresponding to the liquidated Safe ID is removed from the mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[ownerOf(_safeId)]",
            "type": "decrease",
            "what_does_it_track": "The number of Safe NFTs (ERC721 tokens) held by each address.",
            "why_is_is_important": "Maintains accurate ownership records for Safe NFTs.",
            "when_is_it_updated": "Unconditionally decreased when the Safe NFT is burned as part of the liquidation process.",
            "how_to_validate_state_update": "Verify that the balance of the previous owner of the liquidated Safe ID decreases by 1.",
            "has_conditional_updates": false,
            "summary_of_update": "The ERC721 balance of the Safe's owner is decreased as the Safe NFT is burned.",
            "conditions": []
          },
          {
            "state_variable_name": "_owners[_safeId]",
            "type": "set",
            "what_does_it_track": "A mapping from Safe NFT ID to its owner.",
            "why_is_is_important": "Marks the Safe NFT as no longer owned and prevents further transfers.",
            "when_is_it_updated": "Unconditionally set to 'address(0)' when the Safe NFT is burned.",
            "how_to_validate_state_update": "Verify that `_owners[_safeId]` is set to `address(0)`.",
            "has_conditional_updates": false,
            "summary_of_update": "The owner of the liquidated Safe NFT is set to the zero address, indicating it has been burned.",
            "conditions": []
          },
          {
            "state_variable_name": "_tokenApprovals[_safeId]",
            "type": "set",
            "what_does_it_track": "A mapping from Safe NFT ID to an approved address for single-token transfers.",
            "why_is_is_important": "Revokes any third-party control over the burned Safe NFT.",
            "when_is_it_updated": "Unconditionally set to 'address(0)' when the Safe NFT is burned.",
            "how_to_validate_state_update": "Verify that `_tokenApprovals[_safeId]` is set to `address(0)`.",
            "has_conditional_updates": false,
            "summary_of_update": "Any existing ERC721 approval for the liquidated Safe NFT is cleared.",
            "conditions": []
          },
          {
            "state_variable_name": "stabilityPoolCanReceiveRewards",
            "type": "set",
            "what_does_it_track": "A boolean indicating if the Stability Pool is currently eligible to receive rewards.",
            "why_is_is_important": "Controls the flow of certain rewards to the Stability Pool, preventing rewards to an empty pool.",
            "when_is_it_updated": "Conditionally updated if the stability pool performs liquidation and its 'totalStakedRaw' drops to zero.",
            "how_to_validate_state_update": "If liquidation was via stability pool, check if 'totalStakedRaw' became zero AND 'rewardSenderActive' is true; if so, verify 'stabilityPoolCanReceiveRewards' is false.",
            "has_conditional_updates": true,
            "summary_of_update": "This flag is set to false if the Stability Pool is used for liquidation and its total staked amount falls to zero while reward sender is active.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "totalStakedRaw == 0 && rewardSenderActive"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[_safeId].value",
            "type": "delete",
            "what_does_it_track": "Stores the value of each node in the linked list (which corresponds to a Safe ID).",
            "why_is_is_important": "Removes the liquidated Safe's entry from the ordered list of safes for both liquidation and redemption queues.",
            "when_is_it_updated": "Unconditionally deleted when a node is removed (i.e., when a Safe is liquidated).",
            "how_to_validate_state_update": "Verify that `nodes[_safeId].value` is zero for both liquidation and redemption queues.",
            "has_conditional_updates": false,
            "summary_of_update": "The value (Safe ID) of the node representing the liquidated safe is removed from the linked list.",
            "conditions": []
          },
          {
            "state_variable_name": "nodes[_safeId].prev",
            "type": "delete",
            "what_does_it_track": "Stores the ID of the previous node in the linked list.",
            "why_is_is_important": "Maintains the integrity of the doubly linked list by removing the liquidated Safe's link.",
            "when_is_it_updated": "Unconditionally deleted when a node is removed (i.e., when a Safe is liquidated).",
            "how_to_validate_state_update": "Verify that `nodes[_safeId].prev` is zero for both liquidation and redemption queues.",
            "has_conditional_updates": false,
            "summary_of_update": "The 'prev' pointer of the node representing the liquidated safe is removed from the linked list.",
            "conditions": []
          },
          {
            "state_variable_name": "nodes[_safeId].next",
            "type": "delete",
            "what_does_it_track": "Stores the ID of the next node in the linked list.",
            "why_is_is_important": "Maintains the integrity of the doubly linked list by removing the liquidated Safe's link.",
            "when_is_it_updated": "Unconditionally deleted when a node is removed (i.e., when a Safe is liquidated).",
            "how_to_validate_state_update": "Verify that `nodes[_safeId].next` is zero for both liquidation and redemption queues.",
            "has_conditional_updates": false,
            "summary_of_update": "The 'next' pointer of the node representing the liquidated safe is removed from the linked list.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "set",
            "what_does_it_track": "The ID of the first node in the doubly linked list.",
            "why_is_is_important": "Maintains the entry point for iterating through the ordered list of safes.",
            "when_is_it_updated": "Conditionally updated if the liquidated Safe was at the head of the queue.",
            "how_to_validate_state_update": "If the removed node was the head (`node.prev == 0`), verify that 'head' is updated to the 'next' node's ID.",
            "has_conditional_updates": true,
            "summary_of_update": "The head of the linked list is updated if the liquidated safe was the first element in either the liquidation or redemption queue.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "set",
            "what_does_it_track": "The ID of the last node in the doubly linked list.",
            "why_is_is_important": "Maintains the end point for iterating through the ordered list of safes.",
            "when_is_it_updated": "Conditionally updated if the liquidated Safe was at the tail of the queue.",
            "how_to_validate_state_update": "If the removed node was the tail (`node.next == 0`), verify that 'tail' is updated to the 'prev' node's ID.",
            "has_conditional_updates": true,
            "summary_of_update": "The tail of the linked list is updated if the liquidated safe was the last element in either the liquidation or redemption queue.",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[address(stabilityPool)]",
            "type": "decrease",
            "what_does_it_track": "The SBD token balance of an address.",
            "why_is_is_important": "Reflects the consumption of SBD tokens from the Stability Pool during liquidation.",
            "when_is_it_updated": "Conditionally updated if the liquidation is handled by the Stability Pool, causing SBD tokens to be burned.",
            "how_to_validate_state_update": "Verify that the balance of the Stability Pool (`_balances[address(stabilityPool)]`) decreases by the `borrowedAmount` if liquidation uses the Stability Pool.",
            "has_conditional_updates": true,
            "summary_of_update": "The SBD token balance of the Stability Pool is decreased as the SBD debt of the liquidated safe is burned.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "decrease",
            "what_does_it_track": "The total number of SBD tokens in existence.",
            "why_is_is_important": "Maintains an accurate record of the total SBD token supply.",
            "when_is_it_updated": "Conditionally updated if the liquidation is handled by the Stability Pool, leading to SBD token burning.",
            "how_to_validate_state_update": "Verify that `totalSupply` decreases by the `borrowedAmount` if liquidation uses the Stability Pool.",
            "has_conditional_updates": true,
            "summary_of_update": "The total circulating supply of SBD tokens is decreased due to the burning of the borrowed SBD debt.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "increase",
            "what_does_it_track": "The total sum of SBD tokens that have been permanently removed from circulation.",
            "why_is_is_important": "Provides a metric for the deflationary mechanism of the SBD token.",
            "when_is_it_updated": "Conditionally updated if the liquidation is handled by the Stability Pool, contributing to the burned amount.",
            "how_to_validate_state_update": "Verify that `totalBurned` increases by the `borrowedAmount` if liquidation uses the Stability Pool.",
            "has_conditional_updates": true,
            "summary_of_update": "The cumulative amount of SBD tokens burned by the protocol is increased.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "set",
            "what_does_it_track": "A factor used to adjust the effective stake of users in the Stability Pool over time.",
            "why_is_is_important": "Ensures accurate calculation of user rewards and collateral shares despite changes in total staked amount.",
            "when_is_it_updated": "Conditionally updated if the Stability Pool performs liquidation. It's also conditionally reset if it drops below a minimum threshold.",
            "how_to_validate_state_update": "If liquidation is performed via Stability Pool, verify `stakeScalingFactor` is set to `cumulativeProductScalingFactor`. If `cumulativeProductScalingFactor` falls below `minimumScalingFactor`, verify it's reset to `precision`.",
            "has_conditional_updates": true,
            "summary_of_update": "The scaling factor used for calculating stake value is updated based on the liquidation amount. It can be reset to its initial `precision` value if it falls below a minimum threshold.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "increase",
            "what_does_it_track": "The total amount of collateral rewards accumulated per unit of staked SBD in the Stability Pool.",
            "why_is_is_important": "Determines the share of collateral rewards that each staker is entitled to.",
            "when_is_it_updated": "Conditionally increased during liquidation, or when collateral rewards are added. It is reset to 0 if the scaling factor is reset.",
            "how_to_validate_state_update": "If liquidation is performed, verify an increase by `((_collateral * previousScalingFactor * precision) / totalStakedRaw) / precision`. If collateral reward is added, verify an increase by `((_totalAmount * stakeScalingFactor * precision) / _totalStakedRaw) / precision`. If a scaling factor reset occurs, verify it's reset to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "The accumulated collateral reward per unit of staked token increases due to liquidation or added collateral rewards. It is reset to zero if the `stakeScalingFactor` is reset.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "sbrStakingPoolCanReceiveRewards == false && stabilityPoolCanReceiveRewards == true",
              "sbrStakingPoolCanReceiveRewards == true && dfireTokenStaking.addCollateralReward(...) fails && stabilityPoolCanReceiveRewards == true",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "set",
            "what_does_it_track": "A remainder of collateral from liquidations or rewards that could not be perfectly distributed due to precision.",
            "why_is_is_important": "Prevents loss of small collateral amounts due to rounding errors during distribution.",
            "when_is_it_updated": "Conditionally updated when the Stability Pool performs liquidation or receives collateral rewards.",
            "how_to_validate_state_update": "If liquidation or collateral reward addition happens, verify 'collateralLoss' is set to the remainder after distribution calculation.",
            "has_conditional_updates": true,
            "summary_of_update": "Stores any fractional amount of collateral that could not be perfectly distributed among stakers during liquidation or collateral reward distribution.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "sbrStakingPoolCanReceiveRewards == false && stabilityPoolCanReceiveRewards == true",
              "sbrStakingPoolCanReceiveRewards == true && dfireTokenStaking.addCollateralReward(...) fails && stabilityPoolCanReceiveRewards == true"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "decrease",
            "what_does_it_track": "The total unprocessed amount of SBD tokens staked by users in the Stability Pool.",
            "why_is_is_important": "Reflects the total liquidity available for liquidations in the pool.",
            "when_is_it_updated": "Conditionally decreased if the Stability Pool is used for liquidation.",
            "how_to_validate_state_update": "Verify that `totalStakedRaw` decreases by the `amount` (borrowed amount) when liquidation is performed via the Stability Pool.",
            "has_conditional_updates": true,
            "summary_of_update": "The total raw amount of SBD tokens staked in the Stability Pool decreases by the amount of debt absorbed from the liquidated Safe.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots[stakeResetCount]",
            "type": "set",
            "what_does_it_track": "A historical record of Stability Pool state variables at specific reset points.",
            "why_is_is_important": "Allows for accurate accounting of rewards for users who staked across multiple scaling factor resets.",
            "when_is_it_updated": "Conditionally updated if the cumulative product scaling factor drops below a certain minimum, triggering a reset.",
            "how_to_validate_state_update": "If a scaling factor reset occurs, verify that a new snapshot is recorded at the `stakeResetCount` index, containing the current `scalingFactor`, `totalRewardPerToken`, `totalCollateralPerToken`, and `totalSBRRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "A snapshot of key state variables (scaling factor, total rewards/collateral per token) is recorded before a scaling factor reset.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "set",
            "what_does_it_track": "The total amount of reward tokens accumulated per unit of staked SBD.",
            "why_is_is_important": "Prepares for the accurate accumulation of new rewards after a scaling factor reset.",
            "when_is_it_updated": "Conditionally reset to 0 if the cumulative product scaling factor drops below a certain minimum.",
            "how_to_validate_state_update": "If a scaling factor reset occurs, verify that 'totalRewardPerToken' is set to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "The accumulated reward token per unit of staked token is reset to zero when the scaling factor is reset, clearing it for new reward accumulation.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "set",
            "what_does_it_track": "The total amount of SBR rewards accumulated per unit of staked SBD.",
            "why_is_is_important": "Prepares for the accurate accumulation of new SBR rewards after a scaling factor reset.",
            "when_is_it_updated": "Conditionally reset to 0 if the cumulative product scaling factor drops below a certain minimum.",
            "how_to_validate_state_update": "If a scaling factor reset occurs, verify that 'totalSbrRewardPerToken' is set to 0.",
            "has_conditional_updates": true,
            "summary_of_update": "The accumulated SBR reward per unit of staked token is reset to zero when the scaling factor is reset, clearing it for new SBR reward accumulation.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "increase",
            "what_does_it_track": "The number of times the Stability Pool's 'stakeScalingFactor' has been reset.",
            "why_is_is_important": "Used to index historical snapshots of the pool's state.",
            "when_is_it_updated": "Conditionally incremented if the cumulative product scaling factor drops below a certain minimum.",
            "how_to_validate_state_update": "If a scaling factor reset occurs, verify that 'stakeResetCount' increments by 1.",
            "has_conditional_updates": true,
            "summary_of_update": "The counter for scaling factor resets is incremented when a reset occurs.",
            "conditions": [
              "stabilityPool.isLiquidationPossible(borrowedAmount)",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "increase",
            "what_does_it_track": "The total amount of collateral rewards accumulated per unit of staked DFIRE token.",
            "why_is_is_important": "Distributes a share of protocol revenue (liquidation fees) to DFIRE stakers.",
            "when_is_it_updated": "Conditionally updated if liquidation fees are distributed to the DFIRE staking pool.",
            "how_to_validate_state_update": "If a liquidation fee is paid and `sbrStakingPoolCanReceiveRewards` is true, verify `totalCollateralPerToken` increases by `(_amount * PRECISION) / _totalStake`.",
            "has_conditional_updates": true,
            "summary_of_update": "The accumulated collateral reward per unit of staked DFIRE increases, distributing a portion of the liquidation fee to DFIRE stakers.",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards == true"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidate() external nonReentrant {\n        uint256 gasStart = gasleft();\n        uint256 _safeId = safesOrderedForLiquidation.getTail();\n        _liquidate(_safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getTail() external view override returns (uint256) {\n        return tail;\n    }\nfunction getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}