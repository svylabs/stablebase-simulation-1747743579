{
  "action": {
    "name": "Liquidate",
    "summary": "Initiates liquidation.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "probability": 0.9
  },
  "action_detail": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "pre_execution_parameter_generation_rules": [
      "Find a Safe (_safeId) that is undercollateralized, meaning its collateralValue is less than ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR).",
      "Ensure that the safeId exists and its collateralAmount and borrowedAmount are greater than zero.",
      "The contract must be connected to a valid price feed",
      "The caller doesn't need to be approved, since the `liquidate` function does not check for authorization"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Safes mapping: The Safe associated with _safeId is deleted, effectively removing it.",
          "safesOrderedForLiquidation: The _safeId is removed from the liquidation queue.",
          "safesOrderedForRedemption: The _safeId is removed from the redemption queue.",
          "totalCollateral: Decreased by the collateralAmount of the liquidated Safe.",
          "totalDebt: Decreased by the borrowedAmount of the liquidated Safe.",
          "LiquidationSnapshot: liquidationSnapshots[_safeId] is updated to track cumulative debt and collateral changes since the last liquidation attempt."
        ]
      },
      {
        "category": "Debt and Collateral Distribution",
        "state_update_descriptions": [
          "cumulativeCollateralPerUnitCollateral: Increased based on the collateral distributed to remaining borrowers if stability pool liquidation isn't possible.",
          "cumulativeDebtPerUnitCollateral: Increased based on the debt distributed to remaining borrowers if stability pool liquidation isn't possible.",
          "collateralLoss: Updated based on the collateral distribution process.",
          "debtLoss: Updated based on the debt distribution process."
        ]
      },
      {
        "category": "Token Burning",
        "state_update_descriptions": [
          "sbdToken: If liquidation uses the stability pool, the borrowedAmount of SBD tokens is burned from the stability pool's address."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "dfireTokenStaking/stabilityPool: Liquidation fee is transferred to the DFIRE staking pool or the stability pool as a reward, if possible. If both fail, the liquidation fee is refunded to the liquidator.",
          "msg.sender: Receives a refund for gas compensation, calculated based on gas used during liquidation and a gas price."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE: May transition from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe Removal",
        "rule_descriptions": [
          "safes[_safeId] should no longer exist (or its status should be CLOSED).",
          "_ownerOf(safeId) should return the zero address, confirming the Safe's NFT has been burned.",
          "_safeId should be removed from the safesOrderedForLiquidation linked list.",
          "_safeId should be removed from the safesOrderedForRedemption linked list."
        ]
      },
      {
        "category": "Total Debt and Collateral",
        "rule_descriptions": [
          "totalCollateral should be decreased by the collateralAmount of the liquidated Safe.",
          "totalDebt should be decreased by the borrowedAmount of the liquidated Safe."
        ]
      },
      {
        "category": "Stability Pool Interaction",
        "rule_descriptions": [
          "If stabilityPool.performLiquidation is called, the totalStakedRaw in the stability pool should decrease by borrowedAmount.",
          "If addCollateralReward is called on either dfireTokenStaking or stabilityPool, their respective totalCollateralPerToken should increase."
        ]
      },
      {
        "category": "Token State",
        "rule_descriptions": [
          "If stabilityPool.performLiquidation is called, the SBD balance of the stability pool should decrease by borrowedAmount."
        ]
      },
      {
        "category": "Gas Compensation",
        "rule_descriptions": [
          "msg.sender (the liquidator) should receive a refund of up to liquidationFee, based on gasUsed and gas price."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "safesOrderedForLiquidation.head and safesOrderedForLiquidation.tail are appropriately updated based on the removal of _safeId."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the system.",
            "why_is_is_important": "Reflects the total collateral backing the system, used in calculations for system health and individual safe ratios. This is critical for maintaining system solvency.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingStabilityPool with the corresponding parameters. Verify that the totalCollateral state variable decreases by the collateralAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalCollateral by collateralAmount if liquidated using the stability pool.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount) returns true"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of debt in the system.",
            "why_is_is_important": "Reflects the overall debt of the system, crucial for assessing solvency and setting parameters. Accurate tracking ensures the protocol's financial stability.",
            "when_is_it_updated": "When a safe is liquidated using the stability pool.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingStabilityPool with the corresponding parameters. Verify that the totalDebt state variable decreases by the borrowedAmount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalDebt by borrowedAmount if liquidated using the stability pool.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount) returns true"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per unit collateral for debt distribution.",
            "why_is_is_important": "Ensures fair distribution of collateral among borrowers when liquidation occurs through the secondary mechanism, preserving the system's integrity.",
            "when_is_it_updated": "When a safe is liquidated using the secondary mechanism.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingSecondaryMechanism with the corresponding parameters. Calculate the expected new value of cumulativeCollateralPerUnitCollateral using the formula and compare it with the actual value after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates cumulativeCollateralPerUnitCollateral when liquidated using the secondary mechanism by distributing debt and collateral to existing borrowers.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount) returns false",
              "_safeId != _last"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative debt per unit collateral for debt distribution.",
            "why_is_is_important": "Ensures fair distribution of debt among borrowers when liquidation occurs through the secondary mechanism, crucial for maintaining system solvency.",
            "when_is_it_updated": "When a safe is liquidated using the secondary mechanism.",
            "how_to_validate_state_update": "Check the emitted event LiquidatedUsingSecondaryMechanism with the corresponding parameters. Calculate the expected new value of cumulativeDebtPerUnitCollateral using the formula and compare it with the actual value after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates cumulativeDebtPerUnitCollateral when liquidated using the secondary mechanism by distributing debt and collateral to existing borrowers.",
            "conditions": [
              "collateralAmount > 0",
              "borrowedAmount > 0",
              "collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)",
              "stabilityPool.isLiquidationPossible(borrowedAmount) returns false",
              "_safeId != _last"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operational mode of the protocol.",
            "why_is_is_important": "Determines the behavior of the protocol and its resistance to adverse conditions. Transitioning to NORMAL mode signifies the protocol's stability.",
            "when_is_it_updated": "When total debt exceeds a threshold during a liquidation.",
            "how_to_validate_state_update": "Verify the PROTOCOL_MODE state variable changes to NORMAL by calling the mode() function and comparing the result before and after the liquidation. Confirm that the debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes PROTOCOL_MODE from BOOTSTRAP to NORMAL when total debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safesOrderedForLiquidation",
            "type": "mapping",
            "what_does_it_track": "Maintains an ordered list of safes for liquidation.",
            "why_is_is_important": "Maintains the order in which safes should be liquidated. Accurate removal prevents double liquidation or incorrect queue management.",
            "when_is_it_updated": "After a safe has been liquidated.",
            "how_to_validate_state_update": "Check for the SafeRemovedFromLiquidationQueue event with the safeId. Query the safesOrderedForLiquidation contract to confirm the safe is no longer in the queue.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the liquidated safe from the liquidation queue.",
            "conditions": [
              "always"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "mapping",
            "what_does_it_track": "Maintains an ordered list of safes for redemption.",
            "why_is_is_important": "Maintains the order in which safes should be redeemed. Removing the safe ensures it is not mistakenly considered for redemption.",
            "when_is_it_updated": "After a safe has been liquidated.",
            "how_to_validate_state_update": "Check for the SafeRemovedFromRedemptionQueue event with the safeId. Query the safesOrderedForRedemption contract to confirm the safe is no longer in the queue.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the liquidated safe from the redemption queue.",
            "conditions": [
              "always"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Stores all the safes in the protocol.",
            "why_is_is_important": "Stores the state of all safes in the system. Removing a liquidated safe ensures it is not incorrectly accessed or modified.",
            "when_is_it_updated": "After a safe has been liquidated.",
            "how_to_validate_state_update": "Check for the RemovedSafe event with the safeId and the safe's details. Query the safes mapping to confirm the safe no longer exists.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes the safe from the safes mapping.",
            "conditions": [
              "always"
            ]
          },
          {
            "state_variable_name": "dfireTokenStaking",
            "type": "contract",
            "what_does_it_track": "Represents the DFIRE staking pool contract.",
            "why_is_is_important": "Facilitates reward distribution to SBR stakers. Correctly distributing fees ensures the stakers are properly compensated.",
            "when_is_it_updated": "During the distribution of liquidation fees.",
            "how_to_validate_state_update": "Verify that the DFIREStaking contract's addCollateralReward function is called with the correct amount (liquidationFee - refund). Check for the LiquidationFeePaid event with the correct parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "Attempts to send liquidation fees to SBR stakers if the staking pool can receive rewards and liquidation fee is greater than the refund.",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards"
            ]
          },
          {
            "state_variable_name": "stabilityPool",
            "type": "contract",
            "what_does_it_track": "Represents the stability pool contract.",
            "why_is_is_important": "Facilitates reward distribution to the stability pool. Correctly distributing fees ensures the stability pool providers are properly compensated.",
            "when_is_it_updated": "During the distribution of liquidation fees.",
            "how_to_validate_state_update": "Verify that the StabilityPool contract's addCollateralReward function is called with the correct amount (liquidationFee - refund). Check for the LiquidationFeePaid event with the correct parameters.",
            "has_conditional_updates": true,
            "summary_of_update": "Attempts to send liquidation fees to the stability pool if SBR staking pool cannot receive rewards, the stability pool can receive rewards and the liquidation fee is greater than the refund.",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards == false",
              "stabilityPoolCanReceiveRewards"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Stores the nodes of a doubly linked list.",
            "why_is_is_important": "Manages the order of safes in liquidation and redemption queues. Removal ensures the list remains accurate and avoids processing the same safe multiple times.",
            "when_is_it_updated": "When a safe is liquidated and needs to be removed from liquidation or redemption queues.",
            "how_to_validate_state_update": "Check the return value of the remove function to verify the node was removed. Query the nodes mapping to confirm the node no longer exists. Inspect the head and tail variables to ensure the list's integrity.",
            "has_conditional_updates": false,
            "summary_of_update": "Removes a node from the linked list representing the safe, if the safe exists.",
            "conditions": [
              "always"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "Maintains the doubly linked list. Correctly updating the head is essential to preserving the list's structure and order.",
            "when_is_it_updated": "When a safe is liquidated and it is the head of the list.",
            "how_to_validate_state_update": "Check the head state variable before and after the remove function call. Ensure that head is updated to the next node in the list, maintaining list integrity.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the linked list if the node being removed is the head.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "Maintains the doubly linked list. Correctly updating the tail is essential to preserving the list's structure and order.",
            "when_is_it_updated": "When a safe is liquidated and it is the tail of the list.",
            "how_to_validate_state_update": "Check the tail state variable before and after the remove function call. Ensure that tail is updated to the previous node in the list, maintaining list integrity.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the linked list if the node being removed is the tail.",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "Reflects the circulating supply of SBD tokens and ensures the StabilityPool's balance is accurately maintained. Accurately reducing the balance prevents over-allocation of SBD.",
            "when_is_it_updated": "When the StabilityPool successfully performs a liquidation and burns the SBD.",
            "how_to_validate_state_update": "Check for the Burn event emitted with the correct parameters (from the StabilityPool's address and the amount burned). Verify the balanceOf(stabilityPool) decreases by the same amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns the SBD tokens from the StabilityPool contract, reducing its balance.",
            "conditions": [
              "stabilityPool.performLiquidation is successful"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "Reflects the circulating supply of SBD tokens and maintains the integrity of the token's total supply. Correctly reducing the total supply is fundamental to the token's economics.",
            "when_is_it_updated": "When the StabilityPool successfully performs a liquidation and burns the SBD.",
            "how_to_validate_state_update": "Check for the Burn event emitted with the correct parameters. Verify that the totalSupply decreases by the amount burned.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total supply of SBD tokens by the burned amount.",
            "conditions": [
              "stabilityPool.performLiquidation is successful"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of SBD tokens burned.",
            "why_is_is_important": "Provides insight into the deflationary aspects of the SBD token and its long-term economics. This data is crucial for analyzing token supply dynamics.",
            "when_is_it_updated": "When the StabilityPool successfully performs a liquidation and burns the SBD.",
            "how_to_validate_state_update": "Check for the Burn event emitted with the correct parameters. Verify that the totalBurned increases by the amount burned.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total amount of SBD tokens burned.",
            "conditions": [
              "stabilityPool.performLiquidation is successful"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "uint256",
            "what_does_it_track": "Tracks a scaling factor used to adjust user stakes after a liquidation.",
            "why_is_is_important": "Ensures fair distribution of rewards and collateral among stakers after a liquidation. Correct calculation prevents imbalances in the reward system.",
            "when_is_it_updated": "When a liquidation is performed using the stability pool.",
            "how_to_validate_state_update": "Verify the LiquidationPerformed event is emitted with the correct parameters. Calculate the new stakeScalingFactor using the formula and compare it with the actual value after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates stakeScalingFactor based on the liquidation amount.",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total collateral per token for reward calculation.",
            "why_is_is_important": "Used to calculate individual user's collateral balance and rewards. Accurate tracking is essential for fairly distributing collateral.",
            "when_is_it_updated": "When a liquidation is performed using the stability pool.",
            "how_to_validate_state_update": "Verify the LiquidationPerformed event is emitted with the correct parameters. Calculate the new totalCollateralPerToken using the formula and compare it with the actual value after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalCollateralPerToken based on the liquidated collateral.",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks cumulative collateral loss due to rounding errors and other factors.",
            "why_is_is_important": "Tracks any discrepancies in collateral distribution, allowing for potential future adjustments to maintain system balance.",
            "when_is_it_updated": "When a liquidation is performed using the stability pool.",
            "how_to_validate_state_update": "Verify the LiquidationPerformed event is emitted with the correct parameters. Calculate the new collateralLoss using the formula and compare it with the actual value after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralLoss based on the liquidated collateral.",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "uint256",
            "what_does_it_track": "Tracks the total staked amount in raw format.",
            "why_is_is_important": "Maintains an accurate measure of staked tokens. Correctly reducing the staked amount is vital for accurate reward distribution.",
            "when_is_it_updated": "When a liquidation is performed using the stability pool.",
            "how_to_validate_state_update": "Verify the LiquidationPerformed event is emitted with the correct parameters. Check that the totalStakedRaw decreases by the liquidated amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases totalStakedRaw by the liquidated amount.",
            "conditions": [
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Tracks the activity status of the reward sender.",
            "why_is_is_important": "Deactivates reward sending when the stability pool is empty, saving gas costs and preventing errors.",
            "when_is_it_updated": "When the stability pool is used for liquidation and the total stake is zero.",
            "how_to_validate_state_update": "Check setCanStabilityPoolReceiveRewards in the stableBaseCDP contract to ensure that it is called with 'false'. Also ensure that StabilityPool is empty by calling `totalStakedRaw` function.",
            "has_conditional_updates": true,
            "summary_of_update": "Deactivates the reward sender if totalStakedRaw is zero and the reward sender is active.",
            "conditions": [
              "totalStakedRaw == 0",
              "rewardSenderActive",
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "mapping",
            "what_does_it_track": "Tracks stake reset snapshots for recovery purposes.",
            "why_is_is_important": "Preserves staking data for resetting the scaling factor and reward distribution in extreme scenarios, ensuring system recovery.",
            "when_is_it_updated": "During a liquidation if stakeScalingFactor falls below the minimumScalingFactor.",
            "how_to_validate_state_update": "Check the ScalingFactorReset event. Ensure that a new entry exists in stakeResetSnapshots mapping and has the correct scalingFactor, totalRewardPerToken, totalCollateralPerToken, and totalSBRRewardPerToken values.",
            "has_conditional_updates": true,
            "summary_of_update": "Snapshots reset values when cumulative scaling factor drops below minimum.",
            "conditions": [
              "cumulativeProductScalingFactor < minimumScalingFactor",
              "amount <= totalStakedRaw",
              "msg.value == collateral"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral per token for reward distribution.",
            "why_is_is_important": "Tracks rewards for the stability pool stakers, ensuring fair compensation.",
            "when_is_it_updated": "When addCollateralReward is called, typically after a liquidation.",
            "how_to_validate_state_update": "Verify the CollateralRewardAdded event is emitted. Calculate the new totalCollateralPerToken using the formula and compare with the actual value.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates totalCollateralPerToken when a collateral reward is added, fairly distributing rewards to stakers.",
            "conditions": [
              "amount > 0",
              "msg.value == amount",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "uint256",
            "what_does_it_track": "Tracks cumulative collateral loss.",
            "why_is_is_important": "Tracks any discrepancies in collateral distribution within the stability pool.",
            "when_is_it_updated": "When addCollateralReward is called, typically after a liquidation.",
            "how_to_validate_state_update": "Verify the CollateralRewardAdded event is emitted. Calculate the new collateralLoss value using the formula and compare with the actual value.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates collateralLoss when a collateral reward is added, accounting for potential discrepancies.",
            "conditions": [
              "amount > 0",
              "msg.value == amount",
              "totalStakedRaw > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative collateral per token for the staking pool.",
            "why_is_is_important": "Used to calculate collateral rewards for stakers, ensuring they receive their share of the liquidation proceeds. Maintaining accuracy is crucial for incentive alignment.",
            "when_is_it_updated": "When a collateral reward is added to the staking pool after liquidation.",
            "how_to_validate_state_update": "Verify the CollateralRewardAdded event is emitted. Calculate the new totalCollateralPerToken using the formula provided in the contract's code and compare it with the actual value stored in the contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalCollateralPerToken when a collateral reward is added to the staking pool.",
            "conditions": [
              "totalStake > 0",
              "msg.value == _amount"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidate() external nonReentrant {\n        uint256 gasStart = gasleft();\n        uint256 _safeId = safesOrderedForLiquidation.getTail();\n        _liquidate(_safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getTail() external view override returns (uint256) {\n        return tail;\n    }\nfunction getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}