{
  "action": {
    "name": "Liquidate",
    "summary": "Initiates liquidation.",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "probability": 0.9
  },
  "action_detail": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "pre_execution_parameter_generation_rules": [
      "The contract must have safes with collateral and debt.",
      "There must exist a Safe in the safesOrderedForLiquidation queue that satisfies the liquidation criteria (collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR)).",
      "The stabilityPool.isLiquidationPossible(borrowedAmount) must return either true or false, depending on the desired liquidation path for testing.",
      "The contract's state may require manipulation to ensure that PROTOCOL_MODE is in the desired state (BOOTSTRAP or NORMAL) for testing the mode switch.",
      "The msg.sender must have enough balance to receive gas refund."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe Identification and Validation",
        "state_update_descriptions": [
          "The last safe id from the liquidation queue is retrieved.",
          "The safe's borrowed and collateral amounts are updated based on cumulative debt and collateral per unit collateral.",
          "The borrowedAmount, collateralAmount and the price from priceOracle are used to calculate collateralValue.  The function requires collateralValue < ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR).",
          "Checks if stabilityPool.isLiquidationPossible(borrowedAmount) returns true or false."
        ]
      },
      {
        "category": "Debt and Collateral Redistribution",
        "state_update_descriptions": [
          "totalCollateral is decreased by collateralAmount.",
          "totalDebt is decreased by borrowedAmount.",
          "If liquidation via stability pool is possible, collateralAmount - liquidationFee is sent to the stabilityPool.",
          "If liquidation via stability pool is possible, borrowedAmount is burned from the stability pool.",
          "If liquidation via stability pool is not possible, debtAmount and collateralAmount are distributed to existing borrowers by increasing cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral."
        ]
      },
      {
        "category": "Safe Removal and Fee Distribution",
        "state_update_descriptions": [
          "The Safe is removed from the liquidation and redemption queues.",
          "The Safe is removed from the safes mapping.",
          "The liquidation fee is distributed to the SBR staking pool or the stability pool.",
          "Gas compensation is refunded to the user initiating the liquidation."
        ]
      },
      {
        "category": "Cumulative Values Update",
        "state_update_descriptions": [
          "If PROTOCOL_MODE is BOOTSTRAP and the debt is greater than BOOTSTRAP_MODE_DEBT_THRESHOLD, PROTOCOL_MODE is updated to NORMAL.",
          "cumulativeCollateralPerUnitCollateral is increased.",
          "cumulativeDebtPerUnitCollateral is increased."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "The Safe with ID _safeId should be removed from the safes mapping, meaning safes[_safeId] should no longer exist.",
          "totalCollateral should be decreased by the liquidated safe's collateralAmount.",
          "totalDebt should be decreased by the liquidated safe's borrowedAmount."
        ]
      },
      {
        "category": "Liquidation Queue",
        "rule_descriptions": [
          "The Safe with ID _safeId should be removed from the liquidation queue (safesOrderedForLiquidation).",
          "The Safe with ID _safeId should be removed from the redemption queue (safesOrderedForRedemption)."
        ]
      },
      {
        "category": "Stability Pool Interaction",
        "rule_descriptions": [
          "If stabilityPool.isLiquidationPossible(borrowedAmount) returns true, the StabilityPool contract's state should be updated to reflect the liquidation."
        ]
      },
      {
        "category": "Cumulative Debt and Collateral",
        "rule_descriptions": [
          "cumulativeCollateralPerUnitCollateral should be increased to reflect distribution of collateral from liquidated safe.",
          "cumulativeDebtPerUnitCollateral should be increased to reflect distribution of debt from liquidated safe."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Liquidate",
    "contract_name": "StableBaseCDP",
    "function_name": "liquidate",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Stores the Safe struct, holding collateral and debt information for each safe.",
            "why_is_is_important": "Crucial for tracking active safes and their associated data.",
            "when_is_it_updated": "When a safe is liquidated and `_removeSafe` is called.",
            "how_to_validate_state_update": "Check if `safes[_safeId]` returns an empty `Safe` struct after execution.",
            "has_conditional_updates": false,
            "summary_of_update": "Deletes the safe from the `safes` mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Snapshots of debt and collateral ratios for each safe.",
            "why_is_is_important": "Used to calculate debt and collateral increases during liquidation, ensuring accurate updates.",
            "when_is_it_updated": "Before liquidation happens, `_updateSafe` is called to refresh the debt and collateral data.",
            "how_to_validate_state_update": "Check the values before and after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `borrowedAmount` and `collateralAmount` in the `Safe` struct based on `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "variable",
            "what_does_it_track": "Total collateral deposited in the protocol.",
            "why_is_is_important": "Reflects the total collateral backing the system.",
            "when_is_it_updated": "Always, before calling the stability pool, within the `liquidate` function.",
            "how_to_validate_state_update": "Check the `totalCollateral` value before and after the `liquidate` function execution. It should decrease by the liquidated collateral amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases by the `collateralAmount` of the liquidated safe.",
            "conditions": []
          },
          {
            "state_variable_name": "totalDebt",
            "type": "variable",
            "what_does_it_track": "Total debt outstanding in the system.",
            "why_is_is_important": "Indicates the overall debt level of the protocol.",
            "when_is_it_updated": "Always, before calling the stability pool, within the `liquidate` function.",
            "how_to_validate_state_update": "Check the `totalDebt` before and after execution. The value should decrease by the liquidated debt amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases by the `borrowedAmount` of the liquidated safe.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "variable",
            "what_does_it_track": "The current operational mode of the protocol.",
            "why_is_is_important": "Affects protocol behavior and parameters.",
            "when_is_it_updated": "If `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD` and `PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP` in the `_updateTotalDebt` function.",
            "how_to_validate_state_update": "Check the value of `PROTOCOL_MODE` enum before and after the `_updateTotalDebt` is executed to observe state transition.",
            "has_conditional_updates": true,
            "summary_of_update": "May change from `BOOTSTRAP` to `NORMAL` if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "cumulativeCollateralPerUnitCollateral",
            "type": "variable",
            "what_does_it_track": "Cumulative collateral per unit of collateral.",
            "why_is_is_important": "Used for calculating collateral adjustments.",
            "when_is_it_updated": "When liquidation is done via the secondary mechanism.",
            "how_to_validate_state_update": "Check `cumulativeCollateralPerUnitCollateral` before and after execution of `distributeDebtAndCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by `collPerUnitColl` within the `distributeDebtAndCollateral` function.",
            "conditions": [
              "possible == false"
            ]
          },
          {
            "state_variable_name": "cumulativeDebtPerUnitCollateral",
            "type": "variable",
            "what_does_it_track": "Cumulative debt per unit of collateral.",
            "why_is_is_important": "Used for calculating debt adjustments.",
            "when_is_it_updated": "When liquidation is done via the secondary mechanism.",
            "how_to_validate_state_update": "Check `cumulativeDebtPerUnitCollateral` before and after execution of `distributeDebtAndCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increased by `debtPerUnitColl` within the `distributeDebtAndCollateral` function.",
            "conditions": [
              "possible == false"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "variable",
            "what_does_it_track": "Tracks accumulated collateral loss.",
            "why_is_is_important": "Accounts for collateral discrepancies during distribution.",
            "when_is_it_updated": "When liquidation is done via the secondary mechanism.",
            "how_to_validate_state_update": "Check the value before and after.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates based on collateral distribution in `distributeDebtAndCollateral` function.",
            "conditions": [
              "possible == false"
            ]
          },
          {
            "state_variable_name": "debtLoss",
            "type": "variable",
            "what_does_it_track": "Tracks accumulated debt loss.",
            "why_is_is_important": "Accounts for debt discrepancies during distribution.",
            "when_is_it_updated": "When liquidation is done via the secondary mechanism.",
            "how_to_validate_state_update": "Check the value before and after.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates based on debt distribution in `distributeDebtAndCollateral` function.",
            "conditions": [
              "possible == false"
            ]
          },
          {
            "state_variable_name": "_owners",
            "type": "mapping",
            "what_does_it_track": "The owner of each token",
            "why_is_is_important": "Used to track the current owners of safes",
            "when_is_it_updated": "After a Safe is liquidated and `_removeSafe` is called which triggers `_burn` and then `_update`.",
            "how_to_validate_state_update": "Check `_owners[_safeId]` value before and after the transaction. It will point to address(0) after the liquidation",
            "has_conditional_updates": false,
            "summary_of_update": "The Safe is removed by setting the owner of the NFT to address(0) in the internal function `_update`",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The balances of each account",
            "why_is_is_important": "Used to track how many safes an account holds",
            "when_is_it_updated": "After a Safe is liquidated and `_removeSafe` is called which triggers `_burn` and then `_update`.",
            "how_to_validate_state_update": "Check `_balances[previousOwner]` value before and after the transaction. It will decrease by one after the liquidation",
            "has_conditional_updates": false,
            "summary_of_update": "The NFT is removed by decrementing the balance of the account that owned it.",
            "conditions": []
          },
          {
            "state_variable_name": "_tokenApprovals",
            "type": "mapping",
            "what_does_it_track": "The addresses to which tokens have been approved to",
            "why_is_is_important": "Used to track to what accounts a token is approved to",
            "when_is_it_updated": "After a Safe is liquidated and `_removeSafe` is called which triggers `_burn` and then `_update` and then `_approve`.",
            "how_to_validate_state_update": "Check `_tokenApprovals[_safeId]` value before and after the transaction. It will point to address(0) after the liquidation",
            "has_conditional_updates": false,
            "summary_of_update": "The NFT is removed by clearing the token approvals",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "variable",
            "what_does_it_track": "Stores node data (value, previous, next) for the doubly linked list implementation.",
            "why_is_is_important": "Essential for maintaining the order and structure of the liquidation/redemption queues.",
            "when_is_it_updated": "When a safe is liquidated via `_removeSafeFromBothQueues`.",
            "how_to_validate_state_update": "Verify that `nodes[safeId]` returns default values after execution. `nodes[safeId].value == 0 && nodes[safeId].next == 0 && nodes[safeId].prev == 0`",
            "has_conditional_updates": false,
            "summary_of_update": "Deletes the node from the `nodes` mapping for both liquidation and redemption queues.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "variable",
            "what_does_it_track": "The first node in the linked list.",
            "why_is_is_important": "Used to transverse from the start of the list",
            "when_is_it_updated": "When the removed node is the head of the list.",
            "how_to_validate_state_update": "Check if `head` points to the next node after removal if the removed node was the head.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated if the removed node was the head of the queue.",
            "conditions": [
              "nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "variable",
            "what_does_it_track": "The last node in the linked list.",
            "why_is_is_important": "Used to transverse from the end of the list",
            "when_is_it_updated": "When the removed node is the tail of the list.",
            "how_to_validate_state_update": "Check if `tail` points to the previous node after removal if the removed node was the tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated if the removed node was the tail of the queue.",
            "conditions": [
              "nodes[id].next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stakeScalingFactor",
            "type": "variable",
            "what_does_it_track": "A scaling factor used for stake calculations.",
            "why_is_is_important": "Ensures fair distribution of rewards based on stake.",
            "when_is_it_updated": "If `possible` (liquidation amount is less than total staked amount)",
            "how_to_validate_state_update": "Compare the value of stakeScalingFactor prior and after transaction. It should decrease. Also, observe logs for the StabilityPool.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases `stakeScalingFactor` based on liquidation amount. If `totalStakedRaw` is zero and `rewardSenderActive` is true, it tries to set `stableBaseCDP.setCanStabilityPoolReceiveRewards(false)`",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "variable",
            "what_does_it_track": "Total collateral per token in the stability pool.",
            "why_is_is_important": "Used to calculate collateral rewards.",
            "when_is_it_updated": "If `possible` (liquidation amount is less than total staked amount)",
            "how_to_validate_state_update": "Check `totalCollateralPerToken` before and after execution.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases `totalCollateralPerToken` by `_totalCollateralPerToken`.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "collateralLoss",
            "type": "variable",
            "what_does_it_track": "Tracks accumulated collateral loss.",
            "why_is_is_important": "Accounts for collateral discrepancies.",
            "when_is_it_updated": "If `possible` (liquidation amount is less than total staked amount)",
            "how_to_validate_state_update": "Check the value before and after the function call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updated based on total collateral in `performLiquidation` function.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "totalStakedRaw",
            "type": "variable",
            "what_does_it_track": "The total raw staked amount in the stability pool.",
            "why_is_is_important": "Reflects the total stake in the pool.",
            "when_is_it_updated": "If `possible` (liquidation amount is less than total staked amount)",
            "how_to_validate_state_update": "Check `totalStakedRaw` before and after execution. It should decrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases by liquidated `amount`.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "stakeResetSnapshots",
            "type": "mapping",
            "what_does_it_track": "Snapshots of scaling factor and reward data during stake resets.",
            "why_is_is_important": "Allows the pool to track rewards and collateral fairly after scaling factor resets.",
            "when_is_it_updated": "If `cumulativeProductScalingFactor < minimumScalingFactor`",
            "how_to_validate_state_update": "Check values prior and after transaction",
            "has_conditional_updates": true,
            "summary_of_update": "Stores `StakeResetSnapshot` if `cumulativeProductScalingFactor < minimumScalingFactor`, resets `totalCollateralPerToken`, `totalRewardPerToken`, `totalSbrRewardPerToken`, and `stakeScalingFactor`",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          },
          {
            "state_variable_name": "stakeResetCount",
            "type": "variable",
            "what_does_it_track": "The number of stake resets.",
            "why_is_is_important": "Tracks how many times the state has been reset in the pool.",
            "when_is_it_updated": "If `cumulativeProductScalingFactor < minimumScalingFactor`",
            "how_to_validate_state_update": "Check values prior and after transaction",
            "has_conditional_updates": true,
            "summary_of_update": "Incremented if `cumulativeProductScalingFactor < minimumScalingFactor`",
            "conditions": [
              "amount <= totalStakedRaw",
              "cumulativeProductScalingFactor < minimumScalingFactor"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "totalBurned",
            "type": "variable",
            "what_does_it_track": "The total amount of tokens burned.",
            "why_is_is_important": "Used to track the total amount of burned tokens.",
            "when_is_it_updated": "If the liquidation happens using Stability Pool.",
            "how_to_validate_state_update": "Check `totalBurned` before and after execution. It should increase by `borrowedAmount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases by `borrowedAmount` if `possible`",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Balances of accounts and total supply.",
            "why_is_is_important": "Fundamental accounting of token ownership.",
            "when_is_it_updated": "Always, within the internal function `_burn`.",
            "how_to_validate_state_update": "Check `_balances` of the `from` address, and total supply before and after transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the balance of the StabilityPool, and decreasing `_totalSupply`.",
            "conditions": [
              "amount <= totalStakedRaw",
              "from != address(0)",
              "balanceOf(from) >= amount",
              "amount > 0"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "variable",
            "what_does_it_track": "Tracks the total supply of the token.",
            "why_is_is_important": "Maintains correct token supply.",
            "when_is_it_updated": "if `possible` (liquidation amount is less than total staked amount)",
            "how_to_validate_state_update": "Check `_totalSupply` before and after execution of `_burn`.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases when the `sbdToken` are burned.",
            "conditions": [
              "amount <= totalStakedRaw"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "variable",
            "what_does_it_track": "Tracks the collateral rewards.",
            "why_is_is_important": "Used for rewarding stakers.",
            "when_is_it_updated": "If `sbrStakingPoolCanReceiveRewards` is true",
            "how_to_validate_state_update": "Check the value of `totalCollateralPerToken` before and after the transaction.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the rewards for stakers with debt",
            "conditions": [
              "liquidationFee > refund",
              "sbrStakingPoolCanReceiveRewards"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function liquidate() external nonReentrant {\n        uint256 gasStart = gasleft();\n        uint256 _safeId = safesOrderedForLiquidation.getTail();\n        _liquidate(_safeId, gasStart);\n    }\nfunction _liquidate(uint256 _safeId, uint256 gasStart) internal {\n        uint256 _last = safesOrderedForLiquidation.getHead();\n        Safe storage safe = safes[_safeId];\n        _updateSafe(_safeId, safe);\n        safe = safes[_safeId];\n        uint256 borrowedAmount = safe.borrowedAmount;\n        uint256 collateralAmount = safe.collateralAmount;\n        //require(_isApprovedOrOwner(msg.sender, _safeId), \"Unauthorized\");\n        require(collateralAmount > 0, \"Safe does not exist\");\n        require(\n            borrowedAmount > 0,\n            \"Cannot liquidate a Safe with no borrowed amount\"\n        );\n\n        uint256 collateralPrice = priceOracle.fetchPrice();\n        uint256 collateralValue = (collateralAmount * collateralPrice) /\n            PRECISION;\n        // Check if the collateral is sufficient for liquidation\n        require(\n            collateralValue <\n                ((borrowedAmount * liquidationRatio) / BASIS_POINTS_DIVISOR),\n            \"Can't liquidate yet\"\n        );\n        bool possible = stabilityPool.isLiquidationPossible(borrowedAmount);\n\n        // Pay liquidation fee\n        uint256 liquidationFee = (collateralAmount *\n            REDEMPTION_LIQUIDATION_FEE) / BASIS_POINTS_DIVISOR;\n\n        totalCollateral -= collateralAmount;\n        _updateTotalDebt(totalDebt, borrowedAmount, false);\n\n        if (possible) {\n            require(\n                stabilityPool.performLiquidation{\n                    value: collateralAmount - liquidationFee\n                }(borrowedAmount, collateralAmount - liquidationFee),\n                \"Liquidation failed\"\n            );\n            // Burn the amount from stability pool\n            require(\n                sbdToken.burn(address(stabilityPool), borrowedAmount),\n                \"Burn failed\"\n            );\n\n            emit LiquidatedUsingStabilityPool(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        } else {\n            require(_safeId != _last, \"Cannot liquidate the last Safe\");\n            // Liquidate by distributing the debt and collateral to the existing borrowers.\n            distributeDebtAndCollateral(\n                borrowedAmount,\n                collateralAmount - liquidationFee,\n                totalCollateral\n            );\n            emit LiquidatedUsingSecondaryMechanism(\n                _safeId,\n                borrowedAmount,\n                collateralAmount,\n                totalCollateral,\n                totalDebt\n            );\n        }\n        _removeSafeFromBothQueues(_safeId);\n\n        // Remove the Safe from the mapping\n        _removeSafe(_safeId);\n        uint256 gasUsed = gasStart - gasleft();\n        uint256 gasCompensation = (gasUsed + EXTRA_GAS_COMPENSATION) *\n            (block.basefee + (block.basefee * 10) / 100); // 10% extra gas cost\n        uint256 refund = min(gasCompensation, liquidationFee);\n        _distributeLiquidationFeeAndGasCompensation(\n            _safeId,\n            (gasUsed + EXTRA_GAS_COMPENSATION),\n            liquidationFee,\n            refund\n        );\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeDebtAndCollateral(\n        uint256 debtAmount,\n        uint256 collateralAmount,\n        uint256 totalCollateralAfterLiquidation\n    ) internal {\n        uint256 collateralToDistribute = collateralAmount + collateralLoss;\n        uint256 debtToDistribute = debtAmount + debtLoss;\n        uint256 collPerUnitColl = (collateralToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeCollateralPerUnitCollateral += collPerUnitColl;\n        uint256 debtPerUnitColl = (debtToDistribute * PRECISION) /\n            totalCollateralAfterLiquidation;\n        cumulativeDebtPerUnitCollateral += debtPerUnitColl;\n        collateralLoss =\n            collateralToDistribute -\n            (collPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n        debtLoss =\n            debtToDistribute -\n            (debtPerUnitColl * totalCollateralAfterLiquidation) /\n            PRECISION;\n    }\nfunction _removeSafeFromBothQueues(uint256 safeId) internal {\n        safesOrderedForLiquidation.remove(safeId);\n        emit SafeRemovedFromLiquidationQueue(safeId);\n        safesOrderedForRedemption.remove(safeId);\n        emit SafeRemovedFromRedemptionQueue(safeId);\n    }\nfunction _removeSafe(uint256 _safeId) internal {\n        //safes[_safeId].status = SafeStatus.CLOSED;\n        Safe memory safe = safes[_safeId];\n        delete safes[_safeId];\n        _burn(_safeId);\n        emit RemovedSafe(_safeId, safe);\n    }\nfunction _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\nfunction _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\nfunction _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\nfunction _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\nfunction _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\nfunction _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\nfunction _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\nfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\nfunction _distributeLiquidationFeeAndGasCompensation(\n        uint256 safeId,\n        uint256 gasUsed,\n        uint256 liquidationFee,\n        uint256 refund\n    ) internal {\n        // Try to send the liquidation fee to sbr stakers\n        if (liquidationFee > refund) {\n            if (sbrStakingPoolCanReceiveRewards) {\n                bool success = dfireTokenStaking.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success && stabilityPoolCanReceiveRewards) {\n                    success = stabilityPool.addCollateralReward{\n                        value: liquidationFee - refund\n                    }(liquidationFee - refund);\n                    if (!success) {\n                        refund = liquidationFee;\n                    }\n                } else if (success) {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(dfireTokenStaking),\n                        liquidationFee - refund\n                    );\n                }\n            } else if (stabilityPoolCanReceiveRewards) {\n                bool success = stabilityPool.addCollateralReward{\n                    value: liquidationFee - refund\n                }(liquidationFee - refund);\n                if (!success) {\n                    refund = liquidationFee;\n                } else {\n                    emit LiquidationFeePaid(\n                        safeId,\n                        address(stabilityPool),\n                        liquidationFee - refund\n                    );\n                }\n            } else {\n                refund = liquidationFee;\n            }\n        }\n        if (refund > 0) {\n            // Refund the remaining liquidation fee to the user\n            (bool success, ) = msg.sender.call{value: refund}(\"\");\n            require(success, \"Transfer failed\");\n            emit LiquidationGasCompensationPaid(\n                safeId,\n                gasUsed,\n                msg.sender,\n                refund\n            );\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function getTail() external view override returns (uint256) {\n        return tail;\n    }\nfunction getHead() external view override returns (uint256) {\n        return head;\n    }\nfunction remove(\n        uint256 id\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            // Node doesn't exist\n            return Node(0, 0, 0);\n        }\n        return _remove(id);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "MockPriceOracle",
        "code_snippet": "function fetchPrice() external view override returns (uint256) {\n        return price;\n    }",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function isLiquidationPossible(\n        uint256 amount\n    ) external view override returns (bool) {\n        return amount <= totalStakedRaw;\n    }\nfunction performLiquidation(\n        uint256 amount,\n        uint256 collateral\n    ) external payable onlyDebtContract returns (bool) {\n        //require(msg.sender == debtContract, \"Caller is not the debt contract\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        require(amount <= totalStakedRaw, \"Invalid liquidation amount\");\n        require(msg.value == collateral, \"Invalid collateral amount\");\n\n        uint256 previousScalingFactor = stakeScalingFactor;\n        //uint256 scalingFactorReduction = (_amount * precision) / totalStakedRaw;\n        // (1 - Amount / totalStakedRaw)\n        uint256 newScalingFactor = ((totalStakedRaw - amount) * precision) /\n            totalStakedRaw;\n        uint256 cumulativeProductScalingFactor = (stakeScalingFactor *\n            newScalingFactor) / precision;\n\n        stakeScalingFactor = cumulativeProductScalingFactor;\n\n        uint256 _collateral = collateral + collateralLoss;\n\n        uint256 _totalCollateralPerToken = ((_collateral *\n            previousScalingFactor *\n            precision) / totalStakedRaw) / precision;\n\n        // Update total collateral per token\n        totalCollateralPerToken += _totalCollateralPerToken;\n        collateralLoss =\n            _collateral -\n            ((_totalCollateralPerToken * totalStakedRaw * precision) /\n                previousScalingFactor) /\n            precision;\n\n        emit LiquidationPerformed(\n            amount,\n            collateral,\n            totalStakedRaw,\n            stakeScalingFactor,\n            totalCollateralPerToken\n        );\n\n        totalStakedRaw -= amount;\n\n        if (totalStakedRaw == 0 && rewardSenderActive) {\n            require(\n                IRewardSender(stableBaseCDP).setCanStabilityPoolReceiveRewards(\n                    false\n                ),\n                \"Unable to deactivate reward sender\"\n            );\n        }\n\n        if (cumulativeProductScalingFactor < minimumScalingFactor) {\n            StakeResetSnapshot memory resetSnapshot = StakeResetSnapshot({\n                scalingFactor: cumulativeProductScalingFactor,\n                totalRewardPerToken: totalRewardPerToken,\n                totalCollateralPerToken: totalCollateralPerToken,\n                totalSBRRewardPerToken: totalSbrRewardPerToken\n            });\n            stakeResetSnapshots[stakeResetCount] = resetSnapshot;\n            totalCollateralPerToken = 0;\n            totalRewardPerToken = 0;\n            totalSbrRewardPerToken = 0;\n            stakeScalingFactor = precision;\n            stakeResetCount++;\n            emit ScalingFactorReset(stakeResetCount - 1, resetSnapshot);\n        }\n        return true;\n    }\nfunction addCollateralReward(\n        uint256 amount\n    ) external payable returns (bool) {\n        require(amount > 0, \"Reward must be greater than zero\");\n        require(msg.value == amount, \"Invalid collateral amount\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n\n        uint256 _totalAmount = amount + collateralLoss;\n        uint256 _collateralPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalCollateralPerToken += _collateralPerToken;\n\n        collateralLoss =\n            _totalAmount -\n            (((_collateralPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        emit CollateralRewardAdded(amount);\n        return true;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction balanceOf(address account) external view returns (uint256);\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addCollateralReward(\n        uint256 _amount\n    ) external payable returns (bool) {\n        //collateralToken.transferFrom(msg.sender, address(this), _amount);\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(msg.value == _amount, \"Invalid collateral reward amount\");\n            totalCollateralPerToken += (_amount * PRECISION) / _totalStake;\n            emit CollateralRewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}