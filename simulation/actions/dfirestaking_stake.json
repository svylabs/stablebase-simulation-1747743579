{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The '_amount' parameter should be a positive integer.",
      "The caller's DFIREToken (stakingToken) balance must be greater than or equal to '_amount'.",
      "The caller must have approved the DFIREStaking contract to spend at least '_amount' of DFIREToken from their balance."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "DFIREStaking Contract State Updates",
        "state_update_descriptions": [
          "The 'totalStake' variable of the DFIREStaking contract increases by '_amount'.",
          "If 'rewardSenderActive' is true and 'totalStake' was initially 0, the 'setCanSBRStakingPoolReceiveRewards' function on the 'stableBaseContract' (StableBaseCDP) is called with 'true'."
        ]
      },
      {
        "category": "User Specific Stake Updates",
        "state_update_descriptions": [
          "The 'stake' value for the 'msg.sender' in the 'stakes' mapping increases by '_amount'.",
          "The 'rewardSnapshot' for the 'msg.sender' in the 'stakes' mapping is updated to the 'totalRewardPerToken' at the time of the internal '_claim' call.",
          "The 'collateralSnapshot' for the 'msg.sender' in the 'stakes' mapping is updated to the 'totalCollateralPerToken' at the time of the internal '_claim' call."
        ]
      },
      {
        "category": "DFIREToken (Staking Token) Balance Updates",
        "state_update_descriptions": [
          "The DFIREToken balance of the 'msg.sender' decreases by '_amount'.",
          "The DFIREToken balance of the 'DFIREStaking' contract increases by '_amount'."
        ]
      },
      {
        "category": "DFIDToken (Reward Token) Balance Updates (Conditional)",
        "state_update_descriptions": [
          "If a 'reward' amount is calculated and greater than 0 during the internal '_claim' call: The DFIDToken balance of the 'DFIREStaking' contract decreases by the calculated 'reward'.",
          "If a 'reward' amount is calculated and greater than 0 during the internal '_claim' call: The DFIDToken balance of the 'msg.sender' increases by the calculated 'reward'."
        ]
      },
      {
        "category": "Native Currency (Collateral Reward) Balance Updates (Conditional)",
        "state_update_descriptions": [
          "If a 'collateralReward' amount is calculated and greater than 0 during the internal '_claim' call: The native currency balance of the 'DFIREStaking' contract decreases by the calculated 'collateralReward'.",
          "If a 'collateralReward' amount is calculated and greater than 0 during the internal '_claim' call: The native currency balance of the 'msg.sender' increases by the calculated 'collateralReward'."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "DFIREStaking Contract State Validation",
        "rule_descriptions": [
          "The 'totalStake' of the DFIREStaking contract should be equal to its value before the transaction plus the '_amount' staked.",
          "The 'stake' recorded for 'msg.sender' in the 'stakes' mapping should be equal to its value before the transaction plus the '_amount' staked.",
          "The 'rewardSnapshot' recorded for 'msg.sender' in the 'stakes' mapping should be equal to the 'totalRewardPerToken' value at the moment the internal '_claim' function was executed.",
          "The 'collateralSnapshot' recorded for 'msg.sender' in the 'stakes' mapping should be equal to the 'totalCollateralPerToken' value at the moment the internal '_claim' function was executed.",
          "If 'rewardSenderActive' was true and 'totalStake' was 0 prior to the transaction, verify that 'setCanSBRStakingPoolReceiveRewards' on 'stableBaseContract' was called with 'true'."
        ]
      },
      {
        "category": "DFIREToken (Staking Token) Balance Validation",
        "rule_descriptions": [
          "The DFIREToken balance of the 'msg.sender' should be equal to its balance before the transaction minus the '_amount' staked.",
          "The DFIREToken balance of the 'DFIREStaking' contract should be equal to its balance before the transaction plus the '_amount' staked."
        ]
      },
      {
        "category": "DFIDToken (Reward Token) Balance Validation",
        "rule_descriptions": [
          "The DFIDToken balance of the 'DFIREStaking' contract should be equal to its balance before the transaction minus the calculated 'reward' amount (if 'reward' > 0).",
          "The DFIDToken balance of the 'msg.sender' should be equal to its balance before the transaction plus the calculated 'reward' amount (if 'reward' > 0)."
        ]
      },
      {
        "category": "Native Currency (Collateral Reward) Balance Validation",
        "rule_descriptions": [
          "The native currency balance of the 'DFIREStaking' contract should be equal to its balance before the transaction minus the calculated 'collateralReward' amount (if 'collateralReward' > 0).",
          "The native currency balance of the 'msg.sender' should be equal to its balance before the transaction plus the calculated 'collateralReward' amount (if 'collateralReward' > 0)."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "A 'Staked' event must be emitted with 'user' as 'msg.sender' and 'amount' as '_amount'.",
          "A 'Claimed' event must be emitted with 'user' as 'msg.sender', 'rewardAmount' as the calculated 'reward', and 'collateralReward' as the calculated 'collateralReward'."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "mapping(address => struct Stake)",
            "what_does_it_track": "The total amount of DFIRE tokens staked by a specific user.",
            "why_is_is_important": "It tracks the individual user's contribution to the staking pool, which is essential for calculating their share of rewards and for future unstaking operations.",
            "when_is_it_updated": "Unconditionally updated within the `stake` function after successful token transfer.",
            "how_to_validate_state_update": "The value of `stakes[msg.sender].stake` should be `_amount` higher than its value before the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's staked amount is increased by the `_amount` provided.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "mapping(address => struct Stake)",
            "what_does_it_track": "A snapshot of the `totalRewardPerToken` value when the user last interacted (staked, unstaked, or claimed), used to calculate pending rewards.",
            "why_is_is_important": "It ensures that users only claim rewards that have accrued since their last interaction, preventing double-claiming and accurately calculating rewards based on their stake duration.",
            "when_is_it_updated": "Unconditionally updated in the `_claim` internal function, which is called at the beginning of the `stake` function.",
            "how_to_validate_state_update": "The value of `stakes[msg.sender].rewardSnapshot` should be updated to the current `totalRewardPerToken` value at the time of execution.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's reward snapshot is updated to the current global reward per token.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "mapping(address => struct Stake)",
            "what_does_it_track": "A snapshot of the `totalCollateralPerToken` value when the user last interacted (staked, unstaked, or claimed), used to calculate pending collateral rewards.",
            "why_is_is_important": "It ensures that users only claim collateral rewards that have accrued since their last interaction, similar to `rewardSnapshot`.",
            "when_is_it_updated": "Unconditionally updated in the `_claim` internal function, which is called at the beginning of the `stake` function.",
            "how_to_validate_state_update": "The value of `stakes[msg.sender].collateralSnapshot` should be updated to the current `totalCollateralPerToken` value at the time of execution.",
            "has_conditional_updates": false,
            "summary_of_update": "The user's collateral reward snapshot is updated to the current global collateral per token.",
            "conditions": []
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The cumulative sum of all DFIRE tokens staked by all users in the contract.",
            "why_is_is_important": "It represents the total liquidity locked in the staking pool, which is used to calculate the overall reward distribution and determine when to activate reward sending.",
            "when_is_it_updated": "Unconditionally increased by `_amount` after a successful stake.",
            "how_to_validate_state_update": "The value of `totalStake` should be `_amount` higher than its value before the transaction.",
            "has_conditional_updates": false,
            "summary_of_update": "The global total staked amount is increased by the `_amount` provided.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The balance of DFIRE tokens held by a specific address.",
            "why_is_is_important": "Reflects the reduction in the user's DFIREToken holdings as they are moved into the staking contract.",
            "when_is_it_updated": "When `stakingToken.transferFrom(msg.sender, address(this), _amount)` is successfully executed.",
            "how_to_validate_state_update": "The `balanceOf` `msg.sender` should decrease by `_amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The staking token balance of the user (msg.sender) decreases by `_amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "balanceOf[DFIREStaking address]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The balance of DFIRE tokens held by the DFIREStaking contract.",
            "why_is_is_important": "Indicates the total amount of DFIRE tokens that are currently staked and managed by the contract.",
            "when_is_it_updated": "When `stakingToken.transferFrom(msg.sender, address(this), _amount)` is successfully executed.",
            "how_to_validate_state_update": "The `balanceOf` the `DFIREStaking` contract address should increase by `_amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The staking token balance of the DFIREStaking contract increases by `_amount`.",
            "conditions": []
          },
          {
            "state_variable_name": "allowance[msg.sender][DFIREStaking address]",
            "type": "mapping(address => mapping(address => uint256))",
            "what_does_it_track": "The amount of DFIRE tokens that a specific spender (DFIREStaking contract) is approved to transfer from a specific owner (msg.sender).",
            "why_is_is_important": "Ensures that the staking contract can only transfer tokens within the pre-approved limit set by the user.",
            "when_is_it_updated": "When `stakingToken.transferFrom(msg.sender, address(this), _amount)` is successfully executed.",
            "how_to_validate_state_update": "The `allowance` for `msg.sender` to `DFIREStaking` should decrease by `_amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "The allowance granted by the user to the DFIREStaking contract for DFIREToken spending decreases by `_amount`.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The balance of DFID tokens held by a specific address.",
            "why_is_is_important": "Represents the distribution of accumulated rewards to the user as part of the claiming process during staking.",
            "when_is_it_updated": "When `rewardToken.transfer(msg.sender, reward)` is successfully executed within the `_claim` function, but only if `reward` is greater than 0.",
            "how_to_validate_state_update": "If `reward > 0`, the `balanceOf` `msg.sender` should increase by `reward`.",
            "has_conditional_updates": true,
            "summary_of_update": "The reward token balance of the user (msg.sender) increases by the calculated `reward` amount.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "balanceOf[DFIREStaking address]",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "The balance of DFID tokens held by the DFIREStaking contract.",
            "why_is_is_important": "Reflects the outflow of reward tokens from the staking contract to the user.",
            "when_is_it_updated": "When `rewardToken.transfer(msg.sender, reward)` is successfully executed within the `_claim` function, but only if `reward` is greater than 0.",
            "how_to_validate_state_update": "If `reward > 0`, the `balanceOf` the `DFIREStaking` contract address should decrease by `reward`.",
            "has_conditional_updates": true,
            "summary_of_update": "The reward token balance of the DFIREStaking contract decreases by the calculated `reward` amount.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "canSBRStakingPoolReceiveRewards",
            "type": "boolean",
            "what_does_it_track": "A boolean flag indicating if the DFIREStaking contract (referred to as SBR Staking Pool) is eligible to receive rewards from the StableBaseCDP contract.",
            "why_is_is_important": "It activates the reward distribution mechanism from `StableBaseCDP` to `DFIREStaking`, ensuring that rewards can begin flowing once the staking pool becomes active with its first stake.",
            "when_is_it_updated": "If `rewardSenderActive` is true AND the `totalStake` was previously zero (meaning this is the first stake in the pool).",
            "how_to_validate_state_update": "The `canSBRStakingPoolReceiveRewards` flag should be set to `true` if the conditions are met.",
            "has_conditional_updates": true,
            "summary_of_update": "The flag indicating whether the SBR staking pool can receive rewards from the StableBaseCDP contract is set to `true`.",
            "conditions": [
              "rewardSenderActive == true",
              "totalStake == 0 (before this stake)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}