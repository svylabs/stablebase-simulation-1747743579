{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer representing the number of staking tokens the user wants to stake. Ensure this value is greater than 0.",
      "The user must have a sufficient balance of the `stakingToken` (as defined in the contract references) to allow the transfer of the specified `_amount` to the contract. Check user's balance before staking.",
      "The `_amount` parameter should not be zero. Staking zero tokens will revert the transaction."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Core Stake Logic",
        "state_update_descriptions": [
          "The user's stake amount in the `stakes` mapping is increased by `_amount`.",
          "The contract's `totalStake` is increased by `_amount`.",
          "The user's `rewardSnapshot` is updated to the current `totalRewardPerToken`.",
          "The user's `collateralSnapshot` is updated to the current `totalCollateralPerToken`.",
          "If `rewardSenderActive` is true and `_oldTotalStake == 0` (meaning this is the first stake), then `IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true)` is called."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "The staking contract's balance of `stakingToken` increases.",
          "The user's balance of `stakingToken` decreases."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "If there's a pending reward, it is transferred from the contract to the user. The contract's rewardToken balance is decreased.",
          "If there's pending collateral reward, it is transferred from the contract to the user. The contract's ether balance is decreased."
        ]
      },
      {
        "category": "Event Emission",
        "state_update_descriptions": [
          "The `Staked` event is emitted with the user's address and the amount staked.",
          "The `Claimed` event is emitted with user's address, reward amount, and collateral reward amount."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Update",
        "rule_descriptions": [
          "The user's stake in the `stakes` mapping should increase by the specified `_amount`.",
          "The contract's `totalStake` should increase by the specified `_amount`.",
          "The user's `rewardSnapshot` should be updated to the current `totalRewardPerToken`.",
          "The user's `collateralSnapshot` should be updated to the current `totalCollateralPerToken`.",
          "The staking contract's balance of the `stakingToken` should increase by `_amount`.",
          "The user's balance of the `stakingToken` should decrease by `_amount`."
        ]
      },
      {
        "category": "Reward Sender Interaction",
        "rule_descriptions": [
          "If `rewardSenderActive` is true and `totalStake` was previously 0 before staking, then `stableBaseContract.setCanSBRStakingPoolReceiveRewards(true)` should be called."
        ]
      },
      {
        "category": "Reward Claim",
        "rule_descriptions": [
          "If there's a pending reward (`reward > 0`), it should be transferred from the contract to the user, and the contract's balance of `rewardToken` should decrease accordingly.",
          "If there's pending collateral reward (`collateralReward > 0`), it should be transferred from the contract to the user, and the contract's ether balance should decrease accordingly."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of staking token staked by a user.",
            "why_is_is_important": "It represents the user's share in the staking pool and determines their reward.",
            "when_is_it_updated": "When the stake function is called with a positive amount.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's address to see the updated stake amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The stake amount of the user is increased by the amount specified in the stake function.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The snapshot of the total reward per token for a user.",
            "why_is_is_important": "It is used to calculate the reward earned by the user since their last claim.",
            "when_is_it_updated": "Before staking, the _claim function is called, updating rewardSnapshot to totalRewardPerToken.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's rewardSnapshot.",
            "has_conditional_updates": false,
            "summary_of_update": "The rewardSnapshot of the user is updated to the current totalRewardPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The snapshot of the total collateral per token for a user.",
            "why_is_is_important": "It is used to calculate the collateral reward earned by the user since their last claim.",
            "when_is_it_updated": "Before staking, the _claim function is called, updating collateralSnapshot to totalCollateralPerToken.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's collateralSnapshot.",
            "has_conditional_updates": false,
            "summary_of_update": "The collateralSnapshot of the user is updated to the current totalCollateralPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked in the contract.",
            "why_is_is_important": "It is used to calculate the reward per token.",
            "when_is_it_updated": "When the stake function is called with a positive amount.",
            "how_to_validate_state_update": "Check the totalStake variable.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalStake is increased by the amount specified in the stake function.",
            "conditions": []
          },
          {
            "state_variable_name": "rewardSenderActive",
            "type": "bool",
            "what_does_it_track": "Whether the reward sender is active.",
            "why_is_is_important": "It determines whether the staking pool can receive rewards from the stable base contract.",
            "when_is_it_updated": "When the stake function is called and rewardSenderActive is true and _oldTotalStake is 0.",
            "how_to_validate_state_update": "Check the rewardSenderActive variable.",
            "has_conditional_updates": true,
            "summary_of_update": "If rewardSenderActive is true and _oldTotalStake is 0, the stableBaseContract is notified that the staking pool can receive rewards.",
            "conditions": [
              "rewardSenderActive is true",
              "The previous totalStake was 0"
            ]
          }
        ]
      },
      {
        "contract_name": "dfireToken",
        "state_updated": [
          {
            "state_variable_name": "stakingToken.balanceOf(address(this))",
            "type": "uint256",
            "what_does_it_track": "The balance of stakingToken held by the contract.",
            "why_is_is_important": "Represents the total stakingToken under management by the contract.",
            "when_is_it_updated": "Each time a user stakes, the contract's balance increases.",
            "how_to_validate_state_update": "Check the contract's balance of stakingToken.",
            "has_conditional_updates": false,
            "summary_of_update": "The contract receives stakingToken from the user, increasing its stakingToken balance.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "dfidToken",
        "state_updated": [
          {
            "state_variable_name": "rewardToken.balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "The balance of rewardToken held by the user.",
            "why_is_is_important": "It represents the rewards of the user.",
            "when_is_it_updated": "When the _claim function is called, and reward > 0, the rewardToken is transferred to the user.",
            "how_to_validate_state_update": "Check the user's balance of rewardToken.",
            "has_conditional_updates": true,
            "summary_of_update": "The user receives rewardToken, increasing their rewardToken balance.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "address",
        "state_updated": [
          {
            "state_variable_name": "address(msg.sender).balance",
            "type": "uint256",
            "what_does_it_track": "The balance of ether held by the user.",
            "why_is_is_important": "It represents the collateral rewards of the user.",
            "when_is_it_updated": "When the _claim function is called and collateralReward > 0, ether is transferred to the user.",
            "how_to_validate_state_update": "Check the user's balance of ether.",
            "has_conditional_updates": true,
            "summary_of_update": "The user receives ether, increasing their ether balance.",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "stableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "canSBRStakingPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "Whether the staking pool can receive rewards.",
            "why_is_is_important": "It determines whether the staking pool is eligible to receive rewards from the stable base contract.",
            "when_is_it_updated": "When the stake function is called and rewardSenderActive is true and _oldTotalStake is 0.",
            "how_to_validate_state_update": "Check the canSBRStakingPoolReceiveRewards variable in the stableBaseContract.",
            "has_conditional_updates": true,
            "summary_of_update": "If rewardSenderActive is true and _oldTotalStake is 0, the stableBaseContract is notified that the staking pool can receive rewards.",
            "conditions": [
              "rewardSenderActive is true",
              "The previous totalStake was 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}