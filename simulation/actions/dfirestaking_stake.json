{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter must be greater than 0.",
      "The msg.sender must have sufficient balance of the stakingToken to transfer _amount to the contract. User's stakingToken balance must be greater than or equal to _amount",
      "Ensure that the stakingToken contract has approved the DFIREStaking contract to transferFrom on behalf of the user, or that the user has enough balance to make the transfer without approval.",
      "Generate a random amount greater than zero for _amount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "The `stakes` mapping is updated for the `msg.sender`. The `stake` value is increased by `_amount`.",
          "The user's reward snapshot is updated with the current global reward per token value.",
          "The user's collateral snapshot is updated with the current global collateral per token value."
        ]
      },
      {
        "category": "Total Stake",
        "state_update_descriptions": [
          "The `totalStake` variable is increased by `_amount`."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "The user's reward and collateral reward balances are updated by claiming pending rewards before staking. This involves transferring rewardToken and potentially ETH to the user, based on accumulated rewards."
        ]
      },
      {
        "category": "External Contract Interaction",
        "state_update_descriptions": [
          "The staking token is transferred from the user to the contract using `stakingToken.transferFrom(msg.sender, address(this), _amount)`."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "state_update_descriptions": [
          "If `rewardSenderActive` is true and the total stake was 0 before the stake, then the `stableBaseContract`'s `canSBRStakingPoolReceiveRewards` flag is set to true via a call to `IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true)`."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "stakes[msg.sender].stake should be equal to the previous stake plus the staked amount.",
          "stakes[msg.sender].rewardSnapshot should be equal to the totalRewardPerToken.",
          "stakes[msg.sender].collateralSnapshot should be equal to the totalCollateralPerToken."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "totalStake should be equal to the previous totalStake plus the staked amount."
        ]
      },
      {
        "category": "Token Transfer",
        "rule_descriptions": [
          "The stakingToken's balance of the DFIREStaking contract should increase by the staked amount.",
          "The stakingToken's balance of the msg.sender should decrease by the staked amount."
        ]
      },
      {
        "category": "Reward Sender",
        "rule_descriptions": [
          "If `rewardSenderActive` is true and the initial `totalStake` was 0, the `stableBaseContract`'s `canSBRStakingPoolReceiveRewards` function should have been called with true as the argument. Verifying the event emitted by the reward sender contract would be a proxy."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `Staked` event should be emitted with the user's address and the staked amount.",
          "A `Claimed` event should be emitted with the user's address, reward amount, and collateral reward amount."
        ]
      },
      {
        "category": "Staking Token",
        "rule_descriptions": [
          "The `stakingToken` is an ERC20 token. The user must have approved the contract to spend at least `_amount` tokens, or the user's balance must be greater than or equal to `_amount`."
        ]
      },
      {
        "category": "Amount",
        "rule_descriptions": [
          "The `_amount` must be greater than 0."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "The amount of staking tokens staked by each user.",
            "why_is_is_important": "It tracks each user's stake, which is used to calculate rewards and for unstaking.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's address.  It should reflect the increased stake.",
            "has_conditional_updates": true,
            "summary_of_update": "The stake amount for the user is increased.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked in the contract.",
            "why_is_is_important": "It tracks the total stake, used in reward calculations and for knowing total contract holdings.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable. It should reflect the increased stake.",
            "has_conditional_updates": true,
            "summary_of_update": "The total amount of tokens staked in the contract is increased.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseContract",
            "type": "address",
            "what_does_it_track": "Address of the contract to interact with for reward distribution.",
            "why_is_is_important": "Enables reward distribution from the StableBaseContract to the staking pool.",
            "when_is_it_updated": "When a stake occurs and rewardSenderActive is true.",
            "how_to_validate_state_update": "Check if the stableBaseContract has been called to setCanSBRStakingPoolReceiveRewards(true).",
            "has_conditional_updates": true,
            "summary_of_update": "If it is the first stake, the StableBaseContract is notified.",
            "conditions": [
              "rewardSenderActive && _oldTotalStake == 0"
            ]
          },
          {
            "state_variable_name": "rewardToken",
            "type": "IERC20",
            "what_does_it_track": "The reward token contract address.",
            "why_is_is_important": "It is how the user is rewarded.",
            "when_is_it_updated": "Always, the rewards are claimed before staking",
            "how_to_validate_state_update": "Check the rewardToken balance of the user. It should reflect the transferred reward.",
            "has_conditional_updates": true,
            "summary_of_update": "Reward tokens are transferred to the user.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "N/A",
            "what_does_it_track": "N/A",
            "why_is_is_important": "It is how the user receives collateral rewards.",
            "when_is_it_updated": "Always, the collateral rewards are claimed before staking",
            "how_to_validate_state_update": "Check the ether balance of the user. It should reflect the transferred collateral reward.",
            "has_conditional_updates": true,
            "summary_of_update": "Collateral rewards (ETH) are transferred to the user.",
            "conditions": [
              "collateralReward > 0"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Stores the totalRewardPerToken value at the time of the user's last stake or claim.",
            "why_is_is_important": "Used to calculate reward owed to user since the snapshot",
            "when_is_it_updated": "Always, before updating the stake, or claiming rewards",
            "how_to_validate_state_update": "Check the rewardSnapshot variable in stakes mapping for the user's address. It should be updated to totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the reward snapshot for the user to current totalRewardPerToken",
            "conditions": [
              "Always"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Stores the totalCollateralPerToken value at the time of the user's last stake or claim.",
            "why_is_is_important": "Used to calculate collateral reward owed to user since the snapshot",
            "when_is_it_updated": "Always, before updating the stake, or claiming rewards",
            "how_to_validate_state_update": "Check the collateralSnapshot variable in stakes mapping for the user's address. It should be updated to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateral snapshot for the user to current totalCollateralPerToken",
            "conditions": [
              "Always"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "The balance of staking tokens for each address.",
            "why_is_is_important": "It reflects that the contract now holds the staked tokens.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the balance of the msg.sender in the stakingToken contract, it should have decreased by _amount. Check the balance of the DFIREStaking contract in the stakingToken contract, it should have increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The staking tokens are transferred from the user to the contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "The balance of reward tokens for each address.",
            "why_is_is_important": "It is how the user is rewarded.",
            "when_is_it_updated": "When the rewards are claimed",
            "how_to_validate_state_update": "Check the balance of the DFIREStaking contract. It should have decreased by reward amount. Check the balance of the user, it should have increased by the reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Reward tokens are transferred from the contract to the user.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}