{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be greater than 0.",
      "The user must have sufficient balance of the `stakingToken` to transfer the specified `_amount` to the contract.",
      "The user must approve the DFIREStaking contract to spend `_amount` of their `stakingToken`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stakes",
        "state_update_descriptions": [
          "The user's stake in the `stakes` mapping is increased by the staked amount.",
          "The user's `rewardSnapshot` is updated to `totalRewardPerToken` before staking.",
          "The user's `collateralSnapshot` is updated to `totalCollateralPerToken` before staking."
        ]
      },
      {
        "category": "Total Stakes",
        "state_update_descriptions": [
          "The `totalStake` is increased by the staked amount."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "The user may receive reward tokens based on their previous stake and the difference between `totalRewardPerToken` and their `rewardSnapshot`.",
          "The user may receive collateral reward based on their previous stake and the difference between `totalCollateralPerToken` and their `collateralSnapshot`.",
          "The contract transfers reward tokens to the user, if any reward is due.",
          "The contract transfers collateral (ETH) to the user, if any collateral reward is due."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "state_update_descriptions": [
          "If `rewardSenderActive` is true and `totalStake` was previously 0, the `setCanSBRStakingPoolReceiveRewards` function on the `stableBaseContract` *may* be called to activate reward distribution."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "The specified amount of staking tokens is transferred from the user to the contract."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "A `Staked` event is emitted, indicating the user and the amount staked.",
          "A `Claimed` event is emitted, indicating the user, reward amount, and collateral reward amount."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stake, as recorded in the `stakes` mapping, should be increased by the staked amount.",
          "The user's `rewardSnapshot` should be equal to the `totalRewardPerToken` at the time of staking.",
          "The user's `collateralSnapshot` should be equal to the `totalCollateralPerToken` at the time of staking."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "The `totalStake` should be increased by the staked amount."
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The contract's balance of the staking token should increase by the staked amount.",
          "The user's balance of the staking token should decrease by the staked amount."
        ]
      },
      {
        "category": "Reward Distribution Activation",
        "rule_descriptions": [
          "If `rewardSenderActive` is true and `totalStake` was previously 0, verify that `IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true)` was indeed called on the `stableBaseContract`.",
          "This can be verified by checking the state of `stableBaseContract` or by checking the emitted events/logs."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "Tracks the amount of tokens staked by each user, reward snapshot and collateral snapshot.",
            "why_is_is_important": "It is important for tracking individual user's stakes for reward distribution and unstaking purposes. Reward and collateral snapshots are used for claiming rewards later.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the msg.sender address to see if the stake has increased by the specified _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the stake amount for the user in the stakes mapping, as well as reward and collateral snapshots.",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom is successful"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the contract.",
            "why_is_is_important": "It is important for calculating the total rewards to be distributed among all users.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable to ensure it has increased by the amount staked.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total amount of tokens staked in the contract.",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom is successful"
            ]
          },
          {
            "state_variable_name": "stableBaseContract",
            "type": "address",
            "what_does_it_track": "Address of the stable base contract.",
            "why_is_is_important": "Used to signal to another contract (StableBaseCDP) that the staking pool can now receive rewards. Allows the staking pool to start receiving rewards from the stable base contract.",
            "when_is_it_updated": "When the first user stakes tokens and rewardSenderActive is true.",
            "how_to_validate_state_update": "Check if the setCanSBRStakingPoolReceiveRewards function has been called on the stableBaseContract.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls setCanSBRStakingPoolReceiveRewards to true on the stableBaseContract.",
            "conditions": [
              "rewardSenderActive is true",
              "_oldTotalStake == 0"
            ]
          },
          {
            "state_variable_name": "rewardToken",
            "type": "address",
            "what_does_it_track": "Reward token contract address.",
            "why_is_is_important": "Allows users to claim accrued reward before stake action.",
            "when_is_it_updated": "Before staking.",
            "how_to_validate_state_update": "Check the rewardToken contract balance of the staker before and after to ensure the amount is transferred.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers rewards to user if there are pending rewards. Updates user's rewardSnapshot to current totalRewardPerToken.",
            "conditions": [
              "Always, Claiming any accrued reward during staking"
            ]
          },
          {
            "state_variable_name": "totalCollateralPerToken",
            "type": "uint256",
            "what_does_it_track": "Reward per token collateral.",
            "why_is_is_important": "Allows users to claim accrued collateral reward before stake action.",
            "when_is_it_updated": "Before staking.",
            "how_to_validate_state_update": "Check msg.sender ETH balance to see collateral reward transferred.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers collateral reward to user if there is pending collateral reward. Updates user's collateralSnapshot to current totalCollateralPerToken.",
            "conditions": [
              "Always, Claiming any accrued collateral reward during staking"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf",
            "type": "mapping",
            "what_does_it_track": "Tracks the token balance of each address.",
            "why_is_is_important": "Essential for tracking token ownership and ensuring correct transfer of staked tokens. Ensures users have sufficient balance to stake.",
            "when_is_it_updated": "When tokens are transferred between addresses during staking.",
            "how_to_validate_state_update": "Check the balance of msg.sender and DFIREStaking contract using balanceOf(address). Ensure msg.sender balance decreases by _amount and DFIREStaking balance increases by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the staking token (_amount) from the user to the DFIREStaking contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of reward tokens for each address.",
            "why_is_is_important": "Makes sure user gets the claimed reward.",
            "when_is_it_updated": "Before stake action, if there are pending rewards to be claimed.",
            "how_to_validate_state_update": "Check the rewardToken balance of msg.sender and the contract before and after the transfer. User balance should increase, contract balance should decrease.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to the user.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}