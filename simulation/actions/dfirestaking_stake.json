{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter must be greater than 0.",
      "The user must have a sufficient balance of stakingToken to transfer _amount to the contract.",
      "If the user's allowance for the DFIREStaking contract to transfer stakingToken is insufficient, the user needs to approve the DFIREStaking contract before staking.",
      "Consider different values for _amount, including small amounts, large amounts, and edge cases (e.g., maximum stakable amount).",
      "If the user has an existing stake, consider adding a small amount, and a large amount to test the reward calculation.",
      "If the user has not claimed rewards recently, the amount of reward and collateral reward to claim can be increased."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stakes",
        "state_update_descriptions": [
          "The user's stake is increased by the staked amount (_amount).",
          "The user's rewardSnapshot is updated to the current totalRewardPerToken.",
          "The user's collateralSnapshot is updated to the current totalCollateralPerToken."
        ]
      },
      {
        "category": "Total Stakes",
        "state_update_descriptions": [
          "The totalStake is increased by the staked amount (_amount)."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "The user may receive reward tokens (rewardToken) based on their previous stake and the accumulated rewards.",
          "The user may receive collateral reward (ETH) based on their previous stake and the accumulated collateral rewards."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "state_update_descriptions": [
          "If rewardSenderActive is true and the totalStake was previously zero before the staking operation, the IRewardSender contract at stableBaseContract address will be notified to enable SBR staking pool reward receiving."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "stakingToken are transferred from the user to the DFIREStaking contract."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "stakes[msg.sender].stake should be equal to the previous stake plus _amount.",
          "stakes[msg.sender].rewardSnapshot should be equal to totalRewardPerToken before the transaction.",
          "stakes[msg.sender].collateralSnapshot should be equal to totalCollateralPerToken before the transaction."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "totalStake should be equal to the previous totalStake plus _amount."
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The balance of stakingToken in the DFIREStaking contract should increase by _amount.",
          "The balance of stakingToken of the user (msg.sender) should decrease by _amount.",
          "Verify that the user has sufficient stakingToken balance before the staking operation."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A Staked event should be emitted with the user's address and the staked amount (_amount).",
          "A Claimed event should be emitted with the user's address, the reward amount, and the collateral reward amount if any rewards were claimed."
        ]
      },
      {
        "category": "Reward Sender State (Conditional)",
        "rule_descriptions": [
          "If rewardSenderActive is true and totalStake was previously zero before the staking operation, IRewardSender(stableBaseContract).canSBRStakingPoolReceiveRewards() should return true after the transaction."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "Tracks the stake amount for each user.",
            "why_is_is_important": "It's important for tracking individual user's stake for reward calculation and unstaking.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the msg.sender to see if the stake value has increased by the _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The stake amount for the msg.sender is increased by _amount.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the contract.",
            "why_is_is_important": "It's important for calculating rewards distribution among stakers.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable to see if it has increased by _amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The totalStake is increased by _amount.",
            "conditions": [
              "None"
            ]
          },
          {
            "state_variable_name": "stableBaseContract",
            "type": "address",
            "what_does_it_track": "Tracks the address of the stable base contract.",
            "why_is_is_important": "This enables reward distribution.",
            "when_is_it_updated": "When the first stake happens, it tells the reward sender that staking pool can receive rewards.",
            "how_to_validate_state_update": "Check the stableBaseContract if `setCanSBRStakingPoolReceiveRewards` is called with `true`",
            "has_conditional_updates": true,
            "summary_of_update": "If rewardSenderActive is true and totalStake was 0 before this stake, it calls stableBaseContract to setCanSBRStakingPoolReceiveRewards to true.",
            "conditions": [
              "rewardSenderActive is true",
              "_oldTotalStake is 0"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "reward snapshot of the user",
            "why_is_is_important": "To calculate the rewards for the user based on stake duration",
            "when_is_it_updated": "Before updating user's stake",
            "how_to_validate_state_update": "Check rewardToken balance of msg.sender has increased.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the rewardSnapshot for the user with the current totalRewardPerToken.",
            "conditions": [
              "None"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral snapshot of the user",
            "why_is_is_important": "To calculate the collateral rewards for the user based on stake duration",
            "when_is_it_updated": "Before updating user's stake",
            "how_to_validate_state_update": "Check collateral reward per token.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateralSnapshot for the user with the current totalCollateralPerToken.",
            "conditions": [
              "None"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of DFIRE tokens for each address.",
            "why_is_is_important": "Reflects the amount of tokens owned by each address.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the balance of the DFIREStaking contract has increased and the balance of the msg.sender has decreased.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the staking token from the msg.sender to the DFIREStaking contract.",
            "conditions": [
              "Amount > 0",
              "Sufficient allowance",
              "Sufficient balance"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of DFID tokens for each address.",
            "why_is_is_important": "Reflects the amount of reward tokens owned by each address.",
            "when_is_it_updated": "When a user stakes tokens and has unclaimed rewards.",
            "how_to_validate_state_update": "Check rewardToken balance of msg.sender has increased.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens from the DFIREStaking contract to the msg.sender.",
            "conditions": [
              "Reward > 0",
              "Sufficient balance in contract"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}