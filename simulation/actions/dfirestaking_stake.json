{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer representing the amount of staking tokens to be staked.",
      "The `_amount` parameter should be less than or equal to the user's balance of the staking token.",
      "The `_amount` parameter should be greater than 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Staking",
        "state_update_descriptions": [
          "User's stake is increased by `_amount`.",
          "User's `rewardSnapshot` is updated to `totalRewardPerToken`.",
          "User's `collateralSnapshot` is updated to `totalCollateralPerToken`.",
          "Total stake is increased by `_amount`."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "User's `stakingToken` balance decreases by `_amount`.",
          "Contract's `stakingToken` balance increases by `_amount`."
        ]
      },
      {
        "category": "Reward and Collateral Claim",
        "state_update_descriptions": [
          "User may receive `rewardToken` based on stake and `totalRewardPerToken` difference.",
          "User may receive collateral in native tokens based on stake and `totalCollateralPerToken` difference."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "state_update_descriptions": [
          "If `rewardSenderActive` and `totalStake` was 0, `stableBaseContract`'s `canSBRStakingPoolReceiveRewards` is set to true."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Staking",
        "rule_descriptions": [
          "`stakes[msg.sender].stake` should increase by `_amount` from initial value.",
          "`stakes[msg.sender].rewardSnapshot` should equal `totalRewardPerToken`.",
          "`stakes[msg.sender].collateralSnapshot` should equal `totalCollateralPerToken`.",
          "`totalStake` should increase by `_amount` from initial value."
        ]
      },
      {
        "category": "Token Transfers",
        "rule_descriptions": [
          "User's `stakingToken` balance decreases by `_amount` (check `stakingToken.balanceOf(msg.sender)` before and after).",
          "Contract's `stakingToken` balance increases by `_amount` (check `stakingToken.balanceOf(address(this))` before and after)."
        ]
      },
      {
        "category": "Reward and Collateral Claim",
        "rule_descriptions": [
          "User's `rewardToken` and native token balances increase if reward/collateral claims are successful.",
          "If `reward > 0`, `rewardToken.transfer(msg.sender, reward)` was called.",
          "If `collateralReward > 0`, `msg.sender.call{value: collateralReward}(\"\")` was called."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "rule_descriptions": [
          "If `rewardSenderActive` and `totalStake` was 0 before stake, `IRewardSender(stableBaseContract).canSBRStakingPoolReceiveRewards()` returns `true`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "Stake, reward snapshot, and collateral snapshot for a user.",
            "why_is_is_important": "Tracks the stake, reward snapshot, and collateral snapshot for each user. Used to calculate and distribute rewards.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's address after the stake.  The stake value should increase by the staked amount, and rewardSnapshot and collateralSnapshot should be updated to current totalRewardPerToken and totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the stake, rewardSnapshot, and collateralSnapshot for the user at msg.sender.",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom successful"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Total amount of tokens staked.",
            "why_is_is_important": "Tracks the total amount of tokens staked in the contract. Used to calculate rewards.",
            "when_is_it_updated": "When a user stakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable after the stake. It should increase by the staked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the totalStake by the staked amount (_amount).",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom successful"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "uint256",
            "what_does_it_track": "Tracks the DFIREToken balance of user.",
            "why_is_is_important": "It tracks the balance of the staker.",
            "when_is_it_updated": "When `stake` function is called.",
            "how_to_validate_state_update": "Query the `balanceOf` function in `DFIREToken` contract with the staker's address before and after the `stake` function in `DFIREStaking` contract is called. The balance should decrease by the amount staked.",
            "has_conditional_updates": false,
            "summary_of_update": "Decrease the `balanceOf` staker address by `_amount`",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom successful"
            ]
          },
          {
            "state_variable_name": "balances",
            "type": "uint256",
            "what_does_it_track": "Tracks the DFIREToken balance of DFIREStaking contract.",
            "why_is_is_important": "It tracks the balance of the DFIREStaking contract.",
            "when_is_it_updated": "When `stake` function is called.",
            "how_to_validate_state_update": "Query the `balanceOf` function in `DFIREToken` contract with the `DFIREStaking` contract's address before and after the `stake` function in `DFIREStaking` contract is called. The balance should increase by the amount staked.",
            "has_conditional_updates": false,
            "summary_of_update": "Increase the `balanceOf` DFIREStaking contract address by `_amount`",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom successful"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "uint256",
            "what_does_it_track": "Tracks reward token balance of user.",
            "why_is_is_important": "Tracks reward token balance of user.",
            "when_is_it_updated": "If there is any claimable reward when stake is called.",
            "how_to_validate_state_update": "Check the rewardToken.transfer function call. The user's balance in DFIDToken should increase by the reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase the user's reward token balance.",
            "conditions": [
              "_amount > 0",
              "stakingToken.transferFrom successful",
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}