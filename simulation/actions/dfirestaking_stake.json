{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be greater than 0. Otherwise, the transaction will revert with the message 'Cannot stake zero tokens'.",
      "The `msg.sender` must have sufficient balance of the `stakingToken` to transfer `_amount` to the contract. An `approve` call to `stakingToken` might be needed before calling `stake` if the contract is not already approved to spend the user's tokens.",
      "The `_amount` should be a reasonable value, as very large values can lead to unexpected behavior or overflow issues. Consider the total supply and existing stake amounts when determining `_amount`."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Update",
        "state_update_descriptions": [
          "The `stake` field of the `stakes` mapping for the `msg.sender` is increased by `_amount`: `stakes[msg.sender].stake += _amount`.",
          "The `rewardSnapshot` field of the `stakes` mapping for the `msg.sender` is updated to the current `totalRewardPerToken`: `stakes[msg.sender].rewardSnapshot = totalRewardPerToken`.",
          "The `collateralSnapshot` field of the `stakes` mapping for the `msg.sender` is updated to the current `totalCollateralPerToken`: `stakes[msg.sender].collateralSnapshot = totalCollateralPerToken`.",
          "The `totalStake` is increased by `_amount`: `totalStake += _amount`."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "The user may receive reward tokens. The amount, `reward`, is calculated as `((totalRewardPerToken - user.rewardSnapshot) * user.stake) / PRECISION`.",
          "The user may receive collateral reward (ETH). The amount, `collateralReward`, is calculated as `((totalCollateralPerToken - user.collateralSnapshot) * user.stake) / PRECISION`."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "The contract transfers `_amount` of `stakingToken` from `msg.sender` to the contract itself using `stakingToken.transferFrom(msg.sender, address(this), _amount)`. This interaction could revert if the user has not approved the contract to spend their `stakingToken`.",
          "The contract transfers `reward` of `rewardToken` to `msg.sender` using `rewardToken.transfer(msg.sender, reward)`. This assumes the contract has enough `rewardToken` balance.",
          "The contract transfers `collateralReward` of ETH to `msg.sender` using `msg.sender.call{value: collateralReward}(\"\")`. This will fail if sending ETH to `msg.sender` fails."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "state_update_descriptions": [
          "If `rewardSenderActive` is true and `totalStake` was previously zero, the contract calls `IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true)`."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "A `Staked` event is emitted with `user` as `msg.sender` and `amount` as `_amount`.",
          "A `Claimed` event is emitted with `user` as `msg.sender`, `rewardAmount` (the reward token amount claimed), and `collateralReward` (the ETH amount claimed)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Update",
        "rule_descriptions": [
          "The `stakes[msg.sender].stake` should be increased by the `_amount` that was staked: `stakes[msg.sender].stake` (after) = `stakes[msg.sender].stake` (before) + `_amount`.",
          "The `stakes[msg.sender].rewardSnapshot` should be equal to the `totalRewardPerToken` at the time of staking: `stakes[msg.sender].rewardSnapshot` = `totalRewardPerToken` (after staking).",
          "The `stakes[msg.sender].collateralSnapshot` should be equal to the `totalCollateralPerToken` at the time of staking: `stakes[msg.sender].collateralSnapshot` = `totalCollateralPerToken` (after staking).",
          "The `totalStake` should be increased by `_amount`: `totalStake` (after) = `totalStake` (before) + `_amount`."
        ]
      },
      {
        "category": "Reward Claim",
        "rule_descriptions": [
          "If a reward was claimed, `rewardToken.balanceOf(msg.sender)` should increase by the calculated reward amount.",
          "If a collateral reward was claimed, `msg.sender`'s ETH balance should increase by the calculated collateral reward amount."
        ]
      },
      {
        "category": "Token Transfers",
        "rule_descriptions": [
          "`stakingToken.balanceOf(address(this))` should increase by `_amount`: `stakingToken.balanceOf(address(this))` (after) = `stakingToken.balanceOf(address(this))` (before) + `_amount`.",
          "`stakingToken.balanceOf(msg.sender)` should decrease by `_amount`: `stakingToken.balanceOf(msg.sender)` (after) = `stakingToken.balanceOf(msg.sender)` (before) - `_amount`."
        ]
      },
      {
        "category": "Reward Sender Activation",
        "rule_descriptions": [
          "If `totalStake` was previously zero, `rewardSenderActive` is true, then `IRewardSender(stableBaseContract).canSBRStakingPoolReceiveRewards()` should return true after the stake."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "Tracks the stake amount for each user.",
            "why_is_is_important": "This is important to keep track of how much each user has staked, which is used to calculate rewards. It also stores reward and collateral snapshots used in claim calculation. Address is msg.sender and it is used as key to access the data structure Stake which stores the stake, rewardSnapshot and collateralSnapshot values for the user which are required for calculating rewards upon claiming or unstaking. The rewardSnapshot and collateralSnapshot are stored to capture the totalRewardPerToken and totalCollateralPerToken value at the time of staking for the specific user which is used to accurately calculate reward upon claim or unstake. This is to avoid cases of rewarding tokens that were added to staking pool after the user staked their tokens. Furthermore, the stake value is updated to include the _amount that has been staked by the user to the staking contract. Meaning the stake amount is added to the original amount the user already has in stake if any previously exist.. Finally the _claim function is invoked which updates the user.rewardSnapshot and user.collateralSnapshot with the totalRewardPerToken and totalCollateralPerToken at the moment of staking. In addition the claim method sends both reward and collateral reward tokens to the user which effectively updates their balances with these two tokens. The transfer of rewardToken and collateral rewards will update state variables in DFIDToken and msg.sender contract respectively via external calls to these contracts. These state changes are captured in the other state update sections for DFIDToken and msg.sender address below",
            "when_is_it_updated": "When a user calls the stake function.",
            "how_to_validate_state_update": "Check the stakes mapping for the msg.sender and verify that the stake amount has increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the stake amount for the user who is calling the stake function.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the total stake amount in the contract.",
            "why_is_is_important": "This is important to keep track of the total amount staked in the contract, which is used to calculate rewards. The oldTotalStake value is used to check if the rewards sender can receive new rewards if the total stake was 0 previously. This means that a reward sender is set to receive rewards if this is the first time that the contract receives stake. This is an important parameter in the overall staking rewards calculation",
            "when_is_it_updated": "When a user calls the stake function.",
            "how_to_validate_state_update": "Check the totalStake variable and verify that it has increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total stake amount in the contract.",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseContract",
            "type": "address",
            "what_does_it_track": "Address of the stable base contract.",
            "why_is_is_important": "This is important to notify the stable base contract that the staking pool can receive rewards. The call to setCanSBRStakingPoolReceiveRewards allows the stableBaseContract to properly distribute rewards to the staking pool",
            "when_is_it_updated": "When the rewardSenderActive is true and the totalStake was previously 0.",
            "how_to_validate_state_update": "Check the stableBaseContract contract and verify that the setCanSBRStakingPoolReceiveRewards function has been called with true.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls the setCanSBRStakingPoolReceiveRewards function on the stableBaseContract contract.",
            "conditions": [
              "rewardSenderActive && _oldTotalStake == 0"
            ]
          },
          {
            "state_variable_name": "rewardToken",
            "type": "address",
            "what_does_it_track": "Address of the reward token.",
            "why_is_is_important": "This is important to distribute rewards to users. The transfer of the reward tokens is what incentivizes the user to stake in the first place",
            "when_is_it_updated": "When the reward amount is greater than 0.",
            "how_to_validate_state_update": "Check the rewardToken contract and verify that the transfer function has been called with the msg.sender and the reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward amount to the user.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "msg.sender",
            "type": "address",
            "what_does_it_track": "Address of the user.",
            "why_is_is_important": "This is important to distribute collateral rewards to users. Collateral rewards, along with reward tokens incentives users to stake and provide stability to the system",
            "when_is_it_updated": "When the collateralReward amount is greater than 0.",
            "how_to_validate_state_update": "Check the msg.sender balance and verify that it has increased by the collateralReward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the collateral reward amount to the user.",
            "conditions": [
              "collateralReward > 0"
            ]
          },
          {
            "state_variable_name": "user.rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks user's reward snapshot at the time of staking.",
            "why_is_is_important": "Stores the totalRewardPerToken at the time of staking, which is used to calculate reward earned by user. This value is important to calculate and distribute correct rewards since this value acts as the startpoint in which to calculate the rewards, while isolating rewards earned by new totalRewardPerToken in the future from affecting old rewards",
            "when_is_it_updated": "Every time user stakes.",
            "how_to_validate_state_update": "Check that the rewardSnapshot variable in the user stake struct has been updated with totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's reward snapshot.",
            "conditions": [
              "true"
            ]
          },
          {
            "state_variable_name": "user.collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks user's collateral snapshot at the time of staking.",
            "why_is_is_important": "Stores the totalCollateralPerToken at the time of staking, which is used to calculate collateral reward earned by user. This value is important to calculate and distribute correct collateral rewards since this value acts as the startpoint in which to calculate the collateral rewards, while isolating collateral rewards earned by new totalCollateralPerToken in the future from affecting old collateral rewards",
            "when_is_it_updated": "Every time user stakes.",
            "how_to_validate_state_update": "Check that the collateralSnapshot variable in the user stake struct has been updated with totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's collateral snapshot.",
            "conditions": [
              "true"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each address in the DFIREToken contract.",
            "why_is_is_important": "This is important to keep track of the staking tokens in the contract and the user's balance. The transfer from the user to the contract is required to facilitate the staking system",
            "when_is_it_updated": "When a user calls the stake function.",
            "how_to_validate_state_update": "Check the balance of the msg.sender in the DFIREToken contract and verify that it has decreased by _amount. Also, check the balance of the DFIREStaking contract and verify that it has increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the staking token from the user to the DFIREStaking contract.",
            "conditions": [
              "_amount > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each address in the DFIDToken contract.",
            "why_is_is_important": "This is important to transfer reward tokens to users, which incentivizes them to use the platform. Rewarding tokens keeps user engaged with the platform and keeps the system healthy overall",
            "when_is_it_updated": "When a user stakes tokens and has unclaimed rewards.",
            "how_to_validate_state_update": "Check the balance of the msg.sender in the DFIDToken contract and verify that it has increased by reward. Also, check the balance of the DFIREStaking contract and verify that it has decreased by the same amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the reward tokens to the user.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}