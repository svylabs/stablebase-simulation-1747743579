{
  "action": {
    "name": "Stake",
    "summary": "Allows a user to stake a specified amount of the staking token.",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "probability": 0.8
  },
  "action_detail": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer (greater than 0).",
      "The `_amount` parameter should be less than or equal to the `stakingToken` balance of `msg.sender`.",
      "Consider edge cases where `_amount` is close to the maximum uint256 value to check for potential overflow issues."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stakes",
        "state_update_descriptions": [
          "The `stake` field of the `stakes` mapping for the `msg.sender` is increased by `_amount`.",
          "The `rewardSnapshot` field of the `stakes` mapping for the `msg.sender` is updated to `totalRewardPerToken`.",
          "The `collateralSnapshot` field of the `stakes` mapping for the `msg.sender` is updated to `totalCollateralPerToken`."
        ]
      },
      {
        "category": "Total Stake",
        "state_update_descriptions": [
          "The `totalStake` is increased by `_amount`."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "`_amount` of `stakingToken` is transferred from `msg.sender` to the `DFIREStaking` contract."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "If the user has accumulated rewards, the contract attempts to transfer `rewardToken` to `msg.sender` based on their previous stake and the current `totalRewardPerToken`.",
          "If collateral rewards are available, the contract attempts to send the corresponding ETH to `msg.sender`."
        ]
      },
      {
        "category": "External Contract Interaction (Conditional)",
        "state_update_descriptions": [
          "If `rewardSenderActive` is true and `totalStake` was previously 0, then `IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true)` is called."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake Balance",
        "rule_descriptions": [
          "The `stake` field of the `stakes` mapping for the `msg.sender` should be greater than or equal to the initial stake before the transaction."
        ]
      },
      {
        "category": "Total Stake Balance",
        "rule_descriptions": [
          "The `totalStake` should be greater than or equal to its initial value before the transaction."
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The balance of `stakingToken` held by the `DFIREStaking` contract should increase by `_amount`.",
          "The balance of `stakingToken` held by `msg.sender` should decrease by `_amount`."
        ]
      },
      {
        "category": "Reward Claim",
        "rule_descriptions": [
          "If user had rewards due before the staking, the balance of `rewardToken` held by `msg.sender` should increase by the reward amount.",
          "If the contract sends collateral rewards, the `msg.sender`'s ETH balance should increase by the collateral reward amount."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `Staked` event should be emitted with the `user` set to `msg.sender` and the `amount` set to `_amount`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Stake",
    "contract_name": "DFIREStaking",
    "function_name": "stake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "Tracks the amount of tokens staked by each user.",
            "why_is_is_important": "Used to calculate rewards for stakers and track their deposited amounts.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the msg.sender's stake value, it should be increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the stake of the user (msg.sender) by the amount staked (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the contract.",
            "why_is_is_important": "Used to calculate the total reward per token and determine the proportion of rewards each user receives.",
            "when_is_it_updated": "When a user successfully stakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable, it should be increased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total stake in the contract by the amount staked (_amount).",
            "conditions": [
              "_amount > 0"
            ]
          },
          {
            "state_variable_name": "stableBaseContract",
            "type": "address",
            "what_does_it_track": "Keeps track of stableBaseContract.",
            "why_is_is_important": "Used to manage rewards distribution in conjunction with a stable base contract.",
            "when_is_it_updated": "When totalStake transitions from 0 to a positive value and rewardSenderActive is true.",
            "how_to_validate_state_update": "Check if IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true) is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(true) if rewardSenderActive is true and the old total stake is 0.",
            "conditions": [
              "rewardSenderActive && _oldTotalStake == 0"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the users reward snapshot",
            "why_is_is_important": "Used for reward calculations.",
            "when_is_it_updated": "Before updating stake",
            "how_to_validate_state_update": "Check the stakes mapping for the msg.sender's rewardSnapshot value, it should be updated to totalRewardPerToken",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the rewardSnapshot of the user to the current totalRewardPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the users collateral snapshot",
            "why_is_is_important": "Used for collateral reward calculations.",
            "when_is_it_updated": "Before updating stake",
            "how_to_validate_state_update": "Check the stakes mapping for the msg.sender's collateralSnapshot value, it should be updated to totalCollateralPerToken",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateralSnapshot of the user to the current totalCollateralPerToken.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the token balances of each address.",
            "why_is_is_important": "Ensures the contract receives the staked tokens.",
            "when_is_it_updated": "When a user stakes tokens, transferring them to the contract.",
            "how_to_validate_state_update": "Check the balance of DFIREStaking contract. It should be increased by _amount and msg.sender's balance should be decreased by _amount",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers _amount of stakingToken from msg.sender to the DFIREStaking contract.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the token balances of each address.",
            "why_is_is_important": "Distributes accumulated rewards to the staker.",
            "when_is_it_updated": "When a user stakes tokens, any pending rewards are claimed and transferred to the user.",
            "how_to_validate_state_update": "Check the balance of DFIREStaking contract. It should be decreased by reward and msg.sender's balance should be increased by reward",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens from the contract to the user if reward > 0 during _claim.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function stake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot stake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        user.stake += _amount;\n        uint256 _oldTotalStake = totalStake;\n        totalStake += _amount;\n\n        if (rewardSenderActive && _oldTotalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(true);\n        }\n\n        emit Staked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transferFrom(address from, address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        },
        "constants": []
      }
    ]
  }
}