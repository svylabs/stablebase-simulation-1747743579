{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The `_amount` parameter must be a positive integer representing the number of tokens to unstake.",
      "The `_amount` parameter must be less than or equal to the user's current stake, which can be obtained by calling the `getStake` function for the user's address."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Staking and Token Balances",
        "state_update_descriptions": [
          "The user's stake in the `stakes` mapping is decreased by the unstaked amount.",
          "The `totalStake` is decreased by the unstaked amount.",
          "The user's staking token balance increases by the unstaked amount."
        ]
      },
      {
        "category": "Reward Calculation and Distribution",
        "state_update_descriptions": [
          "The user's `rewardSnapshot` in the `stakes` mapping is updated to the current `totalRewardPerToken`.",
          "The user's `collateralSnapshot` in the `stakes` mapping is updated to the current `totalCollateralPerToken`.",
          "The user receives reward tokens, increasing their reward token balance. The amount received is based on the accumulated rewards since their last claim.",
          "The user receives collateral reward (ETH), potentially increasing their ETH balance. The amount received is based on the accumulated collateral rewards since their last claim."
        ]
      },
      {
        "category": "System State",
        "state_update_descriptions": [
          "If `totalStake` becomes zero and `rewardSenderActive` was initially true, the `rewardSenderActive` flag will be set to false. If `totalStake` is not zero, the flag remains unchanged."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Staking and Token Balances",
        "rule_descriptions": [
          "The user's stake in the `stakes` mapping should be decreased by the unstaked amount compared to its previous value.",
          "The `totalStake` should be decreased by the unstaked amount compared to its previous value.",
          "The user's balance of staking tokens should increase by the unstaked amount.",
          "The transfer of staking tokens to the user should succeed (stakingToken.transfer returns true)."
        ]
      },
      {
        "category": "Reward Calculation and Distribution",
        "rule_descriptions": [
          "The user's `rewardSnapshot` should be equal to the `totalRewardPerToken`.",
          "The user's `collateralSnapshot` should be equal to the `totalCollateralPerToken`.",
          "The transfer of reward tokens to the user should succeed (rewardToken.transfer returns true).",
          "Verify that the amount of reward tokens transferred to the user matches the calculated reward amount.",
          "Verify that the amount of collateral (ETH) transferred to the user matches the calculated collateral reward amount."
        ]
      },
      {
        "category": "System State",
        "rule_descriptions": [
          "If totalStake is 0 and rewardSenderActive was true before the transaction, rewardSenderActive should now be false. If totalStake is not 0, rewardSenderActive should remain unchanged."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `Unstaked` event should be emitted with the user's address and the unstaked amount.",
          "A `Claimed` event should be emitted with the user's address, the reward amount, and the collateral reward amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens staked by a specific user.",
            "why_is_is_important": "Tracks the amount of tokens a user has staked, affecting reward distribution and total staked amount.",
            "when_is_it_updated": "When the `unstake` function is called with a valid amount.",
            "how_to_validate_state_update": "Check the `stakes` mapping for the user's address after the transaction to ensure the stake is reduced by the unstaked amount. Specifically, `stakes[msg.sender].stake` should be lower.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduces the user's stake by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked in the contract.",
            "why_is_is_important": "Tracks the total amount of tokens staked in the contract, affecting reward distribution.",
            "when_is_it_updated": "When the `unstake` function is called with a valid amount.",
            "how_to_validate_state_update": "Check the `totalStake` variable after the transaction to ensure it's reduced by the unstaked amount. Specifically, `totalStake` should be lower.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduces the total stake by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stableBaseContract.canSBRStakingPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "Whether the staking pool can receive rewards.",
            "why_is_is_important": "Pauses reward distribution when there are no more tokens staked.",
            "when_is_it_updated": "When the last user unstakes all tokens and `rewardSenderActive` is active.",
            "how_to_validate_state_update": "Call the `canSBRStakingPoolReceiveRewards` function on the `stableBaseContract` after the transaction to confirm it is set to `false`.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the `canSBRStakingPoolReceiveRewards` flag in the `stableBaseContract` to false if `rewardSenderActive` is true and `totalStake` becomes zero.",
            "conditions": [
              "rewardSenderActive == true",
              "totalStake == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "rewardToken",
            "type": "IERC20",
            "what_does_it_track": "Reward token contract",
            "why_is_is_important": "Reward distribution",
            "when_is_it_updated": "When there is pending reward to be claimed",
            "how_to_validate_state_update": "Check the user's balance of reward tokens after the transaction to see if it increase.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to the user.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "collateralReward",
            "type": "uint256",
            "what_does_it_track": "Collateral reward value",
            "why_is_is_important": "Collateral reward distribution",
            "when_is_it_updated": "When there is pending collateral reward to be claimed",
            "how_to_validate_state_update": "Check the user's balance of ETH after the transaction to see if it increased.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers collateral reward (ETH) to the user.",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The user's reward snapshot at the time of staking.",
            "why_is_is_important": "Tracks the user's reward snapshot at the time of staking, affecting reward calculation.",
            "when_is_it_updated": "When the user unstakes.",
            "how_to_validate_state_update": "Check the `stakes` mapping for the user's address after the transaction to ensure the `rewardSnapshot` value is updated with `totalRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's reward snapshot.",
            "conditions": [
              "user.stake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The user's collateral snapshot at the time of staking.",
            "why_is_is_important": "Tracks the user's collateral snapshot at the time of staking, affecting collateral reward calculation.",
            "when_is_it_updated": "When the user unstakes.",
            "how_to_validate_state_update": "Check the `stakes` mapping for the user's address after the transaction to ensure the `collateralSnapshot` value is updated with `totalCollateralPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the user's collateral snapshot.",
            "conditions": [
              "user.stake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The user's balance of DFIRE tokens.",
            "why_is_is_important": "Moves tokens from the contract to the user, completing the unstake process.",
            "when_is_it_updated": "When the `unstake` function is called with a valid amount.",
            "how_to_validate_state_update": "Check the user's `DFIREToken` balance after the transaction to ensure it has increased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the unstaked tokens from the contract to the user.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}