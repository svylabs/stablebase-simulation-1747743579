{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "_amount > 0",
      "_amount <= stakes[msg.sender].stake"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Update",
        "state_update_descriptions": [
          "Decrease user's stake by _amount",
          "Decrease total stake by _amount"
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "Calculate and transfer reward tokens to the user",
          "Calculate and transfer collateral (ETH) to the user",
          "Update user's reward snapshot to totalRewardPerToken",
          "Update user's collateral snapshot to totalCollateralPerToken"
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfer _amount of staking tokens to the user"
        ]
      },
      {
        "category": "Reward Sender Update",
        "state_update_descriptions": [
          "If rewardSenderActive is true and totalStake becomes zero, call setCanSBRStakingPoolReceiveRewards(false) on stableBaseContract"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Update",
        "rule_descriptions": [
          "stakes[msg.sender].stake == previous_stakes[msg.sender].stake - _amount",
          "totalStake == previous_totalStake - _amount"
        ]
      },
      {
        "category": "Reward Claim",
        "rule_descriptions": [
          "userRewardTokenBalance == previousUserRewardTokenBalance + rewardAmount",
          "userETHBalance == previousUserETHBalance + collateralReward",
          "stakes[msg.sender].rewardSnapshot == totalRewardPerToken",
          "stakes[msg.sender].collateralSnapshot == totalCollateralPerToken"
        ]
      },
      {
        "category": "Token Transfer",
        "rule_descriptions": [
          "stakingTokenBalance[msg.sender] == previousStakingTokenBalance[msg.sender] + _amount"
        ]
      },
      {
        "category": "Reward Sender Update",
        "rule_descriptions": [
          "If rewardSenderActive was true and totalStake is zero, then IRewardSender(stableBaseContract).canSBRStakingPoolReceiveRewards() == false"
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "Unstaked event emitted with user address and _amount",
          "Claimed event emitted with user address, rewardAmount and collateralReward"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens staked by a user.",
            "why_is_is_important": "Reflects the current amount of tokens a user has staked, affecting reward calculations and total stake in the contract.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's stake value. It should be reduced by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked in the contract.",
            "why_is_is_important": "Used for reward calculations and tracking the overall health of the staking pool.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable. It should be reduced by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total stake by the unstaked amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "stableBaseContract.setCanSBRStakingPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "A boolean representing reward sending to the stable base contract.",
            "why_is_is_important": "Manage when the SBR staking pool receives rewards.",
            "when_is_it_updated": "When totalStake is equal to 0 and the contract is rewardSenderActive",
            "how_to_validate_state_update": "Call the rewardSenderActive function to confirm the state. If true check the stableBaseContract.setCanSBRStakingPoolReceiveRewards(false) is executed correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "If rewardSenderActive and totalStake is zero, disable reward sending to the stable base contract.",
            "conditions": [
              "rewardSenderActive",
              "totalStake == 0"
            ]
          },
          {
            "state_variable_name": "rewardToken.transfer",
            "type": "function_call",
            "what_does_it_track": "Reward Tokens transfer events",
            "why_is_is_important": "Distributes accumulated rewards to the user.",
            "when_is_it_updated": "Whenever a user unstakes tokens and they have a claimable reward.",
            "how_to_validate_state_update": "Check the rewardToken.transfer call. Check the user's balance for the rewardToken",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers accrued reward tokens to the user.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "msg.sender.call",
            "type": "function_call",
            "what_does_it_track": "Collateral Reward transfer events",
            "why_is_is_important": "Distributes accumulated collateral rewards to the user.",
            "when_is_it_updated": "Whenever a user unstakes tokens and they have a collateral reward.",
            "how_to_validate_state_update": "Check the msg.sender.call{value: collateralReward}(\"\") call. The user's eth balance increases by collateralReward",
            "has_conditional_updates": true,
            "summary_of_update": "Sends collateral reward (ETH) to the user if there are rewards.",
            "conditions": [
              "collateralReward > 0"
            ]
          },
          {
            "state_variable_name": "stakingToken.transfer",
            "type": "function_call",
            "what_does_it_track": "Transfer events related to staking tokens.",
            "why_is_is_important": "Returns the staked tokens to the user, completing the unstaking process.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check the stakingToken.transfer call. The user's staking token balance increases by _amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers unstaked tokens back to the user.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshots of totalRewardPerToken.",
            "why_is_is_important": "Used for calculating rewards for a user.",
            "when_is_it_updated": "Before claimable rewards are given to the user.",
            "how_to_validate_state_update": "Check the Claimed event. Check the rewardSnapshot and collateralSnapshot values of stakes[msg.sender].",
            "has_conditional_updates": false,
            "summary_of_update": "Update user.rewardSnapshot with totalRewardPerToken value.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshots of totalCollateralPerToken.",
            "why_is_is_important": "Used for calculating collateral rewards for a user.",
            "when_is_it_updated": "Before claimable collateral rewards are given to the user.",
            "how_to_validate_state_update": "Check the Claimed event. Check the rewardSnapshot and collateralSnapshot values of stakes[msg.sender].",
            "has_conditional_updates": false,
            "summary_of_update": "Update user.collateralSnapshot with totalCollateralPerToken value.",
            "conditions": []
          },
          {
            "state_variable_name": "Unstaked",
            "type": "event",
            "what_does_it_track": "The unstake event.",
            "why_is_is_important": "Logs unstaking activity for off-chain monitoring.",
            "when_is_it_updated": "After a user unstakes tokens.",
            "how_to_validate_state_update": "Check the Unstaked event to see if the event emitted with the correct user and amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits an event indicating the user and amount unstaked.",
            "conditions": []
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}