{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter should be a positive integer.",
      "The _amount parameter must be less than or equal to the user's current stake, which can be retrieved by calling the getStake function for the user's address."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake",
        "state_update_descriptions": [
          "The user's stake is reduced by the unstaked amount.",
          "Total stake in the contract is reduced by the unstaked amount."
        ]
      },
      {
        "category": "Rewards",
        "state_update_descriptions": [
          "User's reward snapshot is updated to the contract's total reward per token at the start of the transaction.",
          "User's collateral snapshot is updated to the contract's total collateral per token at the start of the transaction.",
          "User receives reward tokens based on their stake and the difference between the total reward per token and their reward snapshot.",
          "User receives collateral reward in ETH based on their stake and the difference between the total collateral per token and their collateral snapshot."
        ]
      },
      {
        "category": "Reward Sender Status",
        "state_update_descriptions": [
          "If rewardSenderActive is true and totalStake becomes 0 after unstaking, the contract calls setCanSBRStakingPoolReceiveRewards(false) on the stableBaseContract to disable reward sending."
        ]
      },
      {
        "category": "Transfers and Events",
        "state_update_descriptions": [
          "Staking tokens are transferred from the contract to the user.",
          "Emits an Unstaked event with the user's address and the unstaked amount.",
          "Emits a Claimed event with the user's address, reward, and collateral reward."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake",
        "rule_descriptions": [
          "stakes[msg.sender].stake should be decreased by _amount.",
          "totalStake should be decreased by _amount.",
          "stakes[msg.sender].stake should be non-negative.",
          "The value of _amount must be non-negative."
        ]
      },
      {
        "category": "Rewards",
        "rule_descriptions": [
          "stakes[msg.sender].rewardSnapshot should be equal to the contract's totalRewardPerToken at the start of the unstake transaction.",
          "stakes[msg.sender].collateralSnapshot should be equal to the contract's totalCollateralPerToken at the start of the unstake transaction.",
          "The user's balance of rewardToken should increase by the reward amount calculated based on their stake and reward snapshots.",
          "The user's ETH balance should increase by the collateral reward amount."
        ]
      },
      {
        "category": "Reward Sender Status",
        "rule_descriptions": [
          "If rewardSenderActive was true and totalStake is now 0, then IRewardSender(stableBaseContract).canSBRStakingPoolReceiveRewards() should return false."
        ]
      },
      {
        "category": "Transfers and Events",
        "rule_descriptions": [
          "The user's stakingToken balance should increase by _amount.",
          "An Unstaked event should be emitted with the user's address and _amount.",
          "A Claimed event should be emitted with the user's address, reward, and collateral reward."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of tokens a user has staked in the contract.",
            "why_is_is_important": "Reflects the accurate amount of tokens a user has staked, affecting reward calculations and total staked amount.",
            "when_is_it_updated": "When a user unstakes tokens, reducing their staked amount.",
            "how_to_validate_state_update": "Call `getStake(msg.sender)` and verify the `stake` field has decreased by `_amount`.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the user's stake.",
            "conditions": []
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked across all users.",
            "why_is_is_important": "Used for reward calculations and determining if the reward sender is active.",
            "when_is_it_updated": "When a user unstakes tokens, reducing the overall staked amount.",
            "how_to_validate_state_update": "Call `totalStake()` and verify it has decreased by `_amount`.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total stake in the contract.",
            "conditions": [
              "totalStake == 0",
              "rewardSenderActive == true"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The user's reward per token snapshot at the time of staking/unstaking/claiming.",
            "why_is_is_important": "Ensures users receive the correct reward amount based on their stake and the reward distribution at the time of unstaking.",
            "when_is_it_updated": "Before unstaking, the user's `rewardSnapshot` is updated to the current `totalRewardPerToken` to calculate and claim any pending rewards.",
            "how_to_validate_state_update": "Call `getStake(msg.sender)` before and after the transaction. The value of `rewardSnapshot` should be updated to `totalRewardPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's reward snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The user's collateral per token snapshot at the time of staking/unstaking/claiming.",
            "why_is_is_important": "Ensures users receive the correct collateral reward amount based on their stake and the collateral reward distribution at the time of unstaking.",
            "when_is_it_updated": "Before unstaking, the user's `collateralSnapshot` is updated to the current `totalCollateralPerToken` to calculate and claim any pending collateral rewards.",
            "how_to_validate_state_update": "Call `getStake(msg.sender)` before and after the transaction. The value of `collateralSnapshot` should be updated to `totalCollateralPerToken`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's collateral snapshot.",
            "conditions": []
          },
          {
            "state_variable_name": "Unstaked Event",
            "type": "event",
            "what_does_it_track": "Logs the unstake action with user and amount.",
            "why_is_is_important": "To emit an event that shows the unstake action happened",
            "when_is_it_updated": "When a user successfully unstakes tokens",
            "how_to_validate_state_update": "Check for the Unstaked event with the user's address and unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits an event indicating successful unstaking.",
            "conditions": []
          },
          {
            "state_variable_name": "Claimed Event",
            "type": "event",
            "what_does_it_track": "Logs the claimed action with user and amount.",
            "why_is_is_important": "To emit an event that shows the claimed action happened",
            "when_is_it_updated": "When a user successfully claims rewards",
            "how_to_validate_state_update": "Check for the Claimed event with the user's address, rewardAmount and collateralReward.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits an event indicating successful claiming of rewards.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The balance of the reward token for the user.",
            "why_is_is_important": "Reflects the accurate balance of reward tokens for the user.",
            "when_is_it_updated": "When the user claims their reward tokens during unstaking.",
            "how_to_validate_state_update": "Check the user's balance before and after unstaking; it should increase by the reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's reward token balance.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "The balance of the staked token for the user.",
            "why_is_is_important": "Reflects the accurate balance of staked tokens for the user.",
            "when_is_it_updated": "When the user unstakes their tokens.",
            "how_to_validate_state_update": "Check the user's balance before and after unstaking; it should increase by the unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the user's staked token balance.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "msg.sender",
        "state_updated": [
          {
            "state_variable_name": "value",
            "type": "uint256",
            "what_does_it_track": "The balance of eth for the user.",
            "why_is_is_important": "Reflects the accurate balance of collateral tokens for the user.",
            "when_is_it_updated": "When the user claims their collateral reward during unstaking.",
            "how_to_validate_state_update": "Check the user's balance before and after unstaking; it should increase by the collateral reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's collateral token balance.",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}