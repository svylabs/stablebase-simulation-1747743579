{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter must be greater than 0.",
      "The _amount parameter must be less than or equal to the user's current stake (user.stake)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "The user's stake is reduced by the unstaked amount: user.stake -= _amount."
        ]
      },
      {
        "category": "Total Stake",
        "state_update_descriptions": [
          "The total stake is reduced by the unstaked amount: totalStake -= _amount."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "The user's pending reward is calculated and transferred to the user.",
          "The user's reward snapshot is updated to the current total reward per token: user.rewardSnapshot = totalRewardPerToken.",
          "The user's pending collateral reward is calculated and transferred to the user via a payable call.",
          "The user's collateral snapshot is updated to the current total collateral per token: user.collateralSnapshot = totalCollateralPerToken."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "The unstaked tokens are transferred from the contract to the user: stakingToken.transfer(msg.sender, _amount)."
        ]
      },
      {
        "category": "Reward Sender Activity",
        "state_update_descriptions": [
          "If rewardSenderActive is true and totalStake becomes 0 after unstaking, IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(false) is called, disabling reward sending."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "An Unstaked event is emitted: emit Unstaked(msg.sender, _amount).",
          "A Claimed event is emitted: emit Claimed(msg.sender, reward, collateralReward)."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "user.stake should be equal to the initial stake minus the unstaked amount.",
          "user.stake >= 0"
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "totalStake should be equal to the initial totalStake minus the unstaked amount.",
          "totalStake >= 0"
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The user's balance of stakingToken should increase by the unstaked amount.",
          "The contract's balance of stakingToken should decrease by the unstaked amount."
        ]
      },
      {
        "category": "Reward Sender Activity",
        "rule_descriptions": [
          "If rewardSenderActive was true and totalStake is now 0, then IRewardSender(stableBaseContract).canSBRStakingPoolReceiveRewards() should return false.  Otherwise it's previous value should persist"
        ]
      },
      {
        "category": "Reward Claim",
        "rule_descriptions": [
          "The user's rewardSnapshot should equal the current totalRewardPerToken.",
          "The user's collateralSnapshot should equal the current totalCollateralPerToken."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping",
            "what_does_it_track": "Tracks the stake, rewardSnapshot and collateralSnapshot of each user.",
            "why_is_is_important": "Tracks the amount of tokens staked by each user which is required for reward calculation and unstaking.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's address to ensure the stake value has decreased by the unstaked amount. Verify that totalStake has also decreased by the same amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The stake of the user is reduced by _amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the contract.",
            "why_is_is_important": "Used to calculate the reward per token and manage overall staking metrics.",
            "when_is_it_updated": "When a user stakes or unstakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable to ensure it has decreased by the unstaked amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total stake in the contract is reduced by _amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "stableBaseContract.canSBRStakingPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "Whether the stable base contract can receive rewards from the staking pool.",
            "why_is_is_important": "Controls whether the stable base contract receives rewards, depending on the total stake amount.",
            "when_is_it_updated": "When the total stake becomes zero and reward sender is active.",
            "how_to_validate_state_update": "Check if the canSBRStakingPoolReceiveRewards function in the IRewardSender interface of the stableBaseContract is set to false.",
            "has_conditional_updates": true,
            "summary_of_update": "If rewardSenderActive is true and totalStake becomes 0, setCanSBRStakingPoolReceiveRewards in the stableBaseContract is set to false.",
            "conditions": [
              "rewardSenderActive && totalStake == 0"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks user's reward snapshot.",
            "why_is_is_important": "Used to calculate reward.",
            "when_is_it_updated": "Before unstaking the token.",
            "how_to_validate_state_update": "Check user's rewardSnapshot, collateralSnapshot in stakes mapping. Also, check the rewardToken and msg.sender balance change.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's reward snapshot",
            "conditions": [
              "Always"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks user's collateral snapshot.",
            "why_is_is_important": "Used to calculate collateral reward.",
            "when_is_it_updated": "Before unstaking the token.",
            "how_to_validate_state_update": "Check user's rewardSnapshot, collateralSnapshot in stakes mapping. Also, check the rewardToken and msg.sender balance change.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates user's collateral snapshot",
            "conditions": [
              "Always"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each user.",
            "why_is_is_important": "Tracks the token balance of the user.",
            "when_is_it_updated": "When tokens are transferred to the user, which happens during unstaking.",
            "how_to_validate_state_update": "Check the balance of msg.sender in the DFIREToken contract. It should increase by _amount.",
            "has_conditional_updates": false,
            "summary_of_update": "The balance of the user is increased by _amount in DFIREToken contract.",
            "conditions": [
              "Always"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf[msg.sender]",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of each user in DFIDToken.",
            "why_is_is_important": "Tracks the reward token balance of each user.",
            "when_is_it_updated": "When a reward is calculated and transferred during unstaking.",
            "how_to_validate_state_update": "Check the balance of msg.sender in the DFIDToken contract, and ensure that it increased by the reward.",
            "has_conditional_updates": true,
            "summary_of_update": "The balance of the user is increased by the calculated reward in DFIDToken contract.",
            "conditions": [
              "reward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}