{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter must be greater than 0.",
      "The _amount parameter must be less than or equal to the user's current stake (stakes[msg.sender].stake)."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "Decreases the user's stake (stakes[msg.sender].stake) by the unstaked amount (_amount)."
        ]
      },
      {
        "category": "Total Stake",
        "state_update_descriptions": [
          "Decreases the total stake (totalStake) by the unstaked amount (_amount)."
        ]
      },
      {
        "category": "Reward Claim",
        "state_update_descriptions": [
          "Updates the user's reward snapshot (stakes[msg.sender].rewardSnapshot) to the current total reward per token (totalRewardPerToken).",
          "Transfers accrued reward tokens (rewardToken) to the user (msg.sender).",
          "Updates the user's collateral reward snapshot (stakes[msg.sender].collateralSnapshot) to the current total collateral per token (totalCollateralPerToken).",
          "Transfers accrued collateral reward (ETH) to the user (msg.sender)."
        ]
      },
      {
        "category": "Reward Sender Status",
        "state_update_descriptions": [
          "If rewardSenderActive is true and totalStake becomes 0, the contract calls setCanSBRStakingPoolReceiveRewards(false) on the stableBaseContract via the IRewardSender interface."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfers the unstaked tokens (stakingToken) from the contract to the user (msg.sender)."
        ]
      },
      {
        "category": "Events",
        "state_update_descriptions": [
          "Emits an Unstaked event with the user's address (msg.sender) and the unstaked amount (_amount).",
          "Emits a Claimed event with the user's address (msg.sender), reward amount, and collateral reward amount."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "stakes[msg.sender].stake should be decreased by _amount compared to its initial value."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "totalStake should be decreased by _amount compared to its initial value."
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The user's (msg.sender) stakingToken balance should increase by _amount.",
          "The contract's DFIREStaking stakingToken balance should decrease by _amount."
        ]
      },
      {
        "category": "Reward Snapshot",
        "rule_descriptions": [
          "stakes[msg.sender].rewardSnapshot should be equal to totalRewardPerToken after the claim.",
          "stakes[msg.sender].collateralSnapshot should be equal to totalCollateralPerToken after the claim."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes",
            "type": "mapping(address => Stake)",
            "what_does_it_track": "Tracks the stake information for each user.",
            "why_is_is_important": "Reflects the current amount staked by the user, which is crucial for reward calculations and overall staking management.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if stakes[msg.sender].stake is decreased by _amount and totalStake is also decreased by _amount",
            "has_conditional_updates": true,
            "summary_of_update": "The stake amount for the user (msg.sender) is reduced by the _amount being unstaked.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the cumulative stake amount from all users.",
            "why_is_is_important": "Used for calculating the reward distribution ratio and overall staking contract state.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if totalStake is decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "The total amount of tokens staked in the contract is reduced by the _amount being unstaked.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "stableBaseContract",
            "type": "address",
            "what_does_it_track": "Address of the stable base contract used for reward distribution.",
            "why_is_is_important": "Manages the reward distribution mechanism and ensures rewards are not sent when there are no staked tokens.",
            "when_is_it_updated": "When the total stake becomes zero and rewardSenderActive is true upon unstaking.",
            "how_to_validate_state_update": "Check if IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards is set to false when totalStake is zero and rewardSenderActive is true.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially interacts with another contract to disable reward distribution to the staking pool if all tokens are unstaked.",
            "conditions": [
              "rewardSenderActive == true",
              "totalStake == 0"
            ]
          },
          {
            "state_variable_name": "rewardToken",
            "type": "IERC20",
            "what_does_it_track": "The contract address of the reward token (e.g., DFID).",
            "why_is_is_important": "Facilitates reward distribution to stakers, incentivizing participation.",
            "when_is_it_updated": "Whenever a user claims their reward during unstaking.",
            "how_to_validate_state_update": "Check if rewardToken.transfer(msg.sender, reward) call is successful.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers accrued reward tokens to the user who is unstaking.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "N/A",
            "what_does_it_track": "N/A",
            "why_is_is_important": "Facilitates collateral reward distribution to stakers, incentivizing participation.",
            "when_is_it_updated": "Whenever a user claims their collateral reward during unstaking.",
            "how_to_validate_state_update": "Check if msg.sender.call{value: collateralReward}(\"\") is successful.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers accrued collateral reward (ETH) to the user who is unstaking.",
            "conditions": [
              "collateralReward > 0"
            ]
          },
          {
            "state_variable_name": "stakes",
            "type": "mapping(address => Stake)",
            "what_does_it_track": "Tracks the stake information for each user.",
            "why_is_is_important": "Used in reward calculations to determine how much reward a user has earned.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if user.rewardSnapshot is updated to totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the reward snapshot for the user when they unstake tokens, using totalRewardPerToken.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes",
            "type": "mapping(address => Stake)",
            "what_does_it_track": "Tracks the stake information for each user.",
            "why_is_is_important": "Used in collateral reward calculations to determine how much collateral reward a user has earned.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check if user.collateralSnapshot is updated to totalCollateralPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the collateral snapshot for the user when they unstake tokens, using totalCollateralPerToken.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "N/A",
            "type": "N/A",
            "what_does_it_track": "N/A",
            "why_is_is_important": "Returns the user's staked tokens, allowing them to use or trade their tokens.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Verify that stakingToken.transfer(msg.sender, _amount) is called and that the transfer is successful. Check if the balance of DFIREToken for msg.sender increases by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the unstaked DFIRE tokens back to the user.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "dfireToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "dfidToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "dfidToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfidToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "mockPriceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "dfireStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StabilityPool"
            }
          ]
        }
      }
    ]
  }
}