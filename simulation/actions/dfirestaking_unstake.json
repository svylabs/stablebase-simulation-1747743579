{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "User specifies the amount of tokens to unstake, which must be greater than 0",
      "User must have an existing stake in the contract",
      "Unstake amount must be less than or equal to the user's current stake"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Stake Management",
        "state_update_descriptions": [
          "Decrease user's stake by the unstaked amount",
          "Decrease total stake by the unstaked amount"
        ]
      },
      {
        "category": "Reward Distribution",
        "state_update_descriptions": [
          "Update user's reward snapshot to the current total reward per token",
          "Update user's collateral snapshot to the current total collateral per token",
          "Transfer reward tokens to the user",
          "Transfer collateral to the user"
        ]
      },
      {
        "category": "System Configuration",
        "state_update_descriptions": [
          "Potentially disable reward sender if total stake becomes zero and reward sender is active"
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfer staked tokens back to the user"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Stake Management",
        "rule_descriptions": [
          "stakes[msg.sender].stake equals previous_stakes[msg.sender].stake minus _amount",
          "totalStake equals previousTotalStake minus _amount"
        ]
      },
      {
        "category": "Reward Distribution",
        "rule_descriptions": [
          "User's rewardSnapshot is updated to totalRewardPerToken",
          "User's collateralSnapshot is updated to totalCollateralPerToken",
          "User receives reward tokens calculated as ((totalRewardPerToken - previous_stakes[msg.sender].rewardSnapshot) * previous_stakes[msg.sender].stake) / PRECISION",
          "User receives collateral calculated as ((totalCollateralPerToken - previous_stakes[msg.sender].collateralSnapshot) * previous_stakes[msg.sender].stake) / PRECISION"
        ]
      },
      {
        "category": "System Configuration",
        "rule_descriptions": [
          "If rewardSenderActive was true and totalStake is now 0, then IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards() is now false"
        ]
      },
      {
        "category": "Token Transfer",
        "rule_descriptions": [
          "User's balance of stakingToken increases by _amount",
          "stakingToken.balanceOf(msg.sender) equals previous_stakingToken.balanceOf(msg.sender) plus _amount"
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "Unstaked event is emitted with the user's address and the unstaked amount",
          "Claimed event is emitted with the user's address, reward amount, and collateral reward",
          "Emitted Unstaked event has correct user address: event.user equals msg.sender",
          "Emitted Unstaked event has correct amount: event.amount equals _amount"
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "The amount of staked tokens for a specific user.",
            "why_is_is_important": "Reflects the current amount of tokens the user has staked.",
            "when_is_it_updated": "When the user successfully unstakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's address and verify that the stake is reduced by the unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the user's stake by the unstaked amount.",
            "conditions": []
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "The total amount of tokens staked in the contract.",
            "why_is_is_important": "Keeps track of the aggregate stake amount.",
            "when_is_it_updated": "When the user successfully unstakes tokens.",
            "how_to_validate_state_update": "Verify that the totalStake is reduced by the unstaked amount. If rewardSenderActive is true and totalStake becomes 0, then IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(false) is called.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total stake by the unstaked amount. Potentially calls IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(false). This may affect the state of stableBaseContract, but specific variables are unknown from current context. RewardSenderActive must be true and totalStake equal to zero after unstake for the stableBaseContract to be affected. Note that we do not have the code or ABI of `stableBaseContract` to determine which state variable is updated upon this call. The `IRewardSender` interface is also unknown from the given context. If rewardSenderActive is true and totalStake is 0, then IRewardSender(stableBaseContract).setCanSBRStakingPoolReceiveRewards(false) is called, which might affect the state of stableBaseContract, although no specific variables are known in this context.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "The user's reward snapshot.",
            "why_is_is_important": "Used to calculate the user's pending reward.",
            "when_is_it_updated": "Before calculating and transferring the user's reward.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's rewardSnapshot value and verify it is updated to the current totalRewardPerToken",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's reward snapshot to the current total reward per token.",
            "conditions": []
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "The user's collateral snapshot.",
            "why_is_is_important": "Used to calculate the user's pending collateral reward.",
            "when_is_it_updated": "Before calculating and transferring the user's collateral reward.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's collateralSnapshot value and verify it is updated to the current totalCollateralPerToken",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the user's collateral snapshot to the current total collateral per token.",
            "conditions": []
          },
          {
            "state_variable_name": "Unstaked",
            "type": "event",
            "what_does_it_track": "Events emitted by the contract",
            "why_is_is_important": "Logs the unstake event for off-chain monitoring and analysis.",
            "when_is_it_updated": "After the user has successfully unstaked tokens.",
            "how_to_validate_state_update": "Verify the Unstaked event is emitted with the user's address and the unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits an Unstaked event with the user's address and the unstaked amount.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "The balance of the user.",
            "why_is_is_important": "Reflects the user's current balance of staking tokens. User is receiving their unstaked tokens.",
            "when_is_it_updated": "When the staking tokens are transferred to the user.",
            "how_to_validate_state_update": "Check the user's balance of the staking token and verify that it has increased by the unstaked amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the user's balance by the unstaked amount (_amount).",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "The balance of the user.",
            "why_is_is_important": "Reflects the user's current balance of reward tokens.",
            "when_is_it_updated": "When the reward tokens are transferred to the user.",
            "how_to_validate_state_update": "Check the user's balance of the reward token and verify that it has increased by the reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's balance by the reward amount.",
            "conditions": [
              "reward > 0"
            ]
          },
          {
            "state_variable_name": "balanceOf(msg.sender)",
            "type": "uint256",
            "what_does_it_track": "The collateral balance of the user",
            "why_is_is_important": "Reflects the user's current balance of collateral reward tokens",
            "when_is_it_updated": "When the collateral reward tokens are transferred to the user.",
            "how_to_validate_state_update": "Check if the transfer of collateralReward succeeds when collateralReward is greater than 0",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the user's balance by the collateralReward amount, through a payable call",
            "conditions": [
              "collateralReward > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      }
    ]
  }
}