{
  "action": {
    "name": "Unstake",
    "summary": "Allows a user to unstake a specified amount of their staked tokens.",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "probability": 0.6
  },
  "action_detail": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "pre_execution_parameter_generation_rules": [
      "The _amount parameter must be greater than 0 to prevent errors during the transfer.",
      "The _amount parameter must be less than or equal to the user's current stake to prevent insufficient balance errors."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "User Stake",
        "state_update_descriptions": [
          "Decreases the user's stake by the unstaked amount.",
          "Updates the user's reward snapshot to the current total reward per token.",
          "Updates the user's collateral snapshot to the current total collateral per token."
        ]
      },
      {
        "category": "Total Stake",
        "state_update_descriptions": [
          "Decreases the total stake by the unstaked amount."
        ]
      },
      {
        "category": "Reward Distribution",
        "state_update_descriptions": [
          "Calculates and transfers accrued reward tokens to the user, based on the difference between the current totalRewardPerToken and the user's rewardSnapshot, multiplied by the user's stake divided by PRECISION.",
          "Calculates and transfers accrued collateral reward (ETH) to the user, based on the difference between the current totalCollateralPerToken and the user's collateralSnapshot, multiplied by the user's stake divided by PRECISION."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfers the unstaked tokens from the contract to the user, increasing the user's DFIREToken balance and decreasing the contract's DFIREToken balance."
        ]
      },
      {
        "category": "Reward Sender",
        "state_update_descriptions": [
          "If rewardSenderActive is true and totalStake becomes 0, the RewardSender contract is notified to stop sending rewards, by calling setCanSBRStakingPoolReceiveRewards(false) on the stableBaseContract."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "User Stake",
        "rule_descriptions": [
          "The user's stake should be decreased by the unstaked amount.",
          "The user's stake should not be negative; i.e., unstaking should not result in the user's stake becoming less than zero.",
          "The user's rewardSnapshot should be equal to the totalRewardPerToken at the time of unstaking.",
          "The user's collateralSnapshot should be equal to the totalCollateralPerToken at the time of unstaking."
        ]
      },
      {
        "category": "Total Stake",
        "rule_descriptions": [
          "The totalStake should be decreased by the unstaked amount.",
          "The totalStake should not be negative."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The user's DFIREToken balance should increase by the unstaked amount.",
          "The contract's DFIREToken balance should decrease by the unstaked amount.",
          "The user's reward token (DFIDToken) balance should increase by the accrued reward amount.",
          "The contract's reward token (DFIDToken) balance should decrease by the accrued reward amount."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "An Unstaked event should be emitted with the user's address and the unstaked amount.",
          "A Claimed event should be emitted with the user's address, reward amount, and collateral reward amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Unstake",
    "contract_name": "DFIREStaking",
    "function_name": "unstake",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "stakes[msg.sender].stake",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of tokens staked by a user.",
            "why_is_is_important": "Reflects the actual amount staked by user and important for reward calculations and total stake tracking.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check the stakes mapping for the user's address. The stake should be decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the user's stake by the specified amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "totalStake",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of tokens staked in the contract.",
            "why_is_is_important": "Used to calculate rewards and determine if the reward sender should be active.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check the totalStake variable. It should be decreased by _amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Decreases the total stake by the specified amount.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake"
            ]
          },
          {
            "state_variable_name": "stableBaseContract.canSBRStakingPoolReceiveRewards",
            "type": "bool",
            "what_does_it_track": "Controls if the stable base contract can receive rewards.",
            "why_is_is_important": "It is important to stop sending rewards to the stable base contract when there are no more tokens staked.",
            "when_is_it_updated": "When the total stake becomes zero.",
            "how_to_validate_state_update": "Check that the stableBaseContract's canSBRStakingPoolReceiveRewards is set to false.",
            "has_conditional_updates": true,
            "summary_of_update": "If rewardSenderActive is true and totalStake is zero, it calls setCanSBRStakingPoolReceiveRewards(false) on stableBaseContract.",
            "conditions": [
              "rewardSenderActive && totalStake == 0"
            ]
          },
          {
            "state_variable_name": "rewardToken",
            "type": "IERC20",
            "what_does_it_track": "Reward token contract.",
            "why_is_is_important": "Sends reward tokens to the user.",
            "when_is_it_updated": "When a user unstakes tokens and has claimable rewards.",
            "how_to_validate_state_update": "Check that rewardToken.transfer to user address is successful.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens to the user.",
            "conditions": [
              "reward > 0",
              "rewardToken != address(0)"
            ]
          },
          {
            "state_variable_name": "collateralReward",
            "type": "uint256",
            "what_does_it_track": "Collateral reward amount",
            "why_is_is_important": "Sends collateral reward to the user.",
            "when_is_it_updated": "When a user unstakes tokens and has claimable collateral rewards.",
            "how_to_validate_state_update": "Check that collateral reward amount has been sent to user",
            "has_conditional_updates": true,
            "summary_of_update": "Sends collateral reward to the user.",
            "conditions": [
              "collateralReward > 0",
              "collateralReward > 0"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].rewardSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the reward per token at the time of staking/unstaking.",
            "why_is_is_important": "Used to calculate the rewards earned by the user since the last stake/unstake action.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check that the rewardSnapshot is updated to totalRewardPerToken.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the reward snapshot for the user's stake.",
            "conditions": [
              "always"
            ]
          },
          {
            "state_variable_name": "stakes[msg.sender].collateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks collateral per token at the time of staking/unstaking.",
            "why_is_is_important": "Used to calculate collateral reward earned by user.",
            "when_is_it_updated": "When a user unstakes tokens",
            "how_to_validate_state_update": "Check collateralSnapshot updated to totalCollateralPerToken",
            "has_conditional_updates": false,
            "summary_of_update": "Update collateralSnapshot for user stake",
            "conditions": [
              "always"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREToken",
        "state_updated": [
          {
            "state_variable_name": "stakingToken",
            "type": "IERC20",
            "what_does_it_track": "The staking token contract.",
            "why_is_is_important": "It returns the staked tokens to the user.",
            "when_is_it_updated": "When a user unstakes tokens.",
            "how_to_validate_state_update": "Check that the user's balance increases by _amount using stakingToken.balanceOf(msg.sender).",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers the unstaked tokens back to the user.",
            "conditions": [
              "_amount > 0",
              "_amount <= user.stake",
              "stakingToken != address(0)"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function unstake(uint256 _amount) external {\n        require(_amount > 0, \"Cannot unstake zero tokens\");\n        Stake storage user = stakes[msg.sender];\n        _claim(user);\n\n        require(_amount <= user.stake, \"Invalid unstake amount\");\n\n        user.stake -= _amount;\n        totalStake -= _amount;\n\n        if (rewardSenderActive && totalStake == 0) {\n            IRewardSender(stableBaseContract)\n                .setCanSBRStakingPoolReceiveRewards(false);\n        }\n\n        require(\n            stakingToken.transfer(msg.sender, _amount),\n            \"Transfer tokens failed\"\n        );\n\n        emit Unstaked(msg.sender, _amount);\n    }\nfunction _claim(Stake storage user) internal {\n        uint256 reward = ((totalRewardPerToken - user.rewardSnapshot) *\n            user.stake) / PRECISION;\n        user.rewardSnapshot = totalRewardPerToken;\n        uint256 collateralReward = ((totalCollateralPerToken -\n            user.collateralSnapshot) * user.stake) / PRECISION;\n        user.collateralSnapshot = totalCollateralPerToken;\n        if (reward > 0) {\n            require(\n                rewardToken.transfer(msg.sender, reward),\n                \"Transfer failed\"\n            );\n        }\n        if (collateralReward > 0) {\n            (bool success, ) = msg.sender.call{value: collateralReward}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit Claimed(msg.sender, reward, collateralReward);\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREToken",
        "code_snippet": "function transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      }
    ]
  }
}