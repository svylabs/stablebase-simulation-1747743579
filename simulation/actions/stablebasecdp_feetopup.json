{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "The `safeId` must correspond to an existing safe owned by the message sender.",
      "`topupRate` must be greater than 0.",
      "`nearestSpotInRedemptionQueue` should be set to 0 if the user wants the contract to find it automatically.  Otherwise a valid `safeId` within the redemption queue should be provided. It is used as a hint to place the safe in the correct position."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the borrowed amount if cumulative debt/collateral per unit collateral has changed since the last update.",
          "Increases the safe's weight by `topupRate`.",
          "Increases the safe's feePaid by the calculated fee."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfers SBD tokens from the message sender to the contract.",
          "Potentially refunds undistributed fee back to the user."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Updates the position of the safe in the redemption queue based on the new weight."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes fees to SBR stakers and the Stability Pool.",
          "Potentially mints and burns SBD tokens during fee distribution."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Updates the total debt of the protocol and potentially transitions the protocol between bootstrap and normal modes."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates the liquidation snapshot with cumulative collateral and debt per unit collateral"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "The safe's `weight` should be increased by `topupRate`.",
          "The safe's `feePaid` should be increased by the calculated fee: `(topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR`.",
          "The safe's `borrowedAmount` is correctly updated based on protocol-wide cumulative debt changes."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The message sender's SBD token balance should be decreased by the fee amount, unless a refund occurs.",
          "The contract's SBD token balance should be increased by the fee amount, unless burning occurs.",
          "If a refund occurs, the message sender's SBD balance should be increased by `refundFee`."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "The safe's position in the redemption queue should be updated according to its new `weight`.",
          "The `prev` pointer of the node after the updated safe in the redemption queue should be the safe's `safeId`."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A `FeeTopup` event should be emitted with the correct parameters: `safeId`, `topupRate`, `feePaid`, and the safe's new `weight`.",
          "A `RedemptionQueueUpdated` event should be emitted with the correct parameters: `safeId`, the safe's new `weight`, and the ID of the previous node in the queue.",
          "A `FeeDistributed` event should be emitted showing how the fee was distributed.",
          "If a refund occurs, a `FeeRefund` event should be emitted with the `safeId` and the `refundFee`."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "Tracks the weight of a safe in the redemption queue.",
            "why_is_is_important": "Used to determine the position of the safe in the redemption queue.",
            "when_is_it_updated": "Updated when feeTopup is called.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the weight is increased by the topupRate.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the weight of the safe by topupRate.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "Tracks the total fee paid for a specific safe.",
            "why_is_is_important": "Tracks how much fee has been paid by the safe",
            "when_is_it_updated": "Updated when feeTopup is called.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the feePaid is increased by the fee amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the feePaid of the safe by the fee amount.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount borrowed for a specific safe.",
            "why_is_is_important": "Reflects the actual borrowed amount after accounting for cumulative debt changes.",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount and totalBorrowedAmount of the safe if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount borrowed for a specific safe.",
            "why_is_is_important": "Reflects the actual borrowed amount after accounting for cumulative debt changes.",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount and totalBorrowedAmount of the safe if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral amount for a specific safe.",
            "why_is_is_important": "Reflects the actual collateral amount after accounting for cumulative collateral changes.",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralAmount of the safe if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of debt per collateral.",
            "why_is_is_important": "Tracks snapshot for debt calculation",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the debtPerCollateralSnapshot of the safe if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Snapshot of collateral per collateral.",
            "why_is_is_important": "Tracks snapshot for collateral calculation",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateralPerCollateralSnapshot of the safe if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks total collateral",
            "why_is_is_important": "Tracks total collateral in protocol",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalCollateral if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks total debt",
            "why_is_is_important": "Tracks total debt in protocol",
            "when_is_it_updated": "Updated when feeTopup is called and the liquidation snapshot is outdated.",
            "how_to_validate_state_update": "Check the safes mapping for the given safeId and verify that the borrowedAmount is increased by the calculated debtIncrease. Also, verify totalBorrowedAmount is increased by the debtIncrease, collateralAmount is increased by collateralIncrease, totalCollateral is increased by collateralIncrease, and cumulativeDebtPerUnitCollateral is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the totalDebt if liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the protocol's operating mode.",
            "why_is_is_important": "Determines the operating mode of the protocol (BOOTSTRAP or NORMAL).",
            "when_is_it_updated": "Updated when totalDebt is updated and conditions are met.",
            "how_to_validate_state_update": "If totalDebt becomes greater than BOOTSTRAP_MODE_DEBT_THRESHOLD, the PROTOCOL_MODE is changed to NORMAL. Check that PROTOCOL_MODE is updated to NORMAL.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates PROTOCOL_MODE if the total debt exceeds a certain threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of a user.",
            "why_is_is_important": "Tracks the amount of SBD tokens held by the user.",
            "when_is_it_updated": "Updated when feeTopup is called and fee is transferred from msg.sender.",
            "how_to_validate_state_update": "Check the balance of the StableBaseCDP contract and verify that it has increased by the fee amount. Also check that the msg.sender balance has decreased by fee.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the SBD token balance of the msg.sender.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Tracks the SBD token balance of the StableBaseCDP contract.",
            "why_is_is_important": "Tracks the amount of SBD tokens held by the contract.",
            "when_is_it_updated": "Updated when feeTopup is called and fee is transferred to the contract.",
            "how_to_validate_state_update": "Check the balance of the StableBaseCDP contract and verify that it has increased by the fee amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the SBD token balance of the StableBaseCDP contract.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Tracks the nodes in the doubly linked list.",
            "why_is_is_important": "Stores the nodes of the ordered doubly linked list.",
            "when_is_it_updated": "Updated when feeTopup is called and the safeId is not already in the redemption queue.",
            "how_to_validate_state_update": "Verify that a new node is inserted into the linked list based on safeId, value and _nearestSpot. Verify that head and tail pointers are updated appropriately.",
            "has_conditional_updates": true,
            "summary_of_update": "If the node with the given id does not exist, insert a new node into the linked list.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes[id]",
            "type": "IDoublyLinkedList.Node",
            "what_does_it_track": "Tracks the nodes in the doubly linked list.",
            "why_is_is_important": "Stores the nodes of the ordered doubly linked list.",
            "when_is_it_updated": "Updated when feeTopup is called and the safeId is already in the redemption queue.",
            "how_to_validate_state_update": "Verify that the existing node is removed and a new node with the updated value and _nearestSpot is inserted. Verify that head and tail pointers are updated appropriately.",
            "has_conditional_updates": true,
            "summary_of_update": "If the node with the given id exists, update the node in the linked list.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the head of the doubly linked list.",
            "why_is_is_important": "Points to the head of the list.",
            "when_is_it_updated": "Updated when a new node is inserted and the linked list is empty.",
            "how_to_validate_state_update": "If the linked list is empty, the head and tail pointers are updated to the new node id.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head pointer if the linked list is empty.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the tail of the doubly linked list.",
            "why_is_is_important": "Points to the tail of the list.",
            "when_is_it_updated": "Updated when a new node is inserted and the linked list is empty.",
            "how_to_validate_state_update": "If the linked list is empty, the head and tail pointers are updated to the new node id.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail pointer if the linked list is empty.",
            "conditions": [
              "head == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the DFIRE staking pool.",
            "why_is_is_important": "Used to calculate the rewards for stakers.",
            "when_is_it_updated": "Updated when feeTopup is called and the staking pool has staked tokens.",
            "how_to_validate_state_update": "Verify that the rewardToken balance of the DFIREStaking contract increases by the sbrStakersFee amount. Verify that totalRewardPerToken increases by the correct amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalRewardPerToken if the staking pool has staked tokens.",
            "conditions": [
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the stability pool.",
            "why_is_is_important": "Used to calculate the rewards for stakers.",
            "when_is_it_updated": "Updated when feeTopup is called and the stability pool has staked tokens.",
            "how_to_validate_state_update": "Verify that the stakingToken balance of the StabilityPool contract increases by the stabilityPoolFee amount. Verify that totalRewardPerToken increases by the correct amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalRewardPerToken if the stability pool has staked tokens.",
            "conditions": [
              "_totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks SBR rewards",
            "why_is_is_important": "Keeps track of sbr rewards.",
            "when_is_it_updated": "Updated when feeTopup is called.",
            "how_to_validate_state_update": "Verify that totalSbrRewardPerToken is updated.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the totalSbrRewardPerToken if sbrRewardDistributionStatus is STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "Tracks SBR rewards",
            "why_is_is_important": "Keeps track of sbr rewards.",
            "when_is_it_updated": "Updated when feeTopup is called.",
            "how_to_validate_state_update": "Verify that lastSBRRewardDistributedTime, sbrRewardDistributionEndTime and sbrRewardDistributionStatus are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the lastSBRRewardDistributedTime if sbrRewardDistributionStatus is NOT_STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "Tracks SBR rewards",
            "why_is_is_important": "Keeps track of sbr rewards.",
            "when_is_it_updated": "Updated when feeTopup is called.",
            "how_to_validate_state_update": "Verify that lastSBRRewardDistributedTime, sbrRewardDistributionEndTime and sbrRewardDistributionStatus are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardDistributionEndTime if sbrRewardDistributionStatus is NOT_STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "Tracks SBR rewards",
            "why_is_is_important": "Keeps track of sbr rewards.",
            "when_is_it_updated": "Updated when feeTopup is called.",
            "how_to_validate_state_update": "Verify that lastSBRRewardDistributedTime, sbrRewardDistributionEndTime and sbrRewardDistributionStatus are updated",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the sbrRewardDistributionStatus if sbrRewardDistributionStatus is NOT_STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}