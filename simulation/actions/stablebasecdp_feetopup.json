{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "safeId: Should be a valid ID of an existing Safe owned by the message sender.",
      "topupRate: Should be a non-zero uint256 value representing the desired fee top-up rate.",
      "nearestSpotInRedemptionQueue: Should be a uint256 representing a node ID close to where safeId should be placed in the redemption queue. If you don't have a nearest spot, set to 0"
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the safe's collateral amount and borrowed amount based on cumulative collateral and debt per unit collateral.",
          "Increases the safe's weight by the topupRate.",
          "Increases the safe's feePaid by the calculated fee."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "Transfers SBD tokens from the message sender to the contract as fee.",
          "Potentially transfers undistributed fee back to the user as a refund."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Updates the safe's position in the redemption queue based on the new weight."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Updates the total debt of the protocol, potentially transitioning the protocol mode from BOOTSTRAP to NORMAL."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes the fee to SBR stakers and the stability pool.",
          "Mints SBD tokens if mint flag is true."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates liquidation snapshots debtPerCollateralSnapshot and collateralPerCollateralSnapshot."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "Updates the totalCollateral value."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safe.weight should be increased by topupRate.",
          "safe.feePaid should be increased by the calculated fee amount.",
          "safe.borrowedAmount should be updated based on the cumulative debt per unit collateral.",
          "safe.collateralAmount should be updated based on the cumulative collateral per unit collateral."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The contract's SBD token balance should increase by the fee amount if no refund.",
          "The message sender's SBD token balance should decrease by the fee amount minus refund.",
          "If a refund occurs, the message sender's SBD token balance should increase by refund amount."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "The safe should be correctly positioned in the redemption queue based on its weight.",
          "Nodes before and after safeId in the redemption queue should point to safeId and vice-versa. "
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "The totalDebt should be updated with debtIncrease amount."
        ]
      },
      {
        "category": "Event Emission",
        "rule_descriptions": [
          "A FeeTopup event should be emitted with the correct parameters (safeId, topupRate, fee, newWeight).",
          "A RedemptionQueueUpdated event should be emitted with the correct parameters (safeId, newWeight, prevNode).",
          "A FeeDistributed event should be emitted with the correct parameters (safeId, feePaid, mint, sbrStakersFee, stabilityPoolFee, canRefund).",
          "A SafeUpdated event should be emitted with the correct parameters (safeId, collateralAmount, debtAmount, collateralIncrease, debtIncrease, totalCollateral, totalDebt)."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "SBR staking pool should receive a reward if `sbrStakingPoolCanReceiveRewards` is set to true.",
          "Stability pool should receive a reward if `stabilityPoolCanReceiveRewards` is set to true."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the collateral amount, borrowed amount, weight, total borrowed amount, and fee paid for each safe.",
            "why_is_is_important": "Important for tracking the fee paid and the weight of each safe, which affects its position in the redemption queue and liquidation queue. Higher the weight higher the safe will be in redemption queue and lower in liquidation queue.",
            "when_is_it_updated": "Updated when the `feeTopup` function is called and the fee is successfully paid.",
            "how_to_validate_state_update": "Check the `safes` mapping for the given `safeId` and verify that the `weight` has increased by `topupRate` and `feePaid` has increased by the calculated `fee`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the `weight` (adds `topupRate`) and `feePaid` (adds `fee`) for a specific safe in the `safes` mapping.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "doubly linked list",
            "what_does_it_track": "Keeps track of the order of safes for redemption based on their weight.",
            "why_is_is_important": "Determines the order in which safes are redeemed. Safes with higher weight are redeemed first.",
            "when_is_it_updated": "Updated after the safe's weight is increased via `feeTopup`.",
            "how_to_validate_state_update": "Check the doubly linked list contract to confirm the safe's updated position based on its new weight.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the position of the safe in the redemption queue based on the new weight using `safesOrderedForRedemption.upsert`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the collateral amount, borrowed amount, weight, total borrowed amount, and fee paid for each safe.",
            "why_is_is_important": "It is important to keep `borrowedAmount` and `collateralAmount` synced with global `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`.",
            "when_is_it_updated": "Updated when the `feeTopup` function is called.",
            "how_to_validate_state_update": "Check the `safes` mapping for the given `safeId` and verify `borrowedAmount` and `collateralAmount` has been updated correctly",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `borrowedAmount` and `collateralAmount` of the safe if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Stores the collateral and debt snapshots for each safe at the time of their last interaction.",
            "why_is_is_important": "Used to calculate the debt and collateral increase for each safe.",
            "when_is_it_updated": "Updated when the `feeTopup` function is called and the safe is updated.",
            "how_to_validate_state_update": "Check the `liquidationSnapshots` mapping for the given `safeId` and verify `debtPerCollateralSnapshot` has been updated to `cumulativeDebtPerUnitCollateral` and `collateralPerCollateralSnapshot` has been updated to `cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` to `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral` respectively, if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral deposited in the protocol.",
            "why_is_is_important": "Used to calculate the collateral ratio of the protocol.",
            "when_is_it_updated": "Updated when a safe's collateral is increased.",
            "how_to_validate_state_update": "Check totalCollateral and verify that it has been updated with the `collateralIncrease` value.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases `totalCollateral` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt borrowed from the protocol.",
            "why_is_is_important": "Used to calculate the collateral ratio of the protocol and to manage the protocol's mode.",
            "when_is_it_updated": "Updated when a safe's debt is increased.",
            "how_to_validate_state_update": "Check totalDebt and verify that it has been updated with the `debtIncrease` value. Also check PROTOCOL_MODE and verify it has changed from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL` if the specified condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases `totalDebt` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`. Also changes `PROTOCOL_MODE` from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL` if `totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Determines the behavior of the protocol.",
            "when_is_it_updated": "Updated when the total debt exceeds the bootstrap mode threshold.",
            "how_to_validate_state_update": "Check PROTOCOL_MODE and verify it has changed from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL` if the specified condition is met.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes `PROTOCOL_MODE` from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL` if `totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP",
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "Reflects the transfer of fee tokens from the user to the contract.",
            "when_is_it_updated": "Updated when the `transferFrom` function is called in `feeTopup`.",
            "how_to_validate_state_update": "Check the balance of the StableBaseCDP contract and the `msg.sender`'s balance.  The StableBaseCDP's balance should increase by `fee`, and the `msg.sender`'s balance should decrease by `fee` if transfer successful. Also ensure that `totalBurned` is increased with canRefund if refund happens.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers `fee` SBD tokens from `msg.sender` to the StableBaseCDP contract, decreasing the sender's balance and increasing the contract's balance.",
            "conditions": []
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks total burned tokens",
            "why_is_is_important": "Reflects the transfer of fee tokens from the contract back to the user.",
            "when_is_it_updated": "Updated when the `transfer` function is called in `feeTopup` and when the `burn` function is called in distributeFees.",
            "how_to_validate_state_update": "Verify that the msg.sender's balance has decreased by fee and StableBaseCDP contract has increased by fee.",
            "has_conditional_updates": false,
            "summary_of_update": "If `refundFee > 0`, transfers `refundFee` SBD tokens from StableBaseCDP contract to `msg.sender`, increasing the sender's balance and decreasing the contract's balance. Also update the `totalBurned` state variable.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Keeps track of nodes in the doubly linked list, storing their value, previous node, and next node.",
            "why_is_is_important": "Maintains the order of safes in the queue based on their weight or collateral ratio.",
            "when_is_it_updated": "Updated when a new safe is added to the redemption queue or liquidation queue.",
            "how_to_validate_state_update": "Check the `nodes` mapping for the given `id` and verify new node is inserted with correct value and linkages.",
            "has_conditional_updates": true,
            "summary_of_update": "If a node with `safeId` does not already exist, insert a new node with the updated `value`.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Keeps track of nodes in the doubly linked list, storing their value, previous node, and next node.",
            "why_is_is_important": "Maintains the order of safes in the queue based on their weight or collateral ratio.",
            "when_is_it_updated": "Updated when a safe's weight or collateral ratio changes, requiring a re-ordering in the queue.",
            "how_to_validate_state_update": "Check the `nodes` mapping for the given `id` and verify node is updated with correct value and linkages.",
            "has_conditional_updates": true,
            "summary_of_update": "If a node with `safeId` already exists, update the existing node's `value`.",
            "conditions": [
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head of the linked list",
            "why_is_is_important": "Head of the linked list",
            "when_is_it_updated": "Updated when new node is inserted and new node becomes the head.",
            "how_to_validate_state_update": "Check `head` and `tail` values",
            "has_conditional_updates": false,
            "summary_of_update": "Updates head of the linkedlist.",
            "conditions": []
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail of the linked list",
            "why_is_is_important": "Tail of the linked list",
            "when_is_it_updated": "Updated when new node is inserted and new node becomes the tail.",
            "how_to_validate_state_update": "Check `head` and `tail` values",
            "has_conditional_updates": false,
            "summary_of_update": "Updates tail of the linkedlist",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the DFIRE staking pool.",
            "why_is_is_important": "Used to calculate the rewards for stakers in the DFIRE staking pool.",
            "when_is_it_updated": "Updated when the `addReward` function is called with a valid `_amount`.",
            "how_to_validate_state_update": "Verify that the `rewardToken` has been transferred from msg.sender to this contract. Verify `totalRewardPerToken` state variable is updated correctly.",
            "has_conditional_updates": true,
            "summary_of_update": "If `totalStake > 0`, transfers SBR tokens from the caller (`msg.sender`) to the DFIREStaking contract and updates the `totalRewardPerToken` variable.",
            "conditions": [
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the stability pool.",
            "why_is_is_important": "Used to calculate the rewards for stakers in the stability pool.",
            "when_is_it_updated": "Updated when the `addReward` function is called with a valid `_amount`.",
            "how_to_validate_state_update": "Verify that `stakingToken` (DFID) has been transferred from msg.sender to this contract, and `totalRewardPerToken` has been updated.",
            "has_conditional_updates": true,
            "summary_of_update": "If `totalStakedRaw > 0`, transfers DFID tokens from the caller (`msg.sender`) to the StabilityPool contract and updates the `totalRewardPerToken` variable.",
            "conditions": [
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative SBR rewards distributed per token staked in the StabilityPool.",
            "why_is_is_important": "Ensures SBR rewards are distributed to stability providers.",
            "when_is_it_updated": "Updated within `_addSBRRewards` during the `addReward` function if SBR reward distribution is active.",
            "how_to_validate_state_update": "Check state variable `totalSbrRewardPerToken`. Verify that `_addSBRRewards` is called which updates the `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Calls `_addSBRRewards` if `sbrRewardDistributionStatus != SBRRewardDistribution.ENDED` when totalStakedRaw > 0, potentially updating SBR reward distribution parameters.",
            "conditions": [
              "totalStakedRaw > 0",
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The status of SBR reward distribution (NOT_STARTED, STARTED, ENDED).",
            "why_is_is_important": "Manages the lifecycle of the SBR reward distribution.",
            "when_is_it_updated": "Updated within `_addSBRRewards` during the `addReward` function if SBR reward distribution is active.",
            "how_to_validate_state_update": "Check `sbrRewardDistributionStatus` state variable.",
            "has_conditional_updates": true,
            "summary_of_update": "If `sbrRewardDistributionStatus != SBRRewardDistribution.ENDED` and the current block timestamp is after the `sbrRewardDistributionEndTime`, set `sbrRewardDistributionStatus` to `SBRRewardDistribution.ENDED`.",
            "conditions": [
              "totalStakedRaw > 0",
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED",
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "N/A",
            "type": "bool",
            "what_does_it_track": "Result of addReward",
            "why_is_is_important": "Prevent errors",
            "when_is_it_updated": "During the call to the `addReward` function.",
            "how_to_validate_state_update": "Check that return value of addReward is `false`.",
            "has_conditional_updates": true,
            "summary_of_update": "If `totalStakedRaw == 0`, returns `false` and does not proceed with the reward distribution.",
            "conditions": [
              "totalStakedRaw == 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}