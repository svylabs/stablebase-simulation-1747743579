{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId owned by the caller.",
      "topupRate: A positive integer representing the fee top-up rate, such that (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR results in a reasonable fee amount.",
      "nearestSpotInRedemptionQueue: A safeId that is currently present in redemption queue, used to find a nearest spot to insert the safe into the queue. If not available, can be set to 0."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe",
        "state_update_descriptions": [
          "Updates the safe's collateralAmount and borrowedAmount based on cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral. The updates reflect accumulated changes since the last snapshot.",
          "Increases the safe's weight by topupRate.",
          "Increases the safe's feePaid by fee."
        ]
      },
      {
        "category": "Token Transfer",
        "state_update_descriptions": [
          "Transfers fee amount of SBD tokens from the msg.sender to the contract.",
          "Refunds undistributed fee (refundFee) back to the user, if any."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Updates the position of the safe in the redemption queue based on the new weight (safe.weight) and nearestSpotInRedemptionQueue."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Updates the total debt of the protocol based on debtIncrease, reflecting any increase in borrowed amount due to cumulative effects.",
          "PROTOCOL_MODE is updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD"
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes the fee to SBR stakers and the stability pool.",
          "Mints SBD tokens if mint parameter in distributeFees is set to true and burns tokens if there is refund."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates liquidation snapshot for collateralPerCollateralSnapshot and debtPerCollateralSnapshot to cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral respectively."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "Updates the total collateral of the protocol based on collateralIncrease."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe",
        "rule_descriptions": [
          "safe.weight should be increased by topupRate compared to its previous value.",
          "safe.feePaid should be increased by fee compared to its previous value.",
          "Safe's collateralAmount and borrowedAmount should be updated based on cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral. Verify these values accurately reflect accumulated changes."
        ]
      },
      {
        "category": "Token Balance",
        "rule_descriptions": [
          "The contract's SBD token balance should increase by `fee - refundFee` (or fee if there is no refund).",
          "The user's SBD token balance should decrease by `fee - refundFee`.",
          "Verify that the StabilityPool's and DFIREStaking's SBD token balances have been updated correctly according to the distributed fees.",
          "If refundFee > 0, verify that the user's SBD token balance has increased by refundFee."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "The safe should be correctly positioned in the redemption queue based on its updated weight.",
          "The previous and next nodes of the safe in the redemption queue should be updated accordingly."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "Total debt should be updated correctly based on the collateral and debt updates.",
          "The PROTOCOL_MODE should reflect the correct state based on the total debt (BOOTSTRAP or NORMAL)."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A FeeTopup event should be emitted with the correct parameters (safeId, topupRate, fee, safe.weight).",
          "A RedemptionQueueUpdated event should be emitted with the updated safe weight and previous node in the queue.",
          "A FeeRefund event should be emitted if there is a refund, with the correct refund amount.",
          "A SafeUpdated event should be emitted if the safe's collateral or debt is updated."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot should be equal to cumulativeCollateralPerUnitCollateral.",
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should be equal to cumulativeDebtPerUnitCollateral."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "Total Collateral should be updated correctly based on the collateral updates."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the collateral amount, borrowed amount, weight, total borrowed amount and fee paid for each safe.",
            "why_is_is_important": "It's important for tracking the accumulated fee for a given safe and its weight in the redemption queue.",
            "when_is_it_updated": "When the `feeTopup` function is called.",
            "how_to_validate_state_update": "Check the `safes` mapping for the given `safeId` and verify that the `weight` has increased by `topupRate` and `feePaid` increased by `fee`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the `weight` and `feePaid` for a given `safeId`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "Tracks the collateral amount, borrowed amount, weight, total borrowed amount and fee paid for each safe.",
            "why_is_is_important": "It's important for tracking changes in the safe's collateral and debt due to protocol-wide updates.",
            "when_is_it_updated": "When the `_updateSafe` function is called.",
            "how_to_validate_state_update": "Check if `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`. If true, calculate the debt and collateral increase and then verify `_safe.borrowedAmount`, `_safe.totalBorrowedAmount` and `_safe.collateralAmount` values.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowedAmount and collateralAmount based on cumulative values.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "Tracks the current operating mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "It's important for controlling protocol behavior based on the total debt level.",
            "when_is_it_updated": "When the `_updateTotalDebt` function is called and debt exceeds the threshold.",
            "how_to_validate_state_update": "Verify that when the condition `debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP` is met, `PROTOCOL_MODE` changes from `SBStructs.Mode.BOOTSTRAP` to `SBStructs.Mode.NORMAL`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL when total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the system.",
            "why_is_is_important": "It's important for tracking the overall health and risk of the protocol.",
            "when_is_it_updated": "When the `_updateTotalDebt` function is called.",
            "how_to_validate_state_update": "Check the value of `totalDebt` after the execution of `_updateTotalDebt` to ensure it reflects the addition or subtraction of `delta` from `currentDebt`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt of the protocol.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "It's important for tracking the amount of SBD tokens held by each address.",
            "when_is_it_updated": "When the `transferFrom` function is called in `feeTopup`.",
            "how_to_validate_state_update": "Verify that the balance of the `StableBaseCDP` contract increases by `fee` and the balance of `msg.sender` decreases by `fee` using `balanceOf(address)` function.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers `fee` amount of SBD tokens from `msg.sender` to the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "Tracks the balance of SBD tokens for each address.",
            "why_is_is_important": "It's important for tracking the amount of SBD tokens held by each address.",
            "when_is_it_updated": "When a refund is issued in the `feeTopup` function.",
            "how_to_validate_state_update": "If `refundFee > 0`, verify that `msg.sender` balance increases by `refundFee` using `balanceOf(address)` function.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers `refundFee` amount of SBD tokens to `msg.sender` if `refundFee > 0`.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "It's important for tracking the overall supply of SBD tokens.",
            "when_is_it_updated": "When the `distributeFees` function is called and `mint` is true.",
            "how_to_validate_state_update": "If mint is true, verify that the contract balance increases by `fee` using `balanceOf` and that `totalSupply` increases by `fee`.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBD tokens to the contract if `mint` is true.",
            "conditions": [
              "mint is true"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Tracks the total supply of SBD tokens.",
            "why_is_is_important": "It's important for tracking the overall supply of SBD tokens.",
            "when_is_it_updated": "When the `distributeFees` function is called, `canRefund` is greater than 0 and `mint` is true.",
            "how_to_validate_state_update": "If `canRefund > 0` and `mint` is true, verify that contract balance decreases by `canRefund` and `totalSupply` decreases by `canRefund`.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens from the contract if `canRefund > 0` and `mint` is true.",
            "conditions": [
              "canRefund > 0 && mint is true"
            ]
          },
          {
            "state_variable_name": "totalBurned",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of burned tokens",
            "why_is_is_important": "It helps to track the total amount of burned tokens.",
            "when_is_it_updated": "When burn function is called.",
            "how_to_validate_state_update": "Verify that totalBurned increases by `amount` when `_burn` is called.",
            "has_conditional_updates": false,
            "summary_of_update": "Increment the total amount of tokens burned.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Stores nodes of the doubly linked list, each representing a safe's position in the queue.",
            "why_is_is_important": "Maintains the order of safes for redemption based on their weight.",
            "when_is_it_updated": "When the `upsert` function is called from `feeTopup`.",
            "how_to_validate_state_update": "If the condition is met, verify that a new node is inserted into the linked list, and the head and tail pointers are updated accordingly. Inspect the `nodes` mapping to confirm the new node's `value`, `prev`, and `next` values.",
            "has_conditional_updates": true,
            "summary_of_update": "Inserts a new node or updates an existing node in the redemption queue based on its `weight`.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Tracks the first node in the linked list.",
            "why_is_is_important": "Points to the first element.",
            "when_is_it_updated": "When a new node is inserted from `upsert`.",
            "how_to_validate_state_update": "Verify that the head pointer is updated when a new node is inserted at the beginning of the list.Inspect the `head` variable.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates head if the new node becomes the first node in the list.",
            "conditions": []
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tracks the last node in the linked list.",
            "why_is_is_important": "Points to the last element.",
            "when_is_it_updated": "When a new node is inserted from `upsert`.",
            "how_to_validate_state_update": "Verify that the tail pointer is updated when a new node is inserted at the end of the list. Inspect the `tail` variable.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates tail if the new node becomes the last node in the list.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the staking pool.",
            "why_is_is_important": "It's important for calculating rewards for stakers.",
            "when_is_it_updated": "When the `addReward` function is called in `distributeFees` and `totalStake > 0`.",
            "how_to_validate_state_update": "If `totalStake > 0`, verify that `totalRewardPerToken` increases by `(_amount * PRECISION) / _totalStake`. Check the contract's balance has increased by `_amount` and the sender's balance has decreased by the same amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token for the staking pool if there are staked tokens.",
            "conditions": [
              "totalStake > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks the total reward per token in the stability pool.",
            "why_is_is_important": "It's important for calculating rewards for stakers.",
            "when_is_it_updated": "When the `addReward` function is called in `distributeFees` and `totalStakedRaw > 0`.",
            "how_to_validate_state_update": "If `totalStakedRaw > 0`, verify that `totalRewardPerToken` increases. Also check if SBR rewards are added.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token in the stability pool if there are staked tokens.",
            "conditions": [
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Tracks total SBR rewards per token",
            "why_is_is_important": "Help to keep track on total sbr reward per token for reward distribution",
            "when_is_it_updated": "when `_addSBRRewards` is called and `sbrRewardDistributionStatus == SBRRewardDistribution.STARTED`.",
            "how_to_validate_state_update": "Verify `totalSbrRewardPerToken` increases by `((_sbrReward * stakeScalingFactor * precision) / totalStakedRaw) / precision` when sbrRewardDistributionStatus is STARTED.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates total SBR rewards per token in stability pool when distribution is started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "tracks the sbr distribution reward status.",
            "why_is_is_important": "Help to distribute reward properly.",
            "when_is_it_updated": "when `_addSBRRewards` is called and `sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED`.",
            "how_to_validate_state_update": "Verify that `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime` and `sbrRewardDistributionStatus` are updated correctly when `sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates SBR reward distribution status to STARTED and initializes distribution parameters",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": []
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}