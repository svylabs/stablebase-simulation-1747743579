{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "Generate a `safeId` that exists and is owned by the user.",
      "Generate `topupRate` greater than 0. A reasonable value can be between 1 and 1000, representing 0.01% to 10% of the borrowed amount as fee.",
      "Generate `nearestSpotInRedemptionQueue`. This value should ideally be close to the current location of the safe in the redemption queue or 0 if the queue is empty. This is an optimization parameter and can be set to 0 if the exact position is unknown."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Update `safes[safeId].weight` by adding `topupRate` to the existing weight.",
          "Update `safes[safeId].feePaid` by adding the calculated fee to the existing feePaid.",
          "Potentially update `safes[safeId].collateralAmount` and `safes[safeId].borrowedAmount` based on cumulative interest accrual calculations."
        ]
      },
      {
        "category": "Token Transfers and Fee Distribution",
        "state_update_descriptions": [
          "Transfer `fee` amount of `sbdToken` from `msg.sender` to the contract.",
          "Potentially mint `fee` amount of `sbdToken` to the contract if `mint` is true in the `distributeFees` function.",
          "Distribute fees to `dfireTokenStaking` and `stabilityPool` contracts.",
          "Potentially burn a `canRefund` amount of `sbdToken` from the contract if a refund is applicable and `mint` is true in `distributeFees` function.",
          "Potentially transfer `refundFee` of `sbdToken` back to `msg.sender` if a refund is applicable."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Update position of `safeId` in the `safesOrderedForRedemption` doubly linked list based on the updated `safe.weight`.",
          "Emit `RedemptionQueueUpdated` event."
        ]
      },
      {
        "category": "Global Debt and Collateral",
        "state_update_descriptions": [
          "Potentially update `totalDebt` and `totalCollateral` if the `_updateSafe` function modifies the `borrowedAmount` and `collateralAmount` due to cumulative interest calculations.",
          "Update `liquidationSnapshots[safeId]` with `cumulativeDebtPerUnitCollateral` and `cumulativeCollateralPerUnitCollateral`."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "Validate that `safes[safeId].weight` is increased by `topupRate` compared to its previous value.",
          "Validate that `safes[safeId].feePaid` is increased by the calculated `fee` amount.",
          "Validate `collateralAmount` and `borrowedAmount` are updated in `safes[safeId]` based on the cumulative interest accrual calculations. This can be checked by calling `getInactiveDebtAndCollateral` and comparing against the previous state and `cumulativeCollateralPerUnitCollateral`/`cumulativeDebtPerUnitCollateral`."
        ]
      },
      {
        "category": "Token Balances and Fee Distribution",
        "rule_descriptions": [
          "Validate that the `sbdToken` balance of `msg.sender` is decreased by `fee - refundFee`.",
          "Validate that the `sbdToken` balance of the contract is increased by `fee - refundFee` if `mint` is false in `distributeFees` or remains the same if `mint` is true because of the minting and burning.",
          "Verify the addition of rewards to `dfireTokenStaking` and `StabilityPool`.  Prioritize checking event logs. If view functions exists to get rewards before and after, use it."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "Validate that the safe's position in the `safesOrderedForRedemption` queue is correctly updated based on the new `safe.weight`.",
          "Check the previous and next node references in the doubly linked list to ensure the safe is correctly positioned.",
          "Fetch the current node from the doubly linked list with the `safeId` and assert the `value`, `prev` and `next` are correct. Also, find the `head` and `tail`, and assert those are correct."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "Validate that a `FeeTopup` event is emitted with the correct parameters (`safeId`, `topupRate`, `fee`, `safe.weight`).",
          "Validate that a `RedemptionQueueUpdated` event is emitted with the correct parameters (`safeId`, `safe.weight`, `node.prev`).",
          "Validate that `SafeUpdated` event is emitted if `_updateSafe` is executed.",
          "Validate that `FeeDistributed` event is emitted with the correct parameters.",
          "Validate that `FeeRefund` is emitted if there is a refund."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of debt associated with a specific safe.",
            "why_is_is_important": "Updates the borrowed amount of the safe, if the collateral per collateral snapshot is not equal to the cumulative collateral per unit collateral.",
            "when_is_it_updated": "When cumulative debt has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Compare the borrowedAmount before and after the function call, ensuring it has increased by the calculated debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The borrowed amount of the safe increases by a debt increase calculated based on cumulativeDebtPerUnitCollateral and liquidationSnapshot.debtPerCollateralSnapshot. totalBorrowedAmount also increased.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total amount ever borrowed by the safe",
            "why_is_is_important": "Keeps track of the total borrowed amount in the safe.",
            "when_is_it_updated": "When the cumulative debt has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Compare the totalBorrowedAmount before and after the function call, ensuring it has increased by the debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The totalBorrowedAmount of the safe is increased by the debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount of collateral associated with a specific safe.",
            "why_is_is_important": "Updates the collateral amount of the safe if the cumulative collateral has changed since the last snapshot.",
            "when_is_it_updated": "When the cumulative collateral has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Compare the collateralAmount before and after the function call, ensuring it has increased by the calculated collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The collateralAmount of the safe increases by a collateralIncrease calculated based on cumulativeCollateralPerUnitCollateral and liquidationSnapshot.collateralPerCollateralSnapshot.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Keeps track of the total collateral in the system.",
            "when_is_it_updated": "When the cumulative collateral has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Compare the totalCollateral before and after the function call, ensuring it has increased by the collateralIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The totalCollateral in the system increases by the collateralIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the debt per collateral snapshot.",
            "why_is_is_important": "Tracks the cumulative debt per unit collateral for a safe.",
            "when_is_it_updated": "When the cumulative debt has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Verify that the liquidationSnapshot.debtPerCollateralSnapshot is set to cumulativeDebtPerUnitCollateral after the update.",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshot.debtPerCollateralSnapshot is updated to cumulativeDebtPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "what_does_it_track": "Tracks the collateral per collateral snapshot.",
            "why_is_is_important": "Tracks the cumulative collateral per unit collateral for a safe.",
            "when_is_it_updated": "When the cumulative collateral has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Verify that the liquidationSnapshot.collateralPerCollateralSnapshot is set to cumulativeCollateralPerUnitCollateral after the update.",
            "has_conditional_updates": true,
            "summary_of_update": "liquidationSnapshot.collateralPerCollateralSnapshot is updated to cumulativeCollateralPerUnitCollateral.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Tracks the total debt in the system.",
            "why_is_is_important": "Updates the total debt in the system.",
            "when_is_it_updated": "When the cumulative debt has changed since the last snapshot for this safe.",
            "how_to_validate_state_update": "Compare the totalDebt before and after the function call, ensuring it has increased by the debtIncrease.",
            "has_conditional_updates": true,
            "summary_of_update": "The totalDebt in the system increases by the debtIncrease.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "SBStructs.Mode",
            "what_does_it_track": "Tracks the operational mode of the protocol.",
            "why_is_is_important": "Updates the protocol mode based on the total debt.",
            "when_is_it_updated": "When totalDebt exceeds the threshold while the protocol is in BOOTSTRAP mode.",
            "how_to_validate_state_update": "Check the value of PROTOCOL_MODE before and after the function call, ensuring it changes from BOOTSTRAP to NORMAL when the conditions are met.",
            "has_conditional_updates": true,
            "summary_of_update": "PROTOCOL_MODE is updated to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD and the current mode is BOOTSTRAP.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "Priority of redemption.",
            "why_is_is_important": "Updates the safe's weight, which is used for prioritizing redemptions.",
            "when_is_it_updated": "Always updated when the function is called successfully.",
            "how_to_validate_state_update": "Verify that safes[safeId].weight increases by topupRate.",
            "has_conditional_updates": false,
            "summary_of_update": "safes[safeId].weight is increased by topupRate.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "Total fees paid.",
            "why_is_is_important": "Tracks the total amount of fees paid by the safe.",
            "when_is_it_updated": "Always updated when the function is called successfully.",
            "how_to_validate_state_update": "Check the value of safes[safeId].feePaid before and after the function call, ensuring it has increased by the calculated fee.",
            "has_conditional_updates": false,
            "summary_of_update": "safes[safeId].feePaid is increased by the calculated fee.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "IDoublyLinkedList",
            "what_does_it_track": "The order of safes for redemption.",
            "why_is_is_important": "Updates the doubly linked list to reflect the change in the safe's weight.",
            "when_is_it_updated": "Always updated when the function is called successfully.",
            "how_to_validate_state_update": "Call the getNodes function of the doubly linked list to get all the nodes. Check the ordering of nodes ensuring order of weight.",
            "has_conditional_updates": false,
            "summary_of_update": "The doubly linked list representing the redemption queue is updated using the upsert function. This function reorders the list based on the new safes[safeId].weight.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Balances of SBD tokens.",
            "why_is_is_important": "Transfers SBD tokens from the user to the contract.",
            "when_is_it_updated": "Always updated when the function is called successfully.",
            "how_to_validate_state_update": "Check the balance of the user and the contract before and after the transfer, ensuring the user's balance decreases and the contract's balance increases by the fee amount.",
            "has_conditional_updates": false,
            "summary_of_update": "_balances[msg.sender] decreases and _balances[address(this)] increases by fee.",
            "conditions": []
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Total supply of SBD tokens.",
            "why_is_is_important": "Updates the total supply of SBD tokens when minting.",
            "when_is_it_updated": "When minting is enabled and fees are distributed.",
            "how_to_validate_state_update": "Check the total supply of SBD before and after the minting, ensuring it has increased by the fee amount.",
            "has_conditional_updates": true,
            "summary_of_update": "_totalSupply increases by fee when mint is true.",
            "conditions": [
              "mint == true",
              "msg.sender has the onlyOwner role"
            ]
          },
          {
            "state_variable_name": "_totalSupply",
            "type": "uint256",
            "what_does_it_track": "Total supply of SBD tokens.",
            "why_is_is_important": "Updates the total supply of SBD tokens when burning.",
            "when_is_it_updated": "When burning is enabled and there is a refund amount.",
            "how_to_validate_state_update": "Check the total supply of SBD before and after the burning, ensuring it has decreased by the canRefund amount.",
            "has_conditional_updates": true,
            "summary_of_update": "_totalSupply decreases by canRefund when mint is true and canRefund > 0.",
            "conditions": [
              "mint == true",
              "canRefund > 0",
              "msg.sender has the onlyOwner role"
            ]
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping(address => uint256)",
            "what_does_it_track": "Balances of SBD tokens.",
            "why_is_is_important": "Transfers undistributed fee back to the user",
            "when_is_it_updated": "When refunding undistributed fee back to the user",
            "how_to_validate_state_update": "Check the balance of the user and the contract before and after the transfer, ensuring the contract's balance decreases and the user's balance increases by the refundFee amount.",
            "has_conditional_updates": true,
            "summary_of_update": "_balances[address(this)] decreases and _balances[msg.sender] increases by refundFee.",
            "conditions": [
              "refundFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Reward per token.",
            "why_is_is_important": "Increase reward per token based on amount transferred.",
            "when_is_it_updated": "When addReward is successful.",
            "how_to_validate_state_update": "Check the totalRewardPerToken before and after the addReward, ensuring it has increased.",
            "has_conditional_updates": true,
            "summary_of_update": "totalRewardPerToken is increased.",
            "conditions": [
              "totalStake != 0",
              "sbrStakingPoolCanReceiveRewards == true",
              "msg.sender must have approved DFIREStaking to spend rewardToken"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "Reward per token for the stability pool.",
            "why_is_is_important": "Updates the total reward per token in the stability pool.",
            "when_is_it_updated": "When addReward is successful.",
            "how_to_validate_state_update": "Check the totalRewardPerToken before and after the addReward, ensuring it has increased.",
            "has_conditional_updates": true,
            "summary_of_update": "totalRewardPerToken is increased by _rewardPerToken. rewardLoss updated.",
            "conditions": [
              "totalStakedRaw != 0",
              "stabilityPoolCanReceiveRewards == true",
              "msg.sender must have approved StabilityPool to spend stakingToken"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "SBR reward distribution parameters.",
            "why_is_is_important": "Updates SBR rewards if distribution is enabled.",
            "when_is_it_updated": "When SBR reward distribution is active.",
            "how_to_validate_state_update": "Check all variables before and after the _addSBRRewards function, ensuring correct values are updated based on distribution status.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates lastSBRRewardDistributedTime, sbrRewardDistributionEndTime, sbrRewardDistributionStatus, totalSbrRewardPerToken, and sbrRewardLoss.",
            "conditions": [
              "sbrRewardDistributionStatus != SBRRewardDistribution.ENDED"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "DFIDToken"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}