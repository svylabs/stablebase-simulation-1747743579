{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId for which the msg.sender is the owner.",
      "topupRate: A value greater than 0 representing the fee top-up rate in basis points (thousandths).",
      "nearestSpotInRedemptionQueue: A valid safeId representing the nearest spot in the redemption queue, used for efficient queue updates. It can be zero if there are no safes in the redemption queue.",
      "The msg.sender must have enough SBD tokens to cover the fee calculated based on the topupRate and borrowedAmount."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "safes[safeId].weight is increased by topupRate.",
          "safes[safeId].feePaid is increased by fee."
        ]
      },
      {
        "category": "Token Balances",
        "state_update_descriptions": [
          "The contract's SBD token balance increases by 'fee' after the transferFrom.",
          "User's SBD token balance decreases by 'fee' after the transferFrom.",
          "If refundFee > 0, user's SBD token balance is increased by 'refundFee'."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "The redemption queue is updated, potentially changing the order of safes."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "liquidationSnapshots[_safeId].debtPerCollateralSnapshot is updated with cumulativeDebtPerUnitCollateral.",
          "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot is updated with cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "totalDebt is updated to reflect the increase or decrease in debt amount."
        ]
      },
      {
        "category": "Protocol Mode",
        "state_update_descriptions": [
          "PROTOCOL_MODE may be updated from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Fees are distributed to sbrStakersFee and stabilityPoolFee.",
          "If mint is true, new sbd tokens are minted to the contract.",
          "If canRefund > 0 and mint is true, sbd tokens are burned from the contract."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "totalCollateral may be updated based on the _updateSafe function."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safe.weight should be updated by topupRate.",
          "safe.feePaid should be increased by fee.",
          "Borrowed amount, total borrowed amount, and collateral amount should be updated based on cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral. Validate the changes to borrowedAmount, totalBorrowedAmount, and collateralAmount using the values of cumulativeCollateralPerUnitCollateral and cumulativeDebtPerUnitCollateral before and after the function call."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "The contract should receive 'fee' amount of SBD tokens.",
          "The msg.sender's SBD token balance should decrease by 'fee' after the transferFrom and subsequently increase by 'refundFee' if refundFee > 0."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "The safe should be correctly positioned in the redemption queue based on its updated weight. Check prevNode's and nextNode's 'prev' and 'next' fields after the update."
        ]
      },
      {
        "category": "Total Debt and Collateral",
        "rule_descriptions": [
          "totalDebt should be correctly updated, and PROTOCOL_MODE should change from BOOTSTRAP to NORMAL if debt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD.",
          "Total collateral should be increased by collateralIncrease."
        ]
      },
      {
        "category": "Fee Distribution",
        "rule_descriptions": [
          "SBR stakers and the stability pool should receive their respective fee shares.",
          "If mint is false, the contract should not mint new SBD tokens for fee distribution.",
          "If mint is true, the contract should mint new SBD tokens for fee distribution.",
          "If canRefund > 0 and mint is true, the contract should burn the refund amount of SBD tokens."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "Tracks the amount borrowed for a specific safe.",
            "why_is_is_important": "Ensures borrowed amount is up to date with the current debt ratio.",
            "when_is_it_updated": "When the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check that `safe.borrowedAmount` and `safe.totalBorrowedAmount` are correctly incremented based on the difference between current and snapshot cumulative debt per unit collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's borrowed amount and total borrowed amount based on cumulative debt per unit collateral.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited for a safe.",
            "why_is_is_important": "Keeps collateral amount consistent with current collateral ratio.",
            "when_is_it_updated": "When the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Verify that `safe.collateralAmount` is correctly incremented based on the difference between current and snapshot cumulative collateral per unit collateral.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the safe's collateral amount based on cumulative collateral per unit collateral.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "Tracks the total amount of collateral in the contract.",
            "why_is_is_important": "Reflects the total collateral held by the contract.",
            "when_is_it_updated": "When the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Check that `totalCollateral` is incremented by the collateral increase amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the contract.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "Keeps track of the total debt in the contract.",
            "why_is_is_important": "Tracks the overall debt in the system.",
            "when_is_it_updated": "When the collateral per collateral snapshot differs from the cumulative collateral per unit collateral.",
            "how_to_validate_state_update": "Confirm that `totalDebt` is incremented by the debt increase amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt in the contract.",
            "conditions": [
              "liquidationSnapshots[safeId].collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The weight or priority of a safe for redemption.",
            "why_is_is_important": "The weight determines the position of the safe in the redemption queue.",
            "when_is_it_updated": "Always when feeTopup is called successfully.",
            "how_to_validate_state_update": "Verify that `safe.weight` is incremented by `topupRate`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the safe's weight by adding the topupRate.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "The total fee paid by the safe.",
            "why_is_is_important": "Keeps track of total fee paid",
            "when_is_it_updated": "Always when feeTopup is called successfully.",
            "how_to_validate_state_update": "Verify that `safe.feePaid` is incremented by `fee`.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the safe's feePaid amount by adding the fee.",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Mintable SBD token balance of the contract.",
            "why_is_is_important": "Increases the contract's SBD balance to distribute fees.",
            "when_is_it_updated": "If mint is true in distributeFees.",
            "how_to_validate_state_update": "Check the contract's SBD balance increases by `fee` when mint is true.",
            "has_conditional_updates": true,
            "summary_of_update": "Mints SBD tokens to the contract.",
            "conditions": [
              "mint == true"
            ]
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Balance of SBD tokens for the contract.",
            "why_is_is_important": "The contract receives fees paid.",
            "when_is_it_updated": "Always, if the transfer succeeds.",
            "how_to_validate_state_update": "Check that the contract's SBD balance increases by `fee` and msg.sender's decreases by the same amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers SBD tokens from msg.sender to the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "Balance of SBD tokens for the msg.sender.",
            "why_is_is_important": "The user pays the fees.",
            "when_is_it_updated": "Always, if the transfer succeeds.",
            "how_to_validate_state_update": "Check that the contract's SBD balance increases by `fee` and msg.sender's decreases by the same amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Transfers SBD tokens from msg.sender to the contract.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "Mintable SBD token balance of the contract.",
            "why_is_is_important": "Reduces the token supply when a refund is available.",
            "when_is_it_updated": "When canRefund is greater than 0 and mint is true in distributeFees.",
            "how_to_validate_state_update": "Verify that the contract's SBD balance decreases by `canRefund`.",
            "has_conditional_updates": true,
            "summary_of_update": "Burns SBD tokens from the contract.",
            "conditions": [
              "canRefund > 0 && mint == true"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "safesOrderedForRedemption.nodes[safeId]",
            "type": "struct",
            "what_does_it_track": "The node in the doubly linked list.",
            "why_is_is_important": "The sorted list needs to update.",
            "when_is_it_updated": "Always when feeTopup is called successfully.",
            "how_to_validate_state_update": "Check that a node with the given safeId is inserted or updated with the correct value (weight) and previous/next pointers based on the sorted order.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the node in the doubly linked list with the new value and position.",
            "conditions": [
              "nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0",
              "nodes[id].value != 0 || nodes[id].next != 0 || nodes[id].prev != 0"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.head",
            "type": "uint256",
            "what_does_it_track": "The head of the list",
            "why_is_is_important": "The head of the list needs to update.",
            "when_is_it_updated": "When a node is added and needs to become the new head.",
            "how_to_validate_state_update": "Check the `head` pointer.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the doubly linked list if the new node is inserted at the beginning.",
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "safesOrderedForRedemption.tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the list",
            "why_is_is_important": "The tail of the list needs to update.",
            "when_is_it_updated": "When a node is added and needs to become the new tail.",
            "how_to_validate_state_update": "Check the `tail` pointer",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the doubly linked list if the new node is inserted at the end.",
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "dfireTokenStaking.rewardToken",
            "type": "address",
            "what_does_it_track": "The reward token associated with the staking contract.",
            "why_is_is_important": "Distributes rewards to stakers based on their stake.",
            "when_is_it_updated": "When `sbrStakersFee > 0` in `distributeFees` function.",
            "how_to_validate_state_update": "Check that `rewardToken` balance increases by `_amount` and `totalRewardPerToken` increases proportionally.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens from msg.sender to the contract and updates `totalRewardPerToken`.",
            "conditions": [
              "sbrStakersFee > 0"
            ]
          },
          {
            "state_variable_name": "dfireTokenStaking.totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total reward per token in the staking contract.",
            "why_is_is_important": "Distributes rewards to stakers based on their stake.",
            "when_is_it_updated": "When `sbrStakersFee > 0` in `distributeFees` function.",
            "how_to_validate_state_update": "Check that `rewardToken` balance increases by `_amount` and `totalRewardPerToken` increases proportionally.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers reward tokens from msg.sender to the contract and updates `totalRewardPerToken`.",
            "conditions": [
              "sbrStakersFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "stabilityPool.stakingToken",
            "type": "address",
            "what_does_it_track": "The staking token associated with the stability pool.",
            "why_is_is_important": "Distributes rewards to stakers based on their stake.",
            "when_is_it_updated": "When `stabilityPoolFee > 0` in `distributeFees` function.",
            "how_to_validate_state_update": "Check that `stakingToken` balance increases by `_amount` and `totalRewardPerToken` increases proportionally.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers staking tokens from msg.sender to the contract and updates `totalRewardPerToken`.",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          },
          {
            "state_variable_name": "stabilityPool.totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total reward per token in the staking contract.",
            "why_is_is_important": "Distributes rewards to stakers based on their stake.",
            "when_is_it_updated": "When `stabilityPoolFee > 0` in `distributeFees` function.",
            "how_to_validate_state_update": "Check that `stakingToken` balance increases by `_amount` and `totalRewardPerToken` increases proportionally.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers staking tokens from msg.sender to the contract and updates `totalRewardPerToken`.",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          },
          {
            "state_variable_name": "stabilityPool.lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The last time SBR reward was distributed",
            "why_is_is_important": "Starts SBR reward distribution.",
            "when_is_it_updated": "Only when SBR reward distribution has not started yet.",
            "how_to_validate_state_update": "Check `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime` and `sbrRewardDistributionStatus`",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `lastSBRRewardDistributedTime`, `sbrRewardDistributionEndTime` and `sbrRewardDistributionStatus`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "stabilityPool.sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The end time for SBR reward distribution",
            "why_is_is_important": "Sets the end time for SBR reward distribution.",
            "when_is_it_updated": "Only when SBR reward distribution has not started yet.",
            "how_to_validate_state_update": "Check `sbrRewardDistributionEndTime`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `sbrRewardDistributionEndTime`.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "stabilityPool.sbrRewardDistributionStatus",
            "type": "uint8",
            "what_does_it_track": "The status of the SBR reward distribution",
            "why_is_is_important": "Starts the distribution.",
            "when_is_it_updated": "Only when SBR reward distribution has not started yet.",
            "how_to_validate_state_update": "Check `sbrRewardDistributionStatus`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `sbrRewardDistributionStatus` to STARTED.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "stabilityPool.totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total SBR reward per token",
            "why_is_is_important": "Updates total SBR reward per token",
            "when_is_it_updated": "When `sbrRewardDistributionStatus` is STARTED",
            "how_to_validate_state_update": "Check `totalSbrRewardPerToken`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `totalSbrRewardPerToken`",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED",
              "totalStakedRaw > 0"
            ]
          },
          {
            "state_variable_name": "stabilityPool.lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The last time SBR reward was distributed",
            "why_is_is_important": "Updates last SBR reward distributed time",
            "when_is_it_updated": "When `sbrRewardDistributionStatus` is STARTED",
            "how_to_validate_state_update": "Check `lastSBRRewardDistributedTime`.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates `lastSBRRewardDistributedTime`",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": []
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}