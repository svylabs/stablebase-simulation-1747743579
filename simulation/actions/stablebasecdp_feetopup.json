{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "safeId: The ID of the safe to top up. Must be a valid, existing safe ID owned by the caller.",
      "topupRate: The rate by which to increase the safe's weight. Must be greater than 0.",
      "nearestSpotInRedemptionQueue:  Hint to the contract where the safe is located. Can be zero."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the Safe's borrowed amount if there were changes in cumulativeDebtPerUnitCollateral since the last snapshot.",
          "Updates the Safe's collateral amount if there were changes in cumulativeCollateralPerUnitCollateral since the last snapshot.",
          "Increases the Safe's weight by topupRate.",
          "Increases the Safe's feePaid by the calculated fee."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "Transfers SBD tokens from the user to the contract to pay the fee.",
          "Refunds any undistributed fee back to the user."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Updates the position of the Safe in the redemption queue based on the new weight."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Updates the total debt of the protocol based on changes in the Safe's borrowed amount.",
          "Potentially updates the PROTOCOL_MODE from BOOTSTRAP to NORMAL if totalDebt exceeds BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Fees Distribution",
        "state_update_descriptions": [
          "Distributes the fee to SBR stakers and the stability pool.",
          "Mints SBD tokens to the contract if mint is true when distributeFees is called.",
          "Burns SBD tokens if there is undistributed fee and mint is true when distributeFees is called."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates the liquidation snapshot with the current cumulative debt and collateral per unit collateral."
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "Total Collateral is updated according to the collateral increase"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safes[safeId].weight should be increased by topupRate compared to its initial value.",
          "safes[safeId].feePaid should be increased by the fee amount compared to its initial value.",
          "The contract should have transferred the fee amount from the msg.sender. Thus sbdToken.balanceOf(msg.sender) should decrease by fee - refundFee where refundFee is the amount refunded to the user.",
          "If mint is true when distributeFees is called, the contract's SBD token balance should increase by the fee amount transferred from the user, minus any fees distributed and refunded. If mint is false the SBD token balance of the contract should remain the same if no refund and decrease by the refund amount if refund > 0.",
          "If _updateSafe updates the safe, then a SafeUpdated event is emitted with the correct parameters"
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "The position of safeId in safesOrderedForRedemption should be updated correctly based on safe.weight. Verify by calling safesOrderedForRedemption.getNode(safeId) and check the value, prev, and next fields."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "If the protocol mode changes from BOOTSTRAP to NORMAL, totalDebt should be greater than BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Events",
        "rule_descriptions": [
          "A FeeTopup event should be emitted with the correct safeId, topupRate, feePaid, and newWeight.",
          "A RedemptionQueueUpdated event should be emitted with the correct safeId, newWeight, and prev node.",
          "A FeeDistributed event should be emitted with the correct safeId, feePaid, sbrStakersFee, stabilityPoolFee, and canRefund.",
          "If a refund is issued, a FeeRefund event should be emitted with the correct safeId and refund amount."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "liquidationSnapshots",
            "type": "mapping",
            "what_does_it_track": "Stores the collateral and debt snapshots for a specific safe.",
            "why_is_is_important": "To ensure the safe's collateral and debt are up to date with the cumulative values.",
            "when_is_it_updated": "Before any other operation to sync the collateral and debt amounts",
            "how_to_validate_state_update": "Compare liquidationSnapshots[_safeId].collateralPerCollateralSnapshot and liquidationSnapshots[_safeId].debtPerCollateralSnapshot before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral and debt snapshots for a safe to the current cumulative values if they are outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "The collateral amount of a specific safe.",
            "why_is_is_important": "To reflect changes in the collateral amount due to cumulative collateral updates",
            "when_is_it_updated": "When the liquidation snapshot is out of sync with cumulative values and before any other changes to the safe.",
            "how_to_validate_state_update": "Check the collateralAmount of the safe before and after calling the function and confirm it matches cumulativeCollateralPerUnitCollateral if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the collateral amount of a safe by `(_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION` if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "The borrowed amount of a specific safe.",
            "why_is_is_important": "To reflect changes in the borrowed amount due to cumulative debt updates",
            "when_is_it_updated": "When the liquidation snapshot is out of sync with cumulative values and before any other changes to the safe.",
            "how_to_validate_state_update": "Check the borrowedAmount of the safe before and after calling the function and confirm it matches cumulativeDebtPerUnitCollateral if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the borrowed amount of a safe by `(_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION` if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total collateral in the system.",
            "why_is_is_important": "To keep track of the total amount of collateral in the system",
            "when_is_it_updated": "When the liquidation snapshot is out of sync with cumulative values.",
            "how_to_validate_state_update": "Check totalCollateral before and after the call. Confirm amount matches `totalCollateral += collateralIncrease` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total collateral by `collateralIncrease`, where `collateralIncrease = (_safe.collateralAmount * (cumulativeCollateralPerUnitCollateral - liquidationSnapshot.collateralPerCollateralSnapshot)) / PRECISION`, if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "To keep track of the total amount of debt in the system",
            "when_is_it_updated": "When the liquidation snapshot is out of sync with cumulative values.",
            "how_to_validate_state_update": "Check totalDebt before and after the call and confirm amount matches `totalDebt += debtIncrease` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total debt by `debtIncrease`, where `debtIncrease = (_safe.collateralAmount * (cumulativeDebtPerUnitCollateral - liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION`, if the liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "The weight of a specific safe, used for ordering in the redemption queue.",
            "why_is_is_important": "Determines the position of the safe in the redemption queue based on its 'weight'.",
            "when_is_it_updated": "Always when the function is executed, after _updateSafe and input validation.",
            "how_to_validate_state_update": "Check the weight of the safe before and after calling the function. The weight should increase by topupRate.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the 'weight' of the safe by `topupRate`.",
            "conditions": []
          },
          {
            "state_variable_name": "safes",
            "type": "mapping",
            "what_does_it_track": "The total fees paid for a specific safe.",
            "why_is_is_important": "Tracks the cumulative fees paid for the CDP, which may be used for accounting or reward purposes.",
            "when_is_it_updated": "Always when the function is executed, after _updateSafe and input validation.",
            "how_to_validate_state_update": "Check the feePaid value of the safe before and after calling the function.  feePaid should increase by the calculated 'fee'.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the 'feePaid' amount of the safe by `fee`, where `fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR`.",
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operating mode of the protocol",
            "why_is_is_important": "To update the global state to reflect normal operation of the protocol",
            "when_is_it_updated": "If totalDebt becomes greater than BOOTSTRAP_MODE_DEBT_THRESHOLD and the protocol is in BOOTSTRAP mode",
            "how_to_validate_state_update": "Check value of PROTOCOL_MODE before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Changes the protocol mode to NORMAL if the total debt exceeds the threshold while in BOOTSTRAP mode.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total debt in the system.",
            "why_is_is_important": "To keep track of the total amount of debt in the system",
            "when_is_it_updated": "Always after _updateSafe function.",
            "how_to_validate_state_update": "Check totalDebt before and after the call.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt, potentially increasing it based on cumulative updates.",
            "conditions": []
          },
          {
            "state_variable_name": "SafeUpdated event",
            "type": "event",
            "what_does_it_track": "Emitted when a safe is updated with new collateral and debt amounts.",
            "why_is_is_important": "To log changes to a safe's collateral and debt.",
            "when_is_it_updated": "When the liquidation snapshot is out of sync with cumulative values.",
            "how_to_validate_state_update": "Check for the SafeUpdated event emission, verifying the logged collateralAmount, debtAmount, collateralIncrease, debtIncrease, totalCollateral, and totalDebt values.",
            "has_conditional_updates": true,
            "summary_of_update": "Emits the SafeUpdated event when liquidation snapshot is outdated.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "RedemptionQueueUpdated event",
            "type": "event",
            "what_does_it_track": "Emitted when the redemption queue is updated for a specific safe.",
            "why_is_is_important": "To track changes in the redemption queue due to weight adjustments.",
            "when_is_it_updated": "Always after the safe's weight is updated and the position is adjusted.",
            "how_to_validate_state_update": "Check for the RedemptionQueueUpdated event emission, verifying the logged safeId, newWeight, and prevNode values.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits the RedemptionQueueUpdated event after the safe's weight is updated and its position adjusted in the redemption queue.",
            "conditions": []
          },
          {
            "state_variable_name": "FeeRefund event",
            "type": "event",
            "what_does_it_track": "Emitted when a fee is refunded to the user.",
            "why_is_is_important": "To log fee refunds to the user.",
            "when_is_it_updated": "If and when a refund is issued to the user.",
            "how_to_validate_state_update": "Check for the FeeRefund event emission, verifying the logged safeId and refund amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Emits the FeeRefund event when a portion of the fee is refunded to the user.",
            "conditions": [
              "refundFee > 0"
            ]
          },
          {
            "state_variable_name": "FeeTopup event",
            "type": "event",
            "what_does_it_track": "Emitted when a fee topup occurs.",
            "why_is_is_important": "To log fee topup events.",
            "when_is_it_updated": "Always after a successful fee topup.",
            "how_to_validate_state_update": "Check for the FeeTopup event emission, verifying the logged safeId, topupRate, feePaid, and newWeight values.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits the FeeTopup event after a successful fee topup.",
            "conditions": []
          },
          {
            "state_variable_name": "FeeDistributed event",
            "type": "event",
            "what_does_it_track": "Emitted when fees are distributed",
            "why_is_is_important": "To log how fees were distributed to different stakeholders.",
            "when_is_it_updated": "Always after fees are distributed.",
            "how_to_validate_state_update": "Check for the FeeDistributed event emission, verifying safeId, feePaid, mint, sbrStakersFee, stabilityPoolFee, and canRefund values.",
            "has_conditional_updates": false,
            "summary_of_update": "Emits the FeeDistributed event after fees are distributed to SBR stakers and the stability pool",
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The token balances of different addresses.",
            "why_is_is_important": "The contract needs to have received tokens to distribute it",
            "when_is_it_updated": "When transferring fee from msg.sender to this contract using `sbdToken.transferFrom`",
            "how_to_validate_state_update": "Check the token balance of both msg.sender and the contract.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the balance of the `msg.sender` (decreases) and this contract (increases) to reflect the fee transfer.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances",
            "type": "mapping",
            "what_does_it_track": "The token balances of different addresses.",
            "why_is_is_important": "To give the user their excess tokens back.",
            "when_is_it_updated": "When refunding undistributed fee back to user using `sbdToken.transfer`",
            "how_to_validate_state_update": "Check the token balance of both msg.sender and this contract.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the balance of the `msg.sender` (increases) and this contract (decreases) to reflect the refund transfer when `refundFee > 0`.",
            "conditions": [
              "refundFee > 0"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of tokens in existence.",
            "why_is_is_important": "To reflect that new tokens have entered the token supply.",
            "when_is_it_updated": "If minting tokens for fees.",
            "how_to_validate_state_update": "Check the total supply before and after minting. It should increase by fee.",
            "has_conditional_updates": true,
            "summary_of_update": "Increase in the total token supply by `fee` when minting is enabled (`mint == true`).",
            "conditions": [
              "mint == true"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total number of tokens in existence.",
            "why_is_is_important": "To reflect that tokens have been removed from the total token supply.",
            "when_is_it_updated": "If burning tokens after fees have been paid out.",
            "how_to_validate_state_update": "Check the total supply before and after burning. It should decrease by canRefund.",
            "has_conditional_updates": true,
            "summary_of_update": "Decrease in the total token supply by `canRefund` when burning is enabled (`mint == true`) and a refund is due (`canRefund > 0`).",
            "conditions": [
              "canRefund > 0",
              "mint == true"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "Nodes in the doubly linked list that represent safes and their corresponding weights.",
            "why_is_is_important": "To update or insert the safe's node based on the new weight, maintaining the redemption queue's integrity.",
            "when_is_it_updated": "Always when the function is executed, after the safe's weight is updated.",
            "how_to_validate_state_update": "Inspect the doubly linked list before and after upsert. Verify node[safeId] exists with the correct 'value' (weight).  Check prev and next pointers are correctly updated.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates or inserts the safe's node in the redemption queue based on the updated weight using upsert.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "To initialize head and tail for the doubly linked list.",
            "when_is_it_updated": "During insert operation if linked list is empty.",
            "how_to_validate_state_update": "Check if the linked list head is set to safeId, confirming the successful initialization of head and tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the head of the doubly linked list with `id` if the list is empty (`head == 0`).",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "To initialize head and tail for the doubly linked list.",
            "when_is_it_updated": "During insert operation if linked list is empty.",
            "how_to_validate_state_update": "Check if the linked list tail is set to safeId, confirming the successful initialization of head and tail.",
            "has_conditional_updates": true,
            "summary_of_update": "Initializes the tail of the doubly linked list with `id` if the list is empty (`head == 0`).",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The head of the doubly linked list.",
            "why_is_is_important": "To change the first node in the linked list",
            "when_is_it_updated": "During insert operation if a node is inserted at the beginning of the linked list.",
            "how_to_validate_state_update": "Check if the linked list head is set to safeId",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the head of the linked list to `id` if the new node should be inserted at the beginning of the list, specifically when `_nearestSpot` is the current head and the value of the current head is greater than or equal to the value of the new node.",
            "conditions": [
              "_nearestSpot == _head",
              "nodes[_nearestSpot].value >= node.value"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The tail of the doubly linked list.",
            "why_is_is_important": "To change the last node in the linked list",
            "when_is_it_updated": "During insert operation if a node is inserted at the end of the linked list.",
            "how_to_validate_state_update": "Check if the linked list tail is set to safeId",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the tail of the linked list to `id` if the new node should be inserted at the end of the list, specifically when `_nearestSpot` is the current tail and the value of the current tail is less than the value of the new node.",
            "conditions": [
              "_nearestSpot == _tail",
              "nodes[_nearestSpot].value < node.value"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total reward per token in the staking contract.",
            "why_is_is_important": "The contract needs to transfer tokens from msg.sender to add to rewards.",
            "when_is_it_updated": "When SBR fee reward tokens are successfully transferred from `msg.sender` to this contract using `rewardToken.transferFrom`",
            "how_to_validate_state_update": "Check balance of msg.sender and this contract before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `totalRewardPerToken` by `(_amount * PRECISION) / _totalStake` based on the transferred SBR fee when `feeAdded1 == true`.",
            "conditions": [
              "feeAdded1 == true"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total reward per token in the stability pool.",
            "why_is_is_important": "The contract needs to transfer tokens from msg.sender to add to rewards.",
            "when_is_it_updated": "When stability pool fee reward tokens are successfully transferred from `msg.sender` to this contract using `stakingToken.transferFrom`.",
            "how_to_validate_state_update": "Check balance of msg.sender and this contract before and after the call",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `totalRewardPerToken` based on the transferred stability pool fee when `feeAdded2 == true`.",
            "conditions": [
              "feeAdded2 == true"
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp of the last SBR reward distribution.",
            "why_is_is_important": "To track the last time SBR rewards were distributed",
            "when_is_it_updated": "When SBR rewards are distributed",
            "how_to_validate_state_update": "Check lastSBRRewardDistributedTime before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the timestamp of the last SBR reward distribution to `block.timestamp` if SBR reward distribution is already started.",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The end time for SBR reward distribution.",
            "why_is_is_important": "To set the initial end time for SBR reward distribution",
            "when_is_it_updated": "When SBR rewards are distributed for the first time",
            "how_to_validate_state_update": "Check sbrRewardDistributionEndTime before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the initial end time for SBR reward distribution to `block.timestamp + 365 days` if SBR reward distribution hasn't started yet (`sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED`).",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The distribution status of SBR rewards.",
            "why_is_is_important": "To mark the start of SBR reward distribution",
            "when_is_it_updated": "When SBR rewards are distributed for the first time",
            "how_to_validate_state_update": "Check sbrRewardDistributionStatus before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Marks the start of SBR reward distribution by setting `sbrRewardDistributionStatus = SBRRewardDistribution.STARTED` if SBR reward distribution hasn't started yet (`sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED`).",
            "conditions": [
              "sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED"
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum",
            "what_does_it_track": "The distribution status of SBR rewards.",
            "why_is_is_important": "To mark the ending of SBR reward distribution",
            "when_is_it_updated": "When the distribution is over.",
            "how_to_validate_state_update": "Check sbrRewardDistributionStatus before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Marks the ending of SBR reward distribution by setting `sbrRewardDistributionStatus = SBRRewardDistribution.ENDED` if the current timestamp is past the distribution end time.",
            "conditions": [
              "block.timestamp > sbrRewardDistributionEndTime"
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The total SBR reward per token in the stability pool.",
            "why_is_is_important": "To keep track of total SBR rewards per token",
            "when_is_it_updated": "When SBR rewards are added",
            "how_to_validate_state_update": "Check totalSbrRewardPerToken before and after the call.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the `totalSbrRewardPerToken` by `((_sbrReward * stakeScalingFactor * precision) / totalStakedRaw) / precision` when `totalStakedRaw > 0`.",
            "conditions": [
              "totalStakedRaw > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        }
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        }
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "dfidToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "dfireToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        }
      }
    ]
  }
}