{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "The 'safeId' parameter must correspond to an existing and valid CDP owned by the transaction sender (msg.sender).",
      "The 'topupRate' parameter must be a positive unsigned integer. This value, when multiplied by the safe's current 'borrowedAmount' and divided by 'BASIS_POINTS_DIVISOR', determines the 'fee' amount to be paid.",
      "The transaction sender (msg.sender) must hold an SBD token balance at least equal to the calculated 'fee' (topupRate * safe.borrowedAmount / BASIS_POINTS_DIVISOR) in the 'sbdToken' contract before the transaction.",
      "The 'nearestSpotInRedemptionQueue' parameter is a hint for optimizing the linked list operation in 'safesOrderedForRedemption'. It can be 0, or the ID of an existing node in the redemption queue that is expected to be near the new position of 'safeId' based on its updated 'weight'. While 0 allows the function to search from the head, providing an accurate nearby node can reduce gas costs."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "StableBaseCDP Contract State Updates",
        "state_update_descriptions": [
          "The 'borrowedAmount' of the specified 'safeId' within the 'safes' mapping may increase due to accumulated debt, as calculated in '_updateSafe' based on 'cumulativeDebtPerUnitCollateral' and 'liquidationSnapshots[safeId].debtPerCollateralSnapshot'.",
          "The 'collateralAmount' of the specified 'safeId' within the 'safes' mapping may increase due to accumulated collateral, as calculated in '_updateSafe' based on 'cumulativeCollateralPerUnitCollateral' and 'liquidationSnapshots[safeId].collateralPerCollateralSnapshot'.",
          "The 'weight' of the specified 'safeId' within the 'safes' mapping is increased by the 'topupRate' provided.",
          "The 'feePaid' of the specified 'safeId' within the 'safes' mapping is increased by the 'fee' amount calculated for the top-up.",
          "The 'collateralPerCollateralSnapshot' for the 'safeId' within the 'liquidationSnapshots' mapping is updated to 'cumulativeCollateralPerUnitCollateral' in '_updateSafe'.",
          "The 'debtPerCollateralSnapshot' for the 'safeId' within the 'liquidationSnapshots' mapping is updated to 'cumulativeDebtPerUnitCollateral' in '_updateSafe'.",
          "The contract's 'totalCollateral' may increase if 'collateralIncrease' is positive during the '_updateSafe' call.",
          "The contract's 'totalDebt' may increase if 'debtIncrease' is positive during the '_updateSafe' and '_updateTotalDebt' calls.",
          "The 'PROTOCOL_MODE' state variable may transition from 'BOOTSTRAP' to 'NORMAL' if 'totalDebt' exceeds 'BOOTSTRAP_MODE_DEBT_THRESHOLD' after the '_updateTotalDebt' call."
        ]
      },
      {
        "category": "DFIDToken (sbdToken) Contract State Updates",
        "state_update_descriptions": [
          "The SBD token balance of the message sender ('msg.sender') decreases by the 'fee' amount transferred to the StableBaseCDP contract.",
          "The SBD token balance of the StableBaseCDP contract ('address(this)') increases by the 'fee' amount received from 'msg.sender'.",
          "The SBD token balance of the DFIREStaking contract may increase by 'sbrStakersFee' if 'dfireTokenStaking.addReward' is successfully called.",
          "The SBD token balance of the StabilityPool contract may increase by 'stabilityPoolFee' if 'stabilityPool.addReward' is successfully called.",
          "If an undistributed 'refundFee' is returned to 'msg.sender', the SBD token balance of the StableBaseCDP contract decreases by 'refundFee', and the SBD token balance of 'msg.sender' increases by 'refundFee'."
        ]
      },
      {
        "category": "OrderedDoublyLinkedList (safesOrderedForRedemption) Contract State Updates",
        "state_update_descriptions": [
          "The 'value' of the node corresponding to 'safeId' in the 'safesOrderedForRedemption.nodes' mapping is updated to the new 'safe.weight'.",
          "The 'prev' and 'next' pointers of the node for 'safeId' and potentially other nodes in the linked list are updated to maintain the correct sorted order based on the new 'safe.weight'.",
          "The 'head' or 'tail' of the 'safesOrderedForRedemption' linked list may be updated if the 'safeId' becomes the new head or tail after the 'upsert' operation."
        ]
      },
      {
        "category": "DFIREStaking Contract State Updates",
        "state_update_descriptions": [
          "The 'totalRewardPerToken' in the DFIREStaking contract is updated if 'addReward' is successfully called and 'totalStake' is greater than zero."
        ]
      },
      {
        "category": "StabilityPool Contract State Updates",
        "state_update_descriptions": [
          "The 'totalRewardPerToken' in the StabilityPool contract is updated if 'addReward' is successfully called and 'totalStakedRaw' is greater than zero.",
          "The 'rewardLoss' in the StabilityPool contract may be updated after a reward distribution.",
          "The 'lastSBRRewardDistributedTime' in the StabilityPool contract is updated if '_addSBRRewards' is called.",
          "The 'sbrRewardDistributionEndTime' in the StabilityPool contract is set if the SBR reward distribution starts ('_addSBRRewards' is called when status is 'NOT_STARTED').",
          "The 'sbrRewardDistributionStatus' in the StabilityPool contract may transition to 'STARTED' or 'ENDED' based on time.",
          "The 'totalSbrRewardPerToken' in the StabilityPool contract is updated if '_addSBRRewards' is called and 'totalStakedRaw' is greater than zero.",
          "The 'sbrRewardLoss' in the StabilityPool contract may be updated after SBR reward distribution."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "StableBaseCDP Contract State Validation",
        "rule_descriptions": [
          "The 'weight' of the safe with 'safeId' (safes[safeId].weight) must be equal to its pre-execution value plus the 'topupRate'.",
          "The 'feePaid' of the safe with 'safeId' (safes[safeId].feePaid) must be equal to its pre-execution value plus the 'fee' amount calculated during execution (topupRate * borrowedAmount / BASIS_POINTS_DIVISOR).",
          "The 'borrowedAmount' and 'collateralAmount' of the safe (safes[safeId]) must be updated according to the '_updateSafe' logic, reflecting any accumulated debt or collateral since the last update.",
          "The 'collateralPerCollateralSnapshot' and 'debtPerCollateralSnapshot' for 'safeId' in 'liquidationSnapshots' must be updated to the current 'cumulativeCollateralPerUnitCollateral' and 'cumulativeDebtPerUnitCollateral' respectively.",
          "If applicable, the 'totalCollateral' and 'totalDebt' global variables must reflect the changes from the '_updateSafe' operation.",
          "If 'totalDebt' exceeded 'BOOTSTRAP_MODE_DEBT_THRESHOLD', the 'PROTOCOL_MODE' must be 'NORMAL'."
        ]
      },
      {
        "category": "DFIDToken (sbdToken) Contract State Validation",
        "rule_descriptions": [
          "The SBD token balance of the transaction sender (msg.sender) must be reduced by the 'fee' amount and then increased by any 'refundFee' received.",
          "The SBD token balance of the StableBaseCDP contract must be increased by the 'fee' amount received from 'msg.sender' and then reduced by any 'refundFee' transferred back to 'msg.sender'.",
          "The SBD token balance of the DFIREStaking contract should have increased by the 'sbrStakersFee' amount, if 'dfireTokenStaking.addReward' was successful.",
          "The SBD token balance of the StabilityPool contract should have increased by the 'stabilityPoolFee' amount, if 'stabilityPool.addReward' was successful."
        ]
      },
      {
        "category": "OrderedDoublyLinkedList (safesOrderedForRedemption) Contract State Validation",
        "rule_descriptions": [
          "The 'value' of the node corresponding to 'safeId' in 'safesOrderedForRedemption' must be equal to the new 'safe.weight'.",
          "The 'safeId' must be correctly positioned within the 'safesOrderedForRedemption' linked list, maintaining ascending order based on its 'weight' relative to other safes.",
          "The 'prev' and 'next' pointers of the updated node, and any nodes whose positions were affected, must correctly reflect the new linked list structure."
        ]
      },
      {
        "category": "DFIREStaking Contract State Validation",
        "rule_descriptions": [
          "If 'dfireTokenStaking.addReward' was successful, the 'totalRewardPerToken' of the DFIREStaking contract must be updated correctly based on 'sbrStakersFee' and the 'totalStake'."
        ]
      },
      {
        "category": "StabilityPool Contract State Validation",
        "rule_descriptions": [
          "If 'stabilityPool.addReward' was successful, the 'totalRewardPerToken' of the StabilityPool contract must be updated correctly based on 'stabilityPoolFee', 'totalStakedRaw', 'stakeScalingFactor', and 'precision'.",
          "If '_addSBRRewards' was triggered, 'lastSBRRewardDistributedTime', 'sbrRewardDistributionEndTime', 'sbrRewardDistributionStatus', 'totalSbrRewardPerToken', and 'sbrRewardLoss' in the StabilityPool contract must be updated according to their logic."
        ]
      },
      {
        "category": "Event Emission Validation",
        "rule_descriptions": [
          "A 'FeeTopup' event must be emitted from StableBaseCDP with the correct 'safeId', 'topupRate', 'feePaid', and 'newWeight'.",
          "A 'SafeUpdated' event must be emitted from StableBaseCDP with the 'safeId', updated 'collateralAmount', 'debtAmount', 'collateralIncrease', 'debtIncrease', 'totalCollateral', and 'totalDebt'.",
          "A 'RedemptionQueueUpdated' event must be emitted from StableBaseCDP with the 'safeId', 'newWeight', and 'prevNode' (the ID of the node before 'safeId' in the updated queue).",
          "A 'FeeDistributed' event must be emitted from StableBaseCDP with the 'safeId', 'feePaid', 'mint' (false), 'sbrStakersFee', 'stabilityPoolFee', and 'canRefund'.",
          "If a 'refundFee' was greater than zero, a 'FeeRefund' event must be emitted from StableBaseCDP with the 'safeId' and 'amount' (refundFee).",
          "A 'Transfer' event must be emitted from the SBD token contract for the fee payment (from 'msg.sender' to StableBaseCDP).",
          "If a refund occurred, another 'Transfer' event must be emitted from the SBD token contract for the refund (from StableBaseCDP to 'msg.sender').",
          "If 'dfireTokenStaking.addReward' was successful, a 'RewardAdded' event must be emitted from the DFIREStaking contract.",
          "If 'stabilityPool.addReward' was successful, a 'RewardAdded' event must be emitted from the StabilityPool contract.",
          "If SBR rewards were added, an 'SBRRewardsAdded' event must be emitted from the StabilityPool contract."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "mapping",
            "what_does_it_track": "The 'weight' associated with a specific CDP, used for ordering in the redemption queue.",
            "why_is_is_important": "It determines the order in which CDPs are prioritized for redemption; higher weight means higher priority.",
            "when_is_it_updated": "Whenever the 'feeTopup' function is called for a given 'safeId'.",
            "how_to_validate_state_update": "The 'weight' of the safe (CDP) at 'safeId' should increase by 'topupRate'.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the weight of the specified safe (CDP), which affects its position in the redemption queue.",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "mapping",
            "what_does_it_track": "The cumulative amount of fees paid for a specific CDP.",
            "why_is_is_important": "It tracks the total fees associated with a CDP over its lifetime.",
            "when_is_it_updated": "Whenever the 'feeTopup' function is called for a given 'safeId'.",
            "how_to_validate_state_update": "The 'feePaid' for the safe (CDP) at 'safeId' should increase by the calculated 'fee' amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the total amount of fees recorded as paid for the specified safe (CDP).",
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "mapping",
            "what_does_it_track": "The current outstanding borrowed amount for a specific CDP, adjusted for accrued debt.",
            "why_is_is_important": "It represents the current debt a CDP owner owes and is crucial for calculating collateralization ratios and liquidation thresholds.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of debt since the last update to the safe's liquidation snapshot.",
            "how_to_validate_state_update": "The 'borrowedAmount' of the safe should increase by 'debtIncrease', which is calculated based on the change in 'cumulativeDebtPerUnitCollateral' since the last snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the 'borrowedAmount' of the safe by adding any accumulated debt since the last time the safe's snapshot was updated.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "mapping",
            "what_does_it_track": "The total cumulative amount borrowed over the lifetime of a specific CDP, including accumulated debt.",
            "why_is_is_important": "It provides a historical record of all debt incurred by a CDP, useful for auditing and tracking overall debt exposure.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of debt since the last update to the safe's liquidation snapshot.",
            "how_to_validate_state_update": "The 'totalBorrowedAmount' of the safe should increase by 'debtIncrease', which is calculated based on the change in 'cumulativeDebtPerUnitCollateral' since the last snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the 'totalBorrowedAmount' of the safe by adding any accumulated debt since the last time the safe's snapshot was updated.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].debtPerCollateralSnapshot",
            "type": "mapping",
            "what_does_it_track": "A snapshot of the 'cumulativeDebtPerUnitCollateral' at the time a CDP was last updated or acted upon.",
            "why_is_is_important": "It is critical for accurately calculating the amount of debt that has accumulated for a CDP since its last interaction.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of debt/collateral since the last update.",
            "how_to_validate_state_update": "The 'debtPerCollateralSnapshot' for the safe's liquidation snapshot should be set to the current 'cumulativeDebtPerUnitCollateral'.",
            "has_conditional_updates": true,
            "summary_of_update": "Resets the 'debtPerCollateralSnapshot' to the current global cumulative debt value for the specified safe, ensuring future debt accumulation is calculated from this point.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "mapping",
            "what_does_it_track": "The current collateral amount for a specific CDP, adjusted for accrued collateral.",
            "why_is_is_important": "It represents the current collateral backing a CDP and is essential for maintaining the collateralization ratio.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of collateral since the last update to the safe's liquidation snapshot.",
            "how_to_validate_state_update": "The 'collateralAmount' of the safe should increase by 'collateralIncrease', which is calculated based on the change in 'cumulativeCollateralPerUnitCollateral' since the last snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the 'collateralAmount' of the safe by adding any accumulated collateral since the last time the safe's snapshot was updated.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[safeId].collateralPerCollateralSnapshot",
            "type": "mapping",
            "what_does_it_track": "A snapshot of the 'cumulativeCollateralPerUnitCollateral' at the time a CDP was last updated or acted upon.",
            "why_is_is_important": "It is critical for accurately calculating the amount of collateral that has accumulated for a CDP since its last interaction.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of debt/collateral since the last update.",
            "how_to_validate_state_update": "The 'collateralPerCollateralSnapshot' for the safe's liquidation snapshot should be set to the current 'cumulativeCollateralPerUnitCollateral'.",
            "has_conditional_updates": true,
            "summary_of_update": "Resets the 'collateralPerCollateralSnapshot' to the current global cumulative collateral value for the specified safe, ensuring future collateral accumulation is calculated from this point.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The sum of all collateral held by the protocol across all active CDPs.",
            "why_is_is_important": "It represents the overall collateralization of the protocol's debt and is a key metric for systemic health.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of collateral for the specific safe.",
            "how_to_validate_state_update": "The 'totalCollateral' should increase by 'collateralIncrease', which is calculated based on the change in 'cumulativeCollateralPerUnitCollateral' since the last snapshot.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total collateral held across all CDPs in the system.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The sum of all debt outstanding (borrowed amounts) across all active CDPs in the protocol.",
            "why_is_is_important": "It represents the overall debt burden of the protocol and is crucial for determining its operating mode and stability.",
            "when_is_it_updated": "During the '_updateSafe' internal call, if there has been an accumulation of debt for the specific safe.",
            "how_to_validate_state_update": "The 'totalDebt' is updated by adding 'debtIncrease' to the current 'totalDebt'.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total debt outstanding across all CDPs in the system.",
            "conditions": [
              "The 'collateralPerCollateralSnapshot' of the 'liquidationSnapshot' for the given 'safeId' is not equal to the current 'cumulativeCollateralPerUnitCollateral'."
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum SBStructs.Mode",
            "what_does_it_track": "The current operational mode of the protocol (e.g., BOOTSTRAP for initial phase, NORMAL for regular operation).",
            "why_is_is_important": "The protocol mode can influence various aspects of the system's behavior, such as liquidation parameters or fee structures.",
            "when_is_it_updated": "During the '_updateTotalDebt' internal call, if the conditions for mode transition are met.",
            "how_to_validate_state_update": "The 'PROTOCOL_MODE' should change from 'BOOTSTRAP' to 'NORMAL'.",
            "has_conditional_updates": true,
            "summary_of_update": "Switches the protocol's operating mode from 'BOOTSTRAP' to 'NORMAL' if the total outstanding debt crosses a predefined threshold.",
            "conditions": [
              "The updated 'totalDebt' is greater than 'BOOTSTRAP_MODE_DEBT_THRESHOLD' AND the current 'PROTOCOL_MODE' is 'BOOTSTRAP'."
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "mapping",
            "what_does_it_track": "The SBD token balance of individual addresses.",
            "why_is_is_important": "It reflects the user's SBD token holdings and their ability to pay or receive fees.",
            "when_is_it_updated": "When the 'transferFrom' function is called to pay the fee, and potentially when the 'transfer' function is called for a refund.",
            "how_to_validate_state_update": "The balance of 'msg.sender' should decrease by the 'fee' amount and then potentially increase by the 'refundFee' amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Decreases the SBD token balance of the user (msg.sender) who is topping up the fee, and potentially increases it if a refund is issued.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[StableBaseCDP contract address]",
            "type": "mapping",
            "what_does_it_track": "The SBD token balance held by the 'StableBaseCDP' contract.",
            "why_is_is_important": "It represents the SBD tokens collected by the protocol for fee distribution.",
            "when_is_it_updated": "When the 'transferFrom' function is called to pay the fee, and potentially when the 'transfer' function is called for a refund.",
            "how_to_validate_state_update": "The balance of the 'StableBaseCDP' contract should increase by the 'fee' amount and then potentially decrease by the 'refundFee' amount.",
            "has_conditional_updates": false,
            "summary_of_update": "Increases the SBD token balance held by the 'StableBaseCDP' contract due to fee payment, and potentially decreases it if a refund is issued.",
            "conditions": []
          },
          {
            "state_variable_name": "_balances[DFIREStaking contract address]",
            "type": "mapping",
            "what_does_it_track": "The SBD token balance held by the 'DFIREStaking' contract as rewards for stakers.",
            "why_is_is_important": "These tokens are accumulated as rewards to be distributed to DFIRE stakers, incentivizing participation in the staking mechanism.",
            "when_is_it_updated": "During the 'distributeFees' internal call, if the reward can be added to 'dfireTokenStaking'.",
            "how_to_validate_state_update": "The balance of the 'DFIREStaking' contract should increase by the 'sbrStakersFee' amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers a portion of the fee ('sbrStakersFee') to the 'DFIREStaking' contract, increasing its SBD token balance.",
            "conditions": [
              "The 'totalStake' in the 'DFIREStaking' contract is greater than 0 AND the 'addReward' call to 'dfireTokenStaking' returns true (indicating successful reward addition)."
            ]
          },
          {
            "state_variable_name": "_balances[StabilityPool contract address]",
            "type": "mapping",
            "what_does_it_track": "The SBD token balance held by the 'StabilityPool' contract as rewards for stakers.",
            "why_is_is_important": "These tokens are accumulated as rewards to be distributed to Stability Pool stakers, incentivizing participation in the stability mechanism.",
            "when_is_it_updated": "During the 'distributeFees' internal call, if the reward can be added to 'stabilityPool'.",
            "how_to_validate_state_update": "The balance of the 'StabilityPool' contract should increase by the 'stabilityPoolFee' amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Transfers a portion of the fee ('stabilityPoolFee') to the 'StabilityPool' contract, increasing its SBD token balance.",
            "conditions": [
              "The 'totalStakedRaw' in the 'StabilityPool' contract is greater than 0 AND the 'addReward' call to 'stabilityPool' returns true (indicating successful reward addition)."
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[id]",
            "type": "mapping",
            "what_does_it_track": "The individual nodes of the doubly linked list, each storing a value (safe's weight) and pointers to the previous and next nodes.",
            "why_is_is_important": "It maintains the integrity and sorted order of the redemption queue, which is essential for determining which CDPs are prioritized for redemption.",
            "when_is_it_updated": "Whenever a CDP's weight is updated, requiring its position in the redemption queue to be adjusted (via the 'upsert' function).",
            "how_to_validate_state_update": "The 'Node' struct at 'safeId' within the 'nodes' mapping should be updated or inserted. Its 'value' should be 'safe.weight', and its 'prev' and 'next' pointers should correctly reflect its new position in the sorted doubly linked list.",
            "has_conditional_updates": false,
            "summary_of_update": "Inserts or updates the node corresponding to the 'safeId' (representing a CDP) within the doubly linked list, ensuring it is positioned according to its new weight.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "The ID of the node with the smallest value in the doubly linked list, serving as the entry point for traversal.",
            "why_is_is_important": "It is crucial for maintaining the correct order and navigability of the redemption queue from the beginning.",
            "when_is_it_updated": "During the 'upsert' function, if a node is inserted or updated such that it becomes the new head, or if the previous head is removed.",
            "how_to_validate_state_update": "The 'head' should point to the correct ID of the new first node in the list.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the identifier of the first node in the ordered doubly linked list, if the insertion or update operation causes a change at the head of the list.",
            "conditions": [
              "The list was initially empty (head was 0), and a new node is inserted.",
              "A new node is inserted and its value is less than or equal to the current head's value, making it the new head.",
              "The current head node is removed from the list."
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "The ID of the node with the largest value in the doubly linked list, serving as the entry point for reverse traversal.",
            "why_is_is_important": "It is crucial for maintaining the correct order and navigability of the redemption queue from the end.",
            "when_is_it_updated": "During the 'upsert' function, if a node is inserted or updated such that it becomes the new tail, or if the previous tail is removed.",
            "how_to_validate_state_update": "The 'tail' should point to the correct ID of the new last node in the list.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the identifier of the last node in the ordered doubly linked list, if the insertion or update operation causes a change at the tail of the list.",
            "conditions": [
              "The list was initially empty (head was 0), and a new node is inserted.",
              "A new node is inserted and its value is greater than the current tail's value, making it the new tail.",
              "The current tail node is removed from the list."
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative amount of reward tokens distributed per unit of staked DFIRE tokens.",
            "why_is_is_important": "It is used to calculate the proportional rewards due to each DFIRE staker, encouraging participation in the staking mechanism.",
            "when_is_it_updated": "When the 'addReward' function is called on the 'dfireTokenStaking' contract, which occurs during fee distribution in StableBaseCDP.",
            "how_to_validate_state_update": "The 'totalRewardPerToken' should increase by '(_amount * PRECISION) / _totalStake', where '_amount' is 'sbrStakersFee'.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the cumulative reward per token staked in the DFIRE staking pool, reflecting the distribution of a portion of the fee.",
            "conditions": [
              "The 'totalStake' in the 'DFIREStaking' contract is greater than 0 AND the 'addReward' call to 'dfireTokenStaking' returns true (indicating successful reward addition)."
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative amount of reward tokens distributed per unit of staked tokens in the Stability Pool.",
            "why_is_is_important": "It is used to calculate the proportional rewards due to each Stability Pool staker, incentivizing participation in the stability mechanism.",
            "when_is_it_updated": "When the 'addReward' function is called on the 'stabilityPool' contract, which occurs during fee distribution in StableBaseCDP.",
            "how_to_validate_state_update": "The 'totalRewardPerToken' should increase by '_rewardPerToken', calculated based on the distributed 'stabilityPoolFee'.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the cumulative reward per token staked in the Stability Pool, reflecting the distribution of a portion of the fee.",
            "conditions": [
              "The 'totalStakedRaw' in the 'StabilityPool' contract is greater than 0 AND the 'addReward' call to 'stabilityPool' returns true (indicating successful reward addition)."
            ]
          },
          {
            "state_variable_name": "rewardLoss",
            "type": "uint256",
            "what_does_it_track": "A small remainder of reward tokens from distributions that could not be perfectly divided among stakers.",
            "why_is_is_important": "It prevents loss of small token amounts that arise from precision issues in reward calculations, ensuring fairness to stakers.",
            "when_is_it_updated": "When the 'addReward' function is called on the 'stabilityPool' contract.",
            "how_to_validate_state_update": "The 'rewardLoss' is updated to the remainder of the reward distribution calculation, ensuring no dust amounts are lost.",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates any minute, undistributable fractions of reward tokens due to integer division, ensuring full distribution over time.",
            "conditions": [
              "The 'totalStakedRaw' in the 'StabilityPool' contract is greater than 0 AND the 'addReward' call to 'stabilityPool' returns true (indicating successful reward addition)."
            ]
          },
          {
            "state_variable_name": "lastSBRRewardDistributedTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp of the most recent SBR reward distribution or the start of the SBR reward distribution period.",
            "why_is_is_important": "It is used to calculate the time elapsed for subsequent SBR reward accrual, ensuring continuous and accurate distribution.",
            "when_is_it_updated": "During the '_addSBRRewards' internal call, if the SBR reward distribution is active or starting.",
            "how_to_validate_state_update": "The 'lastSBRRewardDistributedTime' is set to the current 'block.timestamp'.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the timestamp of the last SBR reward distribution or the start of the SBR reward distribution period.",
            "conditions": [
              "The 'sbrRewardDistributionStatus' is not 'ENDED' (either 'STARTED' or 'NOT_STARTED')."
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionEndTime",
            "type": "uint256",
            "what_does_it_track": "The timestamp indicating when the SBR reward distribution period is scheduled to conclude.",
            "why_is_is_important": "It defines the duration over which SBR rewards are distributed, influencing the incentive structure for Stability Pool stakers.",
            "when_is_it_updated": "During the '_addSBRRewards' internal call, either at the start of the distribution period or upon its natural expiration.",
            "how_to_validate_state_update": "If 'NOT_STARTED', it's set to 'block.timestamp + 365 days'. If 'block.timestamp' exceeds it, the status transitions to 'ENDED'.",
            "has_conditional_updates": true,
            "summary_of_update": "Sets the end time for the SBR reward distribution period, or implicitly marks its end if the current time surpasses it.",
            "conditions": [
              "The 'sbrRewardDistributionStatus' is 'NOT_STARTED' (setting the initial end time).",
              "The current 'block.timestamp' is greater than 'sbrRewardDistributionEndTime' (transitioning to ENDED status)."
            ]
          },
          {
            "state_variable_name": "sbrRewardDistributionStatus",
            "type": "enum StabilityPool.SBRRewardDistribution",
            "what_does_it_track": "The current phase of the SBR token reward distribution mechanism (e.g., whether it has not started, is ongoing, or has ended).",
            "why_is_is_important": "It governs the logic for SBR reward calculation and distribution, impacting when and how SBR tokens are accrued by stakers.",
            "when_is_it_updated": "During the '_addSBRRewards' internal call, when the distribution period begins or concludes.",
            "how_to_validate_state_update": "Changes from 'NOT_STARTED' to 'STARTED' or from 'STARTED' to 'ENDED' based on time and initial conditions.",
            "has_conditional_updates": true,
            "summary_of_update": "Transitions the SBR reward distribution status from 'NOT_STARTED' to 'STARTED', or from 'STARTED' to 'ENDED' based on elapsed time.",
            "conditions": [
              "The 'sbrRewardDistributionStatus' is 'NOT_STARTED' (changes to STARTED).",
              "The current 'block.timestamp' is greater than 'sbrRewardDistributionEndTime' (changes to ENDED)."
            ]
          },
          {
            "state_variable_name": "totalSbrRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative amount of SBR reward tokens distributed per unit of staked tokens in the Stability Pool.",
            "why_is_is_important": "It is used to calculate the proportional SBR rewards due to each Stability Pool staker, providing an additional incentive for stability providers.",
            "when_is_it_updated": "During the '_addSBRRewards' internal call, if the SBR reward distribution is active and there are stakers.",
            "how_to_validate_state_update": "The 'totalSbrRewardPerToken' should increase by '_totalSbrRewardPerToken', calculated based on the SBR reward amount.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the cumulative SBR reward per token staked in the Stability Pool, reflecting the ongoing distribution of SBR tokens.",
            "conditions": [
              "The 'sbrRewardDistributionStatus' is not 'ENDED' AND the 'totalStakedRaw' in the 'StabilityPool' contract is greater than 0."
            ]
          },
          {
            "state_variable_name": "sbrRewardLoss",
            "type": "uint256",
            "what_does_it_track": "A small remainder of SBR reward tokens from distributions that could not be perfectly divided among stakers.",
            "why_is_is_important": "It prevents loss of small SBR token amounts due to integer division, ensuring the accuracy and completeness of SBR reward distribution.",
            "when_is_it_updated": "During the '_addSBRRewards' internal call, if the SBR reward distribution is active and there are stakers.",
            "how_to_validate_state_update": "The 'sbrRewardLoss' is updated to the remainder of the SBR reward calculation, carrying over any dust.",
            "has_conditional_updates": true,
            "summary_of_update": "Accumulates any small, undistributable fractions of SBR reward tokens, ensuring all SBR rewards are eventually accounted for.",
            "conditions": [
              "The 'sbrRewardDistributionStatus' is not 'ENDED' AND the 'totalStakedRaw' in the 'StabilityPool' contract is greater than 0."
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_rewardToken",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stableBaseContract",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "_stakingToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbrToken",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "_sbdToken",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_priceOracle",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stabilityPool",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_dfireTokenStaking",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForLiquidation",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_safesOrderedForRedemption",
              "contract_name": "StableBaseCDP"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}