{
  "action": {
    "name": "Fee Topup",
    "summary": "Tops up the fee for a CDP.",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "probability": 0.2
  },
  "action_detail": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "pre_execution_parameter_generation_rules": [
      "safeId: A valid safeId that exists in the safes mapping and is owned by the message sender.",
      "topupRate: A non-zero uint256 representing the fee top-up rate.",
      "nearestSpotInRedemptionQueue: A uint256 representing the nearest spot in the redemption queue, used as a hint for insertion; can be 0 to indicate head.",
      "The user must have sufficient SBD tokens approved for transfer to the contract, or have sufficient balance if using transfer.",
      "The current block timestamp should be after safe.lastUpdatedTimestamp to trigger potential updates."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Safe State",
        "state_update_descriptions": [
          "Updates the safe's collateralAmount and borrowedAmount based on cumulative collateral and debt per unit collateral if the liquidation snapshot is outdated, reflecting any inactive debt and collateral accrual.",
          "Increases the safe's weight by the topupRate.",
          "Increases the safe's feePaid by the calculated fee."
        ]
      },
      {
        "category": "Token Transfers",
        "state_update_descriptions": [
          "Transfers SBD tokens from the user to the contract to pay the fee.",
          "Potentially refunds undistributed fee back to the user."
        ]
      },
      {
        "category": "Redemption Queue",
        "state_update_descriptions": [
          "Updates the safe's position in the redemption queue based on its new weight."
        ]
      },
      {
        "category": "Fee Distribution",
        "state_update_descriptions": [
          "Distributes the fee to SBR stakers and the stability pool.",
          "Potentially mints or burns SBD tokens related to fee distribution."
        ]
      },
      {
        "category": "Total Debt",
        "state_update_descriptions": [
          "Updates the total debt of the protocol, potentially transitioning the protocol mode from BOOTSTRAP to NORMAL if the debt exceeds the BOOTSTRAP_MODE_DEBT_THRESHOLD."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "state_update_descriptions": [
          "Updates liquidation snapshot's debtPerCollateralSnapshot and collateralPerCollateralSnapshot"
        ]
      },
      {
        "category": "Total Collateral",
        "state_update_descriptions": [
          "Updates totalCollateral"
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Safe State",
        "rule_descriptions": [
          "safe.weight should be increased by topupRate.",
          "safe.feePaid should be increased by (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR.",
          "safe.borrowedAmount should be updated correctly based on cumulativeDebtPerUnitCollateral and liquidationSnapshots.",
          "safe.collateralAmount should be updated correctly based on cumulativeCollateralPerUnitCollateral and liquidationSnapshots."
        ]
      },
      {
        "category": "Token Balances",
        "rule_descriptions": [
          "User's SBD token balance should decrease by the fee amount (minus any refund).",
          "Contract's SBD token balance should increase by the fee amount (minus any distribution to stability pool or dfire staking and any refund)."
        ]
      },
      {
        "category": "Redemption Queue",
        "rule_descriptions": [
          "The doubly linked list representing the redemption queue should be correctly updated.",
          "safeId should exist inside the safesOrderedForRedemption."
        ]
      },
      {
        "category": "Total Debt",
        "rule_descriptions": [
          "Total debt should reflect any increases due to safe updates.",
          "PROTOCOL_MODE should be NORMAL if totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD, otherwise it should remain unchanged."
        ]
      },
      {
        "category": "Liquidation Snapshot",
        "rule_descriptions": [
          "liquidationSnapshots[safeId].debtPerCollateralSnapshot should equal cumulativeDebtPerUnitCollateral.",
          "liquidationSnapshots[safeId].collateralPerCollateralSnapshot should equal cumulativeCollateralPerUnitCollateral."
        ]
      },
      {
        "category": "Total Collateral",
        "rule_descriptions": [
          "totalCollateral value should reflect collateral increase."
        ]
      }
    ]
  },
  "action_execution": {
    "action_name": "Fee Topup",
    "contract_name": "StableBaseCDP",
    "function_name": "feeTopup",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "what_does_it_track": "The relative priority of a safe for redemption.",
            "why_is_is_important": "Determines the order in which safes are redeemed, incentivizing users to pay fees to improve their position in the queue.  Higher weight increases redemption priority, influencing potential liquidation order and creating incentives for maintaining collateralization ratios. Weight affects redemption queue placement, influencing liquidation risk and redemption opportunities. Impacts overall system stability by managing redemption flow based on fee payments and safe prioritization.  Directly affects user incentives and risk management strategies within the protocol by adjusting redemption priority through fee top-ups.  Weight ensures fairness and efficient operation of the redemption mechanism by dynamically adjusting redemption order based on fee contributions and individual safe characteristics. Impacts liquidation risk and redemption opportunities within the system. Influences overall system stability by managing redemption flow based on fee payments and safe prioritization.  Weight updates affect redemption queue placement, liquidation risk, and redemption opportunities, aligning user incentives with system stability. Ensures fairness and efficient operation of the redemption mechanism by dynamically adjusting redemption order based on fee contributions and individual safe characteristics. Affects liquidation risk and redemption opportunities, aligning user incentives with system stability. Dynamically adjusts redemption order based on fee contributions and individual safe characteristics, aligning user incentives with system stability. Influences individual safe risk profiles and system-wide stability by prioritizing safes with higher fee contributions. Provides a mechanism for users to actively manage their risk and incentivize participation in maintaining system health.  Ensures safes with higher fees receive preferential treatment in redemptions, impacting user incentives and system stability.",
            "when_is_it_updated": "When the fee is topped up, increasing the weight.",
            "how_to_validate_state_update": "Compare the new value of safe.weight to the old value after adding topupRate.  Compare the new value of safe.feePaid to the old value after adding fee.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the weight of the safe in the redemption queue by topupRate.",
            "conditions": [
              "balance >= fee",
              "topupRate > 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "what_does_it_track": "The cumulative amount of fees paid for a specific safe.",
            "why_is_is_important": "Tracks the total fees paid by a safe, influencing redemption priority and reflecting user engagement. It also ensures accurate fee accounting for distribution and potential refunds.",
            "when_is_it_updated": "When the fee is topped up.",
            "how_to_validate_state_update": "Compare the new value of safe.feePaid to the old value after adding fee.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the amount of fees paid by the safe.",
            "conditions": [
              "balance >= fee",
              "topupRate > 0"
            ]
          },
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The outstanding debt of a specific safe.",
            "why_is_is_important": "Reflects the real-time debt of the safe, impacting liquidation risk and overall system solvency.",
            "when_is_it_updated": "When cumulative debt per unit collateral changes.",
            "how_to_validate_state_update": "Check SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the borrowed amount of a safe based on cumulative debt and collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "what_does_it_track": "The total debt that has ever been borrowed from a specific safe.",
            "why_is_is_important": "Tracks the total debt of the safe, impacting liquidation risk and overall system solvency.",
            "when_is_it_updated": "When cumulative debt per unit collateral changes.",
            "how_to_validate_state_update": "Check SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total borrowed amount of a safe based on cumulative debt and collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safes[safeId].collateralAmount",
            "type": "uint256",
            "what_does_it_track": "The amount of collateral deposited in a safe.",
            "why_is_is_important": "Determines the collateralization ratio of the safe, directly impacting liquidation risk.",
            "when_is_it_updated": "When cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the collateral amount of a safe based on cumulative debt and collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "what_does_it_track": "The total amount of collateral in the system.",
            "why_is_is_important": "Reflects the overall health of the system and its ability to cover outstanding debt. Vital for calculating global collateralization ratios.",
            "when_is_it_updated": "When cumulative collateral per unit collateral changes.",
            "how_to_validate_state_update": "Check SafeUpdated event.",
            "has_conditional_updates": true,
            "summary_of_update": "Updates the total collateral in the system based on cumulative debt and collateral changes.",
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "what_does_it_track": "The current operational mode of the protocol (BOOTSTRAP or NORMAL).",
            "why_is_is_important": "Affects protocol behavior and risk parameters, especially during initial phases.",
            "when_is_it_updated": "When totalDebt crosses the BOOTSTRAP_MODE_DEBT_THRESHOLD.",
            "how_to_validate_state_update": "Check the PROTOCOL_MODE variable.",
            "has_conditional_updates": true,
            "summary_of_update": "Potentially changes the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds a threshold.",
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "what_does_it_track": "The total outstanding debt in the system.",
            "why_is_is_important": "Reflects the overall system solvency and risk. Used in system-wide calculations.",
            "when_is_it_updated": "When the debt is updated.",
            "how_to_validate_state_update": "Check SafeUpdated event.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the total debt in the system.",
            "conditions": []
          },
          {
            "state_variable_name": "safesOrderedForRedemption",
            "type": "contract",
            "what_does_it_track": "The ordered list of safes for redemption.",
            "why_is_is_important": "Determines the order in which safes are redeemed, impacting liquidation risk and overall system stability.",
            "when_is_it_updated": "When the fee is topped up.",
            "how_to_validate_state_update": "Check RedemptionQueueUpdated event and DoublyLinkedList state.",
            "has_conditional_updates": false,
            "summary_of_update": "The position of the safe is updated in the redemption queue based on its new weight.",
            "conditions": []
          },
          {
            "state_variable_name": "sbdToken",
            "type": "contract",
            "what_does_it_track": "sbdToken contract",
            "why_is_is_important": "Refunds undistributed fee back to the user.",
            "when_is_it_updated": "When there is fee to refund to user.",
            "how_to_validate_state_update": "Check FeeRefund event.",
            "has_conditional_updates": true,
            "summary_of_update": "Refunds undistributed fee back to the user.",
            "conditions": [
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "SBD balance of user.",
            "why_is_is_important": "Tracks user's SBD balance.",
            "when_is_it_updated": "When fee is paid.",
            "how_to_validate_state_update": "Check Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Reduces the SBD balance of the message sender by the fee amount.",
            "conditions": [
              "balance >= fee"
            ]
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "The SBD balance of this contract.",
            "why_is_is_important": "Tracks SBD balance.",
            "when_is_it_updated": "When the fee is paid.",
            "how_to_validate_state_update": "Check Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the SBD balance of the contract by the fee amount.",
            "conditions": [
              "balance >= fee"
            ]
          },
          {
            "state_variable_name": "totalSupply",
            "type": "uint256",
            "what_does_it_track": "The total supply of the SBD token.",
            "why_is_is_important": "Total supply of the token.",
            "when_is_it_updated": "When burning SBD token.",
            "how_to_validate_state_update": "Check Burn event.",
            "has_conditional_updates": true,
            "summary_of_update": "The total supply of SBD token decreases when undistributed fees are burned.",
            "conditions": [
              "canRefund > 0"
            ]
          },
          {
            "state_variable_name": "_balances[address(this)]",
            "type": "uint256",
            "what_does_it_track": "The SBD balance of this contract.",
            "why_is_is_important": "Tracks SBD balance.",
            "when_is_it_updated": "When burning SBD token.",
            "how_to_validate_state_update": "Check Burn event.",
            "has_conditional_updates": true,
            "summary_of_update": "The contract's SBD balance decreases when undistributed fees are burned.",
            "conditions": [
              "canRefund > 0"
            ]
          },
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "what_does_it_track": "SBD balance of user.",
            "why_is_is_important": "Tracks user's SBD balance.",
            "when_is_it_updated": "When fee is refunded.",
            "how_to_validate_state_update": "Check Transfer event.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the SBD balance of the msg.sender when fee is refunded.",
            "conditions": [
              "canRefund > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes",
            "type": "mapping",
            "what_does_it_track": "The structure of the doubly linked list representing the redemption queue.",
            "why_is_is_important": "Maintains the correct ordering of safes for redemption, ensuring fairness and efficiency.",
            "when_is_it_updated": "When the fee is topped up and the safe's weight changes.",
            "how_to_validate_state_update": "Check the nodes mapping for changes in the linked list structure.",
            "has_conditional_updates": false,
            "summary_of_update": "Updates the linked list node structure to reflect the safe's new position in the redemption queue based on the topped-up fee. If the safe's ID is not present, then insert it. If the safe's ID is present, then update it. The nodes maintains value, previous, and next node ids.",
            "conditions": []
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head of the linked list.",
            "why_is_is_important": "Maintains the head of the doubly linked list.",
            "when_is_it_updated": "When the linked list is empty.",
            "how_to_validate_state_update": "Check the head variable.",
            "has_conditional_updates": true,
            "summary_of_update": "If linked list is empty, update the head to safe id.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail of the linked list.",
            "why_is_is_important": "Maintains the tail of the doubly linked list.",
            "when_is_it_updated": "When the linked list is empty.",
            "how_to_validate_state_update": "Check the tail variable.",
            "has_conditional_updates": true,
            "summary_of_update": "If linked list is empty, update the tail to safe id.",
            "conditions": [
              "head == 0"
            ]
          },
          {
            "state_variable_name": "head",
            "type": "uint256",
            "what_does_it_track": "Head of the linked list.",
            "why_is_is_important": "Maintains the head of the doubly linked list.",
            "when_is_it_updated": "When the first node is removed.",
            "how_to_validate_state_update": "Check the head variable.",
            "has_conditional_updates": true,
            "summary_of_update": "If the node is the first, update the head to node.next.",
            "conditions": [
              "node.prev == 0"
            ]
          },
          {
            "state_variable_name": "tail",
            "type": "uint256",
            "what_does_it_track": "Tail of the linked list.",
            "why_is_is_important": "Maintains the tail of the doubly linked list.",
            "when_is_it_updated": "When the last node is removed.",
            "how_to_validate_state_update": "Check the tail variable.",
            "has_conditional_updates": true,
            "summary_of_update": "If the node is the last, update the tail to node.prev.",
            "conditions": [
              "node.next == 0"
            ]
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative reward per token for SBR stakers.",
            "why_is_is_important": "Incentivizes SBR staking by providing rewards, contributing to protocol stability.",
            "when_is_it_updated": "When the fee is topped up and distributed to SBR stakers.",
            "how_to_validate_state_update": "Check RewardAdded event.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token, distributing a portion of the fee to SBR stakers.",
            "conditions": [
              "totalStake > 0",
              "sbrStakersFee > 0"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "what_does_it_track": "The cumulative reward per token for Stability Pool stakers.",
            "why_is_is_important": "Incentivizes staking in the Stability Pool, providing liquidity for liquidations and contributing to protocol stability.",
            "when_is_it_updated": "When the fee is topped up and distributed to the Stability Pool.",
            "how_to_validate_state_update": "Check RewardAdded event.",
            "has_conditional_updates": true,
            "summary_of_update": "Increases the total reward per token in the Stability Pool, distributing a portion of the fee to stakers.",
            "conditions": [
              "stabilityPoolFee > 0"
            ]
          }
        ]
      }
    ]
  },
  "action_context": {
    "contract_context": [
      {
        "contract_name": "StableBaseCDP",
        "code_snippet": "function feeTopup(\n        uint256 safeId,\n        uint256 topupRate,\n        uint256 nearestSpotInRedemptionQueue\n    ) external _onlyOwner(safeId) {\n        Safe storage safe = safes[safeId];\n        _updateSafe(safeId, safe);\n        //TODO:  Check if the required fee is paid\n        require(topupRate > 0, \"Fee rate must be greater than 0\");\n        uint256 balance = sbdToken.balanceOf(msg.sender);\n        uint256 fee = (topupRate * safe.borrowedAmount) / BASIS_POINTS_DIVISOR;\n        require(balance >= fee, \"Insufficient Balance to pay fee\");\n        // Update the spot in the shieldedSafes list\n        safe.weight += topupRate;\n        safe.feePaid += fee;\n        require(\n            sbdToken.transferFrom(msg.sender, address(this), fee),\n            \"Transfering Tokens failed\"\n        );\n        // Jump to the correct position in the redemption queue\n        IDoublyLinkedList.Node memory node = safesOrderedForRedemption.upsert(\n            safeId,\n            safe.weight,\n            nearestSpotInRedemptionQueue\n        );\n        emit RedemptionQueueUpdated(safeId, safe.weight, node.prev);\n        (, uint256 refundFee) = distributeFees(safeId, fee, false);\n        if (refundFee > 0) {\n            // Refund undistributed fee back to the user\n            require(\n                sbdToken.transfer(msg.sender, refundFee),\n                \"Transfer Refund failed\"\n            );\n            emit FeeRefund(safeId, refundFee);\n        }\n        emit FeeTopup(safeId, topupRate, fee, safe.weight);\n    }\nfunction _updateSafe(\n        uint _safeId,\n        Safe storage _safe\n    ) internal returns (Safe memory) {\n        // Update borrowed amount\n        LiquidationSnapshot storage liquidationSnapshot = liquidationSnapshots[\n            _safeId\n        ];\n        if (\n            liquidationSnapshot.collateralPerCollateralSnapshot !=\n            cumulativeCollateralPerUnitCollateral\n        ) {\n            uint debtIncrease = (_safe.collateralAmount *\n                (cumulativeDebtPerUnitCollateral -\n                    liquidationSnapshot.debtPerCollateralSnapshot)) / PRECISION;\n            _safe.borrowedAmount += debtIncrease;\n            _safe.totalBorrowedAmount += debtIncrease;\n            liquidationSnapshot\n                .debtPerCollateralSnapshot = cumulativeDebtPerUnitCollateral;\n\n            // Update deposited amount\n            uint collateralIncrease = (_safe.collateralAmount *\n                (cumulativeCollateralPerUnitCollateral -\n                    liquidationSnapshot.collateralPerCollateralSnapshot)) /\n                PRECISION;\n            _safe.collateralAmount += collateralIncrease;\n            liquidationSnapshot\n                .collateralPerCollateralSnapshot = cumulativeCollateralPerUnitCollateral;\n\n            totalCollateral += collateralIncrease;\n            _updateTotalDebt(totalDebt, debtIncrease, true);\n            emit SafeUpdated(\n                _safeId,\n                _safe.collateralAmount,\n                _safe.borrowedAmount,\n                collateralIncrease,\n                debtIncrease,\n                totalCollateral,\n                totalDebt\n            );\n        }\n\n        return _safe;\n    }\nfunction _updateTotalDebt(\n        uint256 currentDebt,\n        uint256 delta,\n        bool add\n    ) internal returns (uint256) {\n        uint256 debt = currentDebt;\n        if (add) {\n            debt = currentDebt + delta;\n        } else {\n            debt = currentDebt - delta;\n        }\n        // Bootstrap Mode to Normal mode only once, Normal mode to bootstrap mode is not possible\n        if (\n            debt > BOOTSTRAP_MODE_DEBT_THRESHOLD &&\n            PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP\n        ) {\n            PROTOCOL_MODE = SBStructs.Mode.NORMAL;\n        }\n        totalDebt = debt;\n        return debt;\n    }\nfunction distributeFees(\n        uint256 safeId,\n        uint fee,\n        bool mint\n    ) internal returns (uint256 feePaid, uint256 canRefund) {\n        if (mint) {\n            require(sbdToken.mint(address(this), fee), \"Mint failed\");\n        }\n        uint256 sbrStakersFee = (fee * SBR_FEE_REWARD) / 10000;\n        uint256 stabilityPoolFee = fee;\n        canRefund = fee;\n        bool feeAdded1 = dfireTokenStaking.addReward(sbrStakersFee);\n        if (feeAdded1) {\n            stabilityPoolFee = fee - sbrStakersFee;\n            feePaid = fee;\n            canRefund -= sbrStakersFee;\n        }\n        bool feeAdded2 = stabilityPool.addReward(stabilityPoolFee);\n        if (feeAdded2) {\n            feePaid += stabilityPoolFee;\n            canRefund -= stabilityPoolFee;\n        }\n        require(canRefund <= fee, \"Invalid refund amount\");\n        if (canRefund > 0 && mint) {\n            require(sbdToken.burn(address(this), canRefund), \"Burn failed\");\n        }\n        emit FeeDistributed(\n            safeId,\n            feePaid,\n            mint,\n            sbrStakersFee,\n            stabilityPoolFee,\n            canRefund\n        );\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "sbdToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "priceOracle",
              "contract_name": "MockPriceOracle"
            },
            {
              "state_variable_name": "stabilityPool",
              "contract_name": "StabilityPool"
            },
            {
              "state_variable_name": "dfireTokenStaking",
              "contract_name": "DFIREStaking"
            },
            {
              "state_variable_name": "safesOrderedForLiquidation",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "safesOrderedForRedemption",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": [
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          },
          {
            "name": "FIRST_TIME_BORROW_BASIS_POINTS_DISCOUNT_THRESHOLD",
            "value": "20",
            "type": "uint256"
          },
          {
            "name": "MINIMUM_DEBT",
            "value": "2000 * 10 ** 18",
            "type": "uint256"
          },
          {
            "name": "PRECISION",
            "value": "10 ** 18",
            "type": "uint256"
          },
          {
            "name": "SBR_FEE_REWARD",
            "value": "1000",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_LIQUIDATION_FEE",
            "value": "75",
            "type": "uint256"
          },
          {
            "name": "REDEMPTION_BASE_FEE",
            "value": "15",
            "type": "uint256"
          },
          {
            "name": "EXTRA_GAS_COMPENSATION",
            "value": "100000",
            "type": "uint256"
          },
          {
            "name": "BOOTSTRAP_MODE_DEBT_THRESHOLD",
            "value": "5000000 * 10 ** 18",
            "type": "uint256"
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "code_snippet": "function balanceOf(address account) external view returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) external returns (bool);\nfunction mint(\n        address to,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\nfunction _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\nfunction _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\nfunction burn(\n        address from,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        require(from != address(0), \"Invalid address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(balanceOf(from) >= amount, \"Insufficient balance\");\n\n        _burn(from, amount); // Using OpenZeppelin's internal _burn function\n\n        totalBurned += amount;\n\n        emit Burn(from, amount);\n        return true;\n    }\nfunction _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\nfunction transfer(address to, uint256 value) external returns (bool);",
        "references": {
          "references": [
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "stableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "code_snippet": "function upsert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) external override onlyOwner returns (Node memory) {\n        if (\n            nodes[id].value == 0 && nodes[id].next == 0 && nodes[id].prev == 0\n        ) {\n            return _insert(id, value, _nearestSpot);\n        } else {\n            return _update(id, value, _nearestSpot);\n        }\n    }\nfunction _insert(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = Node(value, 0, 0);\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _insert(\n        uint256 id,\n        Node memory node,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        uint256 _head = head;\n        if (_head == 0) {\n            head = id;\n            tail = id;\n        } else {\n            uint256 _tail = tail;\n            if (_nearestSpot == 0) {\n                _nearestSpot = _head;\n            }\n\n            if (\n                nodes[_nearestSpot].prev == 0 &&\n                nodes[_nearestSpot].next == 0 &&\n                nodes[_nearestSpot].value == 0\n            ) {\n                _nearestSpot = head;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node: 7: 7, 7, 9, 11, 11\n            // nearest: 9, node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _tail && nodes[_nearestSpot].value < node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].next;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 11, node:10: 7, 7, 9, 11, 11\n            // nearest: 9, node:7: 7, 7, 9, 11, 11\n            // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n\n            while (\n                _nearestSpot != _head && nodes[_nearestSpot].value >= node.value\n            ) {\n                _nearestSpot = nodes[_nearestSpot].prev;\n                //nearest = nodes[_nearestSpot];\n            }\n            // nearest: 7, node: 7: 7, 7, 9, 11, 11\n\n            if (_nearestSpot == _head) {\n                if (nodes[_nearestSpot].value >= node.value) {\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    head = id;\n                } else {\n                    node.prev = _nearestSpot;\n                    node.next = nodes[_nearestSpot].next;\n                    nodes[_nearestSpot].next = id;\n                    if (node.next != 0) {\n                        nodes[node.next].prev = id;\n                    } else {\n                        tail = id;\n                    }\n                }\n            } else if (_nearestSpot == _tail) {\n                // nearest: 11(last), node: 12: 7, 7, 9, 11, 11\n                if (nodes[_nearestSpot].value < node.value) {\n                    node.prev = _nearestSpot;\n                    nodes[_nearestSpot].next = id;\n                    tail = id;\n                } else {\n                    node.prev = nodes[_nearestSpot].prev;\n                    node.next = _nearestSpot;\n                    nodes[_nearestSpot].prev = id;\n                    if (node.prev != 0) {\n                        nodes[node.prev].next = id;\n                    } else {\n                        head = id;\n                    }\n                }\n            } else {\n                // nearest: 9, node: 10: 7, 7, 9, 11, 11\n                node.prev = _nearestSpot;\n                node.next = nodes[_nearestSpot].next;\n                nodes[_nearestSpot].next = id;\n                nodes[node.next].prev = id;\n            }\n        }\n        nodes[id] = node;\n        return node;\n    }\nfunction _update(\n        uint256 id,\n        uint256 value,\n        uint256 _nearestSpot\n    ) internal returns (Node memory) {\n        Node memory node = _remove(id);\n        node.value = value;\n        node.prev = 0;\n        node.next = 0;\n        return _insert(id, node, _nearestSpot);\n    }\nfunction _remove(uint256 id) internal returns (Node memory) {\n        Node memory node = nodes[id];\n        if (node.prev == 0) {\n            head = node.next;\n            nodes[node.next].prev = 0;\n        } else {\n            nodes[node.prev].next = node.next;\n            nodes[node.next].prev = node.prev;\n        }\n        if (node.next == 0) {\n            tail = node.prev;\n            nodes[node.prev].next = 0;\n        } else {\n            nodes[node.next].prev = node.prev;\n            nodes[node.prev].next = node.next;\n        }\n        delete nodes[id];\n        return node;\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "head",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "tail",
              "contract_name": "OrderedDoublyLinkedList"
            },
            {
              "state_variable_name": "_stableBaseCDP",
              "contract_name": "OrderedDoublyLinkedList"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "DFIREStaking",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        uint _totalStake = totalStake;\n        if (_totalStake == 0) {\n            return false;\n        } else {\n            require(\n                rewardToken.transferFrom(msg.sender, address(this), _amount),\n                \"Transfer tokens failed\"\n            );\n            totalRewardPerToken += (_amount * PRECISION) / _totalStake;\n            emit RewardAdded(_amount);\n            return true;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "rewardToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "stableBaseContract",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": []
      },
      {
        "contract_name": "StabilityPool",
        "code_snippet": "function addReward(uint256 _amount) external returns (bool) {\n        require(_amount > 0, \"Reward must be greater than zero\");\n        //uint256 totalEffectiveStake = getTotalEffectiveStake();\n        //require(totalEffectiveStake > 0, \"No staked tokens\");\n        uint256 _totalStakedRaw = totalStakedRaw;\n        if (_totalStakedRaw == 0) {\n            return false;\n        }\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\n            \"Transfer tokens failed\"\n        );\n\n        uint256 _totalAmount = _amount + rewardLoss;\n        uint256 _rewardPerToken = ((_totalAmount *\n            stakeScalingFactor *\n            precision) / _totalStakedRaw) / precision;\n\n        totalRewardPerToken += _rewardPerToken;\n\n        rewardLoss =\n            _totalAmount -\n            (((_rewardPerToken * _totalStakedRaw * precision) /\n                stakeScalingFactor) / precision);\n\n        if (sbrRewardDistributionStatus != SBRRewardDistribution.ENDED) {\n            _addSBRRewards();\n        }\n\n        emit RewardAdded(_amount);\n        return true;\n    }\nfunction _addSBRRewards() internal {\n        if (sbrRewardDistributionStatus == SBRRewardDistribution.STARTED) {\n            uint256 timeElapsed = block.timestamp -\n                lastSBRRewardDistributedTime;\n            if (block.timestamp > sbrRewardDistributionEndTime) {\n                sbrRewardDistributionStatus = SBRRewardDistribution.ENDED;\n                timeElapsed =\n                    sbrRewardDistributionEndTime -\n                    lastSBRRewardDistributedTime;\n            }\n            uint256 sbrReward = timeElapsed * sbrDistributionRate;\n            if (totalStakedRaw > 0) {\n                uint256 _sbrReward = sbrReward + sbrRewardLoss;\n                uint256 _totalSbrRewardPerToken = ((_sbrReward *\n                    stakeScalingFactor *\n                    precision) / totalStakedRaw) / precision;\n                totalSbrRewardPerToken += _totalSbrRewardPerToken;\n                sbrRewardLoss =\n                    _sbrReward -\n                    ((_totalSbrRewardPerToken * totalStakedRaw * precision) /\n                        stakeScalingFactor) /\n                    precision;\n\n                emit SBRRewardsAdded(\n                    lastSBRRewardDistributedTime,\n                    block.timestamp,\n                    sbrReward,\n                    totalSbrRewardPerToken\n                );\n            }\n            lastSBRRewardDistributedTime = block.timestamp;\n        } else if (\n            sbrRewardDistributionStatus == SBRRewardDistribution.NOT_STARTED\n        ) {\n            lastSBRRewardDistributedTime = block.timestamp;\n            sbrRewardDistributionEndTime = block.timestamp + 365 days;\n            sbrRewardDistributionStatus = SBRRewardDistribution.STARTED;\n        }\n    }",
        "references": {
          "references": [
            {
              "state_variable_name": "stakingToken",
              "contract_name": "DFIDToken"
            },
            {
              "state_variable_name": "sbrToken",
              "contract_name": "DFIREToken"
            },
            {
              "state_variable_name": "stableBaseCDP",
              "contract_name": "StableBaseCDP"
            }
          ]
        },
        "constants": [
          {
            "name": "precision",
            "value": "1e18",
            "type": "uint256"
          },
          {
            "name": "minimumScalingFactor",
            "value": "1e9",
            "type": "uint256"
          },
          {
            "name": "BASIS_POINTS_DIVISOR",
            "value": "10000",
            "type": "uint256"
          }
        ]
      }
    ]
  }
}