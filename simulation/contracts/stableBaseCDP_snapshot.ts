// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot, Safe, LiquidationSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  try {
    const safes: { [safeId: bigint]: Safe } = {};
    const liquidationSnapshots: { [safeId: bigint]: LiquidationSnapshot } = {};
    const balanceOf: { [accountAddress: string]: bigint } = {};
    const getApproved: { [safeId: bigint]: string } = {};
    const isApprovedForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
    const ownerOf: { [safeId: bigint]: string } = {};
    const tokenURI: { [safeId: bigint]: string } = {};
    const getInactiveDebtAndCollateral: { [safeId: bigint]: { debt: bigint; collateral: bigint } } = {};

    // Fetch all safes based on _safeId from actors identifiers
    for (const actor of actors) {
      const safeIds = actor.getIdentifiers()._safeId;

      if (safeIds) {
        const safeIdsArray = Array.isArray(safeIds) ? safeIds : [safeIds];
        for (const safeId of safeIdsArray) {
          try {
            const safe = await contract.safes(BigInt(safeId));
            safes[BigInt(safeId)] = {
              collateralAmount: BigInt(safe.collateralAmount),
              borrowedAmount: BigInt(safe.borrowedAmount),
              weight: BigInt(safe.weight),
              totalBorrowedAmount: BigInt(safe.totalBorrowedAmount),
              feePaid: BigInt(safe.feePaid),
            };
          } catch (error: any) {
            console.error(`Error fetching safe ${safeId}: ${error.message}`);
          }

          try {
            const liquidationSnapshot = await contract.liquidationSnapshots(BigInt(safeId));
            liquidationSnapshots[BigInt(safeId)] = {
              collateralPerCollateralSnapshot: BigInt(liquidationSnapshot.collateralPerCollateralSnapshot),
              debtPerCollateralSnapshot: BigInt(liquidationSnapshot.debtPerCollateralSnapshot),
            };
          } catch (error: any) {
            console.error(`Error fetching liquidation snapshot for safe ${safeId}: ${error.message}`);
          }

          try {
            const approvedAddress = await contract.getApproved(BigInt(safeId));
            getApproved[BigInt(safeId)] = approvedAddress;
          } catch (error: any) {
            console.error(`Error fetching approved address for safe ${safeId}: ${error.message}`);
          }

          try {
            const ownerAddress = await contract.ownerOf(BigInt(safeId));
            ownerOf[BigInt(safeId)] = ownerAddress;
          } catch (error: any) {
            console.error(`Error fetching owner address for safe ${safeId}: ${error.message}`);
          }

          try {
            const uri = await contract.tokenURI(BigInt(safeId));
            tokenURI[BigInt(safeId)] = uri;
          } catch (error: any) {
            console.error(`Error fetching token URI for safe ${safeId}: ${error.message}`);
          }

          try {
            const inactiveData = await contract.getInactiveDebtAndCollateral(BigInt(safeId));
            getInactiveDebtAndCollateral[BigInt(safeId)] = {
              debt: BigInt(inactiveData.debt),
              collateral: BigInt(inactiveData.collateral),
            };
          } catch (error: any) {
            console.error(`Error fetching inactive debt and collateral for safe ${safeId}: ${error.message}`);
          }
        }
      }
    }

    // Fetch balanceOf for each actor (accountAddress)
    for (const actor of actors) {
      const accountAddressIdentifier = actor.getIdentifiers().accountAddress;
      if (accountAddressIdentifier) {
        const accountAddress = accountAddressIdentifier as string; // Explicit cast to string
        try {
          const balance = await contract.balanceOf(accountAddress);
          balanceOf[accountAddress] = BigInt(balance);
        } catch (error: any) {
          console.error(`Error fetching balanceOf for address ${accountAddress}: ${error.message}`);
        }

        // Fetch isApprovedForAll for each operator for the current owner
        isApprovedForAll[accountAddress] = {};
        for (const operatorActor of actors) {
          const operatorAddressIdentifier = operatorActor.getIdentifiers().accountAddress;
          if (operatorAddressIdentifier) {
            const operatorAddress = operatorAddressIdentifier as string; // Explicit cast to string
            try {
              const isApproved = await contract.isApprovedForAll(accountAddress, operatorAddress);
              isApprovedForAll[accountAddress][operatorAddress] = isApproved;
            } catch (error: any) {
              console.error(`Error fetching isApprovedForAll for owner ${accountAddress} and operator ${operatorAddress}: ${error.message}`);
            }
          }
        }
      }
    }

    let collateralLoss: bigint;
    try {
      collateralLoss = BigInt(await contract.collateralLoss());
    } catch (error: any) {
      console.error(`Error fetching collateralLoss: ${error.message}`);
      collateralLoss = BigInt(0);
    }

    let cumulativeCollateralPerUnitCollateral: bigint;
    try {
      cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    } catch (error: any) {
      console.error(`Error fetching cumulativeCollateralPerUnitCollateral: ${error.message}`);
      cumulativeCollateralPerUnitCollateral = BigInt(0);
    }

    let cumulativeDebtPerUnitCollateral: bigint;
    try {
      cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    } catch (error: any) {
      console.error(`Error fetching cumulativeDebtPerUnitCollateral: ${error.message}`);
      cumulativeDebtPerUnitCollateral = BigInt(0);
    }

    let debtLoss: bigint;
    try {
      debtLoss = BigInt(await contract.debtLoss());
    } catch (error: any) {
      console.error(`Error fetching debtLoss: ${error.message}`);
      debtLoss = BigInt(0);
    }

    let mode: number;
    try {
      mode = Number(await contract.mode());
    } catch (error: any) {
      console.error(`Error fetching mode: ${error.message}`);
      mode = 0;
    }

    let name: string;
    try {
      name = await contract.name();
    } catch (error: any) {
      console.error(`Error fetching name: ${error.message}`);
      name = '';
    }

    let dfireTokenStaking: string;
    try {
      dfireTokenStaking = await contract.dfireTokenStaking();
    } catch (error: any) {
      console.error(`Error fetching dfireTokenStaking: ${error.message}`);
      dfireTokenStaking = '';
    }

    let safesOrderedForLiquidation: string;
    try {
      safesOrderedForLiquidation = await contract.safesOrderedForLiquidation();
    } catch (error: any) {
      console.error(`Error fetching safesOrderedForLiquidation: ${error.message}`);
      safesOrderedForLiquidation = '';
    }

    let safesOrderedForRedemption: string;
    try {
      safesOrderedForRedemption = await contract.safesOrderedForRedemption();
    } catch (error: any) {
      console.error(`Error fetching safesOrderedForRedemption: ${error.message}`);
      safesOrderedForRedemption = '';
    }

    let symbol: string;
    try {
      symbol = await contract.symbol();
    } catch (error: any) {
      console.error(`Error fetching symbol: ${error.message}`);
      symbol = '';
    }

    let totalCollateral: bigint;
    try {
      totalCollateral = BigInt(await contract.totalCollateral());
    } catch (error: any) {
      console.error(`Error fetching totalCollateral: ${error.message}`);
      totalCollateral = BigInt(0);
    }

    let totalDebt: bigint;
    try {
      totalDebt = BigInt(await contract.totalDebt());
    } catch (error: any) {
      console.error(`Error fetching totalDebt: ${error.message}`);
      totalDebt = BigInt(0);
    }


    return {
      safes,
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      liquidationSnapshots,
      mode,
      name,
      dfireTokenStaking,
      safesOrderedForLiquidation,
      safesOrderedForRedemption,
      symbol,
      totalCollateral,
      totalDebt,
      balanceOf,
      getApproved,
      isApprovedForAll,
      ownerOf,
      tokenURI,
      getInactiveDebtAndCollateral,
    };
  } catch (error: any) {
    console.error(`Error taking StableBaseCDP snapshot: ${error.message}`);
    throw error;
  }
}
