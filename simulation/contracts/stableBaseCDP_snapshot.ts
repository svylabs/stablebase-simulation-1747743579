// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the StableBaseCDPSnapshot interface
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  const balances: { [accountAddress: string]: bigint } = {};
  const approvals: { [safeId: bigint]: string } = {};
  const inactiveDebtAndCollateral: { [safeId: bigint]: [bigint, bigint] } = {};
  const approvalForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
  const owners: { [safeId: bigint]: string } = {};
  const safes: { [safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
  const tokenURIs: { [safeId: bigint]: string } = {};
  const liquidationSnapshots: { [safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

  try {
    // Fetch constant state variables
    const [collateralLoss, cumulativeCollateralPerUnitCollateral, cumulativeDebtPerUnitCollateral, debtLoss, mode, name, sbrStakingPoolCanReceiveRewards, stabilityPoolCanReceiveRewards, symbol, totalCollateral, totalDebt] = await Promise.all([
      contract.collateralLoss().then(BigInt),
      contract.cumulativeCollateralPerUnitCollateral().then(BigInt),
      contract.cumulativeDebtPerUnitCollateral().then(BigInt),
      contract.debtLoss().then(BigInt),
      contract.mode().then(Number),
      contract.name(),
      contract.sbrStakingPoolCanReceiveRewards(),
      contract.stabilityPoolCanReceiveRewards(),
      contract.symbol(),
      contract.totalCollateral().then(BigInt),
      contract.totalDebt().then(BigInt),
    ]);

    // Iterate over actors and fetch actor-specific data
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      try {
        balances[accountAddress] = BigInt(await contract.balanceOf(accountAddress));
      } catch (e: any) {
        console.error(`Error fetching Balance for ${accountAddress}: ${e.message}`);
      }

      // Fetch ApprovalForAll
      try {
        approvalForAll[accountAddress] = {};
        for (const otherActor of actors) {
          const otherAccountAddress = otherActor.accountAddress;
          approvalForAll[accountAddress][otherAccountAddress] = await contract.isApprovedForAll(accountAddress, otherAccountAddress);
        }
      } catch (e: any) {
        console.error(`Error fetching ApprovalForAll for ${accountAddress}: ${e.message}`);
      }

      if (actor.identifiers && actor.identifiers._safeId) {
        const safeIds = Array.isArray(actor.identifiers._safeId) ? actor.identifiers._safeId : [actor.identifiers._safeId];

        for (const safeId of safeIds) {
          const _safeId = BigInt(safeId);

          try {
            const [approval, inactiveDebtAndCollateralData, owner, safe, tokenURI, liquidationSnapshot] = await Promise.all([
              contract.getApproved(_safeId),
              contract.getInactiveDebtAndCollateral(_safeId),
              contract.ownerOf(_safeId),
              contract.safes(_safeId),
              contract.tokenURI(_safeId),
              contract.liquidationSnapshots(_safeId)
            ]);

            approvals[_safeId] = approval;

            inactiveDebtAndCollateral[_safeId] = [BigInt(inactiveDebtAndCollateralData[0]), BigInt(inactiveDebtAndCollateralData[1])];

            owners[_safeId] = owner;

            safes[_safeId] = { collateralAmount: BigInt(safe.collateralAmount), borrowedAmount: BigInt(safe.borrowedAmount), weight: BigInt(safe.weight), totalBorrowedAmount: BigInt(safe.totalBorrowedAmount), feePaid: BigInt(safe.feePaid) };

            tokenURIs[_safeId] = tokenURI;

            liquidationSnapshots[_safeId] = { collateralPerCollateralSnapshot: BigInt(liquidationSnapshot.collateralPerCollateralSnapshot), debtPerCollateralSnapshot: BigInt(liquidationSnapshot.debtPerCollateralSnapshot) };
          } catch (e: any) {
            console.error(`Error fetching data for safeId ${_safeId}: ${e.message}`);
          }
        }
      }
    }

    const snapshot: StableBaseCDPSnapshot = {
      balances,
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      approvals,
      inactiveDebtAndCollateral,
      approvalForAll,
      mode,
      name,
      owners,
      safes,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      symbol,
      tokenURIs,
      totalCollateral,
      totalDebt,
      liquidationSnapshots
    };

    return snapshot;
  } catch (error: any) {
    console.error('Error taking StableBaseCDP snapshot:', error.message);
    throw error;
  }
}