// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPState, StableBaseCDPUserState, Safe } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP contract state.
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects, used to fetch dynamic state based on safeIds
 * @returns Promise resolving to StableBaseCDPState interface
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPState> {
    try {
        const protocolMode = Number(await contract.PROTOCOL_MODE());
        const collateralLoss = BigInt(await contract.collateralLoss());
        const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
        const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
        const debtLoss = BigInt(await contract.debtLoss());
        const mode = Number(await contract.mode());
        const totalCollateral = BigInt(await contract.totalCollateral());
        const totalDebt = BigInt(await contract.totalDebt());
        const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
        const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();

        const liquidationSnapshots: { [safeId: bigint]: { collateralPerCollateralSnapshot: bigint; debtPerCollateralSnapshot: bigint } } = {};
        for (const actor of actors) {
            const _safeId = actor.identifiers._safeId as bigint;
            const snapshot = await contract.liquidationSnapshots(_safeId);
            liquidationSnapshots[_safeId] = {
                collateralPerCollateralSnapshot: BigInt(snapshot.collateralPerCollateralSnapshot),
                debtPerCollateralSnapshot: BigInt(snapshot.debtPerCollateralSnapshot)
            };
        }

        const inactiveDebtAndCollateralAmounts = await Promise.all(
            actors.map(async (actor) => {
                const _safeId = actor.identifiers._safeId as bigint;
                const inactiveAmounts = await contract.getInactiveDebtAndCollateral(_safeId);
                return {
                    inactiveDebt: BigInt(inactiveAmounts.inactiveDebt),
                    inactiveCollateral: BigInt(inactiveAmounts.inactiveCollateral)
                };
            })
        );

        const totalInactiveDebt = inactiveDebtAndCollateralAmounts.reduce((sum, amounts) => sum + amounts.inactiveDebt, BigInt(0));
        const totalInactiveCollateral = inactiveDebtAndCollateralAmounts.reduce((sum, amounts) => sum + amounts.inactiveCollateral, BigInt(0));

        return {
            protocolMode,
            collateralLoss,
            cumulativeCollateralPerUnitCollateral,
            cumulativeDebtPerUnitCollateral,
            debtLoss,
            liquidationSnapshots,
            mode,
            totalCollateral,
            totalDebt,
            sbrStakingPoolCanReceiveRewards,
            stabilityPoolCanReceiveRewards,
            inactiveDebtAndCollateralAmounts: { inactiveDebt: totalInactiveDebt, inactiveCollateral: totalInactiveCollateral }
        };
    } catch (error: any) {
        console.error('Error taking StableBaseCDP contract snapshot:', error);
        throw new Error(`Failed to take StableBaseCDP contract snapshot: ${error.message}`);
    }
}

/**
 * Takes a snapshot of StableBaseCDP user-specific data.
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects, each representing a user
 * @returns Promise resolving to an array of StableBaseCDPUserState interfaces, one for each actor
 */
export async function takestableBaseCDPUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPUserState[]> {
    const userStates: StableBaseCDPUserState[] = [];

    for (const actor of actors) {
        try {
            const accountAddress = actor.accountAddress;
            const _safeId = actor.identifiers._safeId as bigint;

            const safeBalance = BigInt(await contract.balanceOf(accountAddress));
            const approvedAddress = await contract.getApproved(_safeId);
            const isApprovedForAll = await contract.isApprovedForAll(accountAddress, accountAddress); // Assuming operator is also the accountAddress itself
            const safeDetails = await contract.safes(_safeId) as any as Safe; // Type assertion to Safe
            const safeOwner = await contract.ownerOf(_safeId);

            const userState: StableBaseCDPUserState = {
                safeBalance,
                approvedAddress,
                isApprovedForAll,
                safeDetails: {
                    collateralAmount: BigInt(safeDetails.collateralAmount),
                    borrowedAmount: BigInt(safeDetails.borrowedAmount),
                    weight: BigInt(safeDetails.weight),
                    totalBorrowedAmount: BigInt(safeDetails.totalBorrowedAmount),
                    feePaid: BigInt(safeDetails.feePaid)
                },
                safeOwner
            };

            userStates.push(userState);
        } catch (error: any) {
            console.error(`Error taking StableBaseCDP user snapshot for account ${actor.accountAddress}:`, error);
            throw new Error(`Failed to take StableBaseCDP user snapshot for account ${actor.accountAddress}: ${error.message}`);
        }
    }

    return userStates;
}
