// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  try {
    const balances: { [accountAddress: string]: bigint } = {};
    const approvals: { [_safeId: bigint]: string } = {};
    const inactiveDebtAndCollateral: { [_safeId: bigint]: [bigint, bigint] } = {};
    const approvalForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
    const owners: { [_safeId: bigint]: string } = {};
    const safes: { [_safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
    const tokenURIs: { [_safeId: bigint]: string } = {};
    const liquidationSnapshots: { [_safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

    // Fetch all account addresses from actors
    const accountAddresses = actors.map(actor => actor.accountAddress);
    // Collect _safeIds from actors
    const safeIds: bigint[] = [];
    actors.forEach(actor => {
      if (actor.identifiers && actor.identifiers['_safeId']) {
        const safeId = actor.identifiers['_safeId'];
        if (Array.isArray(safeId)) {
          safeIds.push(...safeId.map(id => BigInt(id)));
        } else {
          safeIds.push(BigInt(safeId));
        }
      }
    });

    // Fetch balances for all account addresses
    for (const accountAddress of accountAddresses) {
      try {
        const balance = await contract.balanceOf(accountAddress);
        balances[accountAddress] = BigInt(balance);
      } catch (error: any) {
        console.error(`Error fetching balance for ${accountAddress}: ${error.message}`);
      }
    }

    // Fetch approvals for all _safeIds
    for (const safeId of safeIds) {
      try {
        const approval = await contract.getApproved(safeId);
        approvals[safeId] = approval;
      } catch (error: any) {
        console.error(`Error fetching approval for safeId ${safeId}: ${error.message}`);
      }
    }

    // Fetch inactiveDebtAndCollateral for all _safeIds
    for (const safeId of safeIds) {
      try {
        const inactive = await contract.getInactiveDebtAndCollateral(safeId);
        inactiveDebtAndCollateral[safeId] = [BigInt(inactive[0]), BigInt(inactive[1])];
      } catch (error: any) {
        console.error(`Error fetching inactiveDebtAndCollateral for safeId ${safeId}: ${error.message}`);
      }
    }

    // Fetch approvalForAll for all combinations of account addresses
    for (const owner of accountAddresses) {
      approvalForAll[owner] = {};
      for (const operator of accountAddresses) {
        try {
          const isApproved = await contract.isApprovedForAll(owner, operator);
          approvalForAll[owner][operator] = isApproved;
        } catch (error: any) {
          console.error(`Error fetching approvalForAll for owner ${owner} and operator ${operator}: ${error.message}`);
          approvalForAll[owner][operator] = false; // Default to false in case of error
        }
      }
    }

    // Fetch owners for all _safeIds
    for (const safeId of safeIds) {
      try {
        const owner = await contract.ownerOf(safeId);
        owners[safeId] = owner;
      } catch (error: any) {
        console.error(`Error fetching owner for safeId ${safeId}: ${error.message}`);
      }
    }

    // Fetch safes for all _safeIds
    for (const safeId of safeIds) {
      try {
        const safe = await contract.safes(safeId);
        safes[safeId] = { 
          collateralAmount: BigInt(safe.collateralAmount), 
          borrowedAmount: BigInt(safe.borrowedAmount), 
          weight: BigInt(safe.weight), 
          totalBorrowedAmount: BigInt(safe.totalBorrowedAmount), 
          feePaid: BigInt(safe.feePaid) 
        };
      } catch (error: any) {
        console.error(`Error fetching safe for safeId ${safeId}: ${error.message}`);
      }
    }

    // Fetch tokenURIs for all _safeIds
    for (const safeId of safeIds) {
      try {
        const tokenURI = await contract.tokenURI(safeId);
        tokenURIs[safeId] = tokenURI;
      } catch (error: any) {
        console.error(`Error fetching tokenURI for safeId ${safeId}: ${error.message}`);
      }
    }

     // Fetch liquidationSnapshots for all _safeIds
     for (const safeId of safeIds) {
        try {
          const snapshot = await contract.liquidationSnapshots(safeId);
          liquidationSnapshots[safeId] = { 
            collateralPerCollateralSnapshot: BigInt(snapshot.collateralPerCollateralSnapshot), 
            debtPerCollateralSnapshot: BigInt(snapshot.debtPerCollateralSnapshot) 
          };
        } catch (error: any) {
          console.error(`Error fetching liquidation snapshot for safeId ${safeId}: ${error.message}`);
        }
      }

    // Fetch single value contract attributes
    const [collateralLoss, cumulativeCollateralPerUnitCollateral, cumulativeDebtPerUnitCollateral, debtLoss, mode, name, sbrStakingPoolCanReceiveRewards, stabilityPoolCanReceiveRewards, symbol, totalCollateral, totalDebt] = await Promise.all([
      contract.collateralLoss(),
      contract.cumulativeCollateralPerUnitCollateral(),
      contract.cumulativeDebtPerUnitCollateral(),
      contract.debtLoss(),
      contract.mode(),
      contract.name(),
      contract.sbrStakingPoolCanReceiveRewards(),
      contract.stabilityPoolCanReceiveRewards(),
      contract.symbol(),
      contract.totalCollateral(),
      contract.totalDebt()
    ]);

    const snapshot: StableBaseCDPSnapshot = {
      balances,
      collateralLoss: BigInt(collateralLoss),
      cumulativeCollateralPerUnitCollateral: BigInt(cumulativeCollateralPerUnitCollateral),
      cumulativeDebtPerUnitCollateral: BigInt(cumulativeDebtPerUnitCollateral),
      debtLoss: BigInt(debtLoss),
      approvals,
      inactiveDebtAndCollateral,
      approvalForAll,
      mode: Number(mode),
      name,
      owners,
      safes,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      symbol,
      tokenURIs,
      totalCollateral: BigInt(totalCollateral),
      totalDebt: BigInt(totalDebt),
      liquidationSnapshots
    };

    return snapshot;
  } catch (error: any) {
    console.error(`Error taking StableBaseCDP snapshot: ${error.message}`);
    throw error;
  }
}
