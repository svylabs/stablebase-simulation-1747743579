// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances containing safeIds
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
    try {
        const totalCollateral = BigInt(await contract.totalCollateral());
        const totalDebt = BigInt(await contract.totalDebt());
        const name = await contract.name();
        const symbol = await contract.symbol();
        const collateralLoss = BigInt(await contract.collateralLoss());
        const debtLoss = BigInt(await contract.debtLoss());
        const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
        const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());

        const safes: { [safeId: number]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
        const tokenURI: { [tokenId: number]: string } = {};
        const inactiveDebt: { [safeId: number]: bigint } = {};
        const inactiveCollateral: { [safeId: number]: bigint } = {};
        const collateralPerCollateralSnapshot: { [safeId: number]: bigint } = {};
        const debtPerCollateralSnapshot: { [safeId: number]: bigint } = {};

        for (const actor of actors) {
            const identifiers = actor.getIdentifiers();
            if (identifiers._safeId) {
                let safeIds: number[] = [];

                if (Array.isArray(identifiers._safeId)) {
                    safeIds = identifiers._safeId as number[];
                } else {
                    safeIds = [identifiers._safeId as number];
                }

                for (const safeId of safeIds) {
                    const safe = await contract.safes(safeId);
                    safes[safeId] = {
                        collateralAmount: BigInt(safe.collateralAmount),
                        borrowedAmount: BigInt(safe.borrowedAmount),
                        weight: BigInt(safe.weight),
                        totalBorrowedAmount: BigInt(safe.totalBorrowedAmount),
                        feePaid: BigInt(safe.feePaid)
                    };

                    const inactiveDebtAndCollateral = await contract.getInactiveDebtAndCollateral(safeId);
                    inactiveDebt[safeId] = BigInt(inactiveDebtAndCollateral[0]);
                    inactiveCollateral[safeId] = BigInt(inactiveDebtAndCollateral[1]);

                    const liquidationSnapshot = await contract.liquidationSnapshots(safeId);
                    collateralPerCollateralSnapshot[safeId] = BigInt(liquidationSnapshot[0]);
                    debtPerCollateralSnapshot[safeId] = BigInt(liquidationSnapshot[1]);
                }
            }
        }

        // Assuming tokenId is available in the identifiers or actor data if needed
        // Example (if each actor also has a tokenId):
        for (const actor of actors) {
            const identifiers = actor.getIdentifiers();
            if (identifiers.tokenId) {
                  let tokenIds: number[] = [];

                if (Array.isArray(identifiers.tokenId)) {
                    tokenIds = identifiers.tokenId as number[];
                } else {
                    tokenIds = [identifiers.tokenId as number];
                }

                 for (const tokenId of tokenIds) {
                     tokenURI[tokenId] = await contract.tokenURI(tokenId);
                 }
            }
        }

        const snapshot: StableBaseCDPSnapshot = {
            totalCollateral,
            totalDebt,
            safes,
            name,
            symbol,
            collateralLoss,
            debtLoss,
            tokenURI,
            cumulativeCollateralPerUnitCollateral,
            cumulativeDebtPerUnitCollateral,
            inactiveDebt,
            inactiveCollateral,
            collateralPerCollateralSnapshot,
            debtPerCollateralSnapshot
        };

        return snapshot;
    } catch (error) {
        console.error('Error taking StableBaseCDP snapshot:', error);
        throw error; // Re-throw the error to be handled upstream
    }
}