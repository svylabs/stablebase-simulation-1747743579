// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPContractStateSnapshot, StableBaseCDPUserDataSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP contract state
 * @param contract - ethers.Contract instance
 * @returns Promise resolving to StableBaseCDPContractStateSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract): Promise<StableBaseCDPContractStateSnapshot> {
  try {
    const collateralLoss = BigInt(await contract.collateralLoss());
    const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    const debtLoss = BigInt(await contract.debtLoss());
    const protocolMode = await contract.mode();
    const contractName = await contract.name();
    const symbol = await contract.symbol();
    const totalCollateral = BigInt(await contract.totalCollateral());
    const totalDebt = BigInt(await contract.totalDebt());
    const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
    const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();

    // Dummy values to avoid errors, as this is dependent on user input and safe address, and we cannot compute
    // redemptionCalculation or liquidationSnapshots here.
    const liquidationSnapshots = {
      collateralPerCollateralSnapshot: BigInt(0),
      debtPerCollateralSnapshot: BigInt(0),
    };

    const redemptionCalculation = {
      borrowMode: false,
      _collateralToRedeem: BigInt(0),
      _amountToRedeem: BigInt(0),
      _amountToRefund: BigInt(0),
      _ownerFee: BigInt(0),
      _redeemerFee: BigInt(0),
    };

    return {
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      inactiveDebt: BigInt(0),
      inactiveCollateral: BigInt(0),
      protocolMode,
      contractName,
      symbol,
      tokenURI: "",
      totalCollateral,
      totalDebt,
      liquidationSnapshots,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      redemptionCalculation
    };
  } catch (error: any) {
    console.error('Error taking contract snapshot:', error);
    throw new Error(`Failed to take contract snapshot: ${error.message}`);
  }
}

/**
 * Takes a snapshot of StableBaseCDP user-specific data
 * @param contract - ethers.Contract instance
 * @param actors - An array of actors with identifiers for user-specific data.
 * @returns Promise resolving to an array of StableBaseCDPUserDataSnapshot
 */
export async function takestableBaseCDPUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPUserDataSnapshot[]> {
  const userDataSnapshots: StableBaseCDPUserDataSnapshot[] = [];

  for (const actor of actors) {
    try {
      const accountAddress = actor.accountAddress;
      const identifiers = actor.identifiers;

      // Type definition for identifiers
      interface Identifiers {
        _safeId?: string | string[];
      }

      let _safeId: bigint | undefined;

      if (identifiers && identifiers._safeId) {
        const safeIdValue = identifiers._safeId;

        if (Array.isArray(safeIdValue)) {
          // Use the first safeId if it's an array
          _safeId = BigInt(safeIdValue[0]);
        } else {
          _safeId = BigInt(safeIdValue);
        }
      }

      const balance = BigInt(await contract.balanceOf(accountAddress));

      // Dummy values, these require tokenId, operatorAddress which cannot be computed here
      const isApproved = false;
      const tokenOwner = ethers.constants.AddressZero;
      const tokenApproved = ethers.constants.AddressZero;

      userDataSnapshots.push({
        balance,
        isApproved,
        tokenOwner,
        tokenApproved
      });
    } catch (error: any) {
      console.error(`Error taking user snapshot for address ${actor.accountAddress}:`, error);
      // Return an empty snapshot instead of throwing an error
      continue;
    }
  }

  return userDataSnapshots;
}