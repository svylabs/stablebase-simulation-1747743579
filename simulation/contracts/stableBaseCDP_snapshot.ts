// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPStateSnapshot, UserStableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP contract state.
 * @param contract - ethers.Contract instance
 * @returns Promise resolving to StableBaseCDPStateSnapshot.
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract): Promise<StableBaseCDPStateSnapshot> {
    try {
        const protocolMode = await contract.PROTOCOL_MODE();
        const collateralLoss = await contract.collateralLoss();
        const cumulativeCollateralPerUnitCollateral = await contract.cumulativeCollateralPerUnitCollateral();
        const cumulativeDebtPerUnitCollateral = await contract.cumulativeDebtPerUnitCollateral();
        const debtLoss = await contract.debtLoss();
        const mode = await contract.mode();
        const totalCollateral = await contract.totalCollateral();
        const totalDebt = await contract.totalDebt();

        return {
            protocolMode: protocolMode,
            collateralLoss: BigInt(collateralLoss.toString()),
            cumulativeCollateralPerUnitCollateral: BigInt(cumulativeCollateralPerUnitCollateral.toString()),
            cumulativeDebtPerUnitCollateral: BigInt(cumulativeDebtPerUnitCollateral.toString()),
            debtLoss: BigInt(debtLoss.toString()),
            liquidationSnapshots: { collateralPerCollateralSnapshot: BigInt(0), debtPerCollateralSnapshot: BigInt(0) },
            mode: mode,
            totalCollateral: BigInt(totalCollateral.toString()),
            totalDebt: BigInt(totalDebt.toString()),
            safeDetails: { collateralAmount: BigInt(0), borrowedAmount: BigInt(0), weight: BigInt(0), totalBorrowedAmount: BigInt(0), feePaid: BigInt(0) }
        };
    } catch (error: any) {
        console.error('Error taking StableBaseCDP contract snapshot:', error);
        throw new Error(`Failed to take StableBaseCDP contract snapshot: ${error.message}`);
    }
}

/**
 * Takes a snapshot of StableBaseCDP user-specific data.
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects, each representing a user.
 * @returns Promise resolving to an array of UserStableBaseCDPSnapshot.
 */
export async function takestableBaseCDPUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<UserStableBaseCDPSnapshot[]> {
    const userSnapshots: UserStableBaseCDPSnapshot[] = [];

    for (const actor of actors) {
        try {
            const accountAddress = actor.accountAddress;

            let _safeId: any = null;
            if (actor.identifiers && actor.identifiers['_safeId']) {
                _safeId = actor.identifiers['_safeId'];
            }

            let safeBalance: bigint;
            try {
                safeBalance = BigInt((await contract.balanceOf(accountAddress)).toString());
            } catch (error: any) {
                console.error(`Error getting safeBalance for ${accountAddress}:`, error);
                safeBalance = BigInt(0);
            }

            let safeApproval: string = '0x0000000000000000000000000000000000000000';
            if (_safeId != null) {
                try {
                    safeApproval = await contract.getApproved(_safeId);
                } catch (error: any) {
                    console.error(`Error getting safeApproval for safeId ${_safeId} and account ${accountAddress}:`, error);
                    safeApproval = '0x0000000000000000000000000000000000000000';
                }
            }

            let isApprovedForAll: boolean;
            try {
                isApprovedForAll = await contract.isApprovedForAll(accountAddress, accountAddress);
            } catch (error: any) {
                console.error(`Error getting isApprovedForAll for ${accountAddress}:`, error);
                isApprovedForAll = false;
            }

            let safeOwner: string = '0x0000000000000000000000000000000000000000';
            if (_safeId != null) {
                try {
                    safeOwner = await contract.ownerOf(_safeId);
                } catch (error: any) {
                    console.error(`Error getting safeOwner for safeId ${_safeId} and account ${accountAddress}:`, error);
                    safeOwner = '0x0000000000000000000000000000000000000000';
                }
            }

            const userSnapshot: UserStableBaseCDPSnapshot = {
                safeBalance: safeBalance,
                safeApproval: safeApproval,
                isApprovedForAll: isApprovedForAll,
                safeOwner: safeOwner,
            };

            userSnapshots.push(userSnapshot);
        } catch (error: any) {
            console.error(`Error taking StableBaseCDP user snapshot for address ${actor.accountAddress}:`, error);
            throw new Error(`Failed to take StableBaseCDP user snapshot for address ${actor.accountAddress}: ${error.message}`);
        }
    }

    return userSnapshots;
}