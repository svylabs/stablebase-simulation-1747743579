// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances containing identifiers.
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
    try {
        const balances: { [accountAddress: string]: bigint } = {};
        const approvals: { [_safeId: bigint]: string } = {};
        const inactiveDebtAndCollateral: { [_safeId: bigint]: [bigint, bigint] } = {};
        const approvalForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
        const owners: { [_safeId: bigint]: string } = {};
        const safes: { [_safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
        const tokenURIs: { [_safeId: bigint]: string } = {};
        const liquidationSnapshots: { [_safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

        // Fetch global contract state
        const collateralLoss = BigInt(await contract.collateralLoss());
        const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
        const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
        const debtLoss = BigInt(await contract.debtLoss());
        const mode = Number(await contract.mode());
        const name = await contract.name();
        const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
        const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();
        const symbol = await contract.symbol();
        const totalCollateral = BigInt(await contract.totalCollateral());
        const totalDebt = BigInt(await contract.totalDebt());

        // Iterate over actors to fetch user-specific and safe-specific data
        for (const actor of actors) {
            const accountAddress = actor.accountAddress;

            // Fetch Balance
            balances[accountAddress] = BigInt(await contract.balanceOf(accountAddress));

            // Fetch Approval For All (only once per owner-operator pair)
            for (const otherActor of actors) {
                const operatorAddress = otherActor.accountAddress;
                if (!approvalForAll[accountAddress]) {
                    approvalForAll[accountAddress] = {};
                }
                if (approvalForAll[accountAddress][operatorAddress] === undefined) {
                    approvalForAll[accountAddress][operatorAddress] = await contract.isApprovedForAll(accountAddress, operatorAddress);
                }
            }

            if (actor.identifiers['_safeId']) {
                let safeIds = actor.identifiers['_safeId'];

                if (!Array.isArray(safeIds)) {
                    safeIds = [safeIds];
                }

                if (safeIds) {
                    for (const safeId of safeIds) {
                        const _safeId = BigInt(safeId);
                        // Fetch Approval
                        approvals[_safeId] = await contract.getApproved(_safeId);

                        // Fetch Inactive Debt and Collateral
                        const inactiveDebtAndCollateralResult = await contract.getInactiveDebtAndCollateral(_safeId);
                        inactiveDebtAndCollateral[_safeId] = [BigInt(inactiveDebtAndCollateralResult[0]), BigInt(inactiveDebtAndCollateralResult[1])];

                        // Fetch Owner
                        owners[_safeId] = await contract.ownerOf(_safeId);

                        // Fetch Safe
                        const safeData = await contract.safes(_safeId);
                        safes[_safeId] = {
                            collateralAmount: BigInt(safeData.collateralAmount),
                            borrowedAmount: BigInt(safeData.borrowedAmount),
                            weight: BigInt(safeData.weight),
                            totalBorrowedAmount: BigInt(safeData.totalBorrowedAmount),
                            feePaid: BigInt(safeData.feePaid)
                        };

                        // Fetch Token URI
                        tokenURIs[_safeId] = await contract.tokenURI(_safeId);

                         // Fetch Liquidation Snapshots
                        const liquidationSnapshot = await contract.liquidationSnapshots(_safeId);
                        liquidationSnapshots[_safeId] = {
                            collateralPerCollateralSnapshot: BigInt(liquidationSnapshot.collateralPerCollateralSnapshot),
                            debtPerCollateralSnapshot: BigInt(liquidationSnapshot.debtPerCollateralSnapshot)
                        };
                    }
                }
            }
        }

        const snapshot: StableBaseCDPSnapshot = {
            balances,
            collateralLoss,
            cumulativeCollateralPerUnitCollateral,
            cumulativeDebtPerUnitCollateral,
            debtLoss,
            approvals,
            inactiveDebtAndCollateral,
            approvalForAll,
            mode,
            name,
            owners,
            safes,
            sbrStakingPoolCanReceiveRewards,
            stabilityPoolCanReceiveRewards,
            symbol,
            tokenURIs,
            totalCollateral,
            totalDebt,
            liquidationSnapshots
        };

        return snapshot;
    } catch (error: any) {
        console.error('Error taking StableBaseCDP snapshot:', error);
        throw new Error(`Failed to take StableBaseCDP snapshot: ${error.message} - Contract error: ${error?.reason || error}`);
    }
}
