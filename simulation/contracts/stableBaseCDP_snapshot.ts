// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  try {
    const balances: { [accountAddress: string]: bigint } = {};
    const approvals: { [_safeId: bigint]: string } = {};
    const inactiveDebtAndCollateral: { [_safeId: bigint]: [bigint, bigint] } = {};
    const approvalForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
    const owners: { [_safeId: bigint]: string } = {};
    const safes: { [_safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
    const tokenURIs: { [_safeId: bigint]: string } = {};
    const liquidationSnapshots: { [_safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

    // Fetch all _safeId values from actors
    const safeIds: bigint[] = [];
    const accountAddresses: string[] = [];

    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();

      // Handle _safeId
      if (identifiers['_safeId']) {
        const safeIdValues = Array.isArray(identifiers['_safeId']) ? identifiers['_safeId'] : [identifiers['_safeId']];
        safeIdValues.forEach((safeId: string | number | bigint) => {
          const safeIdBigInt = BigInt(safeId);
          if (!safeIds.includes(safeIdBigInt)) {
            safeIds.push(safeIdBigInt);
          }
        });
      }

      // Handle accountAddress
      if (identifiers['accountAddress']) {
          const address = identifiers['accountAddress'] as string;
          if (!accountAddresses.includes(address)) {
              accountAddresses.push(address);
          }
      }
    }


    // Fetch balances for all account addresses
    for (const accountAddress of accountAddresses) {
      try {
        const balance = await contract.balanceOf(accountAddress);
        balances[accountAddress] = BigInt(balance.toString());
      } catch (error: any) {
        console.error(`Error fetching Balance for ${accountAddress}: ${error.message}`);
      }
    }

    // Fetch approvals for all _safeIds
    for (const _safeId of safeIds) {
      try {
        const approvedAddress = await contract.getApproved(_safeId);
        approvals[_safeId] = approvedAddress;
      } catch (error: any) {
        console.error(`Error fetching Approval for ${_safeId}: ${error.message}`);
      }

      try {
        const inactiveDebtAndCollateralData = await contract.getInactiveDebtAndCollateral(_safeId);
        inactiveDebtAndCollateral[_safeId] = [BigInt(inactiveDebtAndCollateralData[0].toString()), BigInt(inactiveDebtAndCollateralData[1].toString())];
      } catch (error: any) {
        console.error(`Error fetching InactiveDebtAndCollateral for ${_safeId}: ${error.message}`);
      }

      try {
        const owner = await contract.ownerOf(_safeId);
        owners[_safeId] = owner;
      } catch (error: any) {
        console.error(`Error fetching Owner for ${_safeId}: ${error.message}`);
      }

      try {
        const safeData = await contract.safes(_safeId);
        safes[_safeId] = { collateralAmount: BigInt(safeData.collateralAmount.toString()), borrowedAmount: BigInt(safeData.borrowedAmount.toString()), weight: BigInt(safeData.weight.toString()), totalBorrowedAmount: BigInt(safeData.totalBorrowedAmount.toString()), feePaid: BigInt(safeData.feePaid.toString()) };
      } catch (error: any) {
        console.error(`Error fetching Safe for ${_safeId}: ${error.message}`);
      }

      try {
        const tokenURI = await contract.tokenURI(_safeId);
        tokenURIs[_safeId] = tokenURI;
      } catch (error: any) {
        console.error(`Error fetching TokenURI for ${_safeId}: ${error.message}`);
      }
      try {
        const liquidationSnapshot = await contract.liquidationSnapshots(_safeId);
        liquidationSnapshots[_safeId] = { collateralPerCollateralSnapshot: BigInt(liquidationSnapshot.collateralPerCollateralSnapshot.toString()), debtPerCollateralSnapshot: BigInt(liquidationSnapshot.debtPerCollateralSnapshot.toString()) };
      } catch (error: any) {
          console.error(`Error fetching LiquidationSnapshots for ${_safeId}: ${error.message}`);
      }
    }

    // Fetch approvalForAll for all account address pairs
    for (const ownerAddress of accountAddresses) {
        approvalForAll[ownerAddress] = {};
        for (const operatorAddress of accountAddresses) {
            try {
                const isApproved = await contract.isApprovedForAll(ownerAddress, operatorAddress);
                approvalForAll[ownerAddress][operatorAddress] = isApproved;
            } catch (error: any) {
                console.error(`Error fetching ApprovalForAll for owner ${ownerAddress} and operator ${operatorAddress}: ${error.message}`);
                approvalForAll[ownerAddress][operatorAddress] = false; // Default to false in case of error
            }
        }
    }

    let collateralLoss: bigint;
    try {
      const collateralLossResult = await contract.collateralLoss();
      collateralLoss = BigInt(collateralLossResult.toString());
    } catch (error: any) {
      console.error(`Error fetching CollateralLoss: ${error.message}`);
      collateralLoss = BigInt(0);
    }

    let cumulativeCollateralPerUnitCollateral: bigint;
    try {
      const cumulativeCollateralPerUnitCollateralResult = await contract.cumulativeCollateralPerUnitCollateral();
      cumulativeCollateralPerUnitCollateral = BigInt(cumulativeCollateralPerUnitCollateralResult.toString());
    } catch (error: any) {
      console.error(`Error fetching CumulativeCollateralPerUnitCollateral: ${error.message}`);
      cumulativeCollateralPerUnitCollateral = BigInt(0);
    }

    let cumulativeDebtPerUnitCollateral: bigint;
    try {
      const cumulativeDebtPerUnitCollateralResult = await contract.cumulativeDebtPerUnitCollateral();
      cumulativeDebtPerUnitCollateral = BigInt(cumulativeDebtPerUnitCollateralResult.toString());
    } catch (error: any) {
      console.error(`Error fetching CumulativeDebtPerUnitCollateral: ${error.message}`);
      cumulativeDebtPerUnitCollateral = BigInt(0);
    }

    let debtLoss: bigint;
    try {
      const debtLossResult = await contract.debtLoss();
      debtLoss = BigInt(debtLossResult.toString());
    } catch (error: any) {
      console.error(`Error fetching DebtLoss: ${error.message}`);
      debtLoss = BigInt(0);
    }

    let mode: number;
    try {
      const modeResult = await contract.mode();
      mode = Number(modeResult);
    } catch (error: any) {
      console.error(`Error fetching Mode: ${error.message}`);
      mode = 0;
    }

    let name: string;
    try {
      name = await contract.name();
    } catch (error: any) {
      console.error(`Error fetching Name: ${error.message}`);
      name = '';
    }

    let sbrStakingPoolCanReceiveRewards: boolean;
    try {
      sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
    } catch (error: any) {
      console.error(`Error fetching SBRStakingPoolCanReceiveRewards: ${error.message}`);
      sbrStakingPoolCanReceiveRewards = false;
    }

    let stabilityPoolCanReceiveRewards: boolean;
    try {
      stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();
    } catch (error: any) {
      console.error(`Error fetching StabilityPoolCanReceiveRewards: ${error.message}`);
      stabilityPoolCanReceiveRewards = false;
    }

    let symbol: string;
    try {
      symbol = await contract.symbol();
    } catch (error: any) {
      console.error(`Error fetching Symbol: ${error.message}`);
      symbol = '';
    }

    let totalCollateral: bigint;
    try {
      const totalCollateralResult = await contract.totalCollateral();
      totalCollateral = BigInt(totalCollateralResult.toString());
    } catch (error: any) {
      console.error(`Error fetching TotalCollateral: ${error.message}`);
      totalCollateral = BigInt(0);
    }

    let totalDebt: bigint;
    try {
      const totalDebtResult = await contract.totalDebt();
      totalDebt = BigInt(totalDebtResult.toString());
    } catch (error: any) {
      console.error(`Error fetching TotalDebt: ${error.message}`);
      totalDebt = BigInt(0);
    }

    return {
      balances,
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      approvals,
      inactiveDebtAndCollateral,
      approvalForAll,
      mode,
      name,
      owners,
      safes,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      symbol,
      tokenURIs,
      totalCollateral,
      totalDebt,
      liquidationSnapshots
    };
  } catch (error: any) {
    console.error(`Error taking StableBaseCDP snapshot: ${error.message}`);
    throw error;
  }
}