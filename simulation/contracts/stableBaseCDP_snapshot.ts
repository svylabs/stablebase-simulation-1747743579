// Generated by SnapshotCodeGenerator

import { ethers, BigNumber } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - List of actors to fetch user-specific data
 * @returns Promise returning the StableBaseCDPSnapshot interface
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  const balances: { [accountAddress: string]: bigint } = {};
  const approvals: { [_safeId: bigint]: string } = {};
  const inactiveDebtAndCollateral: { [_safeId: bigint]: [bigint, bigint] } = {};
  const approvalForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
  const owners: { [_safeId: bigint]: string } = {};
  const safes: { [_safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
  const tokenURIs: { [_safeId: bigint]: string } = {};
  const liquidationSnapshots: { [_safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

  try {
    // Fetch simple state variables
    const collateralLoss = BigInt(await contract.collateralLoss());
    const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    const debtLoss = BigInt(await contract.debtLoss());
    const mode = Number(await contract.mode());
    const name = await contract.name();
    const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
    const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();
    const symbol = await contract.symbol();
    const totalCollateral = BigInt(await contract.totalCollateral());
    const totalDebt = BigInt(await contract.totalDebt());

    // Iterate over actors to fetch user-specific data
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;
      balances[accountAddress] = BigInt(await contract.balanceOf(accountAddress));

      if (actor.identifiers) {
        if (actor.identifiers._safeId) {
          let safeIds: any[] = [];
          if (Array.isArray(actor.identifiers._safeId)) {
            safeIds = actor.identifiers._safeId;
          } else if (actor.identifiers._safeId !== null && actor.identifiers._safeId !== undefined) {
            safeIds = [actor.identifiers._safeId];
          }

          for (const safeId of safeIds) {
            if (safeId === null || safeId === undefined) {
              continue;
            }
            const _safeId = BigInt(safeId);
            approvals[_safeId] = await contract.getApproved(_safeId);

            const inactiveDebtAndCollateralResult = await contract.getInactiveDebtAndCollateral(_safeId);
            inactiveDebtAndCollateral[_safeId] = [BigInt(inactiveDebtAndCollateralResult[0]), BigInt(inactiveDebtAndCollateralResult[1])];

            owners[_safeId] = await contract.ownerOf(_safeId);

            const safeData = await contract.safes(_safeId);
            safes[_safeId] = {
              collateralAmount: BigInt(safeData.collateralAmount),
              borrowedAmount: BigInt(safeData.borrowedAmount),
              weight: BigInt(safeData.weight),
              totalBorrowedAmount: BigInt(safeData.totalBorrowedAmount),
              feePaid: BigInt(safeData.feePaid)
            };

            tokenURIs[_safeId] = await contract.tokenURI(_safeId);

            const liquidationSnapshotData = await contract.liquidationSnapshots(_safeId);
            liquidationSnapshots[_safeId] = {
              collateralPerCollateralSnapshot: BigInt(liquidationSnapshotData.collateralPerCollateralSnapshot),
              debtPerCollateralSnapshot: BigInt(liquidationSnapshotData.debtPerCollateralSnapshot)
            };
          }
        }

        // Fetch ApprovalForAll.  Needs to iterate over all actors as both owner and operator.
        for (const operatorActor of actors) {
          if (!approvalForAll[accountAddress]) {
            approvalForAll[accountAddress] = {};
          }
          approvalForAll[accountAddress][operatorActor.accountAddress] = await contract.isApprovedForAll(accountAddress, operatorActor.accountAddress);
        }
      }
    }

    return {
      balances,
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      approvals,
      inactiveDebtAndCollateral,
      approvalForAll,
      mode,
      name,
      owners,
      safes,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      symbol,
      tokenURIs,
      totalCollateral,
      totalDebt,
      liquidationSnapshots
    };
  } catch (error: any) {
    console.error('Error in takestableBaseCDPContractSnapshot:', error);
    throw new Error(`Failed to snapshot StableBaseCDP contract state: ${error.message}`);
  }
}
