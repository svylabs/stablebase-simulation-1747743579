// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot, Safe, RedemptionCalculationOutput } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - List of actors to fetch user specific data
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  try {
    const collateralLoss = BigInt(await contract.collateralLoss());
    const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    const debtLoss = BigInt(await contract.debtLoss());
    const mode = Number(await contract.mode());
    const name = await contract.name();
    const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
    const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();
    const symbol = await contract.symbol();
    const totalCollateral = BigInt(await contract.totalCollateral());
    const totalDebt = BigInt(await contract.totalDebt());

    const approvedAddress: { [tokenId: bigint]: string } = {};
    const inactiveDebtAndCollateral: { [safeId: bigint]: [bigint, bigint] } = {};
    const isApprovedForAll: { [owner: string]: { [operator: string]: boolean } } = {};
    const liquidationSnapshots: { [safeId: bigint]: bigint[] } = {};
    const ownerOf: { [tokenId: bigint]: string } = {};
    const safes: { [safeId: bigint]: Safe } = {};
    const tokenURI: { [tokenId: bigint]: string } = {};
    const supportsInterfaceValues: boolean[] = [];
    const redemptionCalculationOutputs: { [redemptionId: string]: RedemptionCalculationOutput } = {};

    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();

      // Handle tokenId for approvedAddress, ownerOf, and tokenURI
      if (identifiers['_safeId']) {
        const safeId = BigInt(identifiers['_safeId'] as string);
        try {
          const inactiveDebtAndCollateralValues = await contract.getInactiveDebtAndCollateral(safeId);
          inactiveDebtAndCollateral[safeId] = [BigInt(inactiveDebtAndCollateralValues[0]), BigInt(inactiveDebtAndCollateralValues[1])];
        } catch (e: any) {
          console.error(`Error fetching inactiveDebtAndCollateral for safeId ${safeId}:`, e.message);
        }

        try {
          const liquidationSnapshotsValues = await contract.liquidationSnapshots(safeId);
          liquidationSnapshots[safeId] = liquidationSnapshotsValues.map((value: any) => BigInt(value));
        } catch (e: any) {
          console.error(`Error fetching liquidationSnapshots for safeId ${safeId}:`, e.message);
        }

        try {
          const safe = await contract.safes(safeId);
          safes[safeId] = {
            collateralAmount: BigInt(safe.collateralAmount),
            borrowedAmount: BigInt(safe.borrowedAmount),
            weight: BigInt(safe.weight),
            totalBorrowedAmount: BigInt(safe.totalBorrowedAmount),
            feePaid: BigInt(safe.feePaid),
          };
        } catch (e: any) {
          console.error(`Error fetching safes for safeId ${safeId}:`, e.message);
        }

      }
      if (identifiers['tokenId']) {
        const tokenId = BigInt(identifiers['tokenId'] as string);
        try {
          approvedAddress[tokenId] = await contract.getApproved(tokenId);
        } catch (e: any) {
          console.error(`Error fetching approvedAddress for tokenId ${tokenId}:`, e.message);
        }

        try {
          ownerOf[tokenId] = await contract.ownerOf(tokenId);
        } catch (e: any) {
          console.error(`Error fetching ownerOf for tokenId ${tokenId}:`, e.message);
        }

        try {
          tokenURI[tokenId] = await contract.tokenURI(tokenId);
        } catch (e: any) {
          console.error(`Error fetching tokenURI for tokenId ${tokenId}:`, e.message);
        }
      }

      if (identifiers['accountAddress']) {
        const accountAddress = identifiers['accountAddress'] as string;
          try {
            const isApproved = await contract.isApprovedForAll(accountAddress, accountAddress);
            if (!isApprovedForAll[accountAddress]) {
              isApprovedForAll[accountAddress] = {};
            }
            isApprovedForAll[accountAddress][accountAddress] = isApproved;
          } catch (e: any) {
            console.error(`Error fetching isApprovedForAll for owner ${accountAddress} and operator ${accountAddress}:`, e.message);
          }
      }
      if (identifiers['interfaceId']) {
          const interfaceId = identifiers['interfaceId'] as string;
          try {
            const supportsInterface = await contract.supportsInterface(interfaceId);
            supportsInterfaceValues.push(supportsInterface)
          } catch (e: any) {
            console.error(`Error fetching supportsInterface for interfaceId ${interfaceId}:`, e.message);
          }
        }

        if (identifiers['redemptionId'] && identifiers['_safeId']) {
            const redemptionId = identifiers['redemptionId'] as string;
            const safe = safes[BigInt(identifiers['_safeId'] as string)]

            // Dummy values, implement if needed
            redemptionCalculationOutputs[redemptionId] = {
                borrowMode: false,
                _collateralToRedeem: BigInt(0),
                _amountToRedeem: BigInt(0),
                _amountToRefund: BigInt(0),
                _ownerFee: BigInt(0),
                _redeemerFee: BigInt(0),
            };
            try {
                // Assuming calculateRedemptionAmountsAndFee takes a Safe object
                // and other parameters.
                //Adapt this part based on the exact contract function signature

                const collateralPrice = BigInt(1) // DUMMY VALUE NEEDS TO BE REPLACED
                const amountToRedeem = BigInt(1); // DUMMY VALUE NEEDS TO BE REPLACED

                if(safe){
                    const redemptionCalculation = await contract.calculateRedemptionAmountsAndFee(
                        safe,
                        amountToRedeem,
                        collateralPrice
                    );

                    redemptionCalculationOutputs[redemptionId] = {
                        borrowMode: redemptionCalculation.borrowMode,
                        _collateralToRedeem: BigInt(redemptionCalculation._collateralToRedeem),
                        _amountToRedeem: BigInt(redemptionCalculation._amountToRedeem),
                        _amountToRefund: BigInt(redemptionCalculation._amountToRefund),
                        _ownerFee: BigInt(redemptionCalculation._ownerFee),
                        _redeemerFee: BigInt(redemptionCalculation._redeemerFee),
                    };

                }


            } catch (e: any) {
                console.error(`Error fetching redemptionCalculation for redemptionId ${redemptionId}:`, e.message);
            }
        }
    }

    return {
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      approvedAddress,
      inactiveDebtAndCollateral,
      isApprovedForAll,
      liquidationSnapshots,
      mode,
      name,
      ownerOf,
      redemptionCalculation: Object.values(redemptionCalculationOutputs).length > 0 ? Object.values(redemptionCalculationOutputs)[0] : {
                borrowMode: false,
                _collateralToRedeem: BigInt(0),
                _amountToRedeem: BigInt(0),
                _amountToRefund: BigInt(0),
                _ownerFee: BigInt(0),
                _redeemerFee: BigInt(0),
            }, // just return the first value, if multiple are present
      safes,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      symbol,
      supportsInterface: supportsInterfaceValues.length > 0 ? supportsInterfaceValues[0] : false, // just return the first value, if multiple are present
      tokenURI,
      totalCollateral,
      totalDebt,
    };
  } catch (error: any) {
    console.error('Error taking StableBaseCDP snapshot:', error.message);
    throw error;
  }
}
