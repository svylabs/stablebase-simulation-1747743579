// Generated by SnapshotCodeGenerator

import { ethers } from "ethers";
import { Actor } from "@svylabs/ilumina";
import { StableBaseCDPSnapshot } from "./snapshot_interfaces";

/**
 * Takes a snapshot of StableBaseCDP contract state.
 * This function fetches various state variables and aggregated data
 * from the StableBaseCDP contract, including global parameters and
 * data specific to each unique account address and safe ID found in the actors list.
 * @param contract - The ethers.Contract instance connected to the StableBaseCDP contract.
 * @param actors - An array of Actor objects, each potentially containing 'accountAddress' and 'safeId' identifiers.
 * @returns A Promise that resolves to a StableBaseCDPSnapshot object representing the contract's state.
 * @throws {Error} If a critical contract call (for a non-record primitive attribute) fails.
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
    const snapshot: StableBaseCDPSnapshot = {
        protocolMode: 0,
        totalCollateralLoss: BigInt(0),
        cumulativeCollateralPerUnitCollateral: BigInt(0),
        cumulativeDebtPerUnitCollateral: BigInt(0),
        totalDebtLoss: BigInt(0),
        currentMode: 0,
        contractName: "",
        sbrStakingPoolRewardsEnabled: false,
        stabilityPoolRewardsEnabled: false,
        contractSymbol: "",
        totalCollateral: BigInt(0),
        totalDebt: BigInt(0),
        balanceOfSafes: {},
        safeApprovedAddress: {},
        inactiveDebtAndCollateral: {},
        isOperatorApprovedForAll: {},
        safeOwner: {},
        safeDetails: {},
        safeTokenURI: {}
    };

    const uniqueAccountAddresses: Set<string> = new Set();
    const uniqueSafeIds: Set<bigint> = new Set();

    // Collect all unique account addresses and safe IDs from actors
    for (const actor of actors) {
        const identifiers = actor.getIdentifiers();

        // Collect accountAddress
        if (identifiers.accountAddress) {
            if (Array.isArray(identifiers.accountAddress)) {
                identifiers.accountAddress.forEach((addr: string) => uniqueAccountAddresses.add(addr));
            } else {
                uniqueAccountAddresses.add(identifiers.accountAddress as string);
            }
        }

        // Collect safeId
        if (identifiers.safeId) {
            if (Array.isArray(identifiers.safeId)) {
                identifiers.safeId.forEach((id: bigint | string) => uniqueSafeIds.add(typeof id === 'string' ? BigInt(id) : id));
            } else {
                uniqueSafeIds.add(typeof identifiers.safeId === 'string' ? BigInt(identifiers.safeId) : identifiers.safeId as bigint);
            }
        }
    }

    const accountAddressesArray = Array.from(uniqueAccountAddresses);
    const safeIdsArray = Array.from(uniqueSafeIds);

    // --- Fetching global contract state attributes ---

    try {
        snapshot.protocolMode = Number(await contract.PROTOCOL_MODE());
    } catch (error) {
        console.error(`Error fetching protocolMode: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch protocolMode: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.totalCollateralLoss = BigInt(await contract.collateralLoss());
    } catch (error) {
        console.error(`Error fetching totalCollateralLoss: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch totalCollateralLoss: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    } catch (error) {
        console.error(`Error fetching cumulativeCollateralPerUnitCollateral: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch cumulativeCollateralPerUnitCollateral: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    } catch (error) {
        console.error(`Error fetching cumulativeDebtPerUnitCollateral: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch cumulativeDebtPerUnitCollateral: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.totalDebtLoss = BigInt(await contract.debtLoss());
    } catch (error) {
        console.error(`Error fetching totalDebtLoss: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch totalDebtLoss: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.currentMode = Number(await contract.mode());
    } catch (error) {
        console.error(`Error fetching currentMode: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch currentMode: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.contractName = String(await contract.name());
    } catch (error) {
        console.error(`Error fetching contractName: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch contractName: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.sbrStakingPoolRewardsEnabled = Boolean(await contract.sbrStakingPoolCanReceiveRewards());
    } catch (error) {
        console.error(`Error fetching sbrStakingPoolRewardsEnabled: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch sbrStakingPoolRewardsEnabled: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.stabilityPoolRewardsEnabled = Boolean(await contract.stabilityPoolCanReceiveRewards());
    } catch (error) {
        console.error(`Error fetching stabilityPoolRewardsEnabled: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch stabilityPoolRewardsEnabled: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.contractSymbol = String(await contract.symbol());
    } catch (error) {
        console.error(`Error fetching contractSymbol: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch contractSymbol: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.totalCollateral = BigInt(await contract.totalCollateral());
    } catch (error) {
        console.error(`Error fetching totalCollateral: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch totalCollateral: ${error instanceof Error ? error.message : String(error)}`);
    }

    try {
        snapshot.totalDebt = BigInt(await contract.totalDebt());
    } catch (error) {
        console.error(`Error fetching totalDebt: ${error instanceof Error ? error.message : String(error)}`);
        throw new Error(`Failed to fetch totalDebt: ${error instanceof Error ? error.message : String(error)}`);
    }

    // --- Fetching attributes with parameters (per account/safe) ---

    for (const ownerAddress of accountAddressesArray) {
        try {
            snapshot.balanceOfSafes[ownerAddress] = BigInt(await contract.balanceOf(ownerAddress));
        } catch (error) {
            console.error(`Error fetching balanceOfSafes for ${ownerAddress}: ${error instanceof Error ? error.message : String(error)}`);
        }

        for (const operatorAddress of accountAddressesArray) {
            try {
                if (!snapshot.isOperatorApprovedForAll[ownerAddress]) {
                    snapshot.isOperatorApprovedForAll[ownerAddress] = {};
                }
                snapshot.isOperatorApprovedForAll[ownerAddress][operatorAddress] = Boolean(await contract.isApprovedForAll(ownerAddress, operatorAddress));
            } catch (error) {
                console.error(`Error fetching isOperatorApprovedForAll for owner ${ownerAddress} and operator ${operatorAddress}: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    }

    for (const safeId of safeIdsArray) {
        try {
            snapshot.safeApprovedAddress[safeId] = String(await contract.getApproved(safeId));
        } catch (error) {
            console.error(`Error fetching safeApprovedAddress for safeId ${safeId}: ${error instanceof Error ? error.message : String(error)}`);
        }

        try {
            const { inactiveDebt, inactiveCollateral } = await contract.getInactiveDebtAndCollateral(safeId);
            snapshot.inactiveDebtAndCollateral[safeId] = {
                inactiveDebt: BigInt(inactiveDebt),
                inactiveCollateral: BigInt(inactiveCollateral),
            };
        } catch (error) {
            console.error(`Error fetching inactiveDebtAndCollateral for safeId ${safeId}: ${error instanceof Error ? error.message : String(error)}`);
        }

        try {
            snapshot.safeOwner[safeId] = String(await contract.ownerOf(safeId));
        } catch (error) {
            console.error(`Error fetching safeOwner for safeId ${safeId}: ${error instanceof Error ? error.message : String(error)}`);
        }

        try {
            const { collateralAmount, borrowedAmount, weight, totalBorrowedAmount, feePaid } = await contract.safes(safeId);
            snapshot.safeDetails[safeId] = {
                collateralAmount: BigInt(collateralAmount),
                borrowedAmount: BigInt(borrowedAmount),
                weight: BigInt(weight),
                totalBorrowedAmount: BigInt(totalBorrowedAmount),
                feePaid: BigInt(feePaid),
            };
        } catch (error) {
            console.error(`Error fetching safeDetails for safeId ${safeId}: ${error instanceof Error ? error.message : String(error)}`);
        }

        try {
            snapshot.safeTokenURI[safeId] = String(await contract.tokenURI(safeId));
        } catch (error) {
            console.error(`Error fetching safeTokenURI for safeId ${safeId}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    return snapshot;
}
