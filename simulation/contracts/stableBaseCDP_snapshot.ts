// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot, SafeInfo, LiquidationSnapshot, RedemptionAmountsAndFee, InactiveDebtAndCollateral } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances to fetch user-specific data
 * @returns Promise returning the interface StableBaseCDPSnapshot
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
    try {
        const bootstrapModeDebtThreshold = await contract.BOOTSTRAP_MODE_DEBT_THRESHOLD();
        const extraGasCompensation = await contract.EXTRA_GAS_COMPENSATION();
        const minimumDebt = await contract.MINIMUM_DEBT();
        const protocolMode = await contract.PROTOCOL_MODE();
        const redemptionBaseFee = await contract.REDEMPTION_BASE_FEE();
        const redemptionLiquidationFee = await contract.REDEMPTION_LIQUIDATION_FEE();
        const sbrFeeReward = await contract.SBR_FEE_REWARD();
        const collateralLoss = await contract.collateralLoss();
        const cumulativeCollateralPerUnitCollateral = await contract.cumulativeCollateralPerUnitCollateral();
        const cumulativeDebtPerUnitCollateral = await contract.cumulativeDebtPerUnitCollateral();
        const debtLoss = await contract.debtLoss();
        const mode = await contract.mode();
        const contractName = await contract.name();
        const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
        const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();
        const contractSymbol = await contract.symbol();
        const totalCollateral = await contract.totalCollateral();
        const totalDebt = await contract.totalDebt();

        // Default values
        let accountBalance: bigint = BigInt(0);
        let interfaceSupport: boolean = false;
        let safeInfo: SafeInfo | null = null;
        let liquidationSnapshots: LiquidationSnapshot | null = null;
        let redemptionAmountsAndFee: RedemptionAmountsAndFee | null = null;
        let inactiveDebtAndCollateral: InactiveDebtAndCollateral | null = null;
        let isApprovedForAll: boolean = false;

        // Fetch isApprovedForAll for all actors

        // Fetch accountBalance for all actors
        if (actors && actors.length > 0) {
            for (const actor of actors) {
              try{
                const identifiers = actor.getIdentifiers();

                if (identifiers && identifiers.accountAddress) {
                  accountBalance = await contract.balanceOf(identifiers.accountAddress);
                  isApprovedForAll = await contract.isApprovedForAll(identifiers.accountAddress, identifiers.accountAddress);
                }
                if (identifiers && identifiers['Safe ID']) {
                    const safeId = identifiers['Safe ID'];

                    safeInfo = await contract.safes(safeId);
                    liquidationSnapshots = await contract.liquidationSnapshots(safeId);
                    inactiveDebtAndCollateral = await contract.getInactiveDebtAndCollateral(safeId);

                    // Example values.  Replace with actual values.
                    const safe = {
                        collateralAmount: BigInt(100),
                        borrowedAmount: BigInt(10),
                        weight: BigInt(1),
                        totalBorrowedAmount: BigInt(10),
                        feePaid: BigInt(0),
                    };
                    const amountToRedeem = BigInt(5);  // Example amount
                    const collateralPrice = BigInt(2000); // Example price

                    redemptionAmountsAndFee = await contract.calculateRedemptionAmountsAndFee(safe, amountToRedeem, collateralPrice);
                }

                if(identifiers && identifiers['interfaceId']){
                  interfaceSupport = await contract.supportsInterface(identifiers['interfaceId']);
                }
              } catch(e: any){
                console.error(`Error fetching data for actor: ${actor.id}`, e);
              }

            }
        }


        const snapshot: StableBaseCDPSnapshot = {
            bootstrapModeDebtThreshold: BigInt(bootstrapModeDebtThreshold.toString()),
            extraGasCompensation: BigInt(extraGasCompensation.toString()),
            minimumDebt: BigInt(minimumDebt.toString()),
            protocolMode: Number(protocolMode),
            redemptionBaseFee: BigInt(redemptionBaseFee.toString()),
            redemptionLiquidationFee: BigInt(redemptionLiquidationFee.toString()),
            sbrFeeReward: BigInt(sbrFeeReward.toString()),
            collateralLoss: BigInt(collateralLoss.toString()),
            cumulativeCollateralPerUnitCollateral: BigInt(cumulativeCollateralPerUnitCollateral.toString()),
            cumulativeDebtPerUnitCollateral: BigInt(cumulativeDebtPerUnitCollateral.toString()),
            debtLoss: BigInt(debtLoss.toString()),
            mode: Number(mode),
            contractName: contractName,
            sbrStakingPoolCanReceiveRewards: sbrStakingPoolCanReceiveRewards,
            stabilityPoolCanReceiveRewards: stabilityPoolCanReceiveRewards,
            contractSymbol: contractSymbol,
            totalCollateral: BigInt(totalCollateral.toString()),
            totalDebt: BigInt(totalDebt.toString()),
            accountBalance: BigInt(accountBalance.toString()),
            interfaceSupport: interfaceSupport,
        };

        return snapshot;
    } catch (error: any) {
        console.error('Error taking StableBaseCDP snapshot:', error);
        throw new Error(`Failed to take StableBaseCDP snapshot: ${error.message}`);
    }
}