// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances for context
 * @returns Promise returning the StableBaseCDPSnapshot interface
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  try {
    const balances: { [accountAddress: string]: bigint } = {};
    const approvals: { [_safeId: bigint]: string } = {};
    const inactiveDebtAndCollateral: { [_safeId: bigint]: [bigint, bigint] } = {};
    const approvalForAll: { [accountAddress: string]: { [accountAddress: string]: boolean } } = {};
    const owners: { [_safeId: bigint]: string } = {};
    const safes: { [_safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
    const tokenURIs: { [_safeId: bigint]: string } = {};
    const liquidationSnapshots: { [_safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

    // Fetch global contract state
    const collateralLoss = BigInt(await contract.collateralLoss());
    const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    const debtLoss = BigInt(await contract.debtLoss());
    const mode = Number(await contract.mode());
    const name = await contract.name();
    const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
    const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();
    const symbol = await contract.symbol();
    const totalCollateral = BigInt(await contract.totalCollateral());
    const totalDebt = BigInt(await contract.totalDebt());

    // Iterate over actors to fetch user-specific and safe-specific data
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      // Fetch balance for each account
      try {
        balances[accountAddress] = BigInt(await contract.balanceOf(accountAddress));
      } catch (e: any) {
        console.error(`Error fetching balance for ${accountAddress}: ${e.message}`);
        balances[accountAddress] = BigInt(0);
      }

      // Fetch ApprovalForAll for each account
      try {
        for (const otherAccount of actors) {
            approvalForAll[accountAddress] = approvalForAll[accountAddress] || {};
            approvalForAll[accountAddress][otherAccount.accountAddress] = await contract.isApprovedForAll(accountAddress, otherAccount.accountAddress);
        }
      } catch (e: any) {
        console.error(`Error fetching approvalForAll for ${accountAddress}: ${e.message}`);
      }


      if (actor.identifiers && actor.identifiers._safeId) {
        let safeIds: bigint[] = [];
        if (Array.isArray(actor.identifiers._safeId)) {
          safeIds = actor.identifiers._safeId.map((id: string) => BigInt(id));
        } else {
          safeIds = [BigInt(actor.identifiers._safeId)];
        }

        for (const _safeId of safeIds) {
          // Fetch approval for safeId
          try {
            approvals[_safeId] = await contract.getApproved(_safeId);
          } catch (e: any) {
            console.error(`Error fetching approval for safeId ${_safeId}: ${e.message}`);
            approvals[_safeId] = '';
          }

          // Fetch inactiveDebtAndCollateral for safeId
          try {
            const [debt, collateral] = await contract.getInactiveDebtAndCollateral(_safeId);
            inactiveDebtAndCollateral[_safeId] = [BigInt(debt), BigInt(collateral)];
          } catch (e: any) {
            console.error(`Error fetching inactiveDebtAndCollateral for safeId ${_safeId}: ${e.message}`);
            inactiveDebtAndCollateral[_safeId] = [BigInt(0), BigInt(0)];
          }

          // Fetch owner for safeId
          try {
            owners[_safeId] = await contract.ownerOf(_safeId);
          } catch (e: any) {
            console.error(`Error fetching ownerOf for safeId ${_safeId}: ${e.message}`);
            owners[_safeId] = '';
          }

          // Fetch safes for safeId
          try {
            const safe = await contract.safes(_safeId);
            safes[_safeId] = { collateralAmount: BigInt(safe.collateralAmount), borrowedAmount: BigInt(safe.borrowedAmount), weight: BigInt(safe.weight), totalBorrowedAmount: BigInt(safe.totalBorrowedAmount), feePaid: BigInt(safe.feePaid) };
          } catch (e: any) {
            console.error(`Error fetching safes for safeId ${_safeId}: ${e.message}`);
            safes[_safeId] = { collateralAmount: BigInt(0), borrowedAmount: BigInt(0), weight: BigInt(0), totalBorrowedAmount: BigInt(0), feePaid: BigInt(0) };
          }

          // Fetch tokenURI for safeId
          try {
            tokenURIs[_safeId] = await contract.tokenURI(_safeId);
          } catch (e: any) {
            console.error(`Error fetching tokenURI for safeId ${_safeId}: ${e.message}`);
            tokenURIs[_safeId] = '';
          }

            // Fetch liquidationSnapshots for safeId
          try {
            const snapshot = await contract.liquidationSnapshots(_safeId);
            liquidationSnapshots[_safeId] = { collateralPerCollateralSnapshot: BigInt(snapshot.collateralPerCollateralSnapshot), debtPerCollateralSnapshot: BigInt(snapshot.debtPerCollateralSnapshot) };
          } catch (e: any) {
            console.error(`Error fetching liquidationSnapshots for safeId ${_safeId}: ${e.message}`);
            liquidationSnapshots[_safeId] = { collateralPerCollateralSnapshot: BigInt(0), debtPerCollateralSnapshot: BigInt(0) };
          }
        }
      }
    }

    const snapshot: StableBaseCDPSnapshot = {
      balances,
      collateralLoss,
      cumulativeCollateralPerUnitCollateral,
      cumulativeDebtPerUnitCollateral,
      debtLoss,
      approvals,
      inactiveDebtAndCollateral,
      approvalForAll,
      mode,
      name,
      owners,
      safes,
      sbrStakingPoolCanReceiveRewards,
      stabilityPoolCanReceiveRewards,
      symbol,
      tokenURIs,
      totalCollateral,
      totalDebt,
      liquidationSnapshots
    };

    return snapshot;
  } catch (error: any) {
    console.error(`Error taking StableBaseCDP snapshot: ${error.message}`);
    throw error;
  }
}
