// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StableBaseCDPState, StableBaseCDPUserState } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP contract state.
 * @param contract - ethers.Contract instance
 * @returns Promise resolving to StableBaseCDPState interface
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract): Promise<StableBaseCDPState> {
    try {
        const mode = Number(await contract.mode());
        const collateralLoss = BigInt(await contract.collateralLoss());
        const cumulativeCollateralPerUnitCollateral = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
        const cumulativeDebtPerUnitCollateral = BigInt(await contract.cumulativeDebtPerUnitCollateral());
        const debtLoss = BigInt(await contract.debtLoss());
        const name = await contract.name();
        const totalCollateral = BigInt(await contract.totalCollateral());
        const totalDebt = BigInt(await contract.totalDebt());
        const symbol = await contract.symbol();
        const sbrStakingPoolCanReceiveRewards = await contract.sbrStakingPoolCanReceiveRewards();
        const stabilityPoolCanReceiveRewards = await contract.stabilityPoolCanReceiveRewards();

        // Fetch all liquidation snapshots (This might be inefficient if there are too many safes)
        const liquidationSnapshots: { [safeId: string]: { collateralPerCollateralSnapshot: bigint; debtPerCollateralSnapshot: bigint; } } = {};
        // Fetch all safes snapshots (This might be inefficient if there are too many safes)
        const safesSnapshots: { [safeId: string]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint; } } = {};
        
        // TODO: Figure out how to get all safeIds, or a range of safeIds to iterate over
        // For now, just initialize these as empty objects. In real implementation, you need to fetch data for existing safeIds

        const state: StableBaseCDPState = {
            mode,
            collateralLoss,
            cumulativeCollateralPerUnitCollateral,
            cumulativeDebtPerUnitCollateral,
            debtLoss,
            name,
            totalCollateral,
            totalDebt,
            symbol,
            sbrStakingPoolCanReceiveRewards,
            stabilityPoolCanReceiveRewards,
            liquidationSnapshots,
            safes: safesSnapshots
        };

        return state;
    } catch (error) {
        console.error('Error taking contract snapshot:', error);
        throw error;
    }
}

/**
 * Takes a snapshot of StableBaseCDP user-specific state.
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects, each representing a user.  Each actor has identifiers. accountAddress identifier exists for all actors.
 * @returns Promise resolving to an array of StableBaseCDPUserState interfaces, one for each actor
 */
export async function takestableBaseCDPUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<{ [accountAddress: string]: StableBaseCDPUserState }> {
    const userStates: { [accountAddress: string]: StableBaseCDPUserState } = {};

    for (const actor of actors) {
        try {
            const accountAddress = actor.accountAddress;

            if (!accountAddress) {
                console.warn("Actor missing accountAddress, skipping.");
                continue;
            }

            const balanceOf = BigInt(await contract.balanceOf(accountAddress));
            
            let isApprovedForAll = false; // default value
            if (actor.identifiers && actor.identifiers['operator']) {
              const operatorAddresses = Array.isArray(actor.identifiers['operator']) ? actor.identifiers['operator'] : [actor.identifiers['operator']];

              for (const operatorAddress of operatorAddresses) {
                isApprovedForAll = await contract.isApprovedForAll(accountAddress, operatorAddress);
                if(isApprovedForAll) break; // if true, no need to check others
              }

            }

            let ownerOf: string = "";
            let getApproved: string = "";
            let getInactiveDebtAndCollateral: { collateral: bigint; debt: bigint; } = { collateral: 0n, debt: 0n };
            let tokenURI: string = "";

            if (actor.identifiers && actor.identifiers['_safeId']) {
                const safeIds = Array.isArray(actor.identifiers['_safeId']) ? actor.identifiers['_safeId'] : [actor.identifiers['_safeId']];

                for (const safeId of safeIds) {
                    const safeIdNum = BigInt(safeId);

                    ownerOf = await contract.ownerOf(safeIdNum);
                    getApproved = await contract.getApproved(safeIdNum);
                    getInactiveDebtAndCollateral = await contract.getInactiveDebtAndCollateral(safeIdNum);
                    tokenURI = await contract.tokenURI(safeIdNum);
                }
            }

            const userState: StableBaseCDPUserState = {
                balanceOf,
                ownerOf,
                getApproved,
                isApprovedForAll,
                getInactiveDebtAndCollateral,
                tokenURI
            };

            userStates[accountAddress] = userState;

        } catch (error) {
            console.error(`Error taking user snapshot for actor ${actor.accountAddress}:`, error);
            //Decide whether to rethrow or continue
            throw error;
        }
    }

    return userStates;
}