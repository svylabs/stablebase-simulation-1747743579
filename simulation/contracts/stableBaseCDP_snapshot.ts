// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StableBaseCDPSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StableBaseCDP state
 *
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 *
 * @returns Promise returning the StableBaseCDPSnapshot interface
 */
export async function takestableBaseCDPContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StableBaseCDPSnapshot> {
  try {
    const balances: { [accountAddress: string]: bigint } = {};
    const approvals: { [safeId: bigint]: string } = {};
    const inactiveDebtAndCollateral: { [safeId: bigint]: [bigint, bigint] } = {};
    const approvalForAll: { [owner: string]: { [operator: string]: boolean } } = {};
    const owners: { [safeId: bigint]: string } = {};
    const safes: { [safeId: bigint]: { collateralAmount: bigint; borrowedAmount: bigint; weight: bigint; totalBorrowedAmount: bigint; feePaid: bigint } } = {};
    const tokenURIs: { [safeId: bigint]: string } = {};
    const liquidationSnapshots: { [safeId: bigint]: { collateralPerCollateralSnapshot: bigint, debtPerCollateralSnapshot: bigint } } = {};

    /**
     * Fetches contract-wide state variables.
     */
    const collateralLoss: bigint = BigInt(await contract.collateralLoss());
    const cumulativeCollateralPerUnitCollateral: bigint = BigInt(await contract.cumulativeCollateralPerUnitCollateral());
    const cumulativeDebtPerUnitCollateral: bigint = BigInt(await contract.cumulativeDebtPerUnitCollateral());
    const debtLoss: bigint = BigInt(await contract.debtLoss());
    const mode: number = Number(await contract.mode());
    const name: string = await contract.name();
    const sbrStakingPoolCanReceiveRewards: boolean = await contract.sbrStakingPoolCanReceiveRewards();
    const stabilityPoolCanReceiveRewards: boolean = await contract.stabilityPoolCanReceiveRewards();
    const symbol: string = await contract.symbol();
    const totalCollateral: bigint = BigInt(await contract.totalCollateral());
    const totalDebt: bigint = BigInt(await contract.totalDebt());

    /**
     * Iterates over actors to fetch user-specific data.
     */
    for (const actor of actors) {
      const accountAddress: string = actor.accountAddress;

      /**
       * Fetch Balance
       */
      try {
        balances[accountAddress] = BigInt(await contract.balanceOf(accountAddress));
      } catch (error: any) {
        console.error(`Error fetching balance for account ${accountAddress}: ${error.message}`);
      }

      /**
       * Processes the `_safeId` identifier, if present, to fetch SAFE-specific data.
       */
      if (actor.identifiers && actor.identifiers['_safeId']) {
        const safeIds = Array.isArray(actor.identifiers['_safeId']) ? actor.identifiers['_safeId'] : [actor.identifiers['_safeId']];

        for (const safeId of safeIds) {
          const _safeId: bigint = BigInt(safeId);

          /**
           * Fetch Approval
           */
          try {
            approvals[_safeId] = await contract.getApproved(_safeId);
          } catch (error: any) {
            console.error(`Error fetching approval for safeId ${_safeId}: ${error.message}`);
          }

          /**
           * Fetch InactiveDebtAndCollateral
           */
          try {
            const [debt, collateral] = await contract.getInactiveDebtAndCollateral(_safeId);
            inactiveDebtAndCollateral[_safeId] = [BigInt(debt), BigInt(collateral)];
          } catch (error: any) {
            console.error(`Error fetching inactive debt and collateral for safeId ${_safeId}: ${error.message}`);
          }

          /**
           * Fetch Owner
           */
          try {
            owners[_safeId] = await contract.ownerOf(_safeId);
          } catch (error: any) {
            console.error(`Error fetching owner for safeId ${_safeId}: ${error.message}`);
          }

          /**
           * Fetch Safe details
           */
          try {
            const safe = await contract.safes(_safeId);
            const { collateralAmount, borrowedAmount, weight, totalBorrowedAmount, feePaid } = safe;
            safes[_safeId] = { collateralAmount: BigInt(collateralAmount), borrowedAmount: BigInt(borrowedAmount), weight: BigInt(weight), totalBorrowedAmount: BigInt(totalBorrowedAmount), feePaid: BigInt(feePaid) };
          } catch (error: any) {
            console.error(`Error fetching safe for safeId ${_safeId}: ${error.message}`);
          }

          /**
           * Fetch TokenURI
           */
          try {
            tokenURIs[_safeId] = await contract.tokenURI(_safeId);
          } catch (error: any) {
            console.error(`Error fetching tokenURI for safeId ${_safeId}: ${error.message}`);
          }

          /**
           * Fetch liquidationSnapshots
           */
          try {
            const snapshot = await contract.liquidationSnapshots(_safeId);
            const { collateralPerCollateralSnapshot, debtPerCollateralSnapshot } = snapshot;
            liquidationSnapshots[_safeId] = { collateralPerCollateralSnapshot: BigInt(collateralPerCollateralSnapshot), debtPerCollateralSnapshot: BigInt(debtPerCollateralSnapshot) };
          } catch (error: any) {
            console.error(`Error fetching liquidation snapshot for safeId ${_safeId}: ${error.message}`);
          }
        }
      }

      /**
       * Processes the `accountAddress` identifier to fetch approvalForAll data.
       */
      if (actor.identifiers && actor.identifiers['accountAddress']) {
        const accountAddresses: string[] = Array.isArray(actor.identifiers['accountAddress']) ? actor.identifiers['accountAddress'] : [actor.identifiers['accountAddress']];

        for (const operator of accountAddresses) {
          try {
            if (!approvalForAll[accountAddress]) {
              approvalForAll[accountAddress] = {};
            }
            approvalForAll[accountAddress][operator] = await contract.isApprovedForAll(accountAddress, operator);
          } catch (error: any) {
            console.error(`Error fetching approvalForAll for owner ${accountAddress} and operator ${operator}: ${error.message}`);
          }
        }
      }
    }

    return {
      /**
       * Mapping of account addresses to their balances.
       */
      balances,
      /**
       * Total collateral loss in the contract.
       */
      collateralLoss,
      /**
       * Cumulative collateral per unit collateral.
       */
      cumulativeCollateralPerUnitCollateral,
      /**
       * Cumulative debt per unit collateral.
       */
      cumulativeDebtPerUnitCollateral,
      /**
       * Total debt loss in the contract.
       */
      debtLoss,
      /**
       * Mapping of safe IDs to the approved address.
       */
      approvals,
      /**
       * Mapping of safe IDs to their inactive debt and collateral.
       */
      inactiveDebtAndCollateral,
      /**
       * Mapping of owner addresses to operators and their approval status.
       */
      approvalForAll,
      /**
       * Mode of the contract.
       */
      mode,
      /**
       * Name of the contract.
       */
      name,
      /**
       * Mapping of safe IDs to their owners.
       */
      owners,
      /**
       * Mapping of safe IDs to their SAFE details.
       */
      safes,
      /**
       * Indicates whether the SBR staking pool can receive rewards.
       */
      sbrStakingPoolCanReceiveRewards,
      /**
       * Indicates whether the stability pool can receive rewards.
       */
      stabilityPoolCanReceiveRewards,
      /**
       * Symbol of the contract.
       */
      symbol,
      /**
       * Mapping of safe IDs to their token URIs.
       */
      tokenURIs,
      /**
       * Total collateral in the contract.
       */
      totalCollateral,
      /**
       * Total debt in the contract.
       */
      totalDebt,
      /**
       * Mapping of safe IDs to their liquidation snapshots.
       */
      liquidationSnapshots,
    };
  } catch (error: any) {
    console.error(`Error taking StableBaseCDP contract snapshot: ${error.message}`);
    throw error;
  }
}
