// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { DFIREStakingSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIREStaking state
 * @param contract - ethers.Contract instance
 * @param actors - An array of Actor objects to fetch user-specific data.
 * @returns Promise returning the interface DFIREStakingSnapshot
 */
export async function takedfireStakingContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIREStakingSnapshot> {
  try {
    const stakes: { [accountAddress: string]: { stake: bigint; rewardSnapshot: bigint; collateralSnapshot: bigint } } = {};
    const userPendingReward: { [accountAddress: string]: [bigint, bigint] } = {};

    // Fetch stakes and userPendingReward for each actor (user)
    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();
      const accountAddress = identifiers.accountAddress as string;

      if (accountAddress) {
        try {
          const stakeData = await contract.stakes(accountAddress);
          stakes[accountAddress] = {
            stake: BigInt(stakeData.stake),
            rewardSnapshot: BigInt(stakeData.rewardSnapshot),
            collateralSnapshot: BigInt(stakeData.collateralSnapshot),
          };
        } catch (error: any) {
          console.error(`Error fetching stake data for address ${accountAddress}: ${error.message}`);
          // Handle the error appropriately, e.g., set default values or skip the user
          stakes[accountAddress] = { stake: BigInt(0), rewardSnapshot: BigInt(0), collateralSnapshot: BigInt(0) };
        }

        try {
          const pendingRewardData = await contract.userPendingReward(accountAddress);
          userPendingReward[accountAddress] = [BigInt(pendingRewardData[0]), BigInt(pendingRewardData[1])];
        } catch (error: any) {
          console.error(`Error fetching pending reward data for address ${accountAddress}: ${error.message}`);
          // Handle the error appropriately, e.g., set default values or skip the user
          userPendingReward[accountAddress] = [BigInt(0), BigInt(0)];
        }
      }
    }

    const [rewardSenderActive, totalCollateralPerToken, totalRewardPerToken, totalStake, stakingToken, rewardToken, PRECISION] = await Promise.all([
      contract.rewardSenderActive(),
      contract.totalCollateralPerToken(),
      contract.totalRewardPerToken(),
      contract.totalStake(),
      contract.stakingToken(),
      contract.rewardToken(),
      contract.PRECISION()
    ]);


    const snapshot: DFIREStakingSnapshot = {
      stakes,
      rewardSenderActive,
      totalCollateralPerToken: BigInt(totalCollateralPerToken),
      totalRewardPerToken: BigInt(totalRewardPerToken),
      totalStake: BigInt(totalStake),
      userPendingReward,
      stakingToken,
      rewardToken,
      PRECISION: BigInt(PRECISION),
    };

    return snapshot;
  } catch (error: any) {
    console.error(`Error taking DFIREStaking contract snapshot: ${error.message}`);
    throw new Error(`Failed to take DFIREStaking contract snapshot: ${error.message}`);
  }
}