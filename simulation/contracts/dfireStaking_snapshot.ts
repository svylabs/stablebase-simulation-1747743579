// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { DFIREStakingSnapshot, StakeInfo } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIREStaking state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface DFIREStakingSnapshot
 */
export async function takedfireStakingContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIREStakingSnapshot> {
  try {
    const precisionValue = await contract.PRECISION() as bigint;
    const isRewardSenderActive = await contract.rewardSenderActive() as boolean;
    const totalCollateralPerTokenValue = await contract.totalCollateralPerToken() as bigint;
    const totalRewardPerTokenValue = await contract.totalRewardPerToken() as bigint;
    const totalStakeValue = await contract.totalStake() as bigint;

    const stakes: { [accountAddress: string]: StakeInfo } = {};

    for (const actor of actors) {
      const accountAddress = actor.accountAddress;
      if (!accountAddress) {
        console.warn(`Actor ${actor.id} has no accountAddress. Skipping stake info fetch.`);
        continue;
      }

      try {
        const [stake, rewardSnapshot, collateralSnapshot] = await contract.stakes(accountAddress) as [bigint, bigint, bigint];
        stakes[accountAddress] = {
          stake,
          rewardSnapshot,
          collateralSnapshot,
        };
      } catch (error: any) {
        console.error(`Error fetching stake info for actor ${actor.id} with address ${accountAddress}: ${error.message}`);
      }
    }

    return {
      precisionValue,
      isRewardSenderActive,
      stakes,
      totalCollateralPerTokenValue,
      totalRewardPerTokenValue,
      totalStakeValue,
    };
  } catch (error: any) {
    console.error(`Error taking DFIREStaking snapshot: ${error.message}`);
    throw new Error(`Failed to snapshot DFIREStaking contract: ${error.message}`);
  }
}