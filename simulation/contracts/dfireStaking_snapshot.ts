// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';

interface Stake {
  stake: bigint;
  rewardSnapshot: bigint;
  collateralSnapshot: bigint;
}

interface DFIREStakingState {
  PRECISION: bigint;
  owner: string;
  rewardSenderActive: boolean;
  stableBaseContract: string;
  totalCollateralPerToken: bigint;
  totalRewardPerToken: bigint;
  totalStake: bigint;
  stakes: { [accountAddress: string]: Stake };
  userPendingRewards: { [accountAddress: string]: bigint };
}

/**
 * Takes a snapshot of DFIREStaking state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the DFIREStakingState
 */
export async function takedfireStakingContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIREStakingState> {
  try {
    const PRECISION = (await contract.PRECISION()) as bigint;
    const owner = (await contract.owner()) as string;
    const rewardSenderActive = (await contract.rewardSenderActive()) as boolean;
    const stableBaseContract = (await contract.stableBaseContract()) as string;
    const totalCollateralPerToken = (await contract.totalCollateralPerToken()) as bigint;
    const totalRewardPerToken = (await contract.totalRewardPerToken()) as bigint;
    const totalStake = (await contract.totalStake()) as bigint;

    const stakes: { [accountAddress: string]: Stake } = {};
    const userPendingRewards: { [accountAddress: string]: bigint } = {};

    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();
      const accountAddress = identifiers.accountAddress as string;

      if (!accountAddress) {
        console.warn(`Actor ${actor.id} does not have an accountAddress. Skipping.`);
        continue;
      }

      try {
        stakes[accountAddress] = (await contract.getStake(accountAddress)) as Stake;
        userPendingRewards[accountAddress] = (await contract.userPendingReward(accountAddress)) as bigint;
      } catch (error: any) {
        console.error(`Failed to get stake or user pending reward for address ${accountAddress}: ${error.message}`);
      }
    }

    return {
      PRECISION,
      owner,
      rewardSenderActive,
      stableBaseContract,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalStake,
      stakes,
      userPendingRewards,
    };
  } catch (error: any) {
    console.error('Error taking DFIREStaking contract snapshot:', error);
    throw new Error(`Failed to take DFIREStaking contract snapshot: ${error.message}`);
  }
}
