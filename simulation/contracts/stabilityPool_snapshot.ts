// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StabilityPoolSnapshot, UserInfo, SBRRewardSnapshot, StakeResetSnapshot, UserPendingRewardAndCollateralOutput, IsLiquidationPossibleOutput } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects to fetch user-specific data
 * @returns Promise returning the interface StabilityPoolSnapshot
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolSnapshot> {
  try {
    const basisPointsDivisor = await contract.BASIS_POINTS_DIVISOR();
    const collateralLoss = await contract.collateralLoss();
    const precision = await contract.precision();
    const rewardLoss = await contract.rewardLoss();
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = await contract.sbrDistributionRate();
    const sbrRewardDistributionEndTime = await contract.sbrRewardDistributionEndTime();
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = await contract.sbrRewardLoss();
    const stakeResetCount = await contract.stakeResetCount();
    const stakeScalingFactor = await contract.stakeScalingFactor();
    const totalCollateralPerToken = await contract.totalCollateralPerToken();
    const totalRewardPerToken = await contract.totalRewardPerToken();
    const totalSbrRewardPerToken = await contract.totalSbrRewardPerToken();
    const totalStakedRaw = await contract.totalStakedRaw();

    // Fetch user-specific data
    const users: { [accountAddress: string]: UserInfo } = {};
    const sbrRewardSnapshots: { [accountAddress: string]: SBRRewardSnapshot } = {};
    const stakeResetSnapshots: { [stakeResetCount: string]: StakeResetSnapshot } = {};

    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      try {
        const userInfo = await contract.getUser(accountAddress);
        users[accountAddress] = {
          stake: BigInt(userInfo.stake),
          rewardSnapshot: BigInt(userInfo.rewardSnapshot),
          collateralSnapshot: BigInt(userInfo.collateralSnapshot),
          cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
          stakeResetCount: BigInt(userInfo.stakeResetCount),
        };

        const sbrRewardSnapshot = await contract.sbrRewardSnapshots(accountAddress);
        sbrRewardSnapshots[accountAddress] = {
          rewardSnapshot: BigInt(sbrRewardSnapshot.rewardSnapshot),
          status: sbrRewardSnapshot.status,
        };

         // Fetch user-related data
        const userPendingCollateral = await contract.userPendingCollateral(accountAddress);

        const userPendingReward = await contract.userPendingReward(accountAddress);


        // Fetch StakeResetSnapshots for each actor
        const stakeResetSnapshot = await contract.stakeResetSnapshots(stakeResetCount);
        stakeResetSnapshots[stakeResetCount.toString()] = {
          scalingFactor: BigInt(stakeResetSnapshot.scalingFactor),
          totalRewardPerToken: BigInt(stakeResetSnapshot.totalRewardPerToken),
          totalCollateralPerToken: BigInt(stakeResetSnapshot.totalCollateralPerToken),
          totalSBRRewardPerToken: BigInt(stakeResetSnapshot.totalSBRRewardPerToken),
        };
      } catch (userError: any) {
        console.error(`Error fetching user data for ${accountAddress}:`, userError);
        // Handle or re-throw the error as needed.
      }
    }


    return {
      basisPointsDivisor: BigInt(basisPointsDivisor),
      collateralLoss: BigInt(collateralLoss),
      precision: BigInt(precision),
      rewardLoss: BigInt(rewardLoss),
      rewardSenderActive,
      sbrDistributionRate: BigInt(sbrDistributionRate),
      sbrRewardDistributionEndTime: BigInt(sbrRewardDistributionEndTime),
      sbrRewardDistributionStatus,
      sbrRewardLoss: BigInt(sbrRewardLoss),
      stakeResetCount: BigInt(stakeResetCount),
      stakeScalingFactor: BigInt(stakeScalingFactor),
      totalCollateralPerToken: BigInt(totalCollateralPerToken),
      totalRewardPerToken: BigInt(totalRewardPerToken),
      totalSbrRewardPerToken: BigInt(totalSbrRewardPerToken),
      totalStakedRaw: BigInt(totalStakedRaw),
      users,
      sbrRewardSnapshots,
      stakeResetSnapshots,
    };
  } catch (error: any) {
    console.error('Error taking StabilityPool snapshot:', error);
    throw new Error(`Failed to take StabilityPool snapshot: ${error.message}`);
  }
}
