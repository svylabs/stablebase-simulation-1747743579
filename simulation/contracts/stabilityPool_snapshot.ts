// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StabilityPoolStateSnapshot, StabilityPoolUserSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool contract state
 * @param contract - ethers.Contract instance
 * @returns Promise resolving to StabilityPoolStateSnapshot
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract): Promise<StabilityPoolStateSnapshot> {
    try {
        const collateralLoss = await contract.collateralLoss();
        const lastSBRRewardDistributedTime = await contract.lastSBRRewardDistributedTime();
        const minimumScalingFactor = await contract.minimumScalingFactor();
        const precision = await contract.precision();
        const rewardLoss = await contract.rewardLoss();
        const rewardSenderActive = await contract.rewardSenderActive();
        const sbrDistributionRate = await contract.sbrDistributionRate();
        const sbrRewardDistributionEndTime = await contract.sbrRewardDistributionEndTime();
        const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
        const sbrRewardLoss = await contract.sbrRewardLoss();
        const stakeResetCount = await contract.stakeResetCount();
        const stakeScalingFactor = await contract.stakeScalingFactor();
        const totalCollateralPerToken = await contract.totalCollateralPerToken();
        const totalRewardPerToken = await contract.totalRewardPerToken();
        const totalSbrRewardPerToken = await contract.totalSbrRewardPerToken();
        const totalStakedRaw = await contract.totalStakedRaw();

        // Fetch stake reset snapshots.
        const stakeResetSnapshots = [];
        for (let i = 0; i < Number(stakeResetCount); i++) {
            const snapshot = await contract.stakeResetSnapshots(i);
            stakeResetSnapshots.push({
                scalingFactor: BigInt(snapshot.scalingFactor),
                totalRewardPerToken: BigInt(snapshot.totalRewardPerToken),
                totalCollateralPerToken: BigInt(snapshot.totalCollateralPerToken),
                totalSBRRewardPerToken: BigInt(snapshot.totalSBRRewardPerToken),
            });
        }

        const snapshot: StabilityPoolStateSnapshot = {
            collateralLoss: BigInt(collateralLoss),
            lastSBRRewardDistributedTime: BigInt(lastSBRRewardDistributedTime),
            minimumScalingFactor: BigInt(minimumScalingFactor),
            precision: BigInt(precision),
            rewardLoss: BigInt(rewardLoss),
            rewardSenderActive: rewardSenderActive,
            sbrDistributionRate: BigInt(sbrDistributionRate),
            sbrRewardDistributionEndTime: BigInt(sbrRewardDistributionEndTime),
            sbrRewardDistributionStatus: sbrRewardDistributionStatus,
            sbrRewardLoss: BigInt(sbrRewardLoss),
            stakeResetCount: BigInt(stakeResetCount),
            stakeScalingFactor: BigInt(stakeScalingFactor),
            totalCollateralPerToken: BigInt(totalCollateralPerToken),
            totalRewardPerToken: BigInt(totalRewardPerToken),
            totalSbrRewardPerToken: BigInt(totalSbrRewardPerToken),
            totalStakedRaw: BigInt(totalStakedRaw),
            stakeResetSnapshots: stakeResetSnapshots,
        };

        return snapshot;
    } catch (error: any) {
        console.error('Error taking StabilityPool contract snapshot:', error);
        throw new Error(`Failed to take StabilityPool contract snapshot: ${error.message}`);
    }
}

/**
 * Takes a snapshot of StabilityPool user-specific data for multiple actors
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects, each representing a user
 * @returns Promise resolving to an array of StabilityPoolUserSnapshot
 */
export async function takestabilityPoolUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolUserSnapshot[]> {
    const userSnapshots: StabilityPoolUserSnapshot[] = [];

    for (const actor of actors) {
        try {
            const accountAddress = actor.accountAddress;

            if (!accountAddress) {
                console.warn(`Skipping actor due to missing accountAddress.`);
                continue;
            }

            const userInfo = await contract.getUser(accountAddress);
            const pendingReward = await contract.userPendingReward(accountAddress);
            const pendingCollateral = await contract.userPendingCollateral(accountAddress);

            const sbrRewardSnapshots = await contract.sbrRewardSnapshots(accountAddress);

            const snapshot: StabilityPoolUserSnapshot = {
                userInfo: {
                    stake: BigInt(userInfo.stake),
                    rewardSnapshot: BigInt(userInfo.rewardSnapshot),
                    collateralSnapshot: BigInt(userInfo.collateralSnapshot),
                    cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
                    stakeResetCount: BigInt(userInfo.stakeResetCount),
                },
                pendingReward: BigInt(pendingReward),
                pendingCollateral: BigInt(pendingCollateral),
                sbrRewardSnapshot: {
                    rewardSnapshot: BigInt(sbrRewardSnapshots.rewardSnapshot),
                    status: Number(sbrRewardSnapshots.status),
                },
            };

            userSnapshots.push(snapshot);
        } catch (error: any) {
            console.error(`Error taking StabilityPool user snapshot for address ${actor.accountAddress}:`, error);
            throw new Error(`Failed to take StabilityPool user snapshot for address ${actor.accountAddress}: ${error.message}`);
        }
    }

    return userSnapshots;
}