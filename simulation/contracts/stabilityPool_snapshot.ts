// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StabilityPoolState, IStabilityPoolUserInfo, SBRRewardSnapshots, StakeResetSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances for fetching user-specific data
 * @returns Promise returning the interface StabilityPoolState
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolState> {
  try {
    const collateralLoss = BigInt(await contract.collateralLoss());
    const rewardLoss = BigInt(await contract.rewardLoss());
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrRewardDistributionEndTime = BigInt(await contract.sbrRewardDistributionEndTime());
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const stakeResetCount = BigInt(await contract.stakeResetCount());
    const stakeScalingFactor = BigInt(await contract.stakeScalingFactor());
    const totalCollateralPerToken = BigInt(await contract.totalCollateralPerToken());
    const totalRewardPerToken = BigInt(await contract.totalRewardPerToken());
    const totalSbrRewardPerToken = BigInt(await contract.totalSbrRewardPerToken());
    const totalStakedRaw = BigInt(await contract.totalStakedRaw());
    const lastSBRRewardDistributedTime = BigInt(await contract.lastSBRRewardDistributedTime());
    const sbrDistributionRate = BigInt(await contract.sbrDistributionRate());
    const minimumScalingFactor = BigInt(await contract.minimumScalingFactor());
    const precision = BigInt(await contract.precision());

    // Fetch user-specific data
    const users: { [accountAddress: string]: IStabilityPoolUserInfo } = {};
    const sbrRewardSnapshots: { [accountAddress: string]: SBRRewardSnapshots } = {};
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;
      try {
        const userInfo = await contract.users(accountAddress);
        users[accountAddress] = {
          stake: BigInt(userInfo.stake),
          rewardSnapshot: BigInt(userInfo.rewardSnapshot),
          collateralSnapshot: BigInt(userInfo.collateralSnapshot),
          cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
          stakeResetCount: BigInt(userInfo.stakeResetCount),
        };
      } catch (error: any) {
        console.error(`Error fetching user info for ${accountAddress}: ${error.message}`);
        // Initialize user info with 0 if there is an error
        users[accountAddress] = {
          stake: BigInt(0),
          rewardSnapshot: BigInt(0),
          collateralSnapshot: BigInt(0),
          cumulativeProductScalingFactor: BigInt(0),
          stakeResetCount: BigInt(0),
        };
      }

      try {
        const sbrRewardSnapshot = await contract.sbrRewardSnapshots(accountAddress);
        sbrRewardSnapshots[accountAddress] = {
          rewardSnapshot: BigInt(sbrRewardSnapshot.rewardSnapshot),
          status: sbrRewardSnapshot.status,
        };
      } catch (error: any) {
        console.error(`Error fetching sbrRewardSnapshots for ${accountAddress}: ${error.message}`);
        sbrRewardSnapshots[accountAddress] = {
          rewardSnapshot: BigInt(0),
          status: 0,
        };
      }
    }

    // Fetch stakeResetSnapshots
    const stakeResetSnapshots: { [stakeResetCount: string]: StakeResetSnapshot } = {};
    // Assuming stakeResetCount is an iterable number.  If not, this needs adjustment.
    // We will fetch the stake reset snapshot for the current stakeResetCount.  If more are needed, we'll need an array of stakeResetCounts.
    try {
      const stakeResetSnapshot = await contract.stakeResetSnapshots(stakeResetCount);
      stakeResetSnapshots[stakeResetCount.toString()] = {
        scalingFactor: BigInt(stakeResetSnapshot.scalingFactor),
        totalRewardPerToken: BigInt(stakeResetSnapshot.totalRewardPerToken),
        totalCollateralPerToken: BigInt(stakeResetSnapshot.totalCollateralPerToken),
        totalSBRRewardPerToken: BigInt(stakeResetSnapshot.totalSBRRewardPerToken),
      };
    } catch (error: any) {
      console.error(`Error fetching stakeResetSnapshots for stakeResetCount ${stakeResetCount}: ${error.message}`);
      stakeResetSnapshots[stakeResetCount.toString()] = {
        scalingFactor: BigInt(0),
        totalRewardPerToken: BigInt(0),
        totalCollateralPerToken: BigInt(0),
        totalSBRRewardPerToken: BigInt(0),
      };
    }

    return {
      collateralLoss,
      rewardLoss,
      rewardSenderActive,
      sbrRewardDistributionEndTime,
      sbrRewardDistributionStatus,
      stakeResetCount,
      stakeScalingFactor,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalSbrRewardPerToken,
      totalStakedRaw,
      users,
      sbrRewardSnapshots,
      stakeResetSnapshots,
      lastSBRRewardDistributedTime,
      sbrDistributionRate,
      minimumScalingFactor,
      precision,
    };
  } catch (error: any) {
    console.error(`Error taking StabilityPool snapshot: ${error.message}`);
    throw error;
  }
}
