// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StabilityPoolSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool state, fetching user-specific data for each actor.
 * @param contract - ethers.Contract instance
 * @param actors - An array of Actor objects, each containing an accountAddress.
 * @returns Promise returning the interface StabilityPoolSnapshot
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolSnapshot> {
  try {
    // Fetch constant state
    const collateralLoss = BigInt(await contract.collateralLoss());
    const lastSBRRewardDistributedTime = BigInt(await contract.lastSBRRewardDistributedTime());
    const minimumScalingFactor = BigInt(await contract.minimumScalingFactor());
    const precision = BigInt(await contract.precision());
    const rewardLoss = BigInt(await contract.rewardLoss());
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = BigInt(await contract.sbrDistributionRate());
    const sbrRewardDistributionEndTime = BigInt(await contract.sbrRewardDistributionEndTime());
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = BigInt(await contract.sbrRewardLoss());
    const stakeResetCount = BigInt(await contract.stakeResetCount());
    const stakeScalingFactor = BigInt(await contract.stakeScalingFactor());
    const totalCollateralPerToken = BigInt(await contract.totalCollateralPerToken());
    const totalRewardPerToken = BigInt(await contract.totalRewardPerToken());
    const totalSbrRewardPerToken = BigInt(await contract.totalSbrRewardPerToken());
    const totalStakedRaw = BigInt(await contract.totalStakedRaw());

    // Fetch user-specific data for each actor
    const userSpecificData: {
      [accountAddress: string]: {
        userInfo: any; // Replace 'any' with the actual type if known
        userPendingCollateral: bigint;
        userPendingReward: bigint;
        userPendingRewardAndCollateral: [bigint, bigint, bigint];
        users: any; // Replace 'any' with the actual type if known
        sbrRewardSnapshots: { rewardSnapshot: bigint; status: number };
      };
    } = {};

    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      const userInfo = await contract.getUser(accountAddress);
      const userPendingCollateral = BigInt(await contract.userPendingCollateral(accountAddress));
      const userPendingReward = BigInt(await contract.userPendingReward(accountAddress));
      const userPendingRewardAndCollateralResult = await contract.userPendingRewardAndCollateral(accountAddress);
      const userPendingRewardAndCollateral = userPendingRewardAndCollateralResult.map(BigInt) as [bigint, bigint, bigint];
      const users = await contract.users(accountAddress);
      const sbrRewardSnapshotsResponse = await contract.sbrRewardSnapshots(accountAddress);

      userSpecificData[accountAddress] = {
        userInfo,
        userPendingCollateral,
        userPendingReward,
        userPendingRewardAndCollateral,
        users,
        sbrRewardSnapshots: {
          rewardSnapshot: BigInt(sbrRewardSnapshotsResponse.rewardSnapshot),
          status: sbrRewardSnapshotsResponse.status,
        },
      };
    }

    const stakeResetSnapshots: any = {};

    for (let i = 0; i <= Number(stakeResetCount); i++) {
      stakeResetSnapshots[i] = {
        scalingFactor: BigInt(0),
        totalRewardPerToken: BigInt(0),
        totalCollateralPerToken: BigInt(0),
        totalSBRRewardPerToken: BigInt(0),
      }
    }

    // Structure the snapshot data
    const snapshot: StabilityPoolSnapshot = {
      collateralLoss,
      userInfo: {
        stake: BigInt(0),
        rewardSnapshot: BigInt(0),
        collateralSnapshot: BigInt(0),
        cumulativeProductScalingFactor: BigInt(0),
        stakeResetCount: BigInt(0),
      },
      lastSBRRewardDistributedTime,
      minimumScalingFactor,
      precision,
      rewardLoss,
      rewardSenderActive,
      sbrDistributionRate,
      sbrRewardDistributionEndTime,
      sbrRewardDistributionStatus,
      sbrRewardLoss,
      sbrRewardSnapshots: { rewardSnapshot: BigInt(0), status: 0 },
      stakeResetCount,
      stakeResetSnapshots,
      stakeScalingFactor,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalSbrRewardPerToken,
      totalStakedRaw,
      userPendingCollateral: BigInt(0),
      userPendingReward: BigInt(0),
      userPendingRewardAndCollateral: [BigInt(0), BigInt(0), BigInt(0)],
      users: {
        stake: BigInt(0),
        rewardSnapshot: BigInt(0),
        collateralSnapshot: BigInt(0),
        cumulativeProductScalingFactor: BigInt(0),
        stakeResetCount: BigInt(0),
      },
      isLiquidationPossible: false,
    };

    return snapshot;
  } catch (error: any) {
    console.error('Error taking StabilityPool snapshot:', error);
    throw new Error(`Failed to snapshot StabilityPool contract: ${error.message}`);
  }
}