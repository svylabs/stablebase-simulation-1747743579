// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StabilityPoolSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool state
 * @param contract - ethers.Contract instance
 * @param actors - An array of Actor instances.
 * @returns Promise returning the StabilityPoolSnapshot interface
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolSnapshot> {
  try {
    const collateralLoss = BigInt(await contract.collateralLoss());
    const lastSBRRewardDistributedTime = BigInt(await contract.lastSBRRewardDistributedTime());
    const minimumScalingFactor = BigInt(await contract.minimumScalingFactor());
    const precision = BigInt(await contract.precision());
    const rewardLoss = BigInt(await contract.rewardLoss());
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = BigInt(await contract.sbrDistributionRate());
    const sbrRewardDistributionEndTime = BigInt(await contract.sbrRewardDistributionEndTime());
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = BigInt(await contract.sbrRewardLoss());
    const stakeResetCount = BigInt(await contract.stakeResetCount());
    const stakeScalingFactor = BigInt(await contract.stakeScalingFactor());
    const totalCollateralPerToken = BigInt(await contract.totalCollateralPerToken());
    const totalRewardPerToken = BigInt(await contract.totalRewardPerToken());
    const totalSbrRewardPerToken = BigInt(await contract.totalSbrRewardPerToken());
    const totalStakedRaw = BigInt(await contract.totalStakedRaw());
    const liquidationPossible = await contract.isLiquidationPossible(1000); // using static value

    // Fetch user-specific data for all actors
    const userInfos: any[] = [];
    const userPendingCollaterals: bigint[] = [];
    const userPendingRewards: bigint[] = [];
    const userPendingRewardAndCollaterals: bigint[][] = [];
    const usersData: any[] = [];
    const sbrRewardSnapshotsData: any[] = [];
    const stakeResetSnapshotsData: any[] = [];

    for (const actor of actors) {
      const accountAddress = actor.accountAddress;
      userInfos.push(await contract.getUser(accountAddress));
      userPendingCollaterals.push(BigInt(await contract.userPendingCollateral(accountAddress)));
      userPendingRewards.push(BigInt(await contract.userPendingReward(accountAddress)));
      userPendingRewardAndCollaterals.push(await contract.userPendingRewardAndCollateral(accountAddress));
      usersData.push(await contract.users(accountAddress));
      sbrRewardSnapshotsData.push(await contract.sbrRewardSnapshots(accountAddress));

      // Handle stakeResetSnapshots using identifiers, defaulting to stakeResetCount if _safeId is absent
      let stakeResetValues: bigint[] = [stakeResetCount]; // Default to stakeResetCount

      const identifiers = actor.getIdentifiers();
      if (identifiers && identifiers['_safeId']) {
        // Assuming _safeId can be an array of stakeResetCounts
        stakeResetValues = Array.isArray(identifiers['_safeId']) ? identifiers['_safeId'].map(BigInt) : [BigInt(identifiers['_safeId'])];
      }

      const stakeResetSnapshotsForActor: any[] = [];
      for (const stakeResetValue of stakeResetValues) {
        stakeResetSnapshotsForActor.push(await contract.stakeResetSnapshots(stakeResetValue));
      }
      stakeResetSnapshotsData.push(stakeResetSnapshotsForActor);
    }


    // Construct the snapshot object
    const snapshot: StabilityPoolSnapshot = {
      collateralLoss,
      userInfo: userInfos.map((userInfo: any) => ({
        stake: BigInt(userInfo.stake),
        rewardSnapshot: BigInt(userInfo.rewardSnapshot),
        collateralSnapshot: BigInt(userInfo.collateralSnapshot),
        cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
        stakeResetCount: BigInt(userInfo.stakeResetCount),
      })),
      liquidationPossible,
      lastSBRRewardDistributedTime,
      minimumScalingFactor,
      precision,
      rewardLoss,
      rewardSenderActive,
      sbrDistributionRate,
      sbrRewardDistributionEndTime,
      sbrRewardDistributionStatus,
      sbrRewardLoss,
      sbrRewardSnapshots: sbrRewardSnapshotsData.map((sbrRewardSnapshots: any) => ({
        rewardSnapshot: BigInt(sbrRewardSnapshots.rewardSnapshot),
        status: sbrRewardSnapshots.status,
      })),
      stakeResetCount,
      stakeResetSnapshots: stakeResetSnapshotsData.map((stakeResetSnapshotsForActor: any[]) =>
        stakeResetSnapshotsForActor.map((stakeResetSnapshots: any) => ({
          scalingFactor: BigInt(stakeResetSnapshots.scalingFactor),
          totalRewardPerToken: BigInt(stakeResetSnapshots.totalRewardPerToken),
          totalCollateralPerToken: BigInt(stakeResetSnapshots.totalCollateralPerToken),
          totalSBRRewardPerToken: BigInt(stakeResetSnapshots.totalSBRRewardPerToken),
        }))
      ),
      stakeScalingFactor,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalSbrRewardPerToken,
      totalStakedRaw,
      userPendingCollateral: userPendingCollaterals,
      userPendingReward: userPendingRewards,
      userPendingRewardAndCollateral: userPendingRewardAndCollaterals,
      users: usersData.map((users: any) => ({
        stake: BigInt(users.stake),
        rewardSnapshot: BigInt(users.rewardSnapshot),
        collateralSnapshot: BigInt(users.collateralSnapshot),
        cumulativeProductScalingFactor: BigInt(users.cumulativeProductScalingFactor),
        stakeResetCount: BigInt(users.stakeResetCount),
      })),
    };

    return snapshot;
  } catch (error) {
    console.error('Error taking StabilityPool snapshot:', error);
    throw error;
  }
}
