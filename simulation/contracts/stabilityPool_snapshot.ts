// Generated by SnapshotCodeGenerator

import { ethers, Contract } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StabilityPoolSnapshot, UserInfo, SBRRewardSnapshots, StakeResetSnapshots, Users } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool contract state.
 * @param contract - ethers.Contract instance
 * @param actors - An array of Actor objects representing users.
 * @param amount - Amount to use for isLiquidationPossible test.
 * @returns Promise resolving to StabilityPoolSnapshot interface.
 */
export async function takestabilityPoolContractSnapshot(
  contract: Contract,
  actors: Actor[],
  amount: bigint
): Promise<StabilityPoolSnapshot> {
  try {
    const basisPointsDivisor = BigInt(await contract.BASIS_POINTS_DIVISOR());
    const collateralLoss = BigInt(await contract.collateralLoss());
    const lastSBRRewardDistributedTime = BigInt(await contract.lastSBRRewardDistributedTime());
    const minimumScalingFactor = BigInt(await contract.minimumScalingFactor());
    const precision = BigInt(await contract.precision());
    const rewardLoss = BigInt(await contract.rewardLoss());
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = BigInt(await contract.sbrDistributionRate());
    const sbrRewardDistributionEndTime = BigInt(await contract.sbrRewardDistributionEndTime());
    const sbrRewardDistributionStatus = Number(await contract.sbrRewardDistributionStatus());
    const sbrRewardLoss = BigInt(await contract.sbrRewardLoss());
    const stakeResetCount = BigInt(await contract.stakeResetCount());
    const stakeScalingFactor = BigInt(await contract.stakeScalingFactor());
    const totalCollateralPerToken = BigInt(await contract.totalCollateralPerToken());
    const totalRewardPerToken = BigInt(await contract.totalRewardPerToken());
    const totalSbrRewardPerToken = BigInt(await contract.totalSbrRewardPerToken());
    const totalStakedRaw = BigInt(await contract.totalStakedRaw());

    let userInfo: UserInfo = {
      stake: BigInt(0),
      rewardSnapshot: BigInt(0),
      collateralSnapshot: BigInt(0),
      cumulativeProductScalingFactor: BigInt(0),
      stakeResetCount: BigInt(0),
    };
    let sbrRewardSnapshots: SBRRewardSnapshots = {
      rewardSnapshot: BigInt(0),
      status: 0,
    };
    let stakeResetSnapshots: StakeResetSnapshots = {
      scalingFactor: BigInt(0),
      totalRewardPerToken: BigInt(0),
      totalCollateralPerToken: BigInt(0),
      totalSBRRewardPerToken: BigInt(0),
    };
    let users: Users = {
      stake: BigInt(0),
      rewardSnapshot: BigInt(0),
      collateralSnapshot: BigInt(0),
      cumulativeProductScalingFactor: BigInt(0),
      stakeResetCount: BigInt(0),
    };
    let userPendingCollateral: bigint = BigInt(0);
    let userPendingReward: bigint = BigInt(0);
    let userPendingRewardAndCollateral: [bigint, bigint, bigint] = [BigInt(0), BigInt(0), BigInt(0)];

    // Fetch user-specific data only if actors exist
    if (actors && actors.length > 0) {
      const accountAddress = actors[0].getIdentifiers().accountAddress as string;

      // Check if accountAddress is valid before proceeding
      if (accountAddress) {
        try {
          userInfo = (await contract.getUser(accountAddress)) as UserInfo;
        } catch (error: any) {
          console.error(`Error fetching userInfo for ${accountAddress}:`, error);
        }

        try {
          sbrRewardSnapshots = (await contract.sbrRewardSnapshots(accountAddress)) as SBRRewardSnapshots;
        } catch (error: any) {
          console.error(`Error fetching sbrRewardSnapshots for ${accountAddress}:`, error);
        }
        try {
          users = (await contract.users(accountAddress)) as Users;
        } catch (error: any) {
          console.error(`Error fetching users for ${accountAddress}:`, error);
        }

        try {
          userPendingCollateral = BigInt(await contract.userPendingCollateral(accountAddress));
        } catch (error: any) {
          console.error(`Error fetching userPendingCollateral for ${accountAddress}:`, error);
        }

        try {
          userPendingReward = BigInt(await contract.userPendingReward(accountAddress));
        } catch (error: any) {
          console.error(`Error fetching userPendingReward for ${accountAddress}:`, error);
        }

        try {
          const result = await contract.userPendingRewardAndCollateral(accountAddress);
          userPendingRewardAndCollateral = [BigInt(result[0]), BigInt(result[1]), BigInt(result[2])];
        } catch (error: any) {
          console.error(`Error fetching userPendingRewardAndCollateral for ${accountAddress}:`, error);
        }
      }

       // Fetch stakeResetSnapshots only if stakeResetCount > 0 and less than max uint256
      if (Number(stakeResetCount) > 0) {
          try {
              stakeResetSnapshots = (await contract.stakeResetSnapshots(Number(stakeResetCount) - 1)) as StakeResetSnapshots;
          } catch (error: any) {
              console.error(`Error fetching stakeResetSnapshots:`, error);
          }
      }
    }

    const liquidationPossible = actors && actors.length > 0 ? await contract.isLiquidationPossible(amount) : false;

    const snapshot: StabilityPoolSnapshot = {
      basisPointsDivisor,
      collateralLoss,
      userInfo,
      liquidationPossible,
      lastSBRRewardDistributedTime,
      minimumScalingFactor,
      precision,
      rewardLoss,
      rewardSenderActive,
      sbrDistributionRate,
      sbrRewardDistributionEndTime,
      sbrRewardDistributionStatus,
      sbrRewardLoss,
      sbrRewardSnapshots,
      stakeResetCount,
      stakeResetSnapshots,
      stakeScalingFactor,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalSbrRewardPerToken,
      totalStakedRaw,
      users,
      userPendingCollateral,
      userPendingReward,
      userPendingRewardAndCollateral,
    };

    return snapshot;
  } catch (error: any) {
    console.error('Error taking StabilityPool snapshot:', error);
    throw new Error(`Failed to take StabilityPool snapshot: ${error.message}`);
  }
}
