// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StabilityPoolStateSnapshot, StabilityPoolUserSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool contract state
 * @param contract - ethers.Contract instance
 * @returns Promise resolving to StabilityPoolStateSnapshot
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract): Promise<StabilityPoolStateSnapshot> {
  try {
    const collateralLoss = await contract.collateralLoss();
    const lastSBRRewardDistributedTime = await contract.lastSBRRewardDistributedTime();
    const minimumScalingFactor = await contract.minimumScalingFactor();
    const precision = await contract.precision();
    const rewardLoss = await contract.rewardLoss();
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = await contract.sbrDistributionRate();
    const sbrRewardDistributionEndTime = await contract.sbrRewardDistributionEndTime();
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = await contract.sbrRewardLoss();
    const stakeResetCount = await contract.stakeResetCount();
    const stakeScalingFactor = await contract.stakeScalingFactor();
    const totalCollateralPerToken = await contract.totalCollateralPerToken();
    const totalRewardPerToken = await contract.totalRewardPerToken();
    const totalSbrRewardPerToken = await contract.totalSbrRewardPerToken();
    const totalStakedRaw = await contract.totalStakedRaw();

    // Fetch stake reset snapshots
    const stakeResetSnapshots = [];
    for (let i = 0; i < Number(stakeResetCount); i++) {
      const snapshot = await contract.stakeResetSnapshots(i);
      stakeResetSnapshots.push({
        scalingFactor: BigInt(snapshot.scalingFactor.toString()),
        totalRewardPerToken: BigInt(snapshot.totalRewardPerToken.toString()),
        totalCollateralPerToken: BigInt(snapshot.totalCollateralPerToken.toString()),
        totalSBRRewardPerToken: BigInt(snapshot.totalSBRRewardPerToken.toString()),
      });
    }

    const snapshot: StabilityPoolStateSnapshot = {
      collateralLoss: BigInt(collateralLoss.toString()),
      lastSBRRewardDistributedTime: BigInt(lastSBRRewardDistributedTime.toString()),
      minimumScalingFactor: BigInt(minimumScalingFactor.toString()),
      precision: BigInt(precision.toString()),
      rewardLoss: BigInt(rewardLoss.toString()),
      rewardSenderActive: rewardSenderActive,
      sbrDistributionRate: BigInt(sbrDistributionRate.toString()),
      sbrRewardDistributionEndTime: BigInt(sbrRewardDistributionEndTime.toString()),
      sbrRewardDistributionStatus: sbrRewardDistributionStatus,
      sbrRewardLoss: BigInt(sbrRewardLoss.toString()),
      stakeResetCount: BigInt(stakeResetCount.toString()),
      stakeScalingFactor: BigInt(stakeScalingFactor.toString()),
      totalCollateralPerToken: BigInt(totalCollateralPerToken.toString()),
      totalRewardPerToken: BigInt(totalRewardPerToken.toString()),
      totalSbrRewardPerToken: BigInt(totalSbrRewardPerToken.toString()),
      totalStakedRaw: BigInt(totalStakedRaw.toString()),
      stakeResetSnapshots: stakeResetSnapshots,
    };

    return snapshot;
  } catch (error) {
    console.error('Error taking StabilityPool contract snapshot:', error);
    throw error;
  }
}

/**
 * Takes a snapshot of StabilityPool user-specific data
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects, each representing a user
 * @returns Promise resolving to an array of StabilityPoolUserSnapshot
 */
export async function takestabilityPoolUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolUserSnapshot[]> {
  const userSnapshots: StabilityPoolUserSnapshot[] = [];

  for (const actor of actors) {
    try {
      const accountAddress = actor.accountAddress;

      const userInfo = await contract.getUser(accountAddress);
      const pendingReward = await contract.userPendingReward(accountAddress);
      const pendingCollateral = await contract.userPendingCollateral(accountAddress);
      const sbrRewardSnapshotData = await contract.sbrRewardSnapshots(accountAddress);

      const snapshot: StabilityPoolUserSnapshot = {
        userInfo: {
          stake: BigInt(userInfo.stake.toString()),
          rewardSnapshot: BigInt(userInfo.rewardSnapshot.toString()),
          collateralSnapshot: BigInt(userInfo.collateralSnapshot.toString()),
          cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor.toString()),
          stakeResetCount: BigInt(userInfo.stakeResetCount.toString()),
        },
        pendingReward: BigInt(pendingReward.toString()),
        pendingCollateral: BigInt(pendingCollateral.toString()),
        sbrRewardSnapshot: {
          rewardSnapshot: BigInt(sbrRewardSnapshotData.rewardSnapshot.toString()),
          status: sbrRewardSnapshotData.status
        }
      };

      userSnapshots.push(snapshot);
    } catch (error) {
      console.error(`Error taking StabilityPool user snapshot for address ${actor.accountAddress}:`, error);
      throw error;
    }
  }

  return userSnapshots;
}