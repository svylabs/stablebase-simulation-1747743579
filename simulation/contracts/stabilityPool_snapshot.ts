// Generated by SnapshotCodeGenerator

import { ethers } from "ethers"; import { Actor } from "@svylabs/ilumina"; import { StabilityPoolSBRRewardDistribution, IStabilityPoolUserInfo, IStabilityPoolSBRRewardSnapshotInfo, IStabilityPoolStakeResetSnapshot, StabilityPoolSnapshot } from "./snapshot_interfaces";

/**
 * Takes a snapshot of the StabilityPool contract state.
 * This function retrieves various state variables and mapping data from the StabilityPool contract.
 * It handles BigInt conversions and includes comprehensive error handling for each contract call.
 *
 * @param contract - The ethers.Contract instance connected to the StabilityPool contract.
 * @param actors - An array of Actor objects, each potentially containing an accountAddress for user-specific data.
 * @returns A Promise that resolves to a StabilityPoolSnapshot object, representing the current state.
 */
export async function takestabilityPoolContractSnapshot(
  contract: ethers.Contract,
  actors: Actor[]
): Promise<StabilityPoolSnapshot> {
  const snapshot: StabilityPoolSnapshot = {
    collateralLoss: 0n,
    lastSBRRewardDistributedTime: 0n,
    minimumScalingFactor: 0n,
    precision: 0n,
    rewardLoss: 0n,
    rewardSenderActive: false,
    sbrDistributionRate: 0n,
    sbrRewardDistributionEndTime: 0n,
    sbrRewardDistributionStatus: 0n, 
    sbrRewardLoss: 0n,
    stakeResetCount: 0n,
    stakeScalingFactor: 0n,
    totalCollateralPerToken: 0n,
    totalRewardPerToken: 0n,
    totalSbrRewardPerToken: 0n,
    totalStakedRaw: 0n,
    users: {},
    sbrRewardSnapshots: {},
    userPendingCollateral: {},
    userPendingReward: {},
    userPendingRewardAndCollateral: {},
    stakeResetSnapshots: [],
  };

  // --- 1. Fetch direct contract state variables (no parameters) ---
  const directAttributes = [
    { name: "collateralLoss", type: "bigint", contract_function: "collateralLoss" },
    { name: "lastSBRRewardDistributedTime", type: "bigint", contract_function: "lastSBRRewardDistributedTime" },
    { name: "minimumScalingFactor", type: "bigint", contract_function: "minimumScalingFactor" },
    { name: "precision", type: "bigint", contract_function: "precision" },
    { name: "rewardLoss", type: "bigint", contract_function: "rewardLoss" },
    { name: "rewardSenderActive", type: "boolean", contract_function: "rewardSenderActive" },
    { name: "sbrDistributionRate", type: "bigint", contract_function: "sbrDistributionRate" },
    { name: "sbrRewardDistributionEndTime", type: "bigint", contract_function: "sbrRewardDistributionEndTime" },
    { name: "sbrRewardDistributionStatus", type: "bigint", contract_function: "sbrRewardDistributionStatus" },
    { name: "sbrRewardLoss", type: "bigint", contract_function: "sbrRewardLoss" },
    { name: "stakeResetCount", type: "bigint", contract_function: "stakeResetCount" },
    { name: "stakeScalingFactor", type: "bigint", contract_function: "stakeScalingFactor" },
    { name: "totalCollateralPerToken", type: "bigint", contract_function: "totalCollateralPerToken" },
    { name: "totalRewardPerToken", type: "bigint", contract_function: "totalRewardPerToken" },
    { name: "totalSbrRewardPerToken", type: "bigint", contract_function: "totalSbrRewardPerToken" },
    { name: "totalStakedRaw", type: "bigint", contract_function: "totalStakedRaw" },
  ];

  for (const attr of directAttributes) {
    try {
      const value = await contract[attr.contract_function]();
      if (attr.type === "bigint") {
        (snapshot as any)[attr.name] = BigInt(value);
      } else if (attr.type === "boolean") {
        (snapshot as any)[attr.name] = value;
      } else {
        (snapshot as any)[attr.name] = value;
      }
    } catch (error) {
      console.error(`Error fetching StabilityPool.${attr.contract_function}:`, error);
      if (attr.type === "bigint") {
        (snapshot as any)[attr.name] = 0n;
      } else if (attr.type === "boolean") {
        (snapshot as any)[attr.name] = false;
      }
    }
  }

  // --- 2. Fetch user-specific data (using accountAddress from actors) ---
  for (const actor of actors) {
    const identifiers = actor.getIdentifiers();
    const accountAddress = identifiers.accountAddress;

    if (accountAddress) {
      // Fetch users (IStabilityPoolUserInfo)
      try {
        const userInfo = await contract.users(accountAddress);
        snapshot.users[accountAddress] = {
          stake: BigInt(userInfo.stake),
          rewardSnapshot: BigInt(userInfo.rewardSnapshot),
          collateralSnapshot: BigInt(userInfo.collateralSnapshot),
          cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
          stakeResetCount: BigInt(userInfo.stakeResetCount),
        };
      } catch (error) {
        console.error(`Error fetching StabilityPool.users for ${accountAddress}:`, error);
        snapshot.users[accountAddress] = {
          stake: 0n,
          rewardSnapshot: 0n,
          collateralSnapshot: 0n,
          cumulativeProductScalingFactor: 0n,
          stakeResetCount: 0n,
        };
      }

      // Fetch sbrRewardSnapshots (IStabilityPoolSBRRewardSnapshotInfo)
      try {
        const sbrRewardInfo = await contract.sbrRewardSnapshots(accountAddress);
        snapshot.sbrRewardSnapshots[accountAddress] = {
          rewardSnapshot: BigInt(sbrRewardInfo.rewardSnapshot),
          status: BigInt(sbrRewardInfo.status) as StabilityPoolSBRRewardDistribution,
        };
      } catch (error) {
        console.error(`Error fetching StabilityPool.sbrRewardSnapshots for ${accountAddress}:`, error);
        snapshot.sbrRewardSnapshots[accountAddress] = {
          rewardSnapshot: 0n,
          status: 0n as StabilityPoolSBRRewardDistribution,
        };
      }

      // Fetch userPendingCollateral (bigint)
      try {
        const pendingCollateral = await contract.userPendingCollateral(accountAddress);
        snapshot.userPendingCollateral[accountAddress] = BigInt(pendingCollateral);
      } catch (error) {
        console.error(`Error fetching StabilityPool.userPendingCollateral for ${accountAddress}:`, error);
        snapshot.userPendingCollateral[accountAddress] = 0n;
      }

      // Fetch userPendingReward (bigint)
      try {
        const pendingReward = await contract.userPendingReward(accountAddress);
        snapshot.userPendingReward[accountAddress] = BigInt(pendingReward);
      } catch (error) {
        console.error(`Error fetching StabilityPool.userPendingReward for ${accountAddress}:`, error);
        snapshot.userPendingReward[accountAddress] = 0n;
      }

      // Fetch userPendingRewardAndCollateral ([bigint, bigint, bigint])
      try {
        const pendingRewardsAndCollateral = await contract.userPendingRewardAndCollateral(accountAddress);
        snapshot.userPendingRewardAndCollateral[accountAddress] = [
          BigInt(pendingRewardsAndCollateral[0]),
          BigInt(pendingRewardsAndCollateral[1]),
          BigInt(pendingRewardsAndCollateral[2]),
        ];
      } catch (error) {
        console.error(`Error fetching StabilityPool.userPendingRewardAndCollateral for ${accountAddress}:`, error);
        snapshot.userPendingRewardAndCollateral[accountAddress] = [0n, 0n, 0n];
      }
    }
  }

  // --- 3. Fetch indexed mapping data (stakeResetSnapshots) ---
  // Requires stakeResetCount first, which is fetched in the direct attributes section.
  if (snapshot.stakeResetCount > 0n) {
    for (let i = 0n; i < snapshot.stakeResetCount; i++) {
      try {
        const stakeResetSnapshot = await contract.stakeResetSnapshots(i);
        snapshot.stakeResetSnapshots.push({
          scalingFactor: BigInt(stakeResetSnapshot.scalingFactor),
          totalRewardPerToken: BigInt(stakeResetSnapshot.totalRewardPerToken),
          totalCollateralPerToken: BigInt(stakeResetSnapshot.totalCollateralPerToken),
          totalSBRRewardPerToken: BigInt(stakeResetSnapshot.totalSBRRewardPerToken),
        });
      } catch (error) {
        console.error(`Error fetching StabilityPool.stakeResetSnapshots for index ${i}:`, error);
        snapshot.stakeResetSnapshots.push({
          scalingFactor: 0n,
          totalRewardPerToken: 0n,
          totalCollateralPerToken: 0n,
          totalSBRRewardPerToken: 0n,
        });
      }
    }
  }

  return snapshot;
}