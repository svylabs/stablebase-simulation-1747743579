// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { StabilityPoolStateSnapshot, StabilityPoolUserSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool contract state.
 *
 * @param contract - ethers.Contract instance of the StabilityPool contract.
 * @returns A Promise that resolves to a StabilityPoolStateSnapshot object.
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract): Promise<StabilityPoolStateSnapshot> {
  try {
    const collateralLoss = await contract.collateralLoss();
    const lastSBRRewardDistributedTime = await contract.lastSBRRewardDistributedTime();
    const minimumScalingFactor = await contract.minimumScalingFactor();
    const precision = await contract.precision();
    const rewardLoss = await contract.rewardLoss();
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = await contract.sbrDistributionRate();
    const sbrRewardDistributionEndTime = await contract.sbrRewardDistributionEndTime();
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = await contract.sbrRewardLoss();
    const stakeResetCount = await contract.stakeResetCount();
    const stakeScalingFactor = await contract.stakeScalingFactor();
    const totalCollateralPerToken = await contract.totalCollateralPerToken();
    const totalRewardPerToken = await contract.totalRewardPerToken();
    const totalSbrRewardPerToken = await contract.totalSbrRewardPerToken();
    const totalStakedRaw = await contract.totalStakedRaw();

    const stakeResetSnapshotsLength = Number(stakeResetCount);
    const stakeResetSnapshots = [];
    for (let i = 0; i < stakeResetSnapshotsLength; i++) {
      const snapshot = await contract.stakeResetSnapshots(i);
      stakeResetSnapshots.push({
        scalingFactor: BigInt(snapshot.scalingFactor),
        totalRewardPerToken: BigInt(snapshot.totalRewardPerToken),
        totalCollateralPerToken: BigInt(snapshot.totalCollateralPerToken),
        totalSBRRewardPerToken: BigInt(snapshot.totalSBRRewardPerToken),
      });
    }

    const snapshot: StabilityPoolStateSnapshot = {
      collateralLoss: BigInt(collateralLoss),
      lastSBRRewardDistributedTime: BigInt(lastSBRRewardDistributedTime),
      minimumScalingFactor: BigInt(minimumScalingFactor),
      precision: BigInt(precision),
      rewardLoss: BigInt(rewardLoss),
      rewardSenderActive,
      sbrDistributionRate: BigInt(sbrDistributionRate),
      sbrRewardDistributionEndTime: BigInt(sbrRewardDistributionEndTime),
      sbrRewardDistributionStatus,
      sbrRewardLoss: BigInt(sbrRewardLoss),
      stakeResetCount: BigInt(stakeResetCount),
      stakeScalingFactor: BigInt(stakeScalingFactor),
      totalCollateralPerToken: BigInt(totalCollateralPerToken),
      totalRewardPerToken: BigInt(totalRewardPerToken),
      totalSbrRewardPerToken: BigInt(totalSbrRewardPerToken),
      totalStakedRaw: BigInt(totalStakedRaw),
      stakeResetSnapshots,
    };

    return snapshot;
  } catch (error) {
    console.error('Error taking StabilityPool contract snapshot:', error);
    throw error;
  }
}

/**
 * Takes a snapshot of StabilityPool user-specific data.
 *
 * @param contract - ethers.Contract instance of the StabilityPool contract.
 * @param actor - Actor containing the account address to fetch user data for.
 * @returns A Promise that resolves to a StabilityPoolUserSnapshot object.
 */
export async function takestabilityPoolUserSnapshot(contract: ethers.Contract, actor: Actor): Promise<StabilityPoolUserSnapshot> {
  try {
    const accountAddress = actor.accountAddress;

    if (!accountAddress) {
      throw new Error('Account address is required to take a user snapshot.');
    }

    const userInfo = await contract.getUser(accountAddress);
    const pendingReward = await contract.userPendingReward(accountAddress);
    const pendingCollateral = await contract.userPendingCollateral(accountAddress);
    const sbrRewardSnapshots = await contract.sbrRewardSnapshots(accountAddress);

    const snapshot: StabilityPoolUserSnapshot = {
      userInfo: {
        stake: BigInt(userInfo.stake),
        rewardSnapshot: BigInt(userInfo.rewardSnapshot),
        collateralSnapshot: BigInt(userInfo.collateralSnapshot),
        cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
        stakeResetCount: BigInt(userInfo.stakeResetCount),
      },
      pendingReward: BigInt(pendingReward),
      pendingCollateral: BigInt(pendingCollateral),
      sbrRewardSnapshot: {
        rewardSnapshot: BigInt(sbrRewardSnapshots.rewardSnapshot),
        status: sbrRewardSnapshots.status,
      },
    };

    return snapshot;
  } catch (error) {
    console.error('Error taking StabilityPool user snapshot:', error);
    throw error;
  }
}
