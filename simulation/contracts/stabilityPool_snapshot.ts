// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StabilityPoolStateSnapshot, StabilityPoolUserSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool contract state.
 * @param contract - ethers.Contract instance of the StabilityPool contract.
 * @returns Promise resolving to a StabilityPoolStateSnapshot interface.
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract): Promise<StabilityPoolStateSnapshot> {
    try {
        const collateralLoss = await contract.collateralLoss();
        const lastSBRRewardDistributedTime = await contract.lastSBRRewardDistributedTime();
        const minimumScalingFactor = await contract.minimumScalingFactor();
        const precision = await contract.precision();
        const rewardLoss = await contract.rewardLoss();
        const rewardSenderActive = await contract.rewardSenderActive();
        const sbrDistributionRate = await contract.sbrDistributionRate();
        const sbrRewardDistributionEndTime = await contract.sbrRewardDistributionEndTime();
        const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
        const sbrRewardLoss = await contract.sbrRewardLoss();
        const stakeResetCount = await contract.stakeResetCount();
        const stakeScalingFactor = await contract.stakeScalingFactor();
        const totalCollateralPerToken = await contract.totalCollateralPerToken();
        const totalRewardPerToken = await contract.totalRewardPerToken();
        const totalSbrRewardPerToken = await contract.totalSbrRewardPerToken();
        const totalStakedRaw = await contract.totalStakedRaw();

        // Fetch stakeResetSnapshots
        const stakeResetSnapshots = [];
        // Iterate through the stake reset count to fetch each snapshot
        for (let i = 0; i < Number(stakeResetCount); i++) {
            const snapshot = await contract.stakeResetSnapshots(i);
            stakeResetSnapshots.push({
                scalingFactor: BigInt(snapshot.scalingFactor),
                totalRewardPerToken: BigInt(snapshot.totalRewardPerToken),
                totalCollateralPerToken: BigInt(snapshot.totalCollateralPerToken),
                totalSBRRewardPerToken: BigInt(snapshot.totalSBRRewardPerToken),
            });
        }

        return {
            collateralLoss: BigInt(collateralLoss),
            lastSBRRewardDistributedTime: BigInt(lastSBRRewardDistributedTime),
            minimumScalingFactor: BigInt(minimumScalingFactor),
            precision: BigInt(precision),
            rewardLoss: BigInt(rewardLoss),
            rewardSenderActive,
            sbrDistributionRate: BigInt(sbrDistributionRate),
            sbrRewardDistributionEndTime: BigInt(sbrRewardDistributionEndTime),
            sbrRewardDistributionStatus,
            sbrRewardLoss: BigInt(sbrRewardLoss),
            stakeResetCount: BigInt(stakeResetCount),
            stakeScalingFactor: BigInt(stakeScalingFactor),
            totalCollateralPerToken: BigInt(totalCollateralPerToken),
            totalRewardPerToken: BigInt(totalRewardPerToken),
            totalSbrRewardPerToken: BigInt(totalSbrRewardPerToken),
            totalStakedRaw: BigInt(totalStakedRaw),
            stakeResetSnapshots
        };
    } catch (error) {
        console.error('Error taking StabilityPool contract snapshot:', error);
        throw error;
    }
}

/**
 * Takes a snapshot of StabilityPool user-specific data.
 * @param contract - ethers.Contract instance of the StabilityPool contract.
 * @param actors - Array of Actor objects, each representing a user.
 * @returns Promise resolving to an array of StabilityPoolUserSnapshot interfaces.
 */
export async function takestabilityPoolUserSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolUserSnapshot[]> {
    const userSnapshots: StabilityPoolUserSnapshot[] = [];

    for (const actor of actors) {
        try {
            const accountAddress = actor.accountAddress;
            if (!accountAddress) {
                console.warn(`Skipping actor without accountAddress: ${actor}`);
                continue;
            }

            const userInfo = await contract.users(accountAddress);
            const pendingReward = await contract.userPendingReward(accountAddress);
            const pendingCollateral = await contract.userPendingCollateral(accountAddress);
            const sbrRewardSnapshots = await contract.sbrRewardSnapshots(accountAddress);

            userSnapshots.push({
                userInfo: {
                    stake: BigInt(userInfo.stake),
                    rewardSnapshot: BigInt(userInfo.rewardSnapshot),
                    collateralSnapshot: BigInt(userInfo.collateralSnapshot),
                    cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
                    stakeResetCount: BigInt(userInfo.stakeResetCount)
                },
                pendingReward: BigInt(pendingReward),
                pendingCollateral: BigInt(pendingCollateral),
                sbrRewardSnapshot: {
                    rewardSnapshot: BigInt(sbrRewardSnapshots.rewardSnapshot),
                    status: sbrRewardSnapshots.status
                }
            });
        } catch (error) {
            console.error(`Error taking StabilityPool user snapshot for actor ${actor.accountAddress}:`, error);
            throw error;
        }
    }

    return userSnapshots;
}