// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { IStabilityPoolSnapshot, IUserInfo } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface IStabilityPoolSnapshot
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<IStabilityPoolSnapshot> {
  try {
    // Fetch simple values first
    const collateralLoss = BigInt(await contract.collateralLoss());
    const lastSBRRewardDistributedTime = BigInt(await contract.lastSBRRewardDistributedTime());
    const minimumScalingFactor = BigInt(await contract.minimumScalingFactor());
    const rewardLoss = BigInt(await contract.rewardLoss());
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = BigInt(await contract.sbrDistributionRate());
    const sbrRewardDistributionEndTime = BigInt(await contract.sbrRewardDistributionEndTime());
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = BigInt(await contract.sbrRewardLoss());
    const stakeResetCount = BigInt(await contract.stakeResetCount());
    const stakeScalingFactor = BigInt(await contract.stakeScalingFactor());
    const totalCollateralPerToken = BigInt(await contract.totalCollateralPerToken());
    const totalRewardPerToken = BigInt(await contract.totalRewardPerToken());
    const totalSbrRewardPerToken = BigInt(await contract.totalSbrRewardPerToken());
    const totalStakedRaw = BigInt(await contract.totalStakedRaw());

    // Fetch complex values
    const users: { [accountAddress: string]: IUserInfo } = {};
    const userPendingCollateral: { [accountAddress: string]: bigint } = {};
    const userPendingReward: { [accountAddress: string]: bigint } = {};
    const userPendingRewardAndCollateral: { [accountAddress: string]: [bigint, bigint, bigint] } = {};
    const sbrRewardSnapshots: { [accountAddress: string]: { rewardSnapshot: bigint; status: number } } = {};
    const stakeResetSnapshots: { [stakeResetCount: string]: { scalingFactor: bigint; totalRewardPerToken: bigint; totalCollateralPerToken: bigint; totalSBRRewardPerToken: bigint } } = {};


    // Populate user specific data
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      const userInfo = await contract.users(accountAddress) as IUserInfo;
      users[accountAddress] = {
          stake: BigInt(userInfo.stake),
          rewardSnapshot: BigInt(userInfo.rewardSnapshot),
          collateralSnapshot: BigInt(userInfo.collateralSnapshot),
          cumulativeProductScalingFactor: BigInt(userInfo.cumulativeProductScalingFactor),
          stakeResetCount: BigInt(userInfo.stakeResetCount),
      };
      userPendingCollateral[accountAddress] = BigInt(await contract.userPendingCollateral(accountAddress));
      userPendingReward[accountAddress] = BigInt(await contract.userPendingReward(accountAddress));

      const pendingRewardAndCollateral = await contract.userPendingRewardAndCollateral(accountAddress);
      userPendingRewardAndCollateral[accountAddress] = [
        BigInt(pendingRewardAndCollateral[0]),
        BigInt(pendingRewardAndCollateral[1]),
        BigInt(pendingRewardAndCollateral[2]),
      ];

      const sbrRewardSnapshot = await contract.sbrRewardSnapshots(accountAddress);
      sbrRewardSnapshots[accountAddress] = { rewardSnapshot: BigInt(sbrRewardSnapshot.rewardSnapshot), status: sbrRewardSnapshot.status };
    }

    // Fetch stakeResetSnapshots for all stakeResetCounts up to the current one
    for (let i = 0n; i <= stakeResetCount; i++) {
        try {
            const stakeResetSnapshot = await contract.stakeResetSnapshots(i);
            stakeResetSnapshots[i.toString()] = {
                scalingFactor: BigInt(stakeResetSnapshot.scalingFactor),
                totalRewardPerToken: BigInt(stakeResetSnapshot.totalRewardPerToken),
                totalCollateralPerToken: BigInt(stakeResetSnapshot.totalCollateralPerToken),
                totalSBRRewardPerToken: BigInt(stakeResetSnapshot.totalSBRRewardPerToken)
            };
        } catch (error) {
            console.warn(`Could not fetch stakeResetSnapshot for count ${i.toString()}:`, error);
            // It's possible that some stakeResetCounts don't exist, so we catch the error and continue
        }
    }

    // Determine isLiquidationPossible based on actor identifiers
    let isLiquidationPossible = false;
    for (const actor of actors) {
        const identifiers = actor.getIdentifiers();
        if (identifiers && identifiers.amount) {
            // Assuming 'amount' is the amount to check for liquidation possibility
            const amount = BigInt(identifiers.amount as string);
            isLiquidationPossible = await contract.isLiquidationPossible(amount);
            break; // Assuming we only need to check one actor for liquidation possibility
        }
    }

    const stabilityPoolSnapshot: IStabilityPoolSnapshot = {
      collateralLoss,
      users,
      isLiquidationPossible,
      lastSBRRewardDistributedTime,
      minimumScalingFactor,
      rewardLoss,
      rewardSenderActive,
      sbrDistributionRate,
      sbrRewardDistributionEndTime,
      sbrRewardDistributionStatus,
      sbrRewardLoss,
      sbrRewardSnapshots,
      stakeResetCount,
      stakeResetSnapshots,
      stakeScalingFactor,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalSbrRewardPerToken,
      totalStakedRaw,
      userPendingCollateral,
      userPendingReward,
      userPendingRewardAndCollateral,
    };

    return stabilityPoolSnapshot;
  } catch (error) {
    console.error('Error taking StabilityPool snapshot:', error);
    throw error;
  }
}
