// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { StabilityPoolSnapshot, UserInfo, StakeResetSnapshot, SBRRewardSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of StabilityPool state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances to fetch user-specific data
 * @returns Promise returning the interface StabilityPoolSnapshot
 */
export async function takestabilityPoolContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<StabilityPoolSnapshot> {
  try {
    const collateralLoss = BigInt(await contract.collateralLoss());
    const minimumScalingFactor = BigInt(await contract.minimumScalingFactor());
    const precision = BigInt(await contract.precision());
    const rewardLoss = BigInt(await contract.rewardLoss());
    const rewardSenderActive = await contract.rewardSenderActive();
    const sbrDistributionRate = BigInt(await contract.sbrDistributionRate());
    const sbrRewardDistributionEndTime = BigInt(await contract.sbrRewardDistributionEndTime());
    const sbrRewardDistributionStatus = await contract.sbrRewardDistributionStatus();
    const sbrRewardLoss = BigInt(await contract.sbrRewardLoss());
    const stakeResetCount = BigInt(await contract.stakeResetCount());
    const stakeScalingFactor = BigInt(await contract.stakeScalingFactor());
    const totalCollateralPerToken = BigInt(await contract.totalCollateralPerToken());
    const totalRewardPerToken = BigInt(await contract.totalRewardPerToken());
    const totalSbrRewardPerToken = BigInt(await contract.totalSbrRewardPerToken());
    const totalStakedRaw = BigInt(await contract.totalStakedRaw());
    const lastSBRRewardDistributedTime = BigInt(await contract.lastSBRRewardDistributedTime());

    // Fetch user-specific data
    const users: { [accountAddress: string]: UserInfo } = {};
    const sbrRewardSnapshots: { [accountAddress: string]: SBRRewardSnapshot } = {};

    for (const actor of actors) {
      const accountAddress = actor.accountAddress;
      try {
        const userData = await contract.users(accountAddress);
        users[accountAddress] = {
          stake: BigInt(userData.stake),
          rewardSnapshot: BigInt(userData.rewardSnapshot),
          collateralSnapshot: BigInt(userData.collateralSnapshot),
          cumulativeProductScalingFactor: BigInt(userData.cumulativeProductScalingFactor),
          stakeResetCount: BigInt(userData.stakeResetCount),
        };

        const sbrRewardSnapshot = await contract.sbrRewardSnapshots(accountAddress);
        sbrRewardSnapshots[accountAddress] = {
            rewardSnapshot: BigInt(sbrRewardSnapshot.rewardSnapshot),
            status: sbrRewardSnapshot.status,
        };

      } catch (userError: any) {
        console.error(`Error fetching user data for ${accountAddress}:`, userError);
        // Initialize with default values or re-throw the error based on your needs
        users[accountAddress] = {
          stake: BigInt(0),
          rewardSnapshot: BigInt(0),
          collateralSnapshot: BigInt(0),
          cumulativeProductScalingFactor: BigInt(0),
          stakeResetCount: BigInt(0),
        };

        sbrRewardSnapshots[accountAddress] = {
            rewardSnapshot: BigInt(0),
            status: 0,
        };

      }
    }

    // Fetch stake reset snapshots
    const stakeResetSnapshots: { [stakeResetCount: string]: StakeResetSnapshot } = {};
    // Create an array of stake reset counts, we can only query for existing resets. Use a maximum of 100 for safety, as on-chain queries are expensive.
    const stakeResetCountArray = Array.from({ length: Number(stakeResetCount) < 100 ? Number(stakeResetCount) : 100 }, (_, i) => i);

    for (const i of stakeResetCountArray) {
        const resetCount = BigInt(i + 1)
        try {
            const snapshot = await contract.stakeResetSnapshots(resetCount);
            stakeResetSnapshots[resetCount.toString()] = {
                scalingFactor: BigInt(snapshot.scalingFactor),
                totalRewardPerToken: BigInt(snapshot.totalRewardPerToken),
                totalCollateralPerToken: BigInt(snapshot.totalCollateralPerToken),
                totalSBRRewardPerToken: BigInt(snapshot.totalSBRRewardPerToken),
            };
        } catch (resetError: any) {
            console.error(`Error fetching stake reset snapshot for count ${resetCount.toString()}:`, resetError);
             stakeResetSnapshots[resetCount.toString()] = {
                scalingFactor: BigInt(0),
                totalRewardPerToken: BigInt(0),
                totalCollateralPerToken: BigInt(0),
                totalSBRRewardPerToken: BigInt(0),
            };
        }
    }

    return {
      collateralLoss,
      minimumScalingFactor,
      precision,
      rewardLoss,
      rewardSenderActive,
      sbrDistributionRate,
      sbrRewardDistributionEndTime,
      sbrRewardDistributionStatus,
      sbrRewardLoss,
      stakeResetCount,
      stakeScalingFactor,
      totalCollateralPerToken,
      totalRewardPerToken,
      totalSbrRewardPerToken,
      totalStakedRaw,
      users,
      stakeResetSnapshots,
      sbrRewardSnapshots,
      lastSBRRewardDistributedTime
    };
  } catch (error: any) {
    console.error('Error taking StabilityPool snapshot:', error);
    throw new Error(`Failed to snapshot StabilityPool contract: ${error.message}`);
  }
}
