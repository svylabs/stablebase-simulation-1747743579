// Generated by SnapshotCodeGenerator

import {ethers} from "ethers";
import {Actor} from "@svylabs/ilumina";
import {Node, OrderedDoublyLinkedListSnapshot} from "./snapshot_interfaces.ts";

/**
 * Takes a snapshot of OrderedDoublyLinkedList contract state, specifically focusing on 'safesOrderedForRedemption'.
 * This function captures the head, tail, and all relevant nodes associated with 'safeId' identifiers.
 * @param contract - The ethers.Contract instance connected to the OrderedDoublyLinkedList contract.
 * @param actors - An array of Actor objects, each potentially containing 'safeId' identifiers to query node data.
 * @returns A Promise that resolves to an OrderedDoublyLinkedListSnapshot object representing the contract's state.
 * @throws {Error} If any contract call fails or if data parsing encounters an issue.
 */
export async function takesafesOrderedForRedemptionContractSnapshot(
  contract: ethers.Contract,
  actors: Actor[]
): Promise<OrderedDoublyLinkedListSnapshot> {
  const snapshot: OrderedDoublyLinkedListSnapshot = {
    headId: BigInt(0),
    tailId: BigInt(0),
    nodes: {},
  };

  try {
    // Fetch headId
    const headId = await contract.getHead();
    snapshot.headId = BigInt(headId);
  } catch (error) {
    throw new Error(`Failed to fetch headId from contract: ${error}`);
  }

  try {
    // Fetch tailId
    const tailId = await contract.getTail();
    snapshot.tailId = BigInt(tailId);
  } catch (error) {
    throw new Error(`Failed to fetch tailId from contract: ${error}`);
  }

  // Collect all unique safeIds from actors
  const safeIdsToFetch = new Set<bigint>();
  for (const actor of actors) {
    const identifiers = actor.getIdentifiers();
    const safeId = identifiers.safeId;

    if (safeId) {
      if (Array.isArray(safeId)) {
        for (const id of safeId) {
          if (typeof id === 'bigint' || typeof id === 'number' || typeof id === 'string') {
            safeIdsToFetch.add(BigInt(id));
          } else {
            console.warn(`Skipping invalid safeId type in actor identifiers: ${typeof id}`);
          }
        }
      } else if (typeof safeId === 'bigint' || typeof safeId === 'number' || typeof safeId === 'string') {
        safeIdsToFetch.add(BigInt(safeId));
      } else {
        console.warn(`Skipping invalid safeId type in actor identifiers: ${typeof safeId}`);
      }
    }
  }

  // Fetch node data for each unique safeId
  for (const id of safeIdsToFetch) {
    try {
      const nodeData = await contract.nodes(id);
      if (nodeData) {
        const node: Node = {
          value: BigInt(nodeData.value),
          prev: BigInt(nodeData.prev),
          next: BigInt(nodeData.next),
        };
        snapshot.nodes[id.toString()] = node;
      }
    } catch (error) {
      // Log the error but continue to fetch other nodes if one fails
      console.error(`Failed to fetch node data for safeId ${id.toString()}: ${error}`);
    }
  }

  return snapshot;
}
