// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { OrderedDoublyLinkedListSnapshot, Node } from './snapshot_interfaces';

/**
 * Takes a snapshot of the OrderedDoublyLinkedList contract state.
 *
 * This function retrieves the head, tail, owner, and node data from the contract,
 * mapping node data for each provided actor based on their '_safeId' identifiers.
 *
 * @param contract - An ethers.Contract instance connected to the OrderedDoublyLinkedList contract.
 * @param actors - An array of Actor instances, each representing a user or entity with associated identifiers.
 *
 * @returns A Promise that resolves to an OrderedDoublyLinkedListSnapshot object, representing the contract's state.
 *          The snapshot includes the head, tail, owner, and a map of node IDs to their corresponding Node objects.
 *          If an error occurs during the snapshot process, it is caught, logged, and re-thrown as an Error.
 */
export async function takesafesOrderedForRedemptionContractSnapshot(
  contract: ethers.Contract,
  actors: Actor[]
): Promise<OrderedDoublyLinkedListSnapshot> {
  try {
    const head: bigint = BigInt(await contract.head());
    const tail: bigint = BigInt(await contract.tail());
    const owner: string = await contract.owner();

    const nodes: { [key: string]: Node } = {};

    // Iterate through each actor to fetch node data based on their identifiers.
    for (const actor of actors) {
      try {
        const identifiers = actor.getIdentifiers();
        // Check if the actor has the '_safeId' identifier.
        if (identifiers._safeId) {
          // Ensure that safeIds is always an array to simplify processing.
          const safeIds: any[] = Array.isArray(identifiers._safeId) ? identifiers._safeId : [identifiers._safeId];

          // Iterate through each safeId to fetch and map the node data.
          for (const safeId of safeIds) {
            try {
              const nodeId: bigint = BigInt(safeId);
              const nodeData = await contract.getNode(nodeId);

              // Map the node data to the nodes object using the node ID as the key.
              nodes[nodeId.toString()] = {
                value: BigInt(nodeData.value),
                prev: BigInt(nodeData.prev),
                next: BigInt(nodeData.next),
              };
            } catch (nodeError: any) {
              // Log any errors that occur while fetching node data for a specific safeId.
              console.error(`Error fetching node data for safeId ${safeId}:`, nodeError);
            }
          }
        }
      } catch (actorError: any) {
        // Log any errors that occur while processing a specific actor.
        console.error(`Error processing actor:`, actorError);
      }
    }

    // Return the snapshot of the OrderedDoublyLinkedList contract state.
    return {
      head: head,
      tail: tail,
      nodes: nodes,
      owner: owner,
    };
  } catch (error: any) {
    // Log any errors that occur during the snapshot process.
    console.error('Error taking OrderedDoublyLinkedList snapshot:', error);
    // Re-throw the error to indicate that the snapshot process failed.
    throw new Error(`Failed to snapshot OrderedDoublyLinkedList contract: ${error.message}`);
  }
}