// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { OrderedDoublyLinkedListSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of OrderedDoublyLinkedList contract state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface OrderedDoublyLinkedListSnapshot
 */
export async function takesafesOrderedForRedemptionContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<OrderedDoublyLinkedListSnapshot> {
  try {
    const head = await contract.head();
    const tail = await contract.tail();
    const owner = await contract.owner();
    const listHead = await contract.getHead();
    const listTail = await contract.getTail();

    let nodeValue: {
      value: bigint;
      prev: bigint;
      next: bigint;
    } = { value: BigInt(0), prev: BigInt(0), next: BigInt(0) };
    let nodes: {
      value: bigint;
      prev: bigint;
      next: bigint;
    }[] = [];
    let totalFound: bigint = BigInt(0);

    // Process _safeId identifiers from actors
    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();
      if (identifiers && identifiers._safeId) {
        const safeIds = Array.isArray(identifiers._safeId) ? identifiers._safeId : [identifiers._safeId];

        for (const safeId of safeIds) {
          if (safeId !== undefined) {
            try {
              const node = await contract.nodes(safeId);
              nodeValue = {
                value: BigInt(node.value),
                prev: BigInt(node.prev),
                next: BigInt(node.next),
              };
            } catch (nodeError: any) {
              console.error(`Error fetching node for safeId ${safeId}:`, nodeError);
              // Handle the error appropriately, e.g., set default values or rethrow
              throw new Error(`Failed to fetch node for safeId ${safeId}: ${nodeError.message}`);
            }

            try {
               const getNodesResponse = await contract.getNodes(safeId, safeId);    
               totalFound = BigInt(getNodesResponse[1]);
               nodes = getNodesResponse[0].map((node: any) => ({
                    value: BigInt(node.value),
                    prev: BigInt(node.prev),
                    next: BigInt(node.next),
                  }));
            } catch (nodesError: any) {
               console.error(`Error fetching nodes for safeId ${safeId}:`, nodesError);
               throw new Error(`Failed to fetch nodes for safeId ${safeId}: ${nodesError.message}`);
             }
          }
        }
      }
    }

    const snapshot: OrderedDoublyLinkedListSnapshot = {
      head: BigInt(head),
      tail: BigInt(tail),
      nodeValue: nodeValue,
      nodes: nodes,
      totalFound: totalFound,
      listHead: BigInt(listHead),
      listTail: BigInt(listTail),
      owner: owner,
    };

    return snapshot;
  } catch (error: any) {
    console.error('Error taking OrderedDoublyLinkedList snapshot:', error);
    throw new Error(`Failed to take OrderedDoublyLinkedList snapshot: ${error.message}`);
  }
}
