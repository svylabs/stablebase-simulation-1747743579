// Generated by SnapshotCodeGenerator

import { ethers } from "ethers";import { Actor } from "@svylabs/ilumina";import { DFIDTokenContractSnapshot } from "./snapshot_interfaces";/** * Takes a snapshot of DFIDToken contract state. * @param contract - ethers.Contract instance for the DFIDToken contract. * @param actors - An array of Actor instances, each representing a user whose account-specific data needs to be snapshotted. * @returns Promise returning the DFIDTokenContractSnapshot. */export async function takedfidTokenContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIDTokenContractSnapshot> {  const snapshot: DFIDTokenContractSnapshot = {    accountBalances: {},    accountAllowances: {},    tokenName: "",    tokenSymbol: "",    tokenDecimals: 0n,    tokenTotalSupply: 0n,    contractOwner: "",    totalTokensBurned: 0n,  };  const uniqueAccountAddresses = Array.from(new Set(actors.map(actor => actor.getIdentifiers().accountAddress as string)));  for (const accountAddress of uniqueAccountAddresses) {    if (!ethers.utils.isAddress(accountAddress)) {      console.warn(`Invalid accountAddress encountered for balanceOf: ${accountAddress}. Skipping.`);      continue;    }    try {      const balance = await contract.balanceOf(accountAddress);      snapshot.accountBalances[accountAddress] = balance.toBigInt();    } catch (error: any) {      console.error(`Error fetching balance for ${accountAddress}: ${error.message}`);      snapshot.accountBalances[accountAddress] = 0n;    }  }  for (const ownerAddress of uniqueAccountAddresses) {    if (!ethers.utils.isAddress(ownerAddress)) {      console.warn(`Invalid ownerAddress encountered for allowance: ${ownerAddress}. Skipping.`);      continue;    }    snapshot.accountAllowances[ownerAddress] = {};    for (const spenderAddress of uniqueAccountAddresses) {      if (!ethers.utils.isAddress(spenderAddress)) {        console.warn(`Invalid spenderAddress encountered for allowance: ${spenderAddress}. Skipping.`);        continue;      }      try {        const allowance = await contract.allowance(ownerAddress, spenderAddress);        snapshot.accountAllowances[ownerAddress][spenderAddress] = allowance.toBigInt();      } catch (error: any) {        console.error(`Error fetching allowance for owner ${ownerAddress} and spender ${spenderAddress}: ${error.message}`);        snapshot.accountAllowances[ownerAddress][spenderAddress] = 0n;      }    }  }  try {    snapshot.tokenName = await contract.name();  } catch (error: any) {    console.error(`Error fetching tokenName: ${error.message}`);    snapshot.tokenName = "Unknown";  }  try {    snapshot.tokenSymbol = await contract.symbol();  } catch (error: any) {    console.error(`Error fetching tokenSymbol: ${error.message}`);    snapshot.tokenSymbol = "UNKNOWN";  }  try {    const decimals = await contract.decimals();    snapshot.tokenDecimals = decimals.toBigInt();  } catch (error: any) {    console.error(`Error fetching tokenDecimals: ${error.message}`);    snapshot.tokenDecimals = 0n;  }  try {    const totalSupply = await contract.totalSupply();    snapshot.tokenTotalSupply = totalSupply.toBigInt();  } catch (error: any) {    console.error(`Error fetching tokenTotalSupply: ${error.message}`);    snapshot.tokenTotalSupply = 0n;  }  try {    snapshot.contractOwner = await contract.owner();  } catch (error: any) {    console.error(`Error fetching contractOwner: ${error.message}`);    snapshot.contractOwner = ethers.constants.AddressZero;  }  try {    const totalBurned = await contract.totalBurned();    snapshot.totalTokensBurned = totalBurned.toBigInt();  } catch (error: any) {    console.error(`Error fetching totalTokensBurned: ${error.message}`);    snapshot.totalTokensBurned = 0n;  }  return snapshot;}