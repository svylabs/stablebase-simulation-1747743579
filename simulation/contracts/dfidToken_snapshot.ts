// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { DFIDTokenSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIDToken state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances. Each actor should have an 'accountAddress' identifier.
 * @returns Promise returning the interface DFIDTokenSnapshot
 */
export async function takedfidTokenContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIDTokenSnapshot> {
  try {
    const contractAddress = await contract.getAddress();
    const allowances: { [owner: string]: { [spender: string]: bigint } } = {};
    const balances: { [account: string]: bigint } = {};

    // Fetch decimals, name, owner, symbol, totalBurned, and totalSupply in parallel
    const [decimals, name, owner, symbol, totalBurned, totalSupply] = await Promise.all([
      contract.decimals(),
      contract.name(),
      contract.owner(),
      contract.symbol(),
      contract.totalBurned(),
      contract.totalSupply(),
    ]);

    // Iterate through each actor to fetch account-specific data
    for (const actor of actors) {
      const accountAddress = actor.getIdentifiers().accountAddress as string;

      // Fetch account balance
      try {
        balances[accountAddress] = (await contract.balanceOf(accountAddress)) as bigint;
      } catch (err: any) {
        console.error(`Error fetching balance for account ${accountAddress} on contract ${contractAddress}: ${err.message}`);
        balances[accountAddress] = BigInt(0);
      }

      // Fetch allowances for each spender that the account has approved
      allowances[accountAddress] = {};

      // Check if the actor has a 'spenders' identifier, otherwise default to all actors
      const spenders = (actor.getIdentifiers().spenders as string[]) || actors.map(a => a.getIdentifiers().accountAddress as string);

      for (const spenderAddress of spenders) {
          if(typeof spenderAddress !== 'string') continue;
        try {
          allowances[accountAddress][spenderAddress] = (await contract.allowance(accountAddress, spenderAddress)) as bigint;
        } catch (err: any) {
          console.error(`Error fetching allowance for owner ${accountAddress} and spender ${spenderAddress} on contract ${contractAddress}: ${err.message}`);
          allowances[accountAddress][spenderAddress] = BigInt(0);
        }
      }
    }

    const snapshot: DFIDTokenSnapshot = {
      allowances,
      balances,
      decimals: decimals,
      name: name,
      owner: owner,
      symbol: symbol,
      totalBurned: totalBurned as bigint,
      totalSupply: totalSupply as bigint,
    };

    return snapshot;
  } catch (error: any) {
    console.error("Error taking DFIDToken contract snapshot:", error);
    throw new Error(`Failed to take DFIDToken contract snapshot: ${error.message}`);
  }
}