// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { OrderedDoublyLinkedListSnapshot, Node } from './snapshot_interfaces';

/**
 * Takes a snapshot of OrderedDoublyLinkedList state
 * @param contract - ethers.Contract instance
 * @param actors - An array of Actor objects containing identifiers.
 * @returns Promise returning the interface OrderedDoublyLinkedListSnapshot
 */
export async function takesafesOrderedForLiquidationContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<OrderedDoublyLinkedListSnapshot> {
  try {
    const headId: bigint = BigInt(await contract.head());
    const tailId: bigint = BigInt(await contract.tail());
    const nodes: { [safeId: bigint]: Node } = {};

    // Fetch all nodes using getNodes in batches.
    // Assuming a reasonable batch size, adjust as needed.
    const batchSize = 100;
    let currentId = headId;

    while (currentId !== 0n) {
      try {
        const node = await contract.nodes(currentId);
        nodes[currentId] = {
          value: BigInt(node.value),
          prev: BigInt(node.prev),
          next: BigInt(node.next),
        };
        currentId = BigInt(node.next);
      } catch (error: any) {
        console.error(`Error fetching node with id ${currentId}:`, error);
        // Consider re-throwing or setting a default node value.
        break; // Or handle the error as needed.
      }
    }

    // Process actors to fetch specific node information based on safeId.
    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();
      if (identifiers && identifiers.safeId) {
        const safeIds = Array.isArray(identifiers.safeId) ? identifiers.safeId : [identifiers.safeId];
        for (const safeId of safeIds) {
          const safeIdBigInt = BigInt(safeId);
          if (!nodes[safeIdBigInt]) {
            try {
              // Fetch the node if it wasn't already fetched in the batch.
              const node = await contract.nodes(safeIdBigInt);
              nodes[safeIdBigInt] = {
                value: BigInt(node.value),
                prev: BigInt(node.prev),
                next: BigInt(node.next),
              };
            } catch (error: any) {
              console.error(`Error fetching node for safeId ${safeIdBigInt}:`, error);
              // Handle error appropriately.
            }
          }
        }
      }
    }

    return {
      headId,
      tailId,
      nodes,
    };
  } catch (error: any) {
    console.error('Error taking OrderedDoublyLinkedList snapshot:', error);
    throw new Error(`Failed to snapshot OrderedDoublyLinkedList contract: ${error.message}`);
  }
}