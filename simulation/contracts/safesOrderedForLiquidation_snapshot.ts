// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { OrderedDoublyLinkedListSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of OrderedDoublyLinkedList state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances containing identifiers for specific states.
 * @returns Promise returning the interface OrderedDoublyLinkedListSnapshot
 */
export async function takesafesOrderedForLiquidationContractSnapshot(
  contract: ethers.Contract,
  actors: Actor[]
): Promise<OrderedDoublyLinkedListSnapshot> {
  try {
    const head = BigInt(await contract.head());
    const tail = BigInt(await contract.tail());
    const owner = await contract.owner();

    let nodeValue: {
      value: bigint;
      prev: bigint;
      next: bigint;
    } = { value: BigInt(0), prev: BigInt(0), next: BigInt(0) };

    if (actors.length > 0) {
      const safeIdActor = actors.find((actor) => actor.getIdentifiers()._safeId !== undefined);

      if (safeIdActor) {
        const safeIds = Array.isArray(safeIdActor.getIdentifiers()._safeId) ? safeIdActor.getIdentifiers()._safeId : [safeIdActor.getIdentifiers()._safeId];

        if (safeIds && safeIds.length > 0) {
          try {
            const safeId = BigInt(safeIds[0]);
            const node = await contract.nodes(safeId);
            nodeValue = {
              value: BigInt(node.value),
              prev: BigInt(node.prev),
              next: BigInt(node.next),
            };
          } catch (nodeError: any) {
            console.error(`Error fetching node for safeId ${safeIds[0]}:`, nodeError);
          }
        }
      }
    }

    let nodes: { value: bigint; prev: bigint; next: bigint; }[] = [];
    let totalFound: bigint = BigInt(0);

    let beginAt: bigint = BigInt(0);
    let total: bigint = BigInt(0);

    if (actors.length > 0) {
      const safeIdActor = actors.find((actor) => actor.getIdentifiers()._safeId !== undefined);

      if (safeIdActor) {
        const safeIds = Array.isArray(safeIdActor.getIdentifiers()._safeId) ? safeIdActor.getIdentifiers()._safeId : [safeIdActor.getIdentifiers()._safeId];

        if (safeIds && safeIds.length > 0) {
          beginAt = BigInt(safeIds[0]);
          total = BigInt(safeIds[0]);

          try {
            const getNodesResult = await contract.getNodes(beginAt, total);

            nodes = getNodesResult[0].map((node: any) => ({
              value: BigInt(node.value),
              prev: BigInt(node.prev),
              next: BigInt(node.next),
            }));
            totalFound = BigInt(getNodesResult[1]);
          } catch (getNodesError: any) {
            console.error(`Error fetching nodes with beginAt ${beginAt} and total ${total}:`, getNodesError);
          }
        }
      }
    }

    const listHead = BigInt(await contract.getHead());
    const listTail = BigInt(await contract.getTail());

    return {
      head,
      tail,
      nodeValue,
      nodes,
      totalFound,
      listHead,
      listTail,
      owner,
    };
  } catch (error: any) {
    console.error('Error in takesafesOrderedForLiquidationContractSnapshot:', error);
    throw new Error(`Failed to snapshot OrderedDoublyLinkedList state: ${error.message}`);
  }
}
