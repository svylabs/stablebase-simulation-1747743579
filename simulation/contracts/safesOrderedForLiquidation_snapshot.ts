// Generated by SnapshotCodeGenerator

import {ethers} from "ethers";
import {Actor} from "@svylabs/ilumina";
import {Node, OrderedDoublyLinkedListSnapshot} from "./snapshot_interfaces";

/**
 * Takes a snapshot of the state of the OrderedDoublyLinkedList contract (safesOrderedForLiquidation).
 * This function fetches the head, tail, and all relevant node data based on provided actor identifiers.
 * @param contract - An ethers.Contract instance connected to the OrderedDoublyLinkedList contract.
 * @param actors - An array of Actor objects, each potentially containing 'safeId' identifiers.
 * @returns A Promise that resolves to an OrderedDoublyLinkedListSnapshot object representing the contract's state.
 * @throws Throws an error if any contract call fails.
 */
export async function takesafesOrderedForLiquidationContractSnapshot(
  contract: ethers.Contract,
  actors: Actor[]
): Promise<OrderedDoublyLinkedListSnapshot> {
  const snapshot: OrderedDoublyLinkedListSnapshot = {
    headId: BigInt(0),
    tailId: BigInt(0),
    nodes: {},
  };
  const uniqueSafeIds = new Set<bigint>();

  // 1. Fetch headId
  try {
    snapshot.headId = await contract.getHead();
  } catch (error) {
    console.error("Error fetching headId:", error);
    throw new Error(`Failed to fetch headId from contract: ${error}`);
  }

  // 2. Fetch tailId
  try {
    snapshot.tailId = await contract.getTail();
  } catch (error) {
    console.error("Error fetching tailId:", error);
    throw new Error(`Failed to fetch tailId from contract: ${error}`);
  }

  // 3. Collect unique safeIds from actors
  for (const actor of actors) {
    const identifiers = actor.getIdentifiers();
    const safeIds = identifiers.safeId;

    if (safeIds !== undefined) {
      if (Array.isArray(safeIds)) {
        for (const id of safeIds) {
          if (typeof id === "bigint") {
            uniqueSafeIds.add(id);
          } else if (typeof id === "string" || typeof id === "number") {
            try {
              uniqueSafeIds.add(BigInt(id));
            } catch (e) {
              console.warn(
                `Invalid safeId '${id}' for actor ${actor.getIdentifiers().accountAddress}: ${e}`
              );
            }
          }
        }
      } else if (typeof safeIds === "bigint") {
        uniqueSafeIds.add(safeIds);
      } else if (typeof safeIds === "string" || typeof safeIds === "number") {
        try {
          uniqueSafeIds.add(BigInt(safeIds));
        } catch (e) {
          console.warn(
            `Invalid single safeId '${safeIds}' for actor ${actor.getIdentifiers().accountAddress}: ${e}`
          );
        }
      }
    }
  }

  // Add headId and tailId to uniqueSafeIds if they are not zero, as they might be nodes too
  if (snapshot.headId !== BigInt(0)) {
    uniqueSafeIds.add(snapshot.headId);
  }
  if (snapshot.tailId !== BigInt(0) && snapshot.tailId !== snapshot.headId) {
    uniqueSafeIds.add(snapshot.tailId);
  }

  // 4. Fetch node data for all unique safeIds
  for (const safeId of uniqueSafeIds) {
    try {
      // The contract's 'nodes' function typically returns a struct
      const nodeData: any = await contract.nodes(safeId);

      const node: Node = {
        value: BigInt(nodeData.value),
        prev: BigInt(nodeData.prev),
        next: BigInt(nodeData.next),
      };
      snapshot.nodes[safeId.toString()] = node;
    } catch (error) {
      console.error(
        `Error fetching node data for safeId ${safeId.toString()}:`,
        error
      );
      // Decide whether to throw or continue. For a complete snapshot, throwing is safer.
      throw new Error(
        `Failed to fetch node data for safeId ${safeId.toString()}: ${error}`
      );
    }
  }

  return snapshot;
}