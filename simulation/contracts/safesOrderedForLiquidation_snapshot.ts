// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { OrderedDoublyLinkedListState, Node } from './snapshot_interfaces';

/**
 * Takes a snapshot of OrderedDoublyLinkedList state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface OrderedDoublyLinkedListState
 */
export async function takesafesOrderedForLiquidationContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<OrderedDoublyLinkedListState> {
  try {
    const head = BigInt(await contract.getHead());
    const tail = BigInt(await contract.getTail());
    const nodes: { [key: string]: Node } = {};

    // Process actors to fetch node-related data
    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();
      if (identifiers && identifiers._safeId) {
        const safeIds = Array.isArray(identifiers._safeId) ? identifiers._safeId : [identifiers._safeId];

        for (const safeId of safeIds) {
          const safeIdBigInt = BigInt(safeId);

          // Fetch node by ID
          try {
            const nodeData = await contract.nodes(safeIdBigInt);
            const node: Node = {
              value: BigInt(nodeData.value),
              prev: BigInt(nodeData.prev),
              next: BigInt(nodeData.next),
            };
            nodes[safeIdBigInt.toString()] = node;
          } catch (nodeError: any) {
            console.error(`Error fetching node for safeId ${safeIdBigInt}:`, nodeError);
            // Handle the error appropriately, e.g., by logging or setting a default value
          }

        }
      }
    }

    return {
      head,
      tail,
      nodes,
    };
  } catch (error: any) {
    console.error('Error taking snapshot:', error);
    throw new Error(`Failed to take snapshot: ${error.message}`);
  }
}