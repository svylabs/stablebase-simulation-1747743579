// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { DFIRETokenSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIREToken state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface DFIRETokenSnapshot
 */
export async function takedfireTokenContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIRETokenSnapshot> {
  try {
    const allowances: { [owner: string]: { [spender: string]: bigint } } = {};
    const balances: { [account: string]: bigint } = {};

    // Fetch allowances for each actor
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      if (!accountAddress) {
        console.warn(`Actor ${actor.id} has no account address. Skipping allowances.`);
        continue;
      }

      allowances[accountAddress] = {};

      for (const actor2 of actors) {
        const spenderAddress = actor2.accountAddress;

        if (!spenderAddress) {
          console.warn(`Actor ${actor2.id} has no account address. Skipping spender ${actor2.id} for allowance of ${actor.id}.`);
          continue;
        }

        try {
          const allowance = await contract.allowance(accountAddress, spenderAddress);
          allowances[accountAddress][spenderAddress] = BigInt(allowance.toString());
        } catch (error: any) {
          console.error(`Error fetching allowance for owner ${accountAddress} and spender ${spenderAddress}:`, error);
          throw new Error(`Failed to fetch allowance for owner ${accountAddress} and spender ${spenderAddress}: ${error.message}`);
        }
      }
    }

    // Fetch balances for each actor
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;

      if (!accountAddress) {
        console.warn(`Actor ${actor.id} has no account address. Skipping balance.`);
        continue;
      }

      try {
        const balance = await contract.balanceOf(accountAddress);
        balances[accountAddress] = BigInt(balance.toString());
      } catch (error: any) {
        console.error(`Error fetching balance for account ${accountAddress}:`, error);
        throw new Error(`Failed to fetch balance for account ${accountAddress}: ${error.message}`);
      }
    }

    let decimals: bigint;
    try {
      const decimalsResult = await contract.decimals();
      decimals = BigInt(decimalsResult.toString());
    } catch (error: any) {
      console.error('Error fetching decimals:', error);
      throw new Error(`Failed to fetch decimals: ${error.message}`);
    }

    let name: string;
    try {
      name = await contract.name();
    } catch (error: any) {
      console.error('Error fetching name:', error);
      throw new Error(`Failed to fetch name: ${error.message}`);
    }

    let owner: string;
    try {
      owner = await contract.owner();
    } catch (error: any) {
      console.error('Error fetching owner:', error);
      throw new Error(`Failed to fetch owner: ${error.message}`);
    }

    let symbol: string;
    try {
      symbol = await contract.symbol();
    } catch (error: any) {
      console.error('Error fetching symbol:', error);
      throw new Error(`Failed to fetch symbol: ${error.message}`);
    }

    let totalBurned: bigint;
    try {
      const totalBurnedResult = await contract.totalBurned();
      totalBurned = BigInt(totalBurnedResult.toString());
    } catch (error: any) {
      console.error('Error fetching totalBurned:', error);
      throw new Error(`Failed to fetch totalBurned: ${error.message}`);
    }

    let totalSupply: bigint;
    try {
      const totalSupplyResult = await contract.totalSupply();
      totalSupply = BigInt(totalSupplyResult.toString());
    } catch (error: any) {
      console.error('Error fetching totalSupply:', error);
      throw new Error(`Failed to fetch totalSupply: ${error.message}`);
    }

    const snapshot: DFIRETokenSnapshot = {
      allowances,
      balances,
      decimals,
      name,
      owner,
      symbol,
      totalBurned,
      totalSupply,
    };

    return snapshot;
  } catch (error: any) {
    console.error('Error taking DFIREToken snapshot:', error);
    throw new Error(`Failed to take DFIREToken snapshot: ${error.message}`);
  }
}