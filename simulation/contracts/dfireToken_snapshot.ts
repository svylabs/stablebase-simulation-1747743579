// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor, Snapshot } from '@svylabs/ilumina';
import { DFIRETokenSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIREToken state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor objects
 * @returns Promise returning the interface DFIRETokenSnapshot
 */
export async function takedfireTokenContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIRETokenSnapshot> {
  try {
    const allowanceAmounts: { [owner: string]: { [spender: string]: bigint } } = {};
    const tokenBalances: { [account: string]: bigint } = {};

    // Fetch token balances for each actor
    for (const actor of actors) {
      const accountAddress = actor.accountAddress;
      try {
        const balance = await contract.balanceOf(accountAddress);
        tokenBalances[accountAddress] = BigInt(balance);
      } catch (error: any) {
        console.error(`Error fetching token balance for account ${accountAddress}: ${error.message}`);
        // Consider how to handle errors, e.g., setting to 0 or throwing
        tokenBalances[accountAddress] = BigInt(0);
      }

      // Fetch allowance amounts for each actor against every other actor
      allowanceAmounts[accountAddress] = {};
      for (const otherActor of actors) {
        const spenderAddress = otherActor.accountAddress;
        try {
          const allowance = await contract.allowance(accountAddress, spenderAddress);
          allowanceAmounts[accountAddress][spenderAddress] = BigInt(allowance);
        } catch (error: any) {
          console.error(`Error fetching allowance for ${accountAddress} -> ${spenderAddress}: ${error.message}`);
          allowanceAmounts[accountAddress][spenderAddress] = BigInt(0);
        }
      }
    }

    let decimalPlaces: bigint;
    try {
      const decimals = await contract.decimals();
      decimalPlaces = BigInt(decimals);
    } catch (error: any) {
      console.error(`Error fetching decimals: ${error.message}`);
      decimalPlaces = BigInt(0);
    }

    let tokenName: string;
    try {
      tokenName = await contract.name();
    } catch (error: any) {
      console.error(`Error fetching name: ${error.message}`);
      tokenName = 'N/A';
    }

    let tokenSymbol: string;
    try {
      tokenSymbol = await contract.symbol();
    } catch (error: any) {
      console.error(`Error fetching symbol: ${error.message}`);
      tokenSymbol = 'N/A';
    }

    let burnedTokens: bigint;
    try {
      const burned = await contract.totalBurned();
      burnedTokens = BigInt(burned);
    } catch (error: any) {
      console.error(`Error fetching totalBurned: ${error.message}`);
      burnedTokens = BigInt(0);
    }

    let totalTokens: bigint;
    try {
      const total = await contract.totalSupply();
      totalTokens = BigInt(total);
    } catch (error: any) {
      console.error(`Error fetching totalSupply: ${error.message}`);
      totalTokens = BigInt(0);
    }

    let ownerAddress: string;
    try {
      ownerAddress = await contract.owner();
    } catch (error: any) {
      console.error(`Error fetching owner: ${error.message}`);
      ownerAddress = ethers.constants.AddressZero;
    }

    //Stability pool address is not on the contract, so it will need to be populated from the config
    //Consider injecting the stabilityPoolAddress instead of hardcoding.
    const stabilityPoolAddress: string = '0x0000000000000000000000000000000000000000';

    const snapshot: DFIRETokenSnapshot = {
      allowanceAmounts,
      tokenBalances,
      decimalPlaces,
      tokenName,
      tokenSymbol,
      burnedTokens,
      totalTokens,
      ownerAddress,
      stabilityPoolAddress,
    };

    return snapshot;
  } catch (error: any) {
    console.error(`Error taking DFIREToken contract snapshot: ${error.message}`);
    throw error;
  }
}