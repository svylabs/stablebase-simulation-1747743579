// Generated by SnapshotCodeGenerator

/* GENERATED CODE */
import { ethers } from "ethers";
import { Actor } from "@svylabs/ilumina";
import { DFIRETokenAccountSnapshot, DFIRETokenSnapshot } from "./snapshot_interfaces";

/**
 * Takes a snapshot of DFIREToken contract state.
 * @param contract - ethers.Contract instance of the DFIREToken contract.
 * @param actors - An array of Actor objects, each potentially containing an accountAddress.
 * @returns A Promise that resolves to a DFIRETokenSnapshot object.
 * @throws An error if any contract call fails.
 */
export async function takedfireTokenContractSnapshot(
  contract: ethers.Contract,
  actors: Actor[]
): Promise<DFIRETokenSnapshot> {
  try {
    // 1. Fetch Global Contract State
    const decimals = await contract.decimals();
    const tokenName = await contract.name();
    const contractOwner = await contract.owner();
    const tokenSymbol = await contract.symbol();
    const totalBurnedSupply = await contract.totalBurned();
    const totalTokenSupply = await contract.totalSupply();

    // 2. Collect all unique account addresses from actors
    const uniqueAccountAddresses = new Set<string>();
    for (const actor of actors) {
      const identifiers = actor.getIdentifiers();
      if (identifiers.accountAddress) {
        // Ensure accountAddress is a string (it should be)
        uniqueAccountAddresses.add(identifiers.accountAddress as string);
      }
    }
    const accountAddresses = Array.from(uniqueAccountAddresses);

    // 3. Fetch per-account state (balances and allowances)
    const accounts: Record<string, DFIRETokenAccountSnapshot> = {};

    for (const ownerAddress of accountAddresses) {
      const accountSnapshot: DFIRETokenAccountSnapshot = {
        balance: 0n, // Initialize with default bigint
        allowances: {},
      };

      // Fetch balance for the current ownerAddress
      try {
        accountSnapshot.balance = await contract.balanceOf(ownerAddress);
      } catch (balanceErr: any) {
        console.warn(`DFIREToken Snapshot: Failed to fetch balance for ${ownerAddress}: ${balanceErr.message || balanceErr}`);
        // On error, default to 0n for robustness in snapshotting
        accountSnapshot.balance = 0n;
      }

      // Fetch allowances for all other accountAddresses as spenders
      for (const spenderAddress of accountAddresses) {
        try {
          const allowanceValue = await contract.allowance(ownerAddress, spenderAddress);
          accountSnapshot.allowances[spenderAddress] = allowanceValue;
        } catch (allowanceErr: any) {
          console.warn(`DFIREToken Snapshot: Failed to fetch allowance for owner ${ownerAddress} to spender ${spenderAddress}: ${allowanceErr.message || allowanceErr}`);
          // On error, default to 0n for robustness in snapshotting
          accountSnapshot.allowances[spenderAddress] = 0n;
        }
      }
      accounts[ownerAddress] = accountSnapshot;
    }

    // 4. Construct and return the DFIRETokenSnapshot object
    const snapshot: DFIRETokenSnapshot = {
      decimals,
      tokenName,
      contractOwner,
      tokenSymbol,
      totalBurnedSupply,
      totalTokenSupply,
      accounts,
    };

    return snapshot;

  } catch (error: any) {
    const errorMessage = `Failed to take DFIREToken contract snapshot: ${error.message || error}`;
    console.error(errorMessage);
    throw new Error(errorMessage);
  }
}
