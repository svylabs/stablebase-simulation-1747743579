// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { DFIRETokenSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIREToken state, capturing balances and allowances for all provided actors.
 * @param contract - ethers.Contract instance of the DFIREToken contract.
 * @param actors - Array of Actor instances representing user accounts to snapshot.
 *                 Each actor must have an 'accountAddress' identifier.
 * @returns Promise returning the interface DFIRETokenSnapshot, containing the contract's state.
 * @throws Error if any contract call fails during the snapshot process.
 */
export async function takedfireTokenContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIRETokenSnapshot> {
  try {
    // Initialize data structures to hold the snapshot data.
    const allowances: { [accountAddress: string]: { [accountAddress: string]: bigint } } = {};
    const balances: { [accountAddress: string]: bigint } = {};

    // Fetch all unique addresses from actors to reduce redundant calls.
    const uniqueAddresses = new Set<string>();
    actors.forEach(actor => {
      const identifiers = actor.getIdentifiers();
      uniqueAddresses.add(identifiers.accountAddress as string);
    });

    // Fetch balances for all unique addresses.
    for (const accountAddress of uniqueAddresses) {
      try {
        balances[accountAddress] = await contract.balanceOf(accountAddress);
      } catch (error: any) {
        console.error(`Error fetching balance for address ${accountAddress}: ${error.message}`);
        balances[accountAddress] = BigInt(0);
      }
    }

    // Fetch allowances for all combinations of owner and spender addresses.
    for (const ownerActor of actors) {
      const ownerAddress = ownerActor.getIdentifiers().accountAddress as string;
      allowances[ownerAddress] = {};

      for (const spenderActor of actors) {
        const spenderAddress = spenderActor.getIdentifiers().accountAddress as string;
        try {
          allowances[ownerAddress][spenderAddress] = await contract.allowance(ownerAddress, spenderAddress);
        } catch (error: any) {
          console.error(`Error fetching allowance for owner ${ownerAddress} and spender ${spenderAddress}: ${error.message}`);
          allowances[ownerAddress][spenderAddress] = BigInt(0);
        }
      }
    }

    // Fetch scalar values from the contract.
    const decimals = await contract.decimals();
    const name = await contract.name();
    const owner = await contract.owner();
    const symbol = await contract.symbol();
    const totalBurned = await contract.totalBurned();
    const totalSupply = await contract.totalSupply();

    // Construct and return the snapshot object.
    return {
      allowances,
      balances,
      decimals,
      name,
      owner,
      symbol,
      totalBurned,
      totalSupply,
    };
  } catch (error: any) {
    console.error(`Error taking DFIREToken snapshot: ${error.message}`);
    throw new Error(`Failed to take DFIREToken snapshot: ${error.message}`);
  }
}