// Generated by SnapshotCodeGenerator

import { ethers } from 'ethers';
import { Actor } from '@svylabs/ilumina';
import { DFIRETokenSnapshot } from './snapshot_interfaces';

/**
 * Takes a snapshot of DFIREToken state
 * @param contract - ethers.Contract instance
 * @param actors - Array of Actor instances
 * @returns Promise returning the interface DFIRETokenSnapshot
 */
export async function takedfireTokenContractSnapshot(contract: ethers.Contract, actors: Actor[]): Promise<DFIRETokenSnapshot> {
  try {
    const allowanceAmount: { [owner: string]: { [spender: string]: bigint } } = {};
    const accountBalance: { [accountAddress: string]: bigint } = {};

    // Fetch allowance amounts for each actor
    for (const actor of actors) {
      const accountAddress = actor.getIdentifier('accountAddress') as string;

      if (!accountAddress) {
        console.warn(`accountAddress not found for actor, skipping allowanceAmount for actor.`);
        continue;
      }

      allowanceAmount[accountAddress] = {};
      for (const otherActor of actors) {
        const spenderAddress = otherActor.getIdentifier('accountAddress') as string;
        if (!spenderAddress) {
          console.warn(`accountAddress not found for otherActor, skipping allowanceAmount for otherActor.`);
          continue;
        }
        try {
          allowanceAmount[accountAddress][spenderAddress] = BigInt(await contract.allowance(accountAddress, spenderAddress));
        } catch (error: any) {
          console.error(`Error fetching allowance for owner ${accountAddress} and spender ${spenderAddress}:`, error);
          throw new Error(`Failed to fetch allowance: ${error.message}`);
        }
      }
    }

    // Fetch account balances for each actor
    for (const actor of actors) {
      const accountAddress = actor.getIdentifier('accountAddress') as string;
      if (!accountAddress) {
        console.warn(`accountAddress not found for actor, skipping accountBalance for actor.`);
        continue;
      }
      try {
        accountBalance[accountAddress] = BigInt(await contract.balanceOf(accountAddress));
      } catch (error: any) {
        console.error(`Error fetching balance for account ${accountAddress}:`, error);
        throw new Error(`Failed to fetch balance: ${error.message}`);
      }
    }

    let decimalPlaces: bigint;
    try {
      decimalPlaces = BigInt(await contract.decimals());
    } catch (error: any) {
      console.error('Error fetching decimals:', error);
      throw new Error(`Failed to fetch decimals: ${error.message}`);
    }

    let tokenName: string;
    try {
      tokenName = await contract.name();
    } catch (error: any) {
      console.error('Error fetching name:', error);
      throw new Error(`Failed to fetch name: ${error.message}`);
    }

    let contractOwner: string;
    try {
      contractOwner = await contract.owner();
    } catch (error: any) {
      console.error('Error fetching owner:', error);
      throw new Error(`Failed to fetch owner: ${error.message}`);
    }

    let tokenSymbol: string;
    try {
      tokenSymbol = await contract.symbol();
    } catch (error: any) {
      console.error('Error fetching symbol:', error);
      throw new Error(`Failed to fetch symbol: ${error.message}`);
    }

    let burnedSupply: bigint;
    try {
      burnedSupply = BigInt(await contract.totalBurned());
    } catch (error: any) {
      console.error('Error fetching totalBurned:', error);
      throw new Error(`Failed to fetch totalBurned: ${error.message}`);
    }

    let totalTokenSupply: bigint;
    try {
      totalTokenSupply = BigInt(await contract.totalSupply());
    } catch (error: any) {
      console.error('Error fetching totalSupply:', error);
      throw new Error(`Failed to fetch totalSupply: ${error.message}`);
    }

    return {
      allowanceAmount,
      accountBalance,
      decimalPlaces,
      tokenName,
      contractOwner,
      tokenSymbol,
      burnedSupply,
      totalTokenSupply,
    };
  } catch (error: any) {
    console.error('Error taking DFIREToken snapshot:', error);
    throw new Error(`Failed to take DFIREToken snapshot: ${error.message}`);
  }
}