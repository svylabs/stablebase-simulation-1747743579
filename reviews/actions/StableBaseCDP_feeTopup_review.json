{
  "reviews": [
    {
      "line_number": 80,
      "description": "The `validate` function does not check for the conditional state updates to `safes[safeId].borrowedAmount`, `safes[safeId].totalBorrowedAmount`, `safes[safeId].collateralAmount`, `liquidationSnapshots[safeId].debtPerCollateralSnapshot`, `liquidationSnapshots[safeId].collateralPerCollateralSnapshot`, `totalCollateral`, and `totalDebt`. These updates occur within the `_updateSafe` function of the contract and depend on whether `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`. The validation should conditionally check if these values have been updated correctly based on the snapshot data.",
      "function_affected": "validate",
      "category": "implementation_missing",
      "suggested_fix": "Add conditional checks within the `validate` function to verify the state updates to `borrowedAmount`, `totalBorrowedAmount`, `collateralAmount`, and the liquidation snapshots. Retrieve `cumulativeCollateralPerUnitCollateral` from the `stableBaseCDPNew` snapshot and `liquidationSnapshots[safeId].collateralPerCollateralSnapshot` from the `stableBaseCDPPrevious` snapshot. If they are different, calculate the expected changes in the affected state variables using the formulas from the `_updateSafe` function in the contract and compare them to the actual changes observed between the `stableBaseCDPPrevious` and `stableBaseCDPNew` snapshots. Something like:  ```javascript\nif (stableBaseCDPPrevious.liquidationSnapshots[safeId.toString()].collateralPerCollateralSnapshot != stableBaseCDPNew.cumulativeCollateralPerUnitCollateral) {\n    const collateralIncrease = (previousSafe.collateralAmount * (BigInt(stableBaseCDPNew.cumulativeCollateralPerUnitCollateral) - BigInt(stableBaseCDPPrevious.liquidationSnapshots[safeId.toString()].collateralPerCollateralSnapshot))) / BigInt(1000000000);\n    expect(BigInt(newSafe.collateralAmount)).to.equal(BigInt(previousSafe.collateralAmount) + collateralIncrease, 'collateralAmount not correctly updated');\n    // Similar checks for borrowedAmount, totalBorrowedAmount, totalCollateral, and totalDebt\n}\n```"
    },
    {
      "line_number": 146,
      "description": "The `validate` function lacks validation for the `PROTOCOL_MODE` state variable. The code should check if the `PROTOCOL_MODE` has been correctly updated from `BOOTSTRAP` to `NORMAL` when `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
      "function_affected": "validate",
      "category": "implementation_missing",
      "suggested_fix": "Add a conditional check to verify that if `stableBaseCDPNew.totalDebt` is greater than `stableBaseCDPPrevious.bootstrapModeDebtThreshold` and `stableBaseCDPPrevious.protocolMode` is `0` (SBStructs.Mode.BOOTSTRAP), then `stableBaseCDPNew.protocolMode` should be `1` (SBStructs.Mode.NORMAL). ```javascript\nif (BigInt(stableBaseCDPNew.totalDebt) > BigInt(stableBaseCDPPrevious.bootstrapModeDebtThreshold) && stableBaseCDPPrevious.protocolMode == 0) {\n    expect(stableBaseCDPNew.protocolMode).to.equal(1, 'Protocol mode should be NORMAL');\n}\n```"
    },
    {
      "line_number": 97,
      "description": "The validation for the token balances assumes no refund occurs. The `distributeFees` function can potentially refund undistributed fee back to the user, which affects the final balance of the message sender and the contract. The current validation does not account for this possibility.",
      "function_affected": "validate",
      "category": "implementation_error",
      "suggested_fix": "Parse the `FeeRefund` event from the execution receipt to determine the refund amount (if any). Update the token balance validation to account for the refunded fee. If a `FeeRefund` event is present, the actor's SBD balance should be decreased by `fee - refundFee` and the contract's SBD balance should be increased by `fee - refundFee`. Example:\n```javascript\nlet refundFee = BigInt(0);\nconst feeRefundEvent = executionReceipt.receipt.logs.find(\n  (log: any) =>\n    log.address === contractAddress &&\n    log.topics[0] === ethers.id('FeeRefund(uint256,uint256)')\n);\nif (feeRefundEvent) {\n  const parsedFeeRefundEvent = new ethers.Interface([\n    'event FeeRefund(uint256 safeId, uint256 refundFee)',\n  ]).parseLog(feeRefundEvent);\n  refundFee = parsedFeeRefundEvent.args.refundFee;\n}\nexpect(newActorBalance).to.equal(\n  previousActorBalance - fee + refundFee,\n  \"Message sender's SBD balance should be decreased by the fee amount minus any refund\"\n);\nexpect(newContractBalance).to.equal(\n  previousContractBalance + fee - refundFee,\n  \"Contract's SBD balance should be increased by the fee amount minus any refund\"\n);\n```"
    },
    {
      "line_number": 131,
      "description": "The `validate` function does not validate the state updates related to the redemption queue, specifically the `OrderedDoublyLinkedList` contract. The positions and links within the queue might change after the `feeTopup` action, and these changes need to be validated to ensure the integrity of the queue.",
      "function_affected": "validate",
      "category": "implementation_missing",
      "suggested_fix": "Retrieve the state of the `OrderedDoublyLinkedList` contract from the previous and new snapshots. Verify that the `head`, `tail`, and `nodes` mappings have been updated correctly based on the `safeId` and `topupRate`. Due to complexity, a complete solution would involve replicating the linked list logic from the contract to ensure safeId is in right place, however, this can be approximated. If the weight has increased, we can assume that the safeId will now be earlier in the queue. This can be checked by fetching several of the previous `safeId`s, and checking that the current `safeId` has a higher weight.  Without knowing the specific implementation details of how snapshots are structured, the code might resemble this:\n\n```javascript\nconst previousDLL = previousSnapshot.contractSnapshot.orderedDoublyLinkedList;\nconst newDLL = newSnapshot.contractSnapshot.orderedDoublyLinkedList;\n\n//Check that the node exists\nexpect(newDLL.nodes[safeId.toString()]).to.not.be.undefined\n\nif(previousDLL.nodes[safeId.toString()] != undefined){\n    //if safe existed previously, check that it moved earlier in queue\n    let current = newDLL.nodes[safeId.toString()].prev;\n    let counter = 0\n    while(current != 0 && counter < 5){\n        expect(newDLL.nodes[current.toString()].value).to.be.lessThan(newSafe.weight)\n        current = newDLL.nodes[current.toString()].prev;\n        counter++;\n    }\n}\n```"
    },
    {
      "line_number": 131,
      "description": "The `validate` function does not validate that a `RedemptionQueueUpdated` event should be emitted with the correct prev parameter. This parameter is important because it points to the previous node in the queue.",
      "function_affected": "validate",
      "category": "implementation_missing",
      "suggested_fix": "Add the validation for the 'prev' parameter to the redemption queue updated event, ensuring it matches what the state of doubly linked list represents.\n\n```javascript\nif(redemptionQueueUpdatedEvent){\n    const parsedEvent = new ethers.Interface([\"event RedemptionQueueUpdated(uint256 safeId, uint256 weight, uint256 prev)\"]).parseLog(redemptionQueueUpdatedEvent);\n    expect(parsedEvent.args.safeId).to.equal(safeId, \"RedemptionQueueUpdated event safeId mismatch\");\n    expect(parsedEvent.args.weight).to.equal(newSafe.weight, \"RedemptionQueueUpdated event weight mismatch\");\n\n    //Validate prev parameter\n    const prevNodeId = parsedEvent.args.prev;\n\n    if(prevNodeId != BigInt(0)){\n        //Check that the 'prev' node exists and its 'next' pointer points to the current safeId\n        expect(newDLL.nodes[prevNodeId.toString()].next).to.equal(safeId, \"RedemptionQueueUpdated event prev mismatch\");\n    } else {\n        //If prev is 0, then safeId should be the head of the queue\n        expect(newDLL.head).to.equal(safeId, \"RedemptionQueueUpdated event prev mismatch\");\n    }\n}\n```"
    },
    {
      "line_number": 141,
      "description": "The `validate` function does not validate the updates made to the stability pool and DFIREStaking contracts. The function `distributeFees` distributes the fee to the SBR Stakers and Stability Pool",
      "function_affected": "validate",
      "category": "implementation_missing",
      "suggested_fix": "Add the validation for state updates to the stability pool and DFIREStaking contracts. This validation should confirm the rewards have been added as expected. Note: due to the complexity of snapshot structures and reward calculations, it might be difficult to precisely validate the exact changes.  Instead you can validate that the events are emitted and that the totalRewardPerToken has increased.\n\n```javascript\n// DFIREStaking validation\nconst rewardAddedEventDFIRE = executionReceipt.receipt.logs.find(\n  (log: any) =>\n    log.address === dfireTokenStakingAddress && // Replace with actual address\n    log.topics[0] === ethers.id('RewardAdded(uint256)')\n);\nexpect(rewardAddedEventDFIRE).to.not.be.undefined;\n\nif (rewardAddedEventDFIRE) {\n    //Basic check to ensure totalRewardPerToken increased\n    expect(newSnapshot.contractSnapshot.dfireStaking.totalRewardPerToken).to.be.gt(previousSnapshot.contractSnapshot.dfireStaking.totalRewardPerToken)\n}\n\n// StabilityPool validation\nconst rewardAddedEventStabilityPool = executionReceipt.receipt.logs.find(\n  (log: any) =>\n    log.address === stabilityPoolAddress && // Replace with actual address\n    log.topics[0] === ethers.id('RewardAdded(uint256)')\n);\nexpect(rewardAddedEventStabilityPool).to.not.be.undefined;\nif (rewardAddedEventStabilityPool) {\n    //Basic check to ensure totalRewardPerToken increased\n    expect(newSnapshot.contractSnapshot.stabilityPool.totalRewardPerToken).to.be.gt(previousSnapshot.contractSnapshot.stabilityPool.totalRewardPerToken)\n}\n```"
    }
  ],
  "overall_assessment": [
    "The code generally covers the key aspects of the FeeTopup action. However, there are gaps in the validation logic, particularly concerning the conditional state updates related to liquidation snapshots and fee distribution. The event validation also needs to be more robust to handle potential refund events. Furthermore, the interaction with the OrderedDoublyLinkedList contract and the corresponding state updates need to be validated."
  ]
}